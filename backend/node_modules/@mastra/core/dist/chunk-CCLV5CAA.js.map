{"version":3,"sources":["../src/request-context/index.ts"],"names":[],"mappings":"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","file":"chunk-CCLV5CAA.js","sourcesContent":["type RecordToTuple<T> = {\n  [K in keyof T]: [K, T[K]];\n}[keyof T][];\n\n/**\n * Reserved key for setting resourceId from middleware.\n * When set in RequestContext, this takes precedence over client-provided values\n * for security (prevents attackers from hijacking another user's memory).\n *\n * @example\n * ```typescript\n * // In your auth middleware:\n * const requestContext = c.get('requestContext');\n * requestContext.set(MASTRA_RESOURCE_ID_KEY, authenticatedUser.id);\n * ```\n */\nexport const MASTRA_RESOURCE_ID_KEY = 'mastra__resourceId';\n\n/**\n * Reserved key for setting threadId from middleware.\n * When set in RequestContext, this takes precedence over client-provided values\n * for security (prevents attackers from hijacking another user's memory).\n *\n * @example\n * ```typescript\n * // In your auth middleware:\n * const requestContext = c.get('requestContext');\n * requestContext.set(MASTRA_THREAD_ID_KEY, threadId);\n * ```\n */\nexport const MASTRA_THREAD_ID_KEY = 'mastra__threadId';\n\nexport class RequestContext<Values extends Record<string, any> | unknown = unknown> {\n  private registry = new Map<string, unknown>();\n\n  constructor(\n    iterable?: Values extends Record<string, any>\n      ? RecordToTuple<Partial<Values>>\n      : Iterable<readonly [string, unknown]>,\n  ) {\n    this.registry = new Map(iterable);\n  }\n\n  /**\n   * set a value with strict typing if `Values` is a Record and the key exists in it.\n   */\n  public set<K extends Values extends Record<string, any> ? keyof Values : string>(\n    key: K,\n    value: Values extends Record<string, any> ? (K extends keyof Values ? Values[K] : never) : unknown,\n  ): void {\n    // The type assertion `key as string` is safe because K always extends string ultimately.\n    this.registry.set(key as string, value);\n  }\n\n  /**\n   * Get a value with its type\n   */\n  public get<\n    K extends Values extends Record<string, any> ? keyof Values : string,\n    R = Values extends Record<string, any> ? (K extends keyof Values ? Values[K] : never) : unknown,\n  >(key: K): R {\n    return this.registry.get(key as string) as R;\n  }\n\n  /**\n   * Check if a key exists in the container\n   */\n  public has<K extends Values extends Record<string, any> ? keyof Values : string>(key: K): boolean {\n    return this.registry.has(key);\n  }\n\n  /**\n   * Delete a value by key\n   */\n  public delete<K extends Values extends Record<string, any> ? keyof Values : string>(key: K): boolean {\n    return this.registry.delete(key);\n  }\n\n  /**\n   * Clear all values from the container\n   */\n  public clear(): void {\n    this.registry.clear();\n  }\n\n  /**\n   * Get all keys in the container\n   */\n  public keys(): IterableIterator<Values extends Record<string, any> ? keyof Values : string> {\n    return this.registry.keys() as IterableIterator<Values extends Record<string, any> ? keyof Values : string>;\n  }\n\n  /**\n   * Get all values in the container\n   */\n  public values(): IterableIterator<Values extends Record<string, any> ? Values[keyof Values] : unknown> {\n    return this.registry.values() as IterableIterator<\n      Values extends Record<string, any> ? Values[keyof Values] : unknown\n    >;\n  }\n\n  /**\n   * Get all entries in the container.\n   * Returns a discriminated union of tuples for proper type narrowing when iterating.\n   */\n  public entries(): IterableIterator<\n    Values extends Record<string, any> ? { [K in keyof Values]: [K, Values[K]] }[keyof Values] : [string, unknown]\n  > {\n    return this.registry.entries() as IterableIterator<\n      Values extends Record<string, any> ? { [K in keyof Values]: [K, Values[K]] }[keyof Values] : [string, unknown]\n    >;\n  }\n\n  /**\n   * Get the size of the container\n   */\n  public size(): number {\n    return this.registry.size;\n  }\n\n  /**\n   * Execute a function for each entry in the container.\n   * The callback receives properly typed key-value pairs.\n   */\n  public forEach<K extends Values extends Record<string, any> ? keyof Values : string>(\n    callbackfn: (\n      value: Values extends Record<string, any> ? (K extends keyof Values ? Values[K] : unknown) : unknown,\n      key: K,\n      map: Map<string, unknown>,\n    ) => void,\n  ): void {\n    this.registry.forEach(callbackfn as (value: unknown, key: string, map: Map<string, unknown>) => void);\n  }\n\n  /**\n   * Custom JSON serialization method.\n   * Converts the internal Map to a plain object for proper JSON serialization.\n   * Non-serializable values (e.g., RPC proxies, functions, circular references)\n   * are skipped to prevent serialization errors when storing to database.\n   */\n  public toJSON(): Record<string, any> {\n    const result: Record<string, any> = {};\n    for (const [key, value] of this.registry.entries()) {\n      if (this.isSerializable(value)) {\n        result[key] = value;\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Check if a value can be safely serialized to JSON.\n   */\n  private isSerializable(value: unknown): boolean {\n    if (value === null || value === undefined) return true;\n    if (typeof value === 'function') return false;\n    if (typeof value === 'symbol') return false;\n    if (typeof value !== 'object') return true;\n\n    try {\n      JSON.stringify(value);\n      return true;\n    } catch {\n      return false;\n    }\n  }\n\n  /**\n   * Get all values as a typed object for destructuring.\n   * Returns Record<string, any> when untyped, or the Values type when typed.\n   *\n   * @example\n   * ```typescript\n   * const ctx = new RequestContext<{ userId: string; apiKey: string }>();\n   * ctx.set('userId', 'user-123');\n   * ctx.set('apiKey', 'key-456');\n   * const { userId, apiKey } = ctx.all;\n   * ```\n   */\n  public get all(): Values extends Record<string, any> ? Values : Record<string, any> {\n    return Object.fromEntries(this.registry) as Values extends Record<string, any> ? Values : Record<string, any>;\n  }\n}\n"]}