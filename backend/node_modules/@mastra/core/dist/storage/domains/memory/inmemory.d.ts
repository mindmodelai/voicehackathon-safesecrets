import type { MastraDBMessage, StorageThreadType } from '../../../memory/types.js';
import type { StorageMessageType, StorageResourceType, StorageListMessagesInput, StorageListMessagesByResourceIdInput, StorageListMessagesOutput, StorageListThreadsInput, StorageListThreadsOutput, StorageCloneThreadInput, StorageCloneThreadOutput, ObservationalMemoryRecord, CreateObservationalMemoryInput, UpdateActiveObservationsInput, UpdateBufferedObservationsInput, UpdateBufferedReflectionInput, SwapBufferedToActiveInput, SwapBufferedToActiveResult, SwapBufferedReflectionToActiveInput, CreateReflectionGenerationInput } from '../../types.js';
import type { InMemoryDB } from '../inmemory-db.js';
import { MemoryStorage } from './base.js';
export declare class InMemoryMemory extends MemoryStorage {
    readonly supportsObservationalMemory = true;
    private db;
    constructor({ db }: {
        db: InMemoryDB;
    });
    dangerouslyClearAll(): Promise<void>;
    getThreadById({ threadId }: {
        threadId: string;
    }): Promise<StorageThreadType | null>;
    saveThread({ thread }: {
        thread: StorageThreadType;
    }): Promise<StorageThreadType>;
    updateThread({ id, title, metadata, }: {
        id: string;
        title: string;
        metadata: Record<string, unknown>;
    }): Promise<StorageThreadType>;
    deleteThread({ threadId }: {
        threadId: string;
    }): Promise<void>;
    listMessages({ threadId, resourceId: optionalResourceId, include, filter, perPage: perPageInput, page, orderBy, }: StorageListMessagesInput): Promise<StorageListMessagesOutput>;
    listMessagesByResourceId({ resourceId, filter, perPage: perPageInput, page, orderBy, }: StorageListMessagesByResourceIdInput): Promise<StorageListMessagesOutput>;
    protected parseStoredMessage(message: StorageMessageType): MastraDBMessage;
    listMessagesById({ messageIds }: {
        messageIds: string[];
    }): Promise<{
        messages: MastraDBMessage[];
    }>;
    saveMessages(args: {
        messages: MastraDBMessage[];
    }): Promise<{
        messages: MastraDBMessage[];
    }>;
    updateMessages(args: {
        messages: (Partial<MastraDBMessage> & {
            id: string;
        })[];
    }): Promise<MastraDBMessage[]>;
    deleteMessages(messageIds: string[]): Promise<void>;
    listThreads(args: StorageListThreadsInput): Promise<StorageListThreadsOutput>;
    getResourceById({ resourceId }: {
        resourceId: string;
    }): Promise<StorageResourceType | null>;
    saveResource({ resource }: {
        resource: StorageResourceType;
    }): Promise<StorageResourceType>;
    updateResource({ resourceId, workingMemory, metadata, }: {
        resourceId: string;
        workingMemory?: string;
        metadata?: Record<string, unknown>;
    }): Promise<StorageResourceType>;
    cloneThread(args: StorageCloneThreadInput): Promise<StorageCloneThreadOutput>;
    private sortThreads;
    private getObservationalMemoryKey;
    getObservationalMemory(threadId: string | null, resourceId: string): Promise<ObservationalMemoryRecord | null>;
    getObservationalMemoryHistory(threadId: string | null, resourceId: string, limit?: number): Promise<ObservationalMemoryRecord[]>;
    initializeObservationalMemory(input: CreateObservationalMemoryInput): Promise<ObservationalMemoryRecord>;
    updateActiveObservations(input: UpdateActiveObservationsInput): Promise<void>;
    updateBufferedObservations(input: UpdateBufferedObservationsInput): Promise<void>;
    swapBufferedToActive(input: SwapBufferedToActiveInput): Promise<SwapBufferedToActiveResult>;
    createReflectionGeneration(input: CreateReflectionGenerationInput): Promise<ObservationalMemoryRecord>;
    updateBufferedReflection(input: UpdateBufferedReflectionInput): Promise<void>;
    swapBufferedReflectionToActive(input: SwapBufferedReflectionToActiveInput): Promise<ObservationalMemoryRecord>;
    setReflectingFlag(id: string, isReflecting: boolean): Promise<void>;
    setObservingFlag(id: string, isObserving: boolean): Promise<void>;
    setBufferingObservationFlag(id: string, isBuffering: boolean, lastBufferedAtTokens?: number): Promise<void>;
    setBufferingReflectionFlag(id: string, isBuffering: boolean): Promise<void>;
    clearObservationalMemory(threadId: string | null, resourceId: string): Promise<void>;
    setPendingMessageTokens(id: string, tokenCount: number): Promise<void>;
    /**
     * Helper to find an observational memory record by ID across all keys
     */
    private findObservationalMemoryRecordById;
}
//# sourceMappingURL=inmemory.d.ts.map