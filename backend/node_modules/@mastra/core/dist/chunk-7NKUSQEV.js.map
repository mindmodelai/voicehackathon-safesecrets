{"version":3,"sources":["../src/storage/base.ts","../src/storage/domains/base.ts","../src/storage/domains/versioned.ts","../src/storage/domains/agents/base.ts","../src/storage/domains/agents/inmemory.ts","../src/storage/domains/inmemory-db.ts","../src/storage/domains/mcp-clients/base.ts","../src/storage/domains/mcp-clients/inmemory.ts","../src/storage/utils.ts","../src/storage/domains/memory/base.ts","../src/storage/domains/memory/inmemory.ts","../src/storage/domains/observability/base.ts","../src/storage/domains/observability/inmemory.ts","../src/storage/domains/prompt-blocks/base.ts","../src/storage/domains/prompt-blocks/inmemory.ts","../src/storage/domains/scorer-definitions/base.ts","../src/storage/domains/scorer-definitions/inmemory.ts","../src/storage/domains/scores/base.ts","../src/storage/domains/scores/inmemory.ts","../src/workflows/evented/types.ts","../src/storage/domains/workflows/base.ts","../src/storage/domains/workflows/inmemory.ts","../src/storage/mock.ts","../src/storage/domains/operations/base.ts","../src/storage/domains/operations/inmemory.ts","../src/datasets/validation/errors.ts","../src/datasets/validation/validator.ts","../src/storage/domains/datasets/base.ts","../src/storage/domains/datasets/inmemory.ts","../src/storage/domains/experiments/base.ts","../src/storage/domains/experiments/inmemory.ts"],"names":["version","id"],"mappings":"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","file":"chunk-7NKUSQEV.js","sourcesContent":["import { MastraBase } from '../base';\n\nimport type {\n  AgentsStorage,\n  PromptBlocksStorage,\n  ScorerDefinitionsStorage,\n  MCPClientsStorage,\n  ScoresStorage,\n  WorkflowsStorage,\n  MemoryStorage,\n  ObservabilityStorage,\n  DatasetsStorage,\n  ExperimentsStorage,\n} from './domains';\n\nexport type StorageDomains = {\n  workflows: WorkflowsStorage;\n  scores: ScoresStorage;\n  memory: MemoryStorage;\n  observability?: ObservabilityStorage;\n  agents?: AgentsStorage;\n  datasets?: DatasetsStorage;\n  experiments?: ExperimentsStorage;\n  promptBlocks?: PromptBlocksStorage;\n  scorerDefinitions?: ScorerDefinitionsStorage;\n  mcpClients?: MCPClientsStorage;\n};\n\n/**\n * Normalizes perPage input for pagination queries.\n *\n * @param perPageInput - The raw perPage value from the user\n * @param defaultValue - The default perPage value to use when undefined (typically 40 for messages, 100 for threads)\n * @returns A numeric perPage value suitable for queries (false becomes MAX_SAFE_INTEGER)\n * @throws Error if perPage is a negative number\n */\nexport function normalizePerPage(perPageInput: number | false | undefined, defaultValue: number): number {\n  if (perPageInput === false) {\n    return Number.MAX_SAFE_INTEGER; // Get all results\n  } else if (perPageInput === 0) {\n    return 0; // Return zero results\n  } else if (typeof perPageInput === 'number' && perPageInput > 0) {\n    return perPageInput; // Valid positive number\n  } else if (typeof perPageInput === 'number' && perPageInput < 0) {\n    throw new Error('perPage must be >= 0');\n  }\n  // For undefined, use default\n  return defaultValue;\n}\n\n/**\n * Calculates pagination offset and prepares perPage value for response.\n * When perPage is false (fetch all), offset is always 0 regardless of page.\n *\n * @param page - The page number (0-indexed)\n * @param perPageInput - The original perPage input (number, false for all, or undefined)\n * @param normalizedPerPage - The normalized perPage value (from normalizePerPage)\n * @returns Object with offset for query and perPage for response\n */\nexport function calculatePagination(\n  page: number,\n  perPageInput: number | false | undefined,\n  normalizedPerPage: number,\n): { offset: number; perPage: number | false } {\n  return {\n    offset: perPageInput === false ? 0 : page * normalizedPerPage,\n    perPage: perPageInput === false ? false : normalizedPerPage,\n  };\n}\n\n/**\n * Configuration for individual domain overrides.\n * Each domain can be sourced from a different storage adapter.\n */\nexport type MastraStorageDomains = Partial<StorageDomains>;\n\n/**\n * Configuration options for MastraCompositeStore.\n *\n * Can be used in two ways:\n * 1. By store implementations: `{ id, name, disableInit? }` - stores set `this.stores` directly\n * 2. For composition: `{ id, default?, domains?, disableInit? }` - compose domains from multiple stores\n */\nexport interface MastraCompositeStoreConfig {\n  /**\n   * Unique identifier for this storage instance.\n   */\n  id: string;\n\n  /**\n   * Name of the storage adapter (used for logging).\n   * Required for store implementations extending MastraCompositeStore.\n   */\n  name?: string;\n\n  /**\n   * Default storage adapter to use for domains not explicitly specified.\n   * If provided, domains from this storage will be used as fallbacks.\n   */\n  default?: MastraCompositeStore;\n\n  /**\n   * Individual domain overrides. Each domain can come from a different storage adapter.\n   * These take precedence over the default storage.\n   *\n   * @example\n   * ```typescript\n   * domains: {\n   *   memory: pgStore.stores?.memory,\n   *   workflows: libsqlStore.stores?.workflows,\n   * }\n   * ```\n   */\n  domains?: MastraStorageDomains;\n\n  /**\n   * When true, automatic initialization (table creation/migrations) is disabled.\n   * This is useful for CI/CD pipelines where you want to:\n   * 1. Run migrations explicitly during deployment (not at runtime)\n   * 2. Use different credentials for schema changes vs runtime operations\n   *\n   * When disableInit is true:\n   * - The storage will not automatically create/alter tables on first use\n   * - You must call `storage.init()` explicitly in your CI/CD scripts\n   *\n   * @example\n   * // In CI/CD script:\n   * const storage = new PostgresStore({ ...config, disableInit: false });\n   * await storage.init(); // Explicitly run migrations\n   *\n   * // In runtime application:\n   * const storage = new PostgresStore({ ...config, disableInit: true });\n   * // No auto-init, tables must already exist\n   */\n  disableInit?: boolean;\n}\n\n/**\n * Base class for all Mastra storage adapters.\n *\n * Can be used in two ways:\n *\n * 1. **Extended by store implementations** (PostgresStore, LibSQLStore, etc.):\n *    Store implementations extend this class and set `this.stores` with their domain implementations.\n *\n * 2. **Directly instantiated for composition**:\n *    Compose domains from multiple storage backends using `default` and `domains` options.\n *\n * All domain-specific operations should be accessed through `getStore()`:\n *\n * @example\n * ```typescript\n * // Composition: mix domains from different stores\n * const storage = new MastraCompositeStore({\n *   id: 'composite',\n *   default: pgStore,\n *   domains: {\n *     memory: libsqlStore.stores?.memory,\n *   },\n * });\n *\n * // Access domains\n * const memory = await storage.getStore('memory');\n * await memory?.saveThread({ thread });\n * ```\n */\nexport class MastraCompositeStore extends MastraBase {\n  protected hasInitialized: null | Promise<boolean> = null;\n  protected shouldCacheInit = true;\n\n  id: string;\n  stores?: StorageDomains;\n\n  /**\n   * When true, automatic initialization (table creation/migrations) is disabled.\n   */\n  disableInit: boolean = false;\n\n  constructor(config: MastraCompositeStoreConfig) {\n    const name = config.name ?? 'MastraCompositeStore';\n\n    if (!config.id || typeof config.id !== 'string' || config.id.trim() === '') {\n      throw new Error(`${name}: id must be provided and cannot be empty.`);\n    }\n\n    super({\n      component: 'STORAGE',\n      name,\n    });\n\n    this.id = config.id;\n    this.disableInit = config.disableInit ?? false;\n\n    // If composition config is provided (default or domains), compose the stores\n    if (config.default || config.domains) {\n      const defaultStores = config.default?.stores;\n      const domainOverrides = config.domains ?? {};\n\n      // Validate that at least one storage source is provided\n      const hasDefaultDomains = defaultStores && Object.values(defaultStores).some(v => v !== undefined);\n      const hasOverrideDomains = Object.values(domainOverrides).some(v => v !== undefined);\n\n      if (!hasDefaultDomains && !hasOverrideDomains) {\n        throw new Error(\n          'MastraCompositeStore requires at least one storage source. Provide either a default storage with domains or domain overrides.',\n        );\n      }\n\n      // Build the composed stores object\n      // Domain overrides take precedence over default storage\n      this.stores = {\n        memory: domainOverrides.memory ?? defaultStores?.memory,\n        workflows: domainOverrides.workflows ?? defaultStores?.workflows,\n        scores: domainOverrides.scores ?? defaultStores?.scores,\n        observability: domainOverrides.observability ?? defaultStores?.observability,\n        agents: domainOverrides.agents ?? defaultStores?.agents,\n        datasets: domainOverrides.datasets ?? defaultStores?.datasets,\n        experiments: domainOverrides.experiments ?? defaultStores?.experiments,\n        promptBlocks: domainOverrides.promptBlocks ?? defaultStores?.promptBlocks,\n        scorerDefinitions: domainOverrides.scorerDefinitions ?? defaultStores?.scorerDefinitions,\n        mcpClients: domainOverrides.mcpClients ?? defaultStores?.mcpClients,\n      } as StorageDomains;\n    }\n    // Otherwise, subclasses set stores themselves\n  }\n\n  /**\n   * Get a domain-specific storage interface.\n   *\n   * @param storeName - The name of the domain to access ('memory', 'workflows', 'scores', 'observability', 'agents')\n   * @returns The domain storage interface, or undefined if not available\n   *\n   * @example\n   * ```typescript\n   * const memory = await storage.getStore('memory');\n   * if (memory) {\n   *   await memory.saveThread({ thread });\n   * }\n   * ```\n   */\n  async getStore<K extends keyof StorageDomains>(storeName: K): Promise<StorageDomains[K] | undefined> {\n    return this.stores?.[storeName];\n  }\n\n  /**\n   * Initialize all domain stores.\n   * This creates necessary tables, indexes, and performs any required migrations.\n   */\n  async init(): Promise<void> {\n    // to prevent race conditions, await any current init\n    if (this.shouldCacheInit && (await this.hasInitialized)) {\n      return;\n    }\n\n    // Initialize all domain stores\n    const initTasks: Promise<void>[] = [];\n\n    if (this.stores?.memory) {\n      initTasks.push(this.stores.memory.init());\n    }\n\n    if (this.stores?.workflows) {\n      initTasks.push(this.stores.workflows.init());\n    }\n\n    if (this.stores?.scores) {\n      initTasks.push(this.stores.scores.init());\n    }\n\n    if (this.stores?.observability) {\n      initTasks.push(this.stores.observability.init());\n    }\n\n    if (this.stores?.agents) {\n      initTasks.push(this.stores.agents.init());\n    }\n\n    if (this.stores?.datasets) {\n      initTasks.push(this.stores.datasets.init());\n    }\n\n    if (this.stores?.experiments) {\n      initTasks.push(this.stores.experiments.init());\n    }\n\n    if (this.stores?.promptBlocks) {\n      initTasks.push(this.stores.promptBlocks.init());\n    }\n\n    if (this.stores?.scorerDefinitions) {\n      initTasks.push(this.stores.scorerDefinitions.init());\n    }\n\n    if (this.stores?.mcpClients) {\n      initTasks.push(this.stores.mcpClients.init());\n    }\n\n    this.hasInitialized = Promise.all(initTasks).then(() => true);\n\n    await this.hasInitialized;\n  }\n}\n\n/**\n * @deprecated Use MastraCompositeStoreConfig instead. This alias will be removed in a future version.\n */\nexport interface MastraStorageConfig extends MastraCompositeStoreConfig {}\n\n/**\n * @deprecated Use MastraCompositeStore instead. This alias will be removed in a future version.\n */\nexport class MastraStorage extends MastraCompositeStore {}\n","import { MastraBase } from '../../base';\n\n/**\n * Base class for all storage domains.\n * Provides common interface for initialization and data clearing.\n */\nexport abstract class StorageDomain extends MastraBase {\n  /**\n   * Initialize the storage domain.\n   * This should create any necessary tables/collections.\n   * Default implementation is a no-op - override in adapters that need initialization.\n   */\n  async init(): Promise<void> {\n    // Default no-op - adapters override if they need to create tables/collections\n  }\n\n  /**\n   * Clears all data from this storage domain.\n   * This is a destructive operation - use with caution.\n   * Primarily used for testing.\n   */\n  abstract dangerouslyClearAll(): Promise<void>;\n}\n","import type { StorageOrderBy, ThreadOrderBy, ThreadSortDirection } from '../types';\nimport { StorageDomain } from './base';\n\n// ============================================================================\n// Generic Version Types\n// ============================================================================\n\n/**\n * Base interface for version metadata fields that exist on every version row.\n * The `TFkField` parameter controls the name of the foreign key field.\n */\nexport interface VersionBase {\n  /** UUID identifier for this version */\n  id: string;\n  /** Sequential version number (1, 2, 3, ...) */\n  versionNumber: number;\n  /** Array of field names that changed from the previous version */\n  changedFields?: string[];\n  /** Optional message describing the changes */\n  changeMessage?: string;\n  /** When this version was created */\n  createdAt: Date;\n}\n\n/**\n * Base interface for version creation input.\n * Same as VersionBase but without the server-assigned `createdAt` timestamp.\n */\nexport interface CreateVersionInputBase extends Omit<VersionBase, 'createdAt'> {}\n\n/**\n * Sort direction for version listings.\n */\nexport type VersionSortDirectionGeneric = ThreadSortDirection;\n\n/**\n * Fields that can be used for ordering version listings.\n */\nexport type VersionOrderByGeneric = 'versionNumber' | 'createdAt';\n\n/**\n * Input for listing versions with pagination and sorting.\n */\nexport interface ListVersionsInputBase {\n  /** Page number (0-indexed) */\n  page?: number;\n  /**\n   * Number of items per page, or `false` to fetch all records without pagination limit.\n   * Defaults to 20 if not specified.\n   */\n  perPage?: number | false;\n  /** Sorting options */\n  orderBy?: {\n    field?: VersionOrderByGeneric;\n    direction?: VersionSortDirectionGeneric;\n  };\n}\n\n/**\n * Output for listing versions with pagination info.\n */\nexport interface ListVersionsOutputBase<TVersion> {\n  /** Array of versions for the current page */\n  versions: TVersion[];\n  /** Total number of versions */\n  total: number;\n  /** Current page number */\n  page: number;\n  /** Items per page */\n  perPage: number | false;\n  /** Whether there are more pages */\n  hasMore: boolean;\n}\n\n// ============================================================================\n// Entity base  the \"thin record\" must have these fields\n// ============================================================================\n\nexport interface VersionedEntityBase {\n  id: string;\n  activeVersionId?: string;\n}\n\n// ============================================================================\n// Constants for validation (shared across all versioned domains)\n// ============================================================================\n\nconst ENTITY_ORDER_BY_SET: Record<ThreadOrderBy, true> = {\n  createdAt: true,\n  updatedAt: true,\n};\n\nconst SORT_DIRECTION_SET: Record<ThreadSortDirection, true> = {\n  ASC: true,\n  DESC: true,\n};\n\nconst VERSION_ORDER_BY_SET: Record<VersionOrderByGeneric, true> = {\n  versionNumber: true,\n  createdAt: true,\n};\n\n// ============================================================================\n// VersionedStorageDomain  generic base class\n// ============================================================================\n\n/**\n * Generic base class for versioned storage domains (agents, prompt blocks, scorer definitions).\n *\n * Type parameters:\n * - `TEntity`        Thin record type (e.g. StorageAgentType)\n * - `TSnapshot`      Snapshot config type (e.g. StorageAgentSnapshotType)\n * - `TResolved`      Entity + snapshot merged (e.g. StorageResolvedAgentType)\n * - `TVersion`       Version row (e.g. AgentVersion)\n * - `TCreateVersion`  Input for creating a version\n * - `TListVersionsInput`  Input for listing versions\n * - `TListVersionsOutput`  Output for listing versions\n * - `TCreateInput`   Input for creating an entity\n * - `TUpdateInput`   Input for updating an entity\n * - `TListInput`     Input for listing entities\n * - `TListOutput`    Output for listing entities (paginated thin records)\n * - `TListResolvedOutput`  Output for listing resolved entities\n */\nexport abstract class VersionedStorageDomain<\n  TEntity extends VersionedEntityBase,\n  TSnapshot,\n  TResolved extends TEntity,\n  TVersion extends VersionBase,\n  TCreateVersion extends CreateVersionInputBase,\n  TListVersionsInput extends ListVersionsInputBase,\n  TListVersionsOutput extends ListVersionsOutputBase<TVersion>,\n  TCreateInput,\n  TUpdateInput,\n  TListInput,\n  TListOutput,\n  TListResolvedOutput,\n> extends StorageDomain {\n  /**\n   * The key name used in list outputs (e.g. 'agents', 'promptBlocks', 'scorerDefinitions').\n   * Subclasses must provide this so the generic resolution logic can build the correct output shape.\n   */\n  protected abstract readonly listKey: string;\n\n  /**\n   * The set of version metadata field names (including the FK field) to strip\n   * when extracting snapshot config from a version row.\n   * e.g. ['id', 'agentId', 'versionNumber', 'changedFields', 'changeMessage', 'createdAt']\n   */\n  protected abstract readonly versionMetadataFields: string[];\n\n  // ==========================================================================\n  // Entity CRUD (abstract  implemented by concrete store classes)\n  // ==========================================================================\n\n  abstract getById(id: string): Promise<TEntity | null>;\n  abstract create(input: TCreateInput): Promise<TEntity>;\n  abstract update(input: TUpdateInput): Promise<TEntity>;\n  abstract delete(id: string): Promise<void>;\n  abstract list(args?: TListInput): Promise<TListOutput>;\n\n  // ==========================================================================\n  // Version methods (abstract  implemented by concrete store classes)\n  // ==========================================================================\n\n  abstract createVersion(input: TCreateVersion): Promise<TVersion>;\n  abstract getVersion(id: string): Promise<TVersion | null>;\n  abstract getVersionByNumber(entityId: string, versionNumber: number): Promise<TVersion | null>;\n  abstract getLatestVersion(entityId: string): Promise<TVersion | null>;\n  abstract listVersions(input: TListVersionsInput): Promise<TListVersionsOutput>;\n  abstract deleteVersion(id: string): Promise<void>;\n  abstract deleteVersionsByParentId(entityId: string): Promise<void>;\n  abstract countVersions(entityId: string): Promise<number>;\n\n  // ==========================================================================\n  // Concrete resolution methods\n  // ==========================================================================\n\n  /**\n   * Strips version metadata fields from a version row, leaving only snapshot config fields.\n   */\n  protected extractSnapshotConfig(version: TVersion): Partial<TSnapshot> {\n    const result: Record<string, unknown> = {};\n    const metadataSet = new Set(this.versionMetadataFields);\n\n    for (const [key, value] of Object.entries(version)) {\n      if (!metadataSet.has(key)) {\n        result[key] = value;\n      }\n    }\n\n    return result as Partial<TSnapshot>;\n  }\n\n  /**\n   * Resolves an entity by merging its thin record with the active (or latest) version config.\n   */\n  async getByIdResolved(id: string): Promise<TResolved | null> {\n    const entity = await this.getById(id);\n\n    if (!entity) {\n      return null;\n    }\n\n    return this.resolveEntity(entity);\n  }\n\n  /**\n   * Lists entities with version resolution.\n   */\n  async listResolved(args?: TListInput): Promise<TListResolvedOutput> {\n    const result = await this.list(args);\n\n    const entities = (result as Record<string, unknown>)[this.listKey] as TEntity[];\n    const resolved = await Promise.all(entities.map(entity => this.resolveEntity(entity)));\n\n    return {\n      ...result,\n      [this.listKey]: resolved,\n    } as TListResolvedOutput;\n  }\n\n  /**\n   * Resolves a single entity by merging it with its active or latest version.\n   */\n  protected async resolveEntity(entity: TEntity): Promise<TResolved> {\n    let version: TVersion | null = null;\n\n    if (entity.activeVersionId) {\n      version = await this.getVersion(entity.activeVersionId);\n\n      if (!version) {\n        this.logger?.warn?.(\n          `Entity ${entity.id} has activeVersionId ${entity.activeVersionId} but version not found. Falling back to latest version.`,\n        );\n      }\n    }\n\n    if (!version) {\n      version = await this.getLatestVersion(entity.id);\n    }\n\n    if (version) {\n      const snapshotConfig = this.extractSnapshotConfig(version);\n      return {\n        ...entity,\n        ...snapshotConfig,\n      } as unknown as TResolved;\n    }\n\n    return entity as unknown as TResolved;\n  }\n\n  // ==========================================================================\n  // Protected Helper Methods\n  // ==========================================================================\n\n  protected parseOrderBy(\n    orderBy?: StorageOrderBy,\n    defaultDirection: ThreadSortDirection = 'DESC',\n  ): { field: ThreadOrderBy; direction: ThreadSortDirection } {\n    return {\n      field: orderBy?.field && orderBy.field in ENTITY_ORDER_BY_SET ? orderBy.field : 'createdAt',\n      direction: orderBy?.direction && orderBy.direction in SORT_DIRECTION_SET ? orderBy.direction : defaultDirection,\n    };\n  }\n\n  protected parseVersionOrderBy(\n    orderBy?: TListVersionsInput['orderBy'],\n    defaultDirection: VersionSortDirectionGeneric = 'DESC',\n  ): { field: VersionOrderByGeneric; direction: VersionSortDirectionGeneric } {\n    return {\n      field: orderBy?.field && orderBy.field in VERSION_ORDER_BY_SET ? orderBy.field : 'versionNumber',\n      direction: orderBy?.direction && orderBy.direction in SORT_DIRECTION_SET ? orderBy.direction : defaultDirection,\n    };\n  }\n}\n","import type {\n  StorageAgentType,\n  StorageAgentSnapshotType,\n  StorageResolvedAgentType,\n  StorageCreateAgentInput,\n  StorageUpdateAgentInput,\n  StorageListAgentsInput,\n  StorageListAgentsOutput,\n  StorageListAgentsResolvedOutput,\n} from '../../types';\nimport { VersionedStorageDomain } from '../versioned';\nimport type { VersionBase, CreateVersionInputBase, ListVersionsInputBase, ListVersionsOutputBase } from '../versioned';\n\n// ============================================================================\n// Agent Version Types\n// ============================================================================\n\n/**\n * Represents a stored version of an agent configuration.\n * The config fields are top-level on the version row (no nested snapshot object).\n */\nexport interface AgentVersion extends StorageAgentSnapshotType, VersionBase {\n  /** ID of the agent this version belongs to */\n  agentId: string;\n}\n\n/**\n * Input for creating a new agent version.\n * Config fields are top-level (no nested snapshot object).\n */\nexport interface CreateVersionInput extends StorageAgentSnapshotType, CreateVersionInputBase {\n  /** ID of the agent this version belongs to */\n  agentId: string;\n}\n\n/**\n * Sort direction for version listings.\n */\nexport type VersionSortDirection = 'ASC' | 'DESC';\n\n/**\n * Fields that can be used for ordering version listings.\n */\nexport type VersionOrderBy = 'versionNumber' | 'createdAt';\n\n/**\n * Input for listing agent versions with pagination and sorting.\n */\nexport interface ListVersionsInput extends ListVersionsInputBase {\n  /** ID of the agent to list versions for */\n  agentId: string;\n}\n\n/**\n * Output for listing agent versions with pagination info.\n */\nexport interface ListVersionsOutput extends ListVersionsOutputBase<AgentVersion> {}\n\n// ============================================================================\n// AgentsStorage Base Class\n// ============================================================================\n\nexport abstract class AgentsStorage extends VersionedStorageDomain<\n  StorageAgentType,\n  StorageAgentSnapshotType,\n  StorageResolvedAgentType,\n  AgentVersion,\n  CreateVersionInput,\n  ListVersionsInput,\n  ListVersionsOutput,\n  { agent: StorageCreateAgentInput },\n  StorageUpdateAgentInput,\n  StorageListAgentsInput | undefined,\n  StorageListAgentsOutput,\n  StorageListAgentsResolvedOutput\n> {\n  protected readonly listKey = 'agents';\n  protected readonly versionMetadataFields = [\n    'id',\n    'agentId',\n    'versionNumber',\n    'changedFields',\n    'changeMessage',\n    'createdAt',\n  ] satisfies (keyof AgentVersion)[];\n\n  constructor() {\n    super({\n      component: 'STORAGE',\n      name: 'AGENTS',\n    });\n  }\n}\n","import { deepEqual } from '../../../utils';\nimport { normalizePerPage, calculatePagination } from '../../base';\nimport type {\n  StorageAgentType,\n  StorageCreateAgentInput,\n  StorageUpdateAgentInput,\n  StorageListAgentsInput,\n  StorageListAgentsOutput,\n  ThreadOrderBy,\n  ThreadSortDirection,\n} from '../../types';\nimport type { InMemoryDB } from '../inmemory-db';\nimport type {\n  AgentVersion,\n  CreateVersionInput,\n  ListVersionsInput,\n  ListVersionsOutput,\n  VersionOrderBy,\n  VersionSortDirection,\n} from './base';\nimport { AgentsStorage } from './base';\n\nexport class InMemoryAgentsStorage extends AgentsStorage {\n  private db: InMemoryDB;\n\n  constructor({ db }: { db: InMemoryDB }) {\n    super();\n    this.db = db;\n  }\n\n  async dangerouslyClearAll(): Promise<void> {\n    this.db.agents.clear();\n    this.db.agentVersions.clear();\n  }\n\n  // ==========================================================================\n  // Agent CRUD Methods\n  // ==========================================================================\n\n  async getById(id: string): Promise<StorageAgentType | null> {\n    this.logger.debug(`InMemoryAgentsStorage: getById called for ${id}`);\n    const agent = this.db.agents.get(id);\n    return agent ? this.deepCopyAgent(agent) : null;\n  }\n\n  async create(input: { agent: StorageCreateAgentInput }): Promise<StorageAgentType> {\n    const { agent } = input;\n    this.logger.debug(`InMemoryAgentsStorage: create called for ${agent.id}`);\n\n    if (this.db.agents.has(agent.id)) {\n      throw new Error(`Agent with id ${agent.id} already exists`);\n    }\n\n    const now = new Date();\n    const newAgent: StorageAgentType = {\n      id: agent.id,\n      status: 'draft',\n      activeVersionId: undefined,\n      authorId: agent.authorId,\n      metadata: agent.metadata,\n      createdAt: now,\n      updatedAt: now,\n    };\n\n    this.db.agents.set(agent.id, newAgent);\n\n    // Extract config fields from the flat input (everything except agent-record fields)\n    const { id: _id, authorId: _authorId, metadata: _metadata, ...snapshotConfig } = agent;\n\n    // Create version 1 from the config\n    const versionId = crypto.randomUUID();\n    await this.createVersion({\n      id: versionId,\n      agentId: agent.id,\n      versionNumber: 1,\n      ...snapshotConfig,\n      changedFields: Object.keys(snapshotConfig),\n      changeMessage: 'Initial version',\n    });\n\n    // Return the thin agent record (activeVersionId remains null)\n    return this.deepCopyAgent(newAgent);\n  }\n\n  async update(input: StorageUpdateAgentInput): Promise<StorageAgentType> {\n    const { id, ...updates } = input;\n    this.logger.debug(`InMemoryAgentsStorage: update called for ${id}`);\n\n    const existingAgent = this.db.agents.get(id);\n    if (!existingAgent) {\n      throw new Error(`Agent with id ${id} not found`);\n    }\n\n    // Separate metadata fields from config fields\n    const { authorId, activeVersionId, metadata, ...configFields } = updates;\n\n    // Extract just the config field names from StorageAgentSnapshotType\n    const configFieldNames = [\n      'name',\n      'description',\n      'instructions',\n      'model',\n      'tools',\n      'defaultOptions',\n      'workflows',\n      'agents',\n      'integrationTools',\n      'inputProcessors',\n      'outputProcessors',\n      'memory',\n      'scorers',\n      'mcpClients',\n      'requestContextSchema',\n    ];\n\n    // Check if any config fields are present in the update\n    const hasConfigUpdate = configFieldNames.some(field => field in configFields);\n\n    // Update metadata fields on the agent record\n    const updatedAgent: StorageAgentType = {\n      ...existingAgent,\n      ...(authorId !== undefined && { authorId }),\n      ...(activeVersionId !== undefined && { activeVersionId }),\n      ...(metadata !== undefined && {\n        metadata: { ...existingAgent.metadata, ...metadata },\n      }),\n      updatedAt: new Date(),\n    };\n\n    // If activeVersionId is set, mark as published\n    if (activeVersionId !== undefined) {\n      updatedAgent.status = 'published';\n    }\n\n    // If config fields are being updated, create a new version\n    if (hasConfigUpdate) {\n      // Get the latest version to use as base\n      const latestVersion = await this.getLatestVersion(id);\n      if (!latestVersion) {\n        throw new Error(`No versions found for agent ${id}`);\n      }\n\n      // Extract config from latest version\n      const {\n        id: _versionId,\n        agentId: _agentId,\n        versionNumber: _versionNumber,\n        changedFields: _changedFields,\n        changeMessage: _changeMessage,\n        createdAt: _createdAt,\n        ...latestConfig\n      } = latestVersion;\n\n      // Merge updates into latest config\n      // Convert null values to undefined (null means \"remove this field\")\n      const sanitizedConfigFields = Object.fromEntries(\n        Object.entries(configFields).map(([key, value]) => [key, value === null ? undefined : value]),\n      );\n      const newConfig = {\n        ...latestConfig,\n        ...sanitizedConfigFields,\n      };\n\n      // Identify which fields changed\n      const changedFields = configFieldNames.filter(\n        field =>\n          field in configFields &&\n          JSON.stringify(configFields[field as keyof typeof configFields]) !==\n            JSON.stringify(latestConfig[field as keyof typeof latestConfig]),\n      );\n\n      // Only create a new version if something actually changed\n      if (changedFields.length > 0) {\n        const newVersionId = crypto.randomUUID();\n        const newVersionNumber = latestVersion.versionNumber + 1;\n\n        await this.createVersion({\n          id: newVersionId,\n          agentId: id,\n          versionNumber: newVersionNumber,\n          ...newConfig,\n          changedFields,\n          changeMessage: `Updated ${changedFields.join(', ')}`,\n        });\n      }\n    }\n\n    // Save the updated agent record\n    this.db.agents.set(id, updatedAgent);\n    return this.deepCopyAgent(updatedAgent);\n  }\n\n  async delete(id: string): Promise<void> {\n    this.logger.debug(`InMemoryAgentsStorage: delete called for ${id}`);\n    // Idempotent delete - no-op if agent doesn't exist\n    this.db.agents.delete(id);\n    // Also delete all versions for this agent\n    await this.deleteVersionsByParentId(id);\n  }\n\n  async list(args?: StorageListAgentsInput): Promise<StorageListAgentsOutput> {\n    const { page = 0, perPage: perPageInput, orderBy, authorId, metadata } = args || {};\n    const { field, direction } = this.parseOrderBy(orderBy);\n\n    this.logger.debug(`InMemoryAgentsStorage: list called`);\n\n    // Normalize perPage for query (false  MAX_SAFE_INTEGER, 0  0, undefined  100)\n    const perPage = normalizePerPage(perPageInput, 100);\n\n    if (page < 0) {\n      throw new Error('page must be >= 0');\n    }\n\n    // Prevent unreasonably large page values\n    const maxOffset = Number.MAX_SAFE_INTEGER / 2;\n    if (page * perPage > maxOffset) {\n      throw new Error('page value too large');\n    }\n\n    // Get all agents and apply filters\n    let agents = Array.from(this.db.agents.values());\n\n    // Filter by authorId if provided\n    if (authorId !== undefined) {\n      agents = agents.filter(agent => agent.authorId === authorId);\n    }\n\n    // Filter by metadata if provided (AND logic - all key-value pairs must match)\n    if (metadata && Object.keys(metadata).length > 0) {\n      agents = agents.filter(agent => {\n        if (!agent.metadata) return false;\n        return Object.entries(metadata).every(([key, value]) => deepEqual(agent.metadata![key], value));\n      });\n    }\n\n    // Sort filtered agents\n    const sortedAgents = this.sortAgents(agents, field, direction);\n\n    // Deep clone agents to avoid mutation\n    const clonedAgents = sortedAgents.map(agent => this.deepCopyAgent(agent));\n\n    const { offset, perPage: perPageForResponse } = calculatePagination(page, perPageInput, perPage);\n\n    return {\n      agents: clonedAgents.slice(offset, offset + perPage),\n      total: clonedAgents.length,\n      page,\n      perPage: perPageForResponse,\n      hasMore: offset + perPage < clonedAgents.length,\n    };\n  }\n\n  // ==========================================================================\n  // Agent Version Methods\n  // ==========================================================================\n\n  async createVersion(input: CreateVersionInput): Promise<AgentVersion> {\n    this.logger.debug(`InMemoryAgentsStorage: createVersion called for agent ${input.agentId}`);\n\n    // Check if version with this ID already exists (versions are immutable)\n    if (this.db.agentVersions.has(input.id)) {\n      throw new Error(`Version with id ${input.id} already exists`);\n    }\n\n    // Check for duplicate (agentId, versionNumber) pair\n    for (const version of this.db.agentVersions.values()) {\n      if (version.agentId === input.agentId && version.versionNumber === input.versionNumber) {\n        throw new Error(`Version number ${input.versionNumber} already exists for agent ${input.agentId}`);\n      }\n    }\n\n    const version: AgentVersion = {\n      ...input,\n      createdAt: new Date(),\n    };\n\n    // Deep clone before storing to prevent external mutation\n    this.db.agentVersions.set(input.id, this.deepCopyVersion(version));\n    return this.deepCopyVersion(version);\n  }\n\n  async getVersion(id: string): Promise<AgentVersion | null> {\n    this.logger.debug(`InMemoryAgentsStorage: getVersion called for ${id}`);\n    const version = this.db.agentVersions.get(id);\n    return version ? this.deepCopyVersion(version) : null;\n  }\n\n  async getVersionByNumber(agentId: string, versionNumber: number): Promise<AgentVersion | null> {\n    this.logger.debug(`InMemoryAgentsStorage: getVersionByNumber called for agent ${agentId}, v${versionNumber}`);\n\n    for (const version of this.db.agentVersions.values()) {\n      if (version.agentId === agentId && version.versionNumber === versionNumber) {\n        return this.deepCopyVersion(version);\n      }\n    }\n    return null;\n  }\n\n  async getLatestVersion(agentId: string): Promise<AgentVersion | null> {\n    this.logger.debug(`InMemoryAgentsStorage: getLatestVersion called for agent ${agentId}`);\n\n    let latest: AgentVersion | null = null;\n    for (const version of this.db.agentVersions.values()) {\n      if (version.agentId === agentId) {\n        if (!latest || version.versionNumber > latest.versionNumber) {\n          latest = version;\n        }\n      }\n    }\n    return latest ? this.deepCopyVersion(latest) : null;\n  }\n\n  async listVersions(input: ListVersionsInput): Promise<ListVersionsOutput> {\n    const { agentId, page = 0, perPage: perPageInput, orderBy } = input;\n    const { field, direction } = this.parseVersionOrderBy(orderBy);\n\n    this.logger.debug(`InMemoryAgentsStorage: listVersions called for agent ${agentId}`);\n\n    // Normalize perPage for query (false -> MAX_SAFE_INTEGER, 0 -> 0, undefined -> 20)\n    const perPage = normalizePerPage(perPageInput, 20);\n\n    if (page < 0) {\n      throw new Error('page must be >= 0');\n    }\n\n    // Prevent unreasonably large page values\n    const maxOffset = Number.MAX_SAFE_INTEGER / 2;\n    if (page * perPage > maxOffset) {\n      throw new Error('page value too large');\n    }\n\n    // Filter versions by agentId\n    let versions = Array.from(this.db.agentVersions.values()).filter(v => v.agentId === agentId);\n\n    // Sort versions\n    versions = this.sortVersions(versions, field, direction);\n\n    // Deep clone versions to avoid mutation\n    const clonedVersions = versions.map(v => this.deepCopyVersion(v));\n\n    const total = clonedVersions.length;\n    const { offset, perPage: perPageForResponse } = calculatePagination(page, perPageInput, perPage);\n    const paginatedVersions = clonedVersions.slice(offset, offset + perPage);\n\n    return {\n      versions: paginatedVersions,\n      total,\n      page,\n      perPage: perPageForResponse,\n      hasMore: offset + perPage < total,\n    };\n  }\n\n  async deleteVersion(id: string): Promise<void> {\n    this.logger.debug(`InMemoryAgentsStorage: deleteVersion called for ${id}`);\n    // Idempotent delete - no-op if version doesn't exist\n    this.db.agentVersions.delete(id);\n  }\n\n  async deleteVersionsByParentId(entityId: string): Promise<void> {\n    this.logger.debug(`InMemoryAgentsStorage: deleteVersionsByParentId called for agent ${entityId}`);\n\n    const idsToDelete: string[] = [];\n    for (const [id, version] of this.db.agentVersions.entries()) {\n      if (version.agentId === entityId) {\n        idsToDelete.push(id);\n      }\n    }\n\n    for (const id of idsToDelete) {\n      this.db.agentVersions.delete(id);\n    }\n  }\n\n  async countVersions(agentId: string): Promise<number> {\n    this.logger.debug(`InMemoryAgentsStorage: countVersions called for agent ${agentId}`);\n\n    let count = 0;\n    for (const version of this.db.agentVersions.values()) {\n      if (version.agentId === agentId) {\n        count++;\n      }\n    }\n    return count;\n  }\n\n  // ==========================================================================\n  // Private Helper Methods\n  // ==========================================================================\n\n  /**\n   * Deep copy a thin agent record to prevent external mutation of stored data\n   */\n  private deepCopyAgent(agent: StorageAgentType): StorageAgentType {\n    return {\n      ...agent,\n      metadata: agent.metadata ? { ...agent.metadata } : agent.metadata,\n    };\n  }\n\n  /**\n   * Deep copy a version to prevent external mutation of stored data\n   */\n  private deepCopyVersion(version: AgentVersion): AgentVersion {\n    return structuredClone(version);\n  }\n\n  private sortAgents(\n    agents: StorageAgentType[],\n    field: ThreadOrderBy,\n    direction: ThreadSortDirection,\n  ): StorageAgentType[] {\n    return agents.sort((a, b) => {\n      const aValue = new Date(a[field]).getTime();\n      const bValue = new Date(b[field]).getTime();\n\n      return direction === 'ASC' ? aValue - bValue : bValue - aValue;\n    });\n  }\n\n  private sortVersions(\n    versions: AgentVersion[],\n    field: VersionOrderBy,\n    direction: VersionSortDirection,\n  ): AgentVersion[] {\n    return versions.sort((a, b) => {\n      let aVal: number;\n      let bVal: number;\n\n      if (field === 'createdAt') {\n        aVal = a.createdAt.getTime();\n        bVal = b.createdAt.getTime();\n      } else {\n        // versionNumber\n        aVal = a.versionNumber;\n        bVal = b.versionNumber;\n      }\n\n      return direction === 'ASC' ? aVal - bVal : bVal - aVal;\n    });\n  }\n}\n","import type { ScoreRowData } from '../../evals/types';\nimport type { StorageThreadType } from '../../memory/types';\nimport type {\n  StorageAgentType,\n  StorageMCPClientType,\n  StorageMessageType,\n  StoragePromptBlockType,\n  StorageResourceType,\n  StorageScorerDefinitionType,\n  StorageWorkflowRun,\n  ObservationalMemoryRecord,\n  DatasetRecord,\n  DatasetItemRow,\n  DatasetVersion,\n  Experiment,\n  ExperimentResult,\n} from '../types';\nimport type { AgentVersion } from './agents';\nimport type { MCPClientVersion } from './mcp-clients';\nimport type { TraceEntry } from './observability';\nimport type { PromptBlockVersion } from './prompt-blocks';\nimport type { ScorerDefinitionVersion } from './scorer-definitions';\n\n/**\n * InMemoryDB is a thin database layer for in-memory storage.\n * It holds all the Maps that store data, similar to how a real database\n * connection (pg-promise client, libsql client) is shared across domains.\n *\n * Each domain receives a reference to this db and operates on the relevant Maps.\n */\nexport class InMemoryDB {\n  readonly threads = new Map<string, StorageThreadType>();\n  readonly messages = new Map<string, StorageMessageType>();\n  readonly resources = new Map<string, StorageResourceType>();\n  readonly workflows = new Map<string, StorageWorkflowRun>();\n  readonly scores = new Map<string, ScoreRowData>();\n  readonly traces = new Map<string, TraceEntry>();\n  readonly agents = new Map<string, StorageAgentType>();\n  readonly agentVersions = new Map<string, AgentVersion>();\n  readonly promptBlocks = new Map<string, StoragePromptBlockType>();\n  readonly promptBlockVersions = new Map<string, PromptBlockVersion>();\n  readonly scorerDefinitions = new Map<string, StorageScorerDefinitionType>();\n  readonly scorerDefinitionVersions = new Map<string, ScorerDefinitionVersion>();\n  readonly mcpClients = new Map<string, StorageMCPClientType>();\n  readonly mcpClientVersions = new Map<string, MCPClientVersion>();\n  /** Observational memory records, keyed by resourceId, each holding array of records (generations) */\n  readonly observationalMemory = new Map<string, ObservationalMemoryRecord[]>();\n\n  // Dataset domain maps\n  readonly datasets = new Map<string, DatasetRecord>();\n  readonly datasetItems = new Map<string, DatasetItemRow[]>();\n  readonly datasetVersions = new Map<string, DatasetVersion>();\n\n  // Experiment domain maps\n  readonly experiments = new Map<string, Experiment>();\n  readonly experimentResults = new Map<string, ExperimentResult>();\n\n  /**\n   * Clears all data from all collections.\n   * Useful for testing.\n   */\n  clear(): void {\n    this.threads.clear();\n    this.messages.clear();\n    this.resources.clear();\n    this.workflows.clear();\n    this.scores.clear();\n    this.traces.clear();\n    this.agents.clear();\n    this.agentVersions.clear();\n    this.promptBlocks.clear();\n    this.promptBlockVersions.clear();\n    this.scorerDefinitions.clear();\n    this.scorerDefinitionVersions.clear();\n    this.mcpClients.clear();\n    this.mcpClientVersions.clear();\n    this.observationalMemory.clear();\n    this.datasets.clear();\n    this.datasetItems.clear();\n    this.datasetVersions.clear();\n    this.experiments.clear();\n    this.experimentResults.clear();\n  }\n}\n","import type {\n  StorageMCPClientType,\n  StorageMCPClientSnapshotType,\n  StorageResolvedMCPClientType,\n  StorageCreateMCPClientInput,\n  StorageUpdateMCPClientInput,\n  StorageListMCPClientsInput,\n  StorageListMCPClientsOutput,\n  StorageListMCPClientsResolvedOutput,\n} from '../../types';\nimport { VersionedStorageDomain } from '../versioned';\nimport type { VersionBase, CreateVersionInputBase, ListVersionsInputBase, ListVersionsOutputBase } from '../versioned';\n\n// ============================================================================\n// MCP Client Version Types\n// ============================================================================\n\n/**\n * Represents a stored version of an MCP client's content.\n * Client fields are top-level on the version row (no nested snapshot object).\n */\nexport interface MCPClientVersion extends StorageMCPClientSnapshotType, VersionBase {\n  /** ID of the MCP client this version belongs to */\n  mcpClientId: string;\n}\n\n/**\n * Input for creating a new MCP client version.\n * Client fields are top-level (no nested snapshot object).\n */\nexport interface CreateMCPClientVersionInput extends StorageMCPClientSnapshotType, CreateVersionInputBase {\n  /** ID of the MCP client this version belongs to */\n  mcpClientId: string;\n}\n\n/**\n * Sort direction for version listings.\n */\nexport type MCPClientVersionSortDirection = 'ASC' | 'DESC';\n\n/**\n * Fields that can be used for ordering version listings.\n */\nexport type MCPClientVersionOrderBy = 'versionNumber' | 'createdAt';\n\n/**\n * Input for listing MCP client versions with pagination and sorting.\n */\nexport interface ListMCPClientVersionsInput extends ListVersionsInputBase {\n  /** ID of the MCP client to list versions for */\n  mcpClientId: string;\n}\n\n/**\n * Output for listing MCP client versions with pagination info.\n */\nexport interface ListMCPClientVersionsOutput extends ListVersionsOutputBase<MCPClientVersion> {}\n\n// ============================================================================\n// MCPClientsStorage Base Class\n// ============================================================================\n\nexport abstract class MCPClientsStorage extends VersionedStorageDomain<\n  StorageMCPClientType,\n  StorageMCPClientSnapshotType,\n  StorageResolvedMCPClientType,\n  MCPClientVersion,\n  CreateMCPClientVersionInput,\n  ListMCPClientVersionsInput,\n  ListMCPClientVersionsOutput,\n  { mcpClient: StorageCreateMCPClientInput },\n  StorageUpdateMCPClientInput,\n  StorageListMCPClientsInput | undefined,\n  StorageListMCPClientsOutput,\n  StorageListMCPClientsResolvedOutput\n> {\n  protected readonly listKey = 'mcpClients';\n  protected readonly versionMetadataFields = [\n    'id',\n    'mcpClientId',\n    'versionNumber',\n    'changedFields',\n    'changeMessage',\n    'createdAt',\n  ] satisfies (keyof MCPClientVersion)[];\n\n  constructor() {\n    super({\n      component: 'STORAGE',\n      name: 'MCP_CLIENTS',\n    });\n  }\n}\n","import { deepEqual } from '../../../utils';\nimport { normalizePerPage, calculatePagination } from '../../base';\nimport type {\n  StorageMCPClientType,\n  StorageCreateMCPClientInput,\n  StorageUpdateMCPClientInput,\n  StorageListMCPClientsInput,\n  StorageListMCPClientsOutput,\n  ThreadOrderBy,\n  ThreadSortDirection,\n} from '../../types';\nimport type { InMemoryDB } from '../inmemory-db';\nimport type {\n  MCPClientVersion,\n  CreateMCPClientVersionInput,\n  ListMCPClientVersionsInput,\n  ListMCPClientVersionsOutput,\n  MCPClientVersionOrderBy,\n  MCPClientVersionSortDirection,\n} from './base';\nimport { MCPClientsStorage } from './base';\n\nexport class InMemoryMCPClientsStorage extends MCPClientsStorage {\n  private db: InMemoryDB;\n\n  constructor({ db }: { db: InMemoryDB }) {\n    super();\n    this.db = db;\n  }\n\n  async dangerouslyClearAll(): Promise<void> {\n    this.db.mcpClients.clear();\n    this.db.mcpClientVersions.clear();\n  }\n\n  // ==========================================================================\n  // MCP Client CRUD Methods\n  // ==========================================================================\n\n  async getById(id: string): Promise<StorageMCPClientType | null> {\n    this.logger.debug(`InMemoryMCPClientsStorage: getById called for ${id}`);\n    const config = this.db.mcpClients.get(id);\n    return config ? this.deepCopyConfig(config) : null;\n  }\n\n  async create(input: { mcpClient: StorageCreateMCPClientInput }): Promise<StorageMCPClientType> {\n    const { mcpClient } = input;\n    this.logger.debug(`InMemoryMCPClientsStorage: create called for ${mcpClient.id}`);\n\n    if (this.db.mcpClients.has(mcpClient.id)) {\n      throw new Error(`MCP client with id ${mcpClient.id} already exists`);\n    }\n\n    const now = new Date();\n    const newConfig: StorageMCPClientType = {\n      id: mcpClient.id,\n      status: 'draft',\n      activeVersionId: undefined,\n      authorId: mcpClient.authorId,\n      metadata: mcpClient.metadata,\n      createdAt: now,\n      updatedAt: now,\n    };\n\n    this.db.mcpClients.set(mcpClient.id, newConfig);\n\n    // Extract config fields from the flat input (everything except record fields)\n    const { id: _id, authorId: _authorId, metadata: _metadata, ...snapshotConfig } = mcpClient;\n\n    // Create version 1 from the config\n    const versionId = crypto.randomUUID();\n    await this.createVersion({\n      id: versionId,\n      mcpClientId: mcpClient.id,\n      versionNumber: 1,\n      ...snapshotConfig,\n      changedFields: Object.keys(snapshotConfig),\n      changeMessage: 'Initial version',\n    });\n\n    // Return the thin record\n    return this.deepCopyConfig(newConfig);\n  }\n\n  async update(input: StorageUpdateMCPClientInput): Promise<StorageMCPClientType> {\n    const { id, ...updates } = input;\n    this.logger.debug(`InMemoryMCPClientsStorage: update called for ${id}`);\n\n    const existingConfig = this.db.mcpClients.get(id);\n    if (!existingConfig) {\n      throw new Error(`MCP client with id ${id} not found`);\n    }\n\n    // Separate metadata fields from config fields\n    const { authorId, activeVersionId, metadata, status, ...configFields } = updates;\n\n    // Config field names from StorageMCPClientSnapshotType\n    const configFieldNames = ['name', 'description', 'servers'];\n\n    // Check if any config fields are present in the update\n    const hasConfigUpdate = configFieldNames.some(field => field in configFields);\n\n    // Update metadata fields on the record\n    const updatedConfig: StorageMCPClientType = {\n      ...existingConfig,\n      ...(authorId !== undefined && { authorId }),\n      ...(activeVersionId !== undefined && { activeVersionId }),\n      ...(status !== undefined && { status: status as StorageMCPClientType['status'] }),\n      ...(metadata !== undefined && {\n        metadata: { ...existingConfig.metadata, ...metadata },\n      }),\n      updatedAt: new Date(),\n    };\n\n    // Auto-set status to 'published' when activeVersionId is set, only if status is not explicitly provided\n    if (activeVersionId !== undefined && status === undefined) {\n      updatedConfig.status = 'published';\n    }\n\n    // If config fields are being updated, create a new version\n    if (hasConfigUpdate) {\n      // Get the latest version to use as base\n      const latestVersion = await this.getLatestVersion(id);\n      if (!latestVersion) {\n        throw new Error(`No versions found for MCP client ${id}`);\n      }\n\n      // Extract config from latest version\n      const {\n        id: _versionId,\n        mcpClientId: _mcpClientId,\n        versionNumber: _versionNumber,\n        changedFields: _changedFields,\n        changeMessage: _changeMessage,\n        createdAt: _createdAt,\n        ...latestConfig\n      } = latestVersion;\n\n      // Merge updates into latest config\n      const newConfig = {\n        ...latestConfig,\n        ...configFields,\n      };\n\n      // Identify which fields changed\n      const changedFields = configFieldNames.filter(\n        field =>\n          field in configFields &&\n          JSON.stringify(configFields[field as keyof typeof configFields]) !==\n            JSON.stringify(latestConfig[field as keyof typeof latestConfig]),\n      );\n\n      // Only create a new version if something actually changed\n      if (changedFields.length > 0) {\n        const newVersionId = crypto.randomUUID();\n        const newVersionNumber = latestVersion.versionNumber + 1;\n\n        await this.createVersion({\n          id: newVersionId,\n          mcpClientId: id,\n          versionNumber: newVersionNumber,\n          ...newConfig,\n          changedFields,\n          changeMessage: `Updated ${changedFields.join(', ')}`,\n        });\n      }\n    }\n\n    // Save the updated record\n    this.db.mcpClients.set(id, updatedConfig);\n    return this.deepCopyConfig(updatedConfig);\n  }\n\n  async delete(id: string): Promise<void> {\n    this.logger.debug(`InMemoryMCPClientsStorage: delete called for ${id}`);\n    // Idempotent delete\n    this.db.mcpClients.delete(id);\n    // Also delete all versions for this client\n    await this.deleteVersionsByParentId(id);\n  }\n\n  async list(args?: StorageListMCPClientsInput): Promise<StorageListMCPClientsOutput> {\n    const { page = 0, perPage: perPageInput, orderBy, authorId, metadata } = args || {};\n    const { field, direction } = this.parseOrderBy(orderBy);\n\n    this.logger.debug(`InMemoryMCPClientsStorage: list called`);\n\n    // Normalize perPage for query (false  MAX_SAFE_INTEGER, 0  0, undefined  100)\n    const perPage = normalizePerPage(perPageInput, 100);\n\n    if (page < 0) {\n      throw new Error('page must be >= 0');\n    }\n\n    // Prevent unreasonably large page values\n    const maxOffset = Number.MAX_SAFE_INTEGER / 2;\n    if (page * perPage > maxOffset) {\n      throw new Error('page value too large');\n    }\n\n    // Get all MCP clients and apply filters\n    let configs = Array.from(this.db.mcpClients.values());\n\n    // Filter by authorId if provided\n    if (authorId !== undefined) {\n      configs = configs.filter(config => config.authorId === authorId);\n    }\n\n    // Filter by metadata if provided (AND logic)\n    if (metadata && Object.keys(metadata).length > 0) {\n      configs = configs.filter(config => {\n        if (!config.metadata) return false;\n        return Object.entries(metadata).every(([key, value]) => deepEqual(config.metadata![key], value));\n      });\n    }\n\n    // Sort filtered configs\n    const sortedConfigs = this.sortConfigs(configs, field, direction);\n\n    // Deep clone to avoid mutation\n    const clonedConfigs = sortedConfigs.map(config => this.deepCopyConfig(config));\n\n    const { offset, perPage: perPageForResponse } = calculatePagination(page, perPageInput, perPage);\n\n    return {\n      mcpClients: clonedConfigs.slice(offset, offset + perPage),\n      total: clonedConfigs.length,\n      page,\n      perPage: perPageForResponse,\n      hasMore: offset + perPage < clonedConfigs.length,\n    };\n  }\n\n  // ==========================================================================\n  // MCP Client Version Methods\n  // ==========================================================================\n\n  async createVersion(input: CreateMCPClientVersionInput): Promise<MCPClientVersion> {\n    this.logger.debug(`InMemoryMCPClientsStorage: createVersion called for MCP client ${input.mcpClientId}`);\n\n    // Check if version with this ID already exists\n    if (this.db.mcpClientVersions.has(input.id)) {\n      throw new Error(`Version with id ${input.id} already exists`);\n    }\n\n    // Check for duplicate (mcpClientId, versionNumber) pair\n    for (const version of this.db.mcpClientVersions.values()) {\n      if (version.mcpClientId === input.mcpClientId && version.versionNumber === input.versionNumber) {\n        throw new Error(`Version number ${input.versionNumber} already exists for MCP client ${input.mcpClientId}`);\n      }\n    }\n\n    const version: MCPClientVersion = {\n      ...input,\n      createdAt: new Date(),\n    };\n\n    // Deep clone before storing\n    this.db.mcpClientVersions.set(input.id, this.deepCopyVersion(version));\n    return this.deepCopyVersion(version);\n  }\n\n  async getVersion(id: string): Promise<MCPClientVersion | null> {\n    this.logger.debug(`InMemoryMCPClientsStorage: getVersion called for ${id}`);\n    const version = this.db.mcpClientVersions.get(id);\n    return version ? this.deepCopyVersion(version) : null;\n  }\n\n  async getVersionByNumber(mcpClientId: string, versionNumber: number): Promise<MCPClientVersion | null> {\n    this.logger.debug(\n      `InMemoryMCPClientsStorage: getVersionByNumber called for MCP client ${mcpClientId}, v${versionNumber}`,\n    );\n\n    for (const version of this.db.mcpClientVersions.values()) {\n      if (version.mcpClientId === mcpClientId && version.versionNumber === versionNumber) {\n        return this.deepCopyVersion(version);\n      }\n    }\n    return null;\n  }\n\n  async getLatestVersion(mcpClientId: string): Promise<MCPClientVersion | null> {\n    this.logger.debug(`InMemoryMCPClientsStorage: getLatestVersion called for MCP client ${mcpClientId}`);\n\n    let latest: MCPClientVersion | null = null;\n    for (const version of this.db.mcpClientVersions.values()) {\n      if (version.mcpClientId === mcpClientId) {\n        if (!latest || version.versionNumber > latest.versionNumber) {\n          latest = version;\n        }\n      }\n    }\n    return latest ? this.deepCopyVersion(latest) : null;\n  }\n\n  async listVersions(input: ListMCPClientVersionsInput): Promise<ListMCPClientVersionsOutput> {\n    const { mcpClientId, page = 0, perPage: perPageInput, orderBy } = input;\n    const { field, direction } = this.parseVersionOrderBy(orderBy);\n\n    this.logger.debug(`InMemoryMCPClientsStorage: listVersions called for MCP client ${mcpClientId}`);\n\n    // Normalize perPage (false -> MAX_SAFE_INTEGER, 0 -> 0, undefined -> 20)\n    const perPage = normalizePerPage(perPageInput, 20);\n\n    if (page < 0) {\n      throw new Error('page must be >= 0');\n    }\n\n    const maxOffset = Number.MAX_SAFE_INTEGER / 2;\n    if (page * perPage > maxOffset) {\n      throw new Error('page value too large');\n    }\n\n    // Filter versions by mcpClientId\n    let versions = Array.from(this.db.mcpClientVersions.values()).filter(v => v.mcpClientId === mcpClientId);\n\n    // Sort versions\n    versions = this.sortVersions(versions, field, direction);\n\n    // Deep clone\n    const clonedVersions = versions.map(v => this.deepCopyVersion(v));\n\n    const total = clonedVersions.length;\n    const { offset, perPage: perPageForResponse } = calculatePagination(page, perPageInput, perPage);\n    const paginatedVersions = clonedVersions.slice(offset, offset + perPage);\n\n    return {\n      versions: paginatedVersions,\n      total,\n      page,\n      perPage: perPageForResponse,\n      hasMore: offset + perPage < total,\n    };\n  }\n\n  async deleteVersion(id: string): Promise<void> {\n    this.logger.debug(`InMemoryMCPClientsStorage: deleteVersion called for ${id}`);\n    this.db.mcpClientVersions.delete(id);\n  }\n\n  async deleteVersionsByParentId(entityId: string): Promise<void> {\n    this.logger.debug(`InMemoryMCPClientsStorage: deleteVersionsByParentId called for MCP client ${entityId}`);\n\n    const idsToDelete: string[] = [];\n    for (const [id, version] of this.db.mcpClientVersions.entries()) {\n      if (version.mcpClientId === entityId) {\n        idsToDelete.push(id);\n      }\n    }\n\n    for (const id of idsToDelete) {\n      this.db.mcpClientVersions.delete(id);\n    }\n  }\n\n  async countVersions(mcpClientId: string): Promise<number> {\n    this.logger.debug(`InMemoryMCPClientsStorage: countVersions called for MCP client ${mcpClientId}`);\n\n    let count = 0;\n    for (const version of this.db.mcpClientVersions.values()) {\n      if (version.mcpClientId === mcpClientId) {\n        count++;\n      }\n    }\n    return count;\n  }\n\n  // ==========================================================================\n  // Private Helper Methods\n  // ==========================================================================\n\n  private deepCopyConfig(config: StorageMCPClientType): StorageMCPClientType {\n    return {\n      ...config,\n      metadata: config.metadata ? { ...config.metadata } : config.metadata,\n    };\n  }\n\n  private deepCopyVersion(version: MCPClientVersion): MCPClientVersion {\n    return {\n      ...version,\n      servers: version.servers ? JSON.parse(JSON.stringify(version.servers)) : version.servers,\n      changedFields: version.changedFields ? [...version.changedFields] : version.changedFields,\n    };\n  }\n\n  private sortConfigs(\n    configs: StorageMCPClientType[],\n    field: ThreadOrderBy,\n    direction: ThreadSortDirection,\n  ): StorageMCPClientType[] {\n    return configs.sort((a, b) => {\n      const aValue = a[field].getTime();\n      const bValue = b[field].getTime();\n\n      return direction === 'ASC' ? aValue - bValue : bValue - aValue;\n    });\n  }\n\n  private sortVersions(\n    versions: MCPClientVersion[],\n    field: MCPClientVersionOrderBy,\n    direction: MCPClientVersionSortDirection,\n  ): MCPClientVersion[] {\n    return versions.sort((a, b) => {\n      let aVal: number;\n      let bVal: number;\n\n      if (field === 'createdAt') {\n        aVal = a.createdAt.getTime();\n        bVal = b.createdAt.getTime();\n      } else {\n        // versionNumber\n        aVal = a.versionNumber;\n        bVal = b.versionNumber;\n      }\n\n      return direction === 'ASC' ? aVal - bVal : bVal - aVal;\n    });\n  }\n}\n","import type { ScoreRowData } from '../evals/types';\nimport { TABLE_SCHEMAS, TABLE_SCORERS } from './constants';\nimport type { TABLE_NAMES } from './constants';\nimport type { StorageColumn } from './types';\n\n/**\n * Canonical store names for type safety.\n * Provides autocomplete suggestions while still accepting any string.\n */\nexport type StoreName =\n  | 'PG'\n  | 'MSSQL'\n  | 'LIBSQL'\n  | 'MONGODB'\n  | 'CLICKHOUSE'\n  | 'CLOUDFLARE'\n  | 'CLOUDFLARE_D1'\n  | 'DYNAMODB'\n  | 'LANCE'\n  | 'UPSTASH'\n  | 'ASTRA'\n  | 'CHROMA'\n  | 'COUCHBASE'\n  | 'OPENSEARCH'\n  | 'PINECONE'\n  | 'QDRANT'\n  | 'S3'\n  | 'TURBOPUFFER'\n  | 'VECTORIZE'\n  | (string & {});\n\nexport function safelyParseJSON(input: any): any {\n  // If already an object (and not null), return as-is\n  if (input && typeof input === 'object') return input;\n  if (input == null) return {};\n  // If it's a string, try to parse\n  if (typeof input === 'string') {\n    try {\n      return JSON.parse(input);\n    } catch {\n      return input;\n    }\n  }\n  // For anything else (number, boolean, etc.), return empty object\n  return {};\n}\n\n/**\n * Options for transforming storage rows\n */\nexport interface TransformRowOptions {\n  /**\n   * Preferred source fields for timestamps (e.g., { createdAt: 'createdAtZ' } means use createdAtZ if available, else createdAt)\n   */\n  preferredTimestampFields?: Record<string, string>;\n\n  /**\n   * Convert timestamp strings to Date objects (default: false for backwards compatibility)\n   */\n  convertTimestamps?: boolean;\n\n  /**\n   * Pattern to treat as null (e.g., '_null_' for ClickHouse)\n   */\n  nullValuePattern?: string;\n\n  /**\n   * Custom field mappings from source to target (e.g., { entity: 'entityData' } for DynamoDB)\n   */\n  fieldMappings?: Record<string, string>;\n}\n\n/**\n * Generic schema-driven row transformer.\n * Uses TABLE_SCHEMAS to determine field types and apply appropriate transformations:\n * - 'jsonb' fields: parsed from JSON strings using safelyParseJSON\n * - 'timestamp' fields: optionally converted to Date objects\n *\n * @param row - The raw row from storage\n * @param tableName - The table name to look up schema from TABLE_SCHEMAS\n * @param options - Optional configuration for store-specific behavior\n * @returns Transformed row with proper types\n */\nexport function transformRow<T = Record<string, any>>(\n  row: Record<string, any>,\n  tableName: TABLE_NAMES,\n  options: TransformRowOptions = {},\n): T {\n  const { preferredTimestampFields = {}, convertTimestamps = false, nullValuePattern, fieldMappings = {} } = options;\n\n  const tableSchema = TABLE_SCHEMAS[tableName];\n  const result: Record<string, any> = {};\n\n  for (const [key, columnSchema] of Object.entries(tableSchema)) {\n    // Handle field mappings (e.g., entityData -> entity for DynamoDB)\n    const sourceKey = fieldMappings[key] ?? key;\n    let value = row[sourceKey];\n\n    // Handle preferred timestamp sources (e.g., use createdAtZ if available, else createdAt)\n    if (preferredTimestampFields[key]) {\n      value = row[preferredTimestampFields[key]] ?? value;\n    }\n\n    // Skip null/undefined values\n    if (value === undefined || value === null) {\n      continue;\n    }\n\n    // Skip null pattern values (e.g., ClickHouse's '_null_')\n    if (nullValuePattern && value === nullValuePattern) {\n      continue;\n    }\n\n    // Transform based on column type\n    if (columnSchema.type === 'jsonb') {\n      if (typeof value === 'string') {\n        result[key] = safelyParseJSON(value);\n      } else if (typeof value === 'object') {\n        result[key] = value; // Already parsed\n      } else {\n        result[key] = value;\n      }\n    } else if (columnSchema.type === 'timestamp' && convertTimestamps && typeof value === 'string') {\n      result[key] = new Date(value);\n    } else {\n      result[key] = value;\n    }\n  }\n\n  return result as T;\n}\n\n/**\n * Transform a raw score row from storage to ScoreRowData.\n * Convenience wrapper around transformRow for the scores table (TABLE_SCORERS).\n *\n * @param row - The raw row from storage\n * @param options - Optional configuration for store-specific behavior\n * @returns Transformed ScoreRowData\n */\nexport function transformScoreRow(row: Record<string, any>, options: TransformRowOptions = {}): ScoreRowData {\n  return transformRow<ScoreRowData>(row, TABLE_SCORERS, options);\n}\n\n/**\n * Converts a string to UPPER_SNAKE_CASE, preserving word boundaries from camelCase, PascalCase, kebab-case, etc.\n */\nfunction toUpperSnakeCase(str: string): string {\n  return (\n    str\n      // Insert underscore before uppercase letters that follow lowercase letters (camelCase -> camel_Case)\n      .replace(/([a-z])([A-Z])/g, '$1_$2')\n      // Insert underscore before uppercase letters that are followed by lowercase letters (XMLParser -> XML_Parser)\n      .replace(/([A-Z])([A-Z][a-z])/g, '$1_$2')\n      // Convert to uppercase\n      .toUpperCase()\n      // Replace any non-alphanumeric characters with underscore\n      .replace(/[^A-Z0-9]+/g, '_')\n      // Remove leading/trailing underscores\n      .replace(/^_+|_+$/g, '')\n  );\n}\n\n/**\n * Generates a standardized error ID for storage and vector operations.\n *\n * Formats:\n * - Storage: MASTRA_STORAGE_{STORE}_{OPERATION}_{STATUS}\n * - Vector:  MASTRA_VECTOR_{STORE}_{OPERATION}_{STATUS}\n *\n * This function auto-normalizes inputs to UPPER_SNAKE_CASE for flexibility.\n * The store parameter is type-checked against canonical store names for IDE autocomplete.\n *\n * @param type - The operation type ('storage' or 'vector')\n * @param store - The store adapter name (type-checked canonical names)\n * @param operation - The operation that failed (e.g., 'LIST_THREADS_BY_RESOURCE_ID', 'QUERY')\n * @param status - The status/error type (e.g., 'FAILED', 'INVALID_THREAD_ID', 'DUPLICATE_KEY')\n *\n * @example\n * ```ts\n * // Storage operations\n * createStoreErrorId('storage', 'PG', 'LIST_THREADS', 'FAILED')\n * // Returns: 'MASTRA_STORAGE_PG_LIST_THREADS_FAILED'\n *\n * // Vector operations\n * createStoreErrorId('vector', 'CHROMA', 'QUERY', 'FAILED')\n * // Returns: 'MASTRA_VECTOR_CHROMA_QUERY_FAILED'\n *\n * // Auto-normalizes any casing\n * createStoreErrorId('storage', 'PG', 'listMessagesById', 'failed')\n * // Returns: 'MASTRA_STORAGE_PG_LIST_MESSAGES_BY_ID_FAILED'\n * ```\n */\nexport function createStoreErrorId(\n  type: 'storage' | 'vector',\n  store: StoreName,\n  operation: string,\n  status: string,\n): Uppercase<string> {\n  const normalizedStore = toUpperSnakeCase(store);\n  const normalizedOperation = toUpperSnakeCase(operation);\n  const normalizedStatus = toUpperSnakeCase(status);\n  const typePrefix = type === 'storage' ? 'STORAGE' : 'VECTOR';\n\n  return `MASTRA_${typePrefix}_${normalizedStore}_${normalizedOperation}_${normalizedStatus}` as Uppercase<string>;\n}\n\nexport function createStorageErrorId(store: StoreName, operation: string, status: string): Uppercase<string> {\n  return createStoreErrorId('storage', store, operation, status);\n}\n\nexport function createVectorErrorId(store: StoreName, operation: string, status: string): Uppercase<string> {\n  return createStoreErrorId('vector', store, operation, status);\n}\n\nexport function getSqlType(type: StorageColumn['type']): string {\n  switch (type) {\n    case 'text':\n      return 'TEXT';\n    case 'timestamp':\n      return 'TIMESTAMP';\n    case 'float':\n      return 'FLOAT';\n    case 'integer':\n      return 'INTEGER';\n    case 'bigint':\n      return 'BIGINT';\n    case 'jsonb':\n      return 'JSONB';\n    case 'boolean':\n      return 'BOOLEAN';\n    default:\n      return 'TEXT';\n  }\n}\n\nexport function getDefaultValue(type: StorageColumn['type']): string {\n  switch (type) {\n    case 'text':\n    case 'uuid':\n      return \"DEFAULT ''\";\n    case 'timestamp':\n      return \"DEFAULT '1970-01-01 00:00:00'\";\n    case 'integer':\n    case 'bigint':\n    case 'float':\n      return 'DEFAULT 0';\n    case 'jsonb':\n      return \"DEFAULT '{}'\";\n    case 'boolean':\n      return 'DEFAULT FALSE';\n    default:\n      return \"DEFAULT ''\";\n  }\n}\n\nexport function ensureDate(date: Date | string | undefined): Date | undefined {\n  if (!date) return undefined;\n  return date instanceof Date ? date : new Date(date);\n}\n\nexport function serializeDate(date: Date | string | undefined): string | undefined {\n  if (!date) return undefined;\n  const dateObj = ensureDate(date);\n  return dateObj?.toISOString();\n}\n\n/**\n * Date range filter configuration for in-memory filtering operations.\n */\nexport interface DateRangeFilter {\n  start?: Date | string;\n  end?: Date | string;\n  startExclusive?: boolean;\n  endExclusive?: boolean;\n}\n\n/**\n * Filter an array of items by date range. Used by in-memory storage adapters.\n *\n * This provides a consistent implementation of date range filtering with\n * support for inclusive/exclusive bounds across all storage adapters.\n *\n * @param items - Array of items to filter\n * @param getCreatedAt - Function to extract the createdAt date from an item\n * @param dateRange - Optional date range filter configuration\n * @returns Filtered array of items\n *\n * @example\n * ```ts\n * const filtered = filterByDateRange(\n *   messages,\n *   (msg) => new Date(msg.createdAt),\n *   { start: new Date('2024-01-01'), startExclusive: true }\n * );\n * ```\n */\nexport function filterByDateRange<T>(items: T[], getCreatedAt: (item: T) => Date, dateRange?: DateRangeFilter): T[] {\n  if (!dateRange) return items;\n\n  let result = items;\n\n  if (dateRange.start) {\n    const startTime = ensureDate(dateRange.start)!.getTime();\n    result = result.filter(item => {\n      const itemTime = getCreatedAt(item).getTime();\n      return dateRange.startExclusive ? itemTime > startTime : itemTime >= startTime;\n    });\n  }\n\n  if (dateRange.end) {\n    const endTime = ensureDate(dateRange.end)!.getTime();\n    result = result.filter(item => {\n      const itemTime = getCreatedAt(item).getTime();\n      return dateRange.endExclusive ? itemTime < endTime : itemTime <= endTime;\n    });\n  }\n\n  return result;\n}\n\n/**\n * Deep equality check for JSON values.\n * Compares primitives, arrays, objects, and Date instances recursively.\n *\n * @param a - First value to compare\n * @param b - Second value to compare\n * @returns true if values are deeply equal, false otherwise\n */\nexport function jsonValueEquals(a: unknown, b: unknown): boolean {\n  if (a === undefined || b === undefined) {\n    return a === b;\n  }\n  if (a === null || b === null) {\n    return a === b;\n  }\n  if (typeof a !== typeof b) {\n    return false;\n  }\n  // Handle Date objects\n  if (a instanceof Date && b instanceof Date) {\n    return a.getTime() === b.getTime();\n  }\n  if (a instanceof Date || b instanceof Date) {\n    return false; // One is Date, other is not\n  }\n  if (typeof a === 'object') {\n    if (Array.isArray(a) && Array.isArray(b)) {\n      if (a.length !== b.length) return false;\n      return a.every((val, i) => jsonValueEquals(val, b[i]));\n    }\n    if (Array.isArray(a) || Array.isArray(b)) {\n      return false;\n    }\n    const aKeys = Object.keys(a as object);\n    const bKeys = Object.keys(b as object);\n    if (aKeys.length !== bKeys.length) return false;\n    return aKeys.every(key =>\n      jsonValueEquals((a as Record<string, unknown>)[key], (b as Record<string, unknown>)[key]),\n    );\n  }\n  return a === b;\n}\n","import type { MastraMessageContentV2 } from '../../../agent';\nimport type { MastraDBMessage, StorageThreadType } from '../../../memory/types';\nimport type {\n  StorageResourceType,\n  ThreadOrderBy,\n  ThreadSortDirection,\n  StorageListMessagesInput,\n  StorageListMessagesByResourceIdInput,\n  StorageListMessagesOutput,\n  StorageListThreadsInput,\n  StorageListThreadsOutput,\n  StorageOrderBy,\n  StorageCloneThreadInput,\n  StorageCloneThreadOutput,\n  ObservationalMemoryRecord,\n  CreateObservationalMemoryInput,\n  UpdateActiveObservationsInput,\n  UpdateBufferedObservationsInput,\n  UpdateBufferedReflectionInput,\n  SwapBufferedToActiveInput,\n  SwapBufferedToActiveResult,\n  SwapBufferedReflectionToActiveInput,\n  CreateReflectionGenerationInput,\n} from '../../types';\nimport { StorageDomain } from '../base';\n\n// Constants for metadata key validation\nconst SAFE_METADATA_KEY_PATTERN = /^[a-zA-Z_][a-zA-Z0-9_]*$/;\nconst MAX_METADATA_KEY_LENGTH = 128;\nconst DISALLOWED_METADATA_KEYS = new Set(['__proto__', 'prototype', 'constructor']);\n\nexport abstract class MemoryStorage extends StorageDomain {\n  /**\n   * Whether this storage adapter supports Observational Memory.\n   * Adapters that implement OM methods should set this to true.\n   * Defaults to false for backwards compatibility with custom adapters.\n   */\n  readonly supportsObservationalMemory?: boolean = false;\n\n  constructor() {\n    super({\n      component: 'STORAGE',\n      name: 'MEMORY',\n    });\n  }\n\n  abstract getThreadById({ threadId }: { threadId: string }): Promise<StorageThreadType | null>;\n\n  abstract saveThread({ thread }: { thread: StorageThreadType }): Promise<StorageThreadType>;\n\n  abstract updateThread({\n    id,\n    title,\n    metadata,\n  }: {\n    id: string;\n    title: string;\n    metadata: Record<string, unknown>;\n  }): Promise<StorageThreadType>;\n\n  abstract deleteThread({ threadId }: { threadId: string }): Promise<void>;\n\n  abstract listMessages(args: StorageListMessagesInput): Promise<StorageListMessagesOutput>;\n\n  /**\n   * List messages by resource ID only (across all threads).\n   * Used by Observational Memory and LongMemEval for resource-scoped queries.\n   *\n   * @param args - Resource ID and pagination/filtering options\n   * @returns Paginated list of messages for the resource\n   */\n  async listMessagesByResourceId(_args: StorageListMessagesByResourceIdInput): Promise<StorageListMessagesOutput> {\n    throw new Error(\n      `Resource-scoped message listing is not implemented by this storage adapter (${this.constructor.name}). ` +\n        `Use an adapter that supports Observational Memory (pg, libsql, mongodb) or disable observational memory.`,\n    );\n  }\n\n  abstract listMessagesById({ messageIds }: { messageIds: string[] }): Promise<{ messages: MastraDBMessage[] }>;\n\n  abstract saveMessages(args: { messages: MastraDBMessage[] }): Promise<{ messages: MastraDBMessage[] }>;\n\n  abstract updateMessages(args: {\n    messages: (Partial<Omit<MastraDBMessage, 'createdAt'>> & {\n      id: string;\n      content?: { metadata?: MastraMessageContentV2['metadata']; content?: MastraMessageContentV2['content'] };\n    })[];\n  }): Promise<MastraDBMessage[]>;\n\n  async deleteMessages(_messageIds: string[]): Promise<void> {\n    throw new Error(\n      `Message deletion is not supported by this storage adapter (${this.constructor.name}). ` +\n        `The deleteMessages method needs to be implemented in the storage adapter.`,\n    );\n  }\n\n  /**\n   * List threads with optional filtering by resourceId and metadata.\n   *\n   * @param args - Filter, pagination, and ordering options\n   * @param args.filter - Optional filters for resourceId and/or metadata\n   * @param args.filter.resourceId - Optional resource ID to filter by\n   * @param args.filter.metadata - Optional metadata key-value pairs to filter by (AND logic)\n   * @returns Paginated list of threads matching the filters\n   */\n  abstract listThreads(args: StorageListThreadsInput): Promise<StorageListThreadsOutput>;\n\n  /**\n   * Clone a thread and its messages to create a new independent thread.\n   * The cloned thread will have clone metadata stored in its metadata field.\n   *\n   * @param args - Clone configuration options\n   * @returns The newly created thread and the cloned messages\n   */\n  async cloneThread(_args: StorageCloneThreadInput): Promise<StorageCloneThreadOutput> {\n    throw new Error(\n      `Thread cloning is not implemented by this storage adapter (${this.constructor.name}). ` +\n        `The cloneThread method needs to be implemented in the storage adapter.`,\n    );\n  }\n\n  async getResourceById(_: { resourceId: string }): Promise<StorageResourceType | null> {\n    throw new Error(\n      `Resource working memory is not implemented by this storage adapter (${this.constructor.name}). ` +\n        `This is likely a bug - all Mastra storage adapters should implement resource support. ` +\n        `Please report this issue at https://github.com/mastra-ai/mastra/issues`,\n    );\n  }\n\n  async saveResource(_: { resource: StorageResourceType }): Promise<StorageResourceType> {\n    throw new Error(\n      `Resource working memory is not implemented by this storage adapter (${this.constructor.name}). ` +\n        `This is likely a bug - all Mastra storage adapters should implement resource support. ` +\n        `Please report this issue at https://github.com/mastra-ai/mastra/issues`,\n    );\n  }\n\n  async updateResource(_: {\n    resourceId: string;\n    workingMemory?: string;\n    metadata?: Record<string, unknown>;\n  }): Promise<StorageResourceType> {\n    throw new Error(\n      `Resource working memory is not implemented by this storage adapter (${this.constructor.name}). ` +\n        `This is likely a bug - all Mastra storage adapters should implement resource support. ` +\n        `Please report this issue at https://github.com/mastra-ai/mastra/issues`,\n    );\n  }\n\n  protected parseOrderBy(\n    orderBy?: StorageOrderBy,\n    defaultDirection: ThreadSortDirection = 'DESC',\n  ): { field: ThreadOrderBy; direction: ThreadSortDirection } {\n    return {\n      field: orderBy?.field && orderBy.field in THREAD_ORDER_BY_SET ? orderBy.field : 'createdAt',\n      direction:\n        orderBy?.direction && orderBy.direction in THREAD_THREAD_SORT_DIRECTION_SET\n          ? orderBy.direction\n          : defaultDirection,\n    };\n  }\n\n  // ============================================\n  // Observational Memory Methods\n  // ============================================\n\n  /**\n   * Get the current observational memory record for a thread/resource.\n   * Returns the most recent active record.\n   */\n  async getObservationalMemory(\n    _threadId: string | null,\n    _resourceId: string,\n  ): Promise<ObservationalMemoryRecord | null> {\n    throw new Error(`Observational memory is not implemented by this storage adapter (${this.constructor.name}).`);\n  }\n\n  /**\n   * Get observational memory history (previous generations).\n   * Returns records in reverse chronological order (newest first).\n   */\n  async getObservationalMemoryHistory(\n    _threadId: string | null,\n    _resourceId: string,\n    _limit?: number,\n  ): Promise<ObservationalMemoryRecord[]> {\n    throw new Error(`Observational memory is not implemented by this storage adapter (${this.constructor.name}).`);\n  }\n\n  /**\n   * Create a new observational memory record.\n   * Called when starting observations for a new thread/resource.\n   */\n  async initializeObservationalMemory(_input: CreateObservationalMemoryInput): Promise<ObservationalMemoryRecord> {\n    throw new Error(`Observational memory is not implemented by this storage adapter (${this.constructor.name}).`);\n  }\n\n  /**\n   * Update active observations.\n   * Called when observations are created and immediately activated (no buffering).\n   */\n  async updateActiveObservations(_input: UpdateActiveObservationsInput): Promise<void> {\n    throw new Error(`Observational memory is not implemented by this storage adapter (${this.constructor.name}).`);\n  }\n\n  // ============================================\n  // Buffering Methods (for async observation/reflection)\n  // These methods support async buffering when `bufferTokens` is configured.\n  // ============================================\n\n  /**\n   * Update buffered observations.\n   * Called when observations are created asynchronously via `bufferTokens`.\n   */\n  async updateBufferedObservations(_input: UpdateBufferedObservationsInput): Promise<void> {\n    throw new Error(`Observational memory is not implemented by this storage adapter (${this.constructor.name}).`);\n  }\n\n  /**\n   * Swap buffered observations to active.\n   * Atomic operation that:\n   * 1. Appends bufferedObservations  activeObservations (based on activationRatio)\n   * 2. Moves activated bufferedMessageIds  observedMessageIds\n   * 3. Keeps remaining buffered content if activationRatio < 100\n   * 4. Updates lastObservedAt\n   *\n   * Returns info about what was activated for UI feedback.\n   */\n  async swapBufferedToActive(_input: SwapBufferedToActiveInput): Promise<SwapBufferedToActiveResult> {\n    throw new Error(`Observational memory is not implemented by this storage adapter (${this.constructor.name}).`);\n  }\n\n  /**\n   * Create a new generation from a reflection.\n   * Creates a new record with:\n   * - originType: 'reflection'\n   * - activeObservations containing the reflection\n   * - generationCount incremented from the current record\n   */\n  async createReflectionGeneration(_input: CreateReflectionGenerationInput): Promise<ObservationalMemoryRecord> {\n    throw new Error(`Observational memory is not implemented by this storage adapter (${this.constructor.name}).`);\n  }\n\n  /**\n   * Update buffered reflection (async reflection in progress).\n   * Called when reflection runs asynchronously via `bufferTokens`.\n   */\n  async updateBufferedReflection(_input: UpdateBufferedReflectionInput): Promise<void> {\n    throw new Error(`Observational memory is not implemented by this storage adapter (${this.constructor.name}).`);\n  }\n\n  /**\n   * Swap buffered reflection to active observations.\n   * Creates a new generation where activeObservations = bufferedReflection + unreflected observations.\n   * The `tokenCount` in input is the processor-computed token count for the combined content.\n   */\n  async swapBufferedReflectionToActive(\n    _input: SwapBufferedReflectionToActiveInput,\n  ): Promise<ObservationalMemoryRecord> {\n    throw new Error(`Observational memory is not implemented by this storage adapter (${this.constructor.name}).`);\n  }\n\n  /**\n   * Set the isReflecting flag.\n   */\n  async setReflectingFlag(_id: string, _isReflecting: boolean): Promise<void> {\n    throw new Error(`Observational memory is not implemented by this storage adapter (${this.constructor.name}).`);\n  }\n\n  /**\n   * Set the isObserving flag.\n   */\n  async setObservingFlag(_id: string, _isObserving: boolean): Promise<void> {\n    throw new Error(`Observational memory is not implemented by this storage adapter (${this.constructor.name}).`);\n  }\n\n  /**\n   * Set the isBufferingObservation flag and update lastBufferedAtTokens.\n   * Called when async observation buffering starts (true) or ends/fails (false).\n   * @param id - Record ID\n   * @param isBuffering - Whether buffering is in progress\n   * @param lastBufferedAtTokens - The pending token count at which this buffer was triggered (only set when isBuffering=true)\n   */\n  async setBufferingObservationFlag(_id: string, _isBuffering: boolean, _lastBufferedAtTokens?: number): Promise<void> {\n    throw new Error(`Observational memory is not implemented by this storage adapter (${this.constructor.name}).`);\n  }\n\n  /**\n   * Set the isBufferingReflection flag.\n   * Called when async reflection buffering starts (true) or ends/fails (false).\n   */\n  async setBufferingReflectionFlag(_id: string, _isBuffering: boolean): Promise<void> {\n    throw new Error(`Observational memory is not implemented by this storage adapter (${this.constructor.name}).`);\n  }\n\n  /**\n   * Clear all observational memory for a thread/resource.\n   * Removes all records and history.\n   */\n  async clearObservationalMemory(_threadId: string | null, _resourceId: string): Promise<void> {\n    throw new Error(`Observational memory is not implemented by this storage adapter (${this.constructor.name}).`);\n  }\n\n  /**\n   * Set the pending message token count.\n   * Called at the end of each OM processing step to persist the current\n   * context window token count so the UI can display it on page load.\n   */\n  async setPendingMessageTokens(_id: string, _tokenCount: number): Promise<void> {\n    throw new Error(`Observational memory is not implemented by this storage adapter (${this.constructor.name}).`);\n  }\n\n  /**\n   * Validates metadata keys to prevent SQL injection attacks and prototype pollution.\n   * Keys must start with a letter or underscore, followed by alphanumeric characters or underscores.\n   * @param metadata - The metadata object to validate\n   * @throws Error if any key contains invalid characters or is a disallowed key\n   */\n  protected validateMetadataKeys(metadata: Record<string, unknown> | undefined): void {\n    if (!metadata) return;\n\n    for (const key of Object.keys(metadata)) {\n      // First check for disallowed prototype pollution keys\n      if (DISALLOWED_METADATA_KEYS.has(key)) {\n        throw new Error(`Invalid metadata key: \"${key}\".`);\n      }\n\n      // Then check pattern\n      if (!SAFE_METADATA_KEY_PATTERN.test(key)) {\n        throw new Error(\n          `Invalid metadata key: \"${key}\". Keys must start with a letter or underscore and contain only alphanumeric characters and underscores.`,\n        );\n      }\n\n      // Also limit key length to prevent potential issues\n      if (key.length > MAX_METADATA_KEY_LENGTH) {\n        throw new Error(`Metadata key \"${key}\" exceeds maximum length of ${MAX_METADATA_KEY_LENGTH} characters.`);\n      }\n    }\n  }\n\n  /**\n   * Validates pagination parameters and returns safe offset.\n   * @param page - Page number (0-indexed)\n   * @param perPage - Items per page (0 is allowed and returns empty results)\n   * @throws Error if page is negative, perPage is negative/invalid, or offset would overflow\n   */\n  protected validatePagination(page: number, perPage: number): void {\n    if (!Number.isFinite(page) || !Number.isSafeInteger(page) || page < 0) {\n      throw new Error('page must be >= 0');\n    }\n\n    // perPage: 0 is allowed (returns empty results), negative values are rejected\n    if (!Number.isFinite(perPage) || !Number.isSafeInteger(perPage) || perPage < 0) {\n      throw new Error('perPage must be >= 0');\n    }\n\n    // Skip overflow check when perPage is 0 (no offset needed)\n    if (perPage === 0) {\n      return;\n    }\n\n    // Prevent overflow when calculating offset\n    const offset = page * perPage;\n    if (!Number.isSafeInteger(offset) || offset > Number.MAX_SAFE_INTEGER) {\n      throw new Error('page value too large');\n    }\n  }\n\n  /**\n   * Validates pagination input before normalization.\n   * Use this when accepting raw perPageInput (number | false) from callers.\n   *\n   * When perPage is false (fetch all), page must be 0 since pagination is disabled.\n   * When perPage is a number, delegates to validatePagination for full validation.\n   *\n   * @param page - Page number (0-indexed)\n   * @param perPageInput - Items per page as number, or false to fetch all results\n   * @throws Error if perPageInput is false and page !== 0\n   * @throws Error if perPageInput is invalid (not false or a non-negative safe integer)\n   * @throws Error if page is invalid or offset would overflow\n   */\n  protected validatePaginationInput(page: number, perPageInput: number | false): void {\n    // Validate perPageInput type first\n    if (perPageInput !== false) {\n      if (typeof perPageInput !== 'number' || !Number.isFinite(perPageInput) || !Number.isSafeInteger(perPageInput)) {\n        throw new Error('perPage must be false or a safe integer');\n      }\n      if (perPageInput < 0) {\n        throw new Error('perPage must be >= 0');\n      }\n    }\n\n    // When fetching all (perPage: false), only page 0 is valid\n    if (perPageInput === false) {\n      if (page !== 0) {\n        throw new Error('page must be 0 when perPage is false');\n      }\n      // Still validate page is a valid integer\n      if (!Number.isFinite(page) || !Number.isSafeInteger(page)) {\n        throw new Error('page must be >= 0');\n      }\n      return;\n    }\n\n    // For numeric perPage, delegate to existing validation\n    this.validatePagination(page, perPageInput);\n  }\n}\n\nconst THREAD_ORDER_BY_SET: Record<ThreadOrderBy, true> = {\n  createdAt: true,\n  updatedAt: true,\n};\n\nconst THREAD_THREAD_SORT_DIRECTION_SET: Record<ThreadSortDirection, true> = {\n  ASC: true,\n  DESC: true,\n};\n","import { MessageList } from '../../../agent/message-list';\nimport type { MastraDBMessage, StorageThreadType } from '../../../memory/types';\nimport { normalizePerPage, calculatePagination } from '../../base';\nimport type {\n  StorageMessageType,\n  StorageResourceType,\n  ThreadOrderBy,\n  ThreadSortDirection,\n  StorageListMessagesInput,\n  StorageListMessagesByResourceIdInput,\n  StorageListMessagesOutput,\n  StorageListThreadsInput,\n  StorageListThreadsOutput,\n  StorageCloneThreadInput,\n  StorageCloneThreadOutput,\n  ThreadCloneMetadata,\n  ObservationalMemoryRecord,\n  BufferedObservationChunk,\n  CreateObservationalMemoryInput,\n  UpdateActiveObservationsInput,\n  UpdateBufferedObservationsInput,\n  UpdateBufferedReflectionInput,\n  SwapBufferedToActiveInput,\n  SwapBufferedToActiveResult,\n  SwapBufferedReflectionToActiveInput,\n  CreateReflectionGenerationInput,\n} from '../../types';\nimport { filterByDateRange, jsonValueEquals, safelyParseJSON } from '../../utils';\nimport type { InMemoryDB } from '../inmemory-db';\nimport { MemoryStorage } from './base';\n\nexport class InMemoryMemory extends MemoryStorage {\n  readonly supportsObservationalMemory = true;\n  private db: InMemoryDB;\n\n  constructor({ db }: { db: InMemoryDB }) {\n    super();\n    this.db = db;\n  }\n\n  async dangerouslyClearAll(): Promise<void> {\n    this.db.threads.clear();\n    this.db.messages.clear();\n    this.db.resources.clear();\n    this.db.observationalMemory.clear();\n  }\n\n  async getThreadById({ threadId }: { threadId: string }): Promise<StorageThreadType | null> {\n    this.logger.debug(`InMemoryMemory: getThreadById called for ${threadId}`);\n    const thread = this.db.threads.get(threadId);\n    return thread ? { ...thread, metadata: thread.metadata ? { ...thread.metadata } : thread.metadata } : null;\n  }\n\n  async saveThread({ thread }: { thread: StorageThreadType }): Promise<StorageThreadType> {\n    this.logger.debug(`InMemoryMemory: saveThread called for ${thread.id}`);\n    const key = thread.id;\n    this.db.threads.set(key, thread);\n    return thread;\n  }\n\n  async updateThread({\n    id,\n    title,\n    metadata,\n  }: {\n    id: string;\n    title: string;\n    metadata: Record<string, unknown>;\n  }): Promise<StorageThreadType> {\n    this.logger.debug(`InMemoryMemory: updateThread called for ${id}`);\n    const thread = this.db.threads.get(id);\n\n    if (!thread) {\n      throw new Error(`Thread with id ${id} not found`);\n    }\n\n    if (thread) {\n      thread.title = title;\n      thread.metadata = { ...thread.metadata, ...metadata };\n      thread.updatedAt = new Date();\n    }\n    return thread;\n  }\n\n  async deleteThread({ threadId }: { threadId: string }): Promise<void> {\n    this.logger.debug(`InMemoryMemory: deleteThread called for ${threadId}`);\n    this.db.threads.delete(threadId);\n\n    this.db.messages.forEach((msg, key) => {\n      if (msg.thread_id === threadId) {\n        this.db.messages.delete(key);\n      }\n    });\n  }\n\n  async listMessages({\n    threadId,\n    resourceId: optionalResourceId,\n    include,\n    filter,\n    perPage: perPageInput,\n    page = 0,\n    orderBy,\n  }: StorageListMessagesInput): Promise<StorageListMessagesOutput> {\n    // Normalize threadId to array\n    const threadIds = Array.isArray(threadId) ? threadId : [threadId];\n\n    this.logger.debug(`InMemoryMemory: listMessages called for threads ${threadIds.join(', ')}`);\n\n    if (threadIds.length === 0 || threadIds.some(id => !id.trim())) {\n      throw new Error('threadId must be a non-empty string or array of non-empty strings');\n    }\n\n    const threadIdSet = new Set(threadIds);\n\n    const { field, direction } = this.parseOrderBy(orderBy, 'ASC');\n\n    // Normalize perPage for query (false  MAX_SAFE_INTEGER, 0  0, undefined  40)\n    const perPage = normalizePerPage(perPageInput, 40);\n\n    if (page < 0) {\n      throw new Error('page must be >= 0');\n    }\n\n    // Prevent unreasonably large page values that could cause performance issues\n    const maxOffset = Number.MAX_SAFE_INTEGER / 2;\n    if (page * perPage > maxOffset) {\n      throw new Error('page value too large');\n    }\n\n    // Calculate offset from page\n\n    const { offset, perPage: perPageForResponse } = calculatePagination(page, perPageInput, perPage);\n\n    // Step 1: Get messages matching threadId(s) and optionally resourceId\n    let threadMessages = Array.from(this.db.messages.values()).filter((msg: any) => {\n      // Message must be in one of the specified threads\n      if (threadIdSet && !threadIdSet.has(msg.thread_id)) return false;\n      // If optionalResourceId provided, message must match it\n      if (optionalResourceId && msg.resourceId !== optionalResourceId) return false;\n      return true;\n    });\n\n    // Apply date filtering\n    threadMessages = filterByDateRange(threadMessages, (msg: any) => new Date(msg.createdAt), filter?.dateRange);\n\n    // Sort thread messages before pagination\n    threadMessages.sort((a: any, b: any) => {\n      const isDateField = field === 'createdAt' || field === 'updatedAt';\n      const aValue = isDateField ? new Date(a[field]).getTime() : a[field];\n      const bValue = isDateField ? new Date(b[field]).getTime() : b[field];\n\n      if (typeof aValue === 'number' && typeof bValue === 'number') {\n        return direction === 'ASC' ? aValue - bValue : bValue - aValue;\n      }\n      return direction === 'ASC'\n        ? String(aValue).localeCompare(String(bValue))\n        : String(bValue).localeCompare(String(aValue));\n    });\n\n    // Get total count of thread messages (for pagination metadata)\n    const totalThreadMessages = threadMessages.length;\n\n    // Apply pagination to thread messages\n    const start = offset;\n    const end = start + perPage;\n    const paginatedThreadMessages = threadMessages.slice(start, end);\n\n    // Convert paginated thread messages to MastraDBMessage\n    const messages: MastraDBMessage[] = [];\n    const messageIds = new Set<string>();\n\n    for (const msg of paginatedThreadMessages) {\n      const convertedMessage = this.parseStoredMessage(msg);\n      messages.push(convertedMessage);\n      messageIds.add(msg.id);\n    }\n\n    // Step 2: Add included messages with context (if any), excluding duplicates\n    if (include && include.length > 0) {\n      for (const includeItem of include) {\n        const targetMessage = this.db.messages.get(includeItem.id);\n        if (targetMessage) {\n          // Convert StorageMessageType to MastraDBMessage\n          const convertedMessage = {\n            id: targetMessage.id,\n            threadId: targetMessage.thread_id,\n            content: safelyParseJSON(targetMessage.content),\n            role: targetMessage.role as 'user' | 'assistant' | 'system' | 'tool',\n            type: targetMessage.type,\n            createdAt: targetMessage.createdAt,\n            resourceId: targetMessage.resourceId,\n          } as MastraDBMessage;\n\n          // Only add if not already in messages array (deduplication)\n          if (!messageIds.has(convertedMessage.id)) {\n            messages.push(convertedMessage);\n            messageIds.add(convertedMessage.id);\n          }\n\n          // Add previous messages if requested\n          if (includeItem.withPreviousMessages) {\n            const allThreadMessages = Array.from(this.db.messages.values())\n              .filter((msg: any) => msg.thread_id === (includeItem.threadId || threadId))\n              .sort((a: any, b: any) => new Date(a.createdAt).getTime() - new Date(b.createdAt).getTime());\n\n            const targetIndex = allThreadMessages.findIndex(msg => msg.id === includeItem.id);\n            if (targetIndex !== -1) {\n              const startIndex = Math.max(0, targetIndex - (includeItem.withPreviousMessages || 0));\n              for (let i = startIndex; i < targetIndex; i++) {\n                const message = allThreadMessages[i];\n                if (message && !messageIds.has(message.id)) {\n                  const convertedPrevMessage = {\n                    id: message.id,\n                    threadId: message.thread_id,\n                    content: safelyParseJSON(message.content),\n                    role: message.role as 'user' | 'assistant' | 'system' | 'tool',\n                    type: message.type,\n                    createdAt: message.createdAt,\n                    resourceId: message.resourceId,\n                  } as MastraDBMessage;\n                  messages.push(convertedPrevMessage);\n                  messageIds.add(message.id);\n                }\n              }\n            }\n          }\n\n          // Add next messages if requested\n          if (includeItem.withNextMessages) {\n            const allThreadMessages = Array.from(this.db.messages.values())\n              .filter((msg: any) => msg.thread_id === (includeItem.threadId || threadId))\n              .sort((a: any, b: any) => new Date(a.createdAt).getTime() - new Date(b.createdAt).getTime());\n\n            const targetIndex = allThreadMessages.findIndex(msg => msg.id === includeItem.id);\n            if (targetIndex !== -1) {\n              const endIndex = Math.min(\n                allThreadMessages.length,\n                targetIndex + (includeItem.withNextMessages || 0) + 1,\n              );\n              for (let i = targetIndex + 1; i < endIndex; i++) {\n                const message = allThreadMessages[i];\n                if (message && !messageIds.has(message.id)) {\n                  const convertedNextMessage = {\n                    id: message.id,\n                    threadId: message.thread_id,\n                    content: safelyParseJSON(message.content),\n                    role: message.role as 'user' | 'assistant' | 'system' | 'tool',\n                    type: message.type,\n                    createdAt: message.createdAt,\n                    resourceId: message.resourceId,\n                  } as MastraDBMessage;\n                  messages.push(convertedNextMessage);\n                  messageIds.add(message.id);\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n    // Sort all messages (paginated + included) for final output\n    messages.sort((a: any, b: any) => {\n      const isDateField = field === 'createdAt' || field === 'updatedAt';\n      const aValue = isDateField ? new Date(a[field]).getTime() : a[field];\n      const bValue = isDateField ? new Date(b[field]).getTime() : b[field];\n\n      if (typeof aValue === 'number' && typeof bValue === 'number') {\n        return direction === 'ASC' ? aValue - bValue : bValue - aValue;\n      }\n      return direction === 'ASC'\n        ? String(aValue).localeCompare(String(bValue))\n        : String(bValue).localeCompare(String(aValue));\n    });\n\n    // Calculate hasMore\n    let hasMore;\n    if (include && include.length > 0) {\n      // When using include, check if we've returned all messages from the thread\n      // because include might bring in messages beyond the pagination window\n      const returnedThreadMessageIds = new Set(messages.filter(m => m.threadId === threadId).map(m => m.id));\n      hasMore = returnedThreadMessageIds.size < totalThreadMessages;\n    } else {\n      // Standard pagination: check if there are more pages\n      hasMore = end < totalThreadMessages;\n    }\n\n    return {\n      messages,\n      total: totalThreadMessages,\n      page,\n      perPage: perPageForResponse,\n      hasMore,\n    };\n  }\n\n  async listMessagesByResourceId({\n    resourceId,\n    filter,\n    perPage: perPageInput,\n    page = 0,\n    orderBy,\n  }: StorageListMessagesByResourceIdInput): Promise<StorageListMessagesOutput> {\n    this.logger.debug(`InMemoryMemory: listMessagesByResourceId called for resource ${resourceId}`);\n\n    const { field, direction } = this.parseOrderBy(orderBy, 'ASC');\n\n    // Normalize perPage for query (false  MAX_SAFE_INTEGER, 0  0, undefined  40)\n    const perPage = normalizePerPage(perPageInput, 40);\n\n    if (page < 0) {\n      throw new Error('page must be >= 0');\n    }\n\n    // Prevent unreasonably large page values that could cause performance issues\n    const maxOffset = Number.MAX_SAFE_INTEGER / 2;\n    if (page * perPage > maxOffset) {\n      throw new Error('page value too large');\n    }\n\n    const { offset, perPage: perPageForResponse } = calculatePagination(page, perPageInput, perPage);\n\n    // Get all messages matching the resourceId (across all threads)\n    let messages = Array.from(this.db.messages.values()).filter((msg: any) => msg.resourceId === resourceId);\n\n    // Apply date filtering\n    messages = filterByDateRange(messages, (msg: any) => new Date(msg.createdAt), filter?.dateRange);\n\n    // Sort messages\n    messages.sort((a: any, b: any) => {\n      const isDateField = field === 'createdAt' || field === 'updatedAt';\n      const aValue = isDateField ? new Date(a[field]).getTime() : a[field];\n      const bValue = isDateField ? new Date(b[field]).getTime() : b[field];\n\n      if (typeof aValue === 'number' && typeof bValue === 'number') {\n        return direction === 'ASC' ? aValue - bValue : bValue - aValue;\n      }\n      return direction === 'ASC'\n        ? String(aValue).localeCompare(String(bValue))\n        : String(bValue).localeCompare(String(aValue));\n    });\n\n    // Get total count for pagination\n    const total = messages.length;\n\n    // Apply pagination\n    const paginatedMessages = messages.slice(offset, offset + perPage);\n\n    const list = new MessageList().add(\n      paginatedMessages.map(m => this.parseStoredMessage(m)),\n      'memory',\n    );\n\n    const hasMore = offset + paginatedMessages.length < total;\n\n    return {\n      messages: list.get.all.db(),\n      total,\n      page,\n      perPage: perPageForResponse,\n      hasMore,\n    };\n  }\n\n  protected parseStoredMessage(message: StorageMessageType): MastraDBMessage {\n    const { resourceId, content, role, thread_id, ...rest } = message;\n\n    // Parse content using safelyParseJSON utility\n    let parsedContent = safelyParseJSON(content);\n\n    // If the result is a plain string (V1 format), wrap it in V2 structure\n    if (typeof parsedContent === 'string') {\n      parsedContent = {\n        format: 2,\n        content: parsedContent,\n        parts: [{ type: 'text', text: parsedContent }],\n      };\n    }\n\n    return {\n      ...rest,\n      threadId: thread_id,\n      ...(message.resourceId && { resourceId: message.resourceId }),\n      content: parsedContent,\n      role: role as MastraDBMessage['role'],\n    } satisfies MastraDBMessage;\n  }\n\n  async listMessagesById({ messageIds }: { messageIds: string[] }): Promise<{ messages: MastraDBMessage[] }> {\n    this.logger.debug(`InMemoryMemory: listMessagesById called`);\n\n    const rawMessages = messageIds.map(id => this.db.messages.get(id)).filter(message => !!message);\n\n    const list = new MessageList().add(\n      rawMessages.map(m => this.parseStoredMessage(m)),\n      'memory',\n    );\n    return { messages: list.get.all.db() };\n  }\n\n  async saveMessages(args: { messages: MastraDBMessage[] }): Promise<{ messages: MastraDBMessage[] }> {\n    const { messages } = args;\n    this.logger.debug(`InMemoryMemory: saveMessages called with ${messages.length} messages`);\n    // Simulate error handling for testing - check before saving\n    if (messages.some(msg => msg.id === 'error-message' || msg.resourceId === null)) {\n      throw new Error('Simulated error for testing');\n    }\n\n    // Update thread timestamps for each unique threadId\n    const threadIds = new Set(messages.map(msg => msg.threadId).filter((id): id is string => Boolean(id)));\n    for (const threadId of threadIds) {\n      const thread = this.db.threads.get(threadId);\n      if (thread) {\n        thread.updatedAt = new Date();\n      }\n    }\n\n    for (const message of messages) {\n      const key = message.id;\n      // Convert MastraDBMessage to StorageMessageType\n      const storageMessage: StorageMessageType = {\n        id: message.id,\n        thread_id: message.threadId || '',\n        content: JSON.stringify(message.content),\n        role: message.role || 'user',\n        type: message.type || 'text',\n        createdAt: message.createdAt,\n        resourceId: message.resourceId || null,\n      };\n      this.db.messages.set(key, storageMessage);\n    }\n\n    const list = new MessageList().add(messages, 'memory');\n    return { messages: list.get.all.db() };\n  }\n\n  async updateMessages(args: { messages: (Partial<MastraDBMessage> & { id: string })[] }): Promise<MastraDBMessage[]> {\n    const updatedMessages: MastraDBMessage[] = [];\n    for (const update of args.messages) {\n      const storageMsg = this.db.messages.get(update.id);\n      if (!storageMsg) continue;\n\n      // Track old threadId for possible move\n      const oldThreadId = storageMsg.thread_id;\n      const newThreadId = update.threadId || oldThreadId;\n      let threadIdChanged = false;\n      if (update.threadId && update.threadId !== oldThreadId) {\n        threadIdChanged = true;\n      }\n\n      // Update fields\n      if (update.role !== undefined) storageMsg.role = update.role;\n      if (update.type !== undefined) storageMsg.type = update.type;\n      if (update.createdAt !== undefined) storageMsg.createdAt = update.createdAt;\n      if (update.resourceId !== undefined) storageMsg.resourceId = update.resourceId;\n      // Deep merge content if present\n      if (update.content !== undefined) {\n        let oldContent = safelyParseJSON(storageMsg.content);\n        let newContent = update.content;\n        if (typeof newContent === 'object' && typeof oldContent === 'object') {\n          // Deep merge for metadata/content fields\n          newContent = { ...oldContent, ...newContent };\n          if (oldContent.metadata && newContent.metadata) {\n            newContent.metadata = { ...oldContent.metadata, ...newContent.metadata };\n          }\n        }\n        storageMsg.content = JSON.stringify(newContent);\n      }\n      // Handle threadId change\n      if (threadIdChanged) {\n        storageMsg.thread_id = newThreadId;\n        // Update updatedAt for both threads, ensuring strictly greater and not equal\n        const base = Date.now();\n        let oldThreadNewTime: number | undefined;\n        const oldThread = this.db.threads.get(oldThreadId);\n        if (oldThread) {\n          const prev = new Date(oldThread.updatedAt).getTime();\n          oldThreadNewTime = Math.max(base, prev + 1);\n          oldThread.updatedAt = new Date(oldThreadNewTime);\n        }\n        const newThread = this.db.threads.get(newThreadId);\n        if (newThread) {\n          const prev = new Date(newThread.updatedAt).getTime();\n          let newThreadNewTime = Math.max(base + 1, prev + 1);\n          if (oldThreadNewTime !== undefined && newThreadNewTime <= oldThreadNewTime) {\n            newThreadNewTime = oldThreadNewTime + 1;\n          }\n          newThread.updatedAt = new Date(newThreadNewTime);\n        }\n      } else {\n        // Only update the thread's updatedAt if not a move\n        const thread = this.db.threads.get(oldThreadId);\n        if (thread) {\n          const prev = new Date(thread.updatedAt).getTime();\n          let newTime = Date.now();\n          if (newTime <= prev) newTime = prev + 1;\n          thread.updatedAt = new Date(newTime);\n        }\n      }\n      // Save the updated message\n      this.db.messages.set(update.id, storageMsg);\n      // Return as MastraDBMessage\n      updatedMessages.push({\n        id: storageMsg.id,\n        threadId: storageMsg.thread_id,\n        content: safelyParseJSON(storageMsg.content),\n        role: storageMsg.role === 'user' || storageMsg.role === 'assistant' ? storageMsg.role : 'user',\n        type: storageMsg.type,\n        createdAt: storageMsg.createdAt,\n        resourceId: storageMsg.resourceId === null ? undefined : storageMsg.resourceId,\n      });\n    }\n    return updatedMessages;\n  }\n\n  async deleteMessages(messageIds: string[]): Promise<void> {\n    if (!messageIds || messageIds.length === 0) {\n      return;\n    }\n\n    this.logger.debug(`InMemoryMemory: deleteMessages called for ${messageIds.length} messages`);\n\n    // Collect thread IDs to update\n    const threadIds = new Set<string>();\n\n    for (const messageId of messageIds) {\n      const message = this.db.messages.get(messageId);\n      if (message && message.thread_id) {\n        threadIds.add(message.thread_id);\n      }\n      // Delete the message\n      this.db.messages.delete(messageId);\n    }\n\n    // Update thread timestamps\n    const now = new Date();\n    for (const threadId of threadIds) {\n      const thread = this.db.threads.get(threadId);\n      if (thread) {\n        thread.updatedAt = now;\n      }\n    }\n  }\n\n  async listThreads(args: StorageListThreadsInput): Promise<StorageListThreadsOutput> {\n    const { page = 0, perPage: perPageInput, orderBy, filter } = args;\n    const { field, direction } = this.parseOrderBy(orderBy);\n\n    // Validate pagination input before normalization\n    // This ensures page === 0 when perPageInput === false\n    this.validatePaginationInput(page, perPageInput ?? 100);\n\n    const perPage = normalizePerPage(perPageInput, 100);\n\n    this.logger.debug(`InMemoryMemory: listThreads called with filter: ${JSON.stringify(filter)}`);\n\n    // Start with all threads\n    let threads = Array.from(this.db.threads.values());\n\n    // Apply resourceId filter if provided\n    if (filter?.resourceId) {\n      threads = threads.filter((t: any) => t.resourceId === filter.resourceId);\n    }\n\n    // Validate metadata keys before filtering\n    this.validateMetadataKeys(filter?.metadata);\n\n    // Apply metadata filter if provided (AND logic - all key-value pairs must match)\n    if (filter?.metadata && Object.keys(filter.metadata).length > 0) {\n      threads = threads.filter(thread => {\n        if (!thread.metadata) return false;\n        return Object.entries(filter.metadata!).every(([key, value]) => jsonValueEquals(thread.metadata![key], value));\n      });\n    }\n\n    const sortedThreads = this.sortThreads(threads, field, direction);\n    const clonedThreads = sortedThreads.map(thread => ({\n      ...thread,\n      metadata: thread.metadata ? { ...thread.metadata } : thread.metadata,\n    })) as StorageThreadType[];\n\n    const { offset, perPage: perPageForResponse } = calculatePagination(page, perPageInput, perPage);\n\n    return {\n      threads: clonedThreads.slice(offset, offset + perPage),\n      total: clonedThreads.length,\n      page,\n      perPage: perPageForResponse,\n      hasMore: offset + perPage < clonedThreads.length,\n    };\n  }\n\n  async getResourceById({ resourceId }: { resourceId: string }): Promise<StorageResourceType | null> {\n    this.logger.debug(`InMemoryMemory: getResourceById called for ${resourceId}`);\n    const resource = this.db.resources.get(resourceId);\n    return resource\n      ? { ...resource, metadata: resource.metadata ? { ...resource.metadata } : resource.metadata }\n      : null;\n  }\n\n  async saveResource({ resource }: { resource: StorageResourceType }): Promise<StorageResourceType> {\n    this.logger.debug(`InMemoryMemory: saveResource called for ${resource.id}`);\n    this.db.resources.set(resource.id, resource);\n    return resource;\n  }\n\n  async updateResource({\n    resourceId,\n    workingMemory,\n    metadata,\n  }: {\n    resourceId: string;\n    workingMemory?: string;\n    metadata?: Record<string, unknown>;\n  }): Promise<StorageResourceType> {\n    this.logger.debug(`InMemoryMemory: updateResource called for ${resourceId}`);\n    let resource = this.db.resources.get(resourceId);\n\n    if (!resource) {\n      // Create new resource if it doesn't exist\n      resource = {\n        id: resourceId,\n        workingMemory,\n        metadata: metadata || {},\n        createdAt: new Date(),\n        updatedAt: new Date(),\n      };\n    } else {\n      resource = {\n        ...resource,\n        workingMemory: workingMemory !== undefined ? workingMemory : resource.workingMemory,\n        metadata: {\n          ...resource.metadata,\n          ...metadata,\n        },\n        updatedAt: new Date(),\n      };\n    }\n\n    this.db.resources.set(resourceId, resource);\n    return resource;\n  }\n\n  async cloneThread(args: StorageCloneThreadInput): Promise<StorageCloneThreadOutput> {\n    const { sourceThreadId, newThreadId: providedThreadId, resourceId, title, metadata, options } = args;\n\n    this.logger.debug(`InMemoryMemory: cloneThread called for source thread ${sourceThreadId}`);\n\n    // Get the source thread\n    const sourceThread = this.db.threads.get(sourceThreadId);\n    if (!sourceThread) {\n      throw new Error(`Source thread with id ${sourceThreadId} not found`);\n    }\n\n    // Use provided ID or generate a new one\n    const newThreadId = providedThreadId || crypto.randomUUID();\n\n    // Check if the new thread ID already exists\n    if (this.db.threads.has(newThreadId)) {\n      throw new Error(`Thread with id ${newThreadId} already exists`);\n    }\n\n    // Get messages from the source thread\n    let sourceMessages = Array.from(this.db.messages.values())\n      .filter((msg: StorageMessageType) => msg.thread_id === sourceThreadId)\n      .sort((a, b) => new Date(a.createdAt).getTime() - new Date(b.createdAt).getTime());\n\n    // Apply message filters if provided\n    if (options?.messageFilter) {\n      const { startDate, endDate, messageIds } = options.messageFilter;\n\n      if (messageIds && messageIds.length > 0) {\n        const messageIdSet = new Set(messageIds);\n        sourceMessages = sourceMessages.filter(msg => messageIdSet.has(msg.id));\n      }\n\n      if (startDate) {\n        sourceMessages = sourceMessages.filter(msg => new Date(msg.createdAt) >= startDate);\n      }\n\n      if (endDate) {\n        sourceMessages = sourceMessages.filter(msg => new Date(msg.createdAt) <= endDate);\n      }\n    }\n\n    // Apply message limit (take from the end to get most recent)\n    if (options?.messageLimit && options.messageLimit > 0 && sourceMessages.length > options.messageLimit) {\n      sourceMessages = sourceMessages.slice(-options.messageLimit);\n    }\n\n    const now = new Date();\n\n    // Determine the last message ID for clone metadata\n    const lastMessageId = sourceMessages.length > 0 ? sourceMessages[sourceMessages.length - 1]!.id : undefined;\n\n    // Create clone metadata\n    const cloneMetadata: ThreadCloneMetadata = {\n      sourceThreadId,\n      clonedAt: now,\n      ...(lastMessageId && { lastMessageId }),\n    };\n\n    // Create the new thread\n    const newThread: StorageThreadType = {\n      id: newThreadId,\n      resourceId: resourceId || sourceThread.resourceId,\n      title: title || (sourceThread.title ? `Clone of ${sourceThread.title}` : undefined),\n      metadata: {\n        ...metadata,\n        clone: cloneMetadata,\n      },\n      createdAt: now,\n      updatedAt: now,\n    };\n\n    // Save the new thread\n    this.db.threads.set(newThreadId, newThread);\n\n    // Clone messages with new IDs\n    const clonedMessages: MastraDBMessage[] = [];\n    for (const sourceMsg of sourceMessages) {\n      const newMessageId = crypto.randomUUID();\n      const parsedContent = safelyParseJSON(sourceMsg.content);\n\n      // Create storage message\n      const newStorageMessage: StorageMessageType = {\n        id: newMessageId,\n        thread_id: newThreadId,\n        content: sourceMsg.content,\n        role: sourceMsg.role,\n        type: sourceMsg.type,\n        createdAt: sourceMsg.createdAt,\n        resourceId: resourceId || sourceMsg.resourceId,\n      };\n\n      this.db.messages.set(newMessageId, newStorageMessage);\n\n      // Create MastraDBMessage for return\n      clonedMessages.push({\n        id: newMessageId,\n        threadId: newThreadId,\n        content: parsedContent,\n        role: sourceMsg.role as MastraDBMessage['role'],\n        type: sourceMsg.type,\n        createdAt: sourceMsg.createdAt,\n        resourceId: resourceId || sourceMsg.resourceId || undefined,\n      });\n    }\n\n    this.logger.debug(\n      `InMemoryMemory: cloned thread ${sourceThreadId} to ${newThreadId} with ${clonedMessages.length} messages`,\n    );\n\n    return {\n      thread: newThread,\n      clonedMessages,\n    };\n  }\n\n  private sortThreads(threads: any[], field: ThreadOrderBy, direction: ThreadSortDirection): any[] {\n    return threads.sort((a, b) => {\n      const isDateField = field === 'createdAt' || field === 'updatedAt';\n      const aValue = isDateField ? new Date(a[field]).getTime() : a[field];\n      const bValue = isDateField ? new Date(b[field]).getTime() : b[field];\n\n      if (typeof aValue === 'number' && typeof bValue === 'number') {\n        if (direction === 'ASC') {\n          return aValue - bValue;\n        } else {\n          return bValue - aValue;\n        }\n      }\n      return direction === 'ASC'\n        ? String(aValue).localeCompare(String(bValue))\n        : String(bValue).localeCompare(String(aValue));\n    });\n  }\n\n  // ============================================\n  // Observational Memory Implementation\n  // ============================================\n\n  private getObservationalMemoryKey(threadId: string | null, resourceId: string): string {\n    if (threadId) {\n      return `thread:${threadId}`;\n    }\n    return `resource:${resourceId}`;\n  }\n\n  async getObservationalMemory(threadId: string | null, resourceId: string): Promise<ObservationalMemoryRecord | null> {\n    const key = this.getObservationalMemoryKey(threadId, resourceId);\n    const records = this.db.observationalMemory.get(key);\n    return records?.[0] ?? null;\n  }\n\n  async getObservationalMemoryHistory(\n    threadId: string | null,\n    resourceId: string,\n    limit?: number,\n  ): Promise<ObservationalMemoryRecord[]> {\n    const key = this.getObservationalMemoryKey(threadId, resourceId);\n    const records = this.db.observationalMemory.get(key) ?? [];\n    return limit != null ? records.slice(0, limit) : records;\n  }\n\n  async initializeObservationalMemory(input: CreateObservationalMemoryInput): Promise<ObservationalMemoryRecord> {\n    const { threadId, resourceId, scope, config, observedTimezone } = input;\n    const key = this.getObservationalMemoryKey(threadId, resourceId);\n    const now = new Date();\n\n    const record: ObservationalMemoryRecord = {\n      id: crypto.randomUUID(),\n      scope,\n      threadId,\n      resourceId,\n      // Timestamps at top level\n      createdAt: now,\n      updatedAt: now,\n      // lastObservedAt starts undefined - all messages are \"unobserved\" initially\n      // This ensures historical data (like LongMemEval fixtures) works correctly\n      lastObservedAt: undefined,\n      originType: 'initial',\n      generationCount: 0,\n      activeObservations: '',\n      // Buffering (for async observation/reflection)\n      bufferedObservations: undefined,\n      bufferedReflection: undefined,\n      // Message tracking\n      // Note: Message ID tracking removed in favor of cursor-based lastObservedAt\n      // Token tracking\n      totalTokensObserved: 0,\n      observationTokenCount: 0,\n      pendingMessageTokens: 0,\n      // State flags\n      isReflecting: false,\n      isObserving: false,\n      isBufferingObservation: false,\n      isBufferingReflection: false,\n      lastBufferedAtTokens: 0,\n      lastBufferedAtTime: null,\n      // Configuration\n      config,\n      // Timezone used for observation date formatting\n      observedTimezone,\n      // Extensible metadata (optional)\n      metadata: {},\n    };\n\n    // Add as first record (most recent)\n    const existing = this.db.observationalMemory.get(key) ?? [];\n    this.db.observationalMemory.set(key, [record, ...existing]);\n\n    return record;\n  }\n\n  async updateActiveObservations(input: UpdateActiveObservationsInput): Promise<void> {\n    const { id, observations, tokenCount, lastObservedAt, observedMessageIds } = input;\n    const record = this.findObservationalMemoryRecordById(id);\n    if (!record) {\n      throw new Error(`Observational memory record not found: ${id}`);\n    }\n\n    record.activeObservations = observations;\n    record.observationTokenCount = tokenCount;\n    record.totalTokensObserved += tokenCount;\n    // Reset pending tokens since we've now observed them\n    record.pendingMessageTokens = 0;\n\n    // Update timestamps (top-level, not in metadata)\n    record.lastObservedAt = lastObservedAt;\n    record.updatedAt = new Date();\n\n    // Store observed message IDs as safeguard against re-observation\n    if (observedMessageIds) {\n      record.observedMessageIds = observedMessageIds;\n    }\n  }\n\n  async updateBufferedObservations(input: UpdateBufferedObservationsInput): Promise<void> {\n    const { id, chunk } = input;\n    const record = this.findObservationalMemoryRecordById(id);\n    if (!record) {\n      throw new Error(`Observational memory record not found: ${id}`);\n    }\n\n    // Create a new chunk with generated id and timestamp\n    const newChunk: BufferedObservationChunk = {\n      id: `ombuf-${crypto.randomUUID()}`,\n      cycleId: chunk.cycleId,\n      observations: chunk.observations,\n      tokenCount: chunk.tokenCount,\n      messageIds: chunk.messageIds,\n      messageTokens: chunk.messageTokens,\n      lastObservedAt: chunk.lastObservedAt,\n      createdAt: new Date(),\n      suggestedContinuation: chunk.suggestedContinuation,\n      currentTask: chunk.currentTask,\n    };\n\n    // Add chunk to the array\n    const existingChunks = Array.isArray(record.bufferedObservationChunks) ? record.bufferedObservationChunks : [];\n    record.bufferedObservationChunks = [...existingChunks, newChunk];\n\n    if (input.lastBufferedAtTime) {\n      record.lastBufferedAtTime = input.lastBufferedAtTime;\n    }\n\n    record.updatedAt = new Date();\n  }\n\n  async swapBufferedToActive(input: SwapBufferedToActiveInput): Promise<SwapBufferedToActiveResult> {\n    const { id, activationRatio, lastObservedAt } = input;\n    const record = this.findObservationalMemoryRecordById(id);\n    if (!record) {\n      throw new Error(`Observational memory record not found: ${id}`);\n    }\n\n    const chunks = Array.isArray(record.bufferedObservationChunks) ? record.bufferedObservationChunks : [];\n    if (chunks.length === 0) {\n      return {\n        chunksActivated: 0,\n        messageTokensActivated: 0,\n        observationTokensActivated: 0,\n        messagesActivated: 0,\n        activatedCycleIds: [],\n        activatedMessageIds: [],\n      };\n    }\n\n    // Calculate target: how many message tokens to remove so that\n    // (1 - activationRatio) * threshold worth of raw messages remain.\n    // e.g., ratio=0.8, threshold=5000, pending=6000  remove 6000 - 1000 = 5000\n    const retentionFloor = input.messageTokensThreshold * (1 - activationRatio);\n    const targetMessageTokens = Math.max(0, input.currentPendingTokens - retentionFloor);\n\n    // Find the closest chunk boundary to the target, biased under\n    let cumulativeMessageTokens = 0;\n    let bestBoundary = 0;\n    let bestBoundaryMessageTokens = 0;\n\n    for (let i = 0; i < chunks.length; i++) {\n      cumulativeMessageTokens += chunks[i]!.messageTokens ?? 0;\n      const boundary = i + 1;\n\n      // Prefer boundaries that are under the target (leaves more raw messages in context)\n      // Only go over if there's no under option\n      const isUnder = cumulativeMessageTokens <= targetMessageTokens;\n      const bestIsUnder = bestBoundaryMessageTokens <= targetMessageTokens;\n\n      if (bestBoundary === 0) {\n        // First boundary, take it\n        bestBoundary = boundary;\n        bestBoundaryMessageTokens = cumulativeMessageTokens;\n      } else if (isUnder && !bestIsUnder) {\n        // Current is under, best is over - prefer under\n        bestBoundary = boundary;\n        bestBoundaryMessageTokens = cumulativeMessageTokens;\n      } else if (isUnder && bestIsUnder) {\n        // Both under - prefer the one closer to target (higher)\n        if (cumulativeMessageTokens > bestBoundaryMessageTokens) {\n          bestBoundary = boundary;\n          bestBoundaryMessageTokens = cumulativeMessageTokens;\n        }\n      } else if (!isUnder && !bestIsUnder) {\n        // Both over - prefer the one closer to target (lower)\n        if (cumulativeMessageTokens < bestBoundaryMessageTokens) {\n          bestBoundary = boundary;\n          bestBoundaryMessageTokens = cumulativeMessageTokens;\n        }\n      }\n      // If current is over and best is under, keep best (do nothing)\n    }\n\n    // If bestBoundary is 0 (no boundary under target), activate at least 1 chunk\n    // since we've reached threshold and need to clear some context\n    const chunksToActivate = bestBoundary === 0 ? 1 : bestBoundary;\n    const activatedChunks = chunks.slice(0, chunksToActivate);\n    const remainingChunks = chunks.slice(chunksToActivate);\n\n    // Combine activated chunks into content\n    const activatedContent = activatedChunks.map(c => c.observations).join('\\n\\n');\n    const activatedTokens = activatedChunks.reduce((sum, c) => sum + c.tokenCount, 0);\n    const activatedMessageTokens = activatedChunks.reduce((sum, c) => sum + (c.messageTokens ?? 0), 0);\n    const activatedMessageCount = activatedChunks.reduce((sum, c) => sum + c.messageIds.length, 0);\n    const activatedCycleIds = activatedChunks.map(c => c.cycleId).filter((id): id is string => !!id);\n    const activatedMessageIds = activatedChunks.flatMap(c => c.messageIds);\n\n    // Derive lastObservedAt from the latest activated chunk, or use provided value\n    const latestChunk = activatedChunks[activatedChunks.length - 1];\n    const derivedLastObservedAt =\n      lastObservedAt ?? (latestChunk?.lastObservedAt ? new Date(latestChunk.lastObservedAt) : new Date());\n\n    // Append activated content to active observations\n    if (record.activeObservations) {\n      record.activeObservations = `${record.activeObservations}\\n\\n${activatedContent}`;\n    } else {\n      record.activeObservations = activatedContent;\n    }\n\n    // Update observation token count\n    record.observationTokenCount = (record.observationTokenCount ?? 0) + activatedTokens;\n\n    // Decrement pending message tokens (clamped to zero)\n    record.pendingMessageTokens = Math.max(0, (record.pendingMessageTokens ?? 0) - activatedMessageTokens);\n\n    // NOTE: We intentionally do NOT add activatedMessageIds to record.observedMessageIds.\n    // observedMessageIds is used by getUnobservedMessages to filter future messages.\n    // Since AI SDK may reuse message IDs for new content, adding them here would\n    // permanently block new content from being observed. Instead, we return\n    // activatedMessageIds so the caller can remove them from messageList directly.\n\n    // Update buffered state with remaining chunks\n    record.bufferedObservationChunks = remainingChunks.length > 0 ? remainingChunks : undefined;\n\n    // Update timestamps\n    record.lastObservedAt = derivedLastObservedAt;\n    record.updatedAt = new Date();\n\n    return {\n      chunksActivated: activatedChunks.length,\n      messageTokensActivated: activatedMessageTokens,\n      observationTokensActivated: activatedTokens,\n      messagesActivated: activatedMessageCount,\n      activatedCycleIds,\n      activatedMessageIds,\n      observations: activatedContent,\n      perChunk: activatedChunks.map(c => ({\n        cycleId: c.cycleId ?? '',\n        messageTokens: c.messageTokens ?? 0,\n        observationTokens: c.tokenCount,\n        messageCount: c.messageIds.length,\n        observations: c.observations,\n      })),\n    };\n  }\n\n  async createReflectionGeneration(input: CreateReflectionGenerationInput): Promise<ObservationalMemoryRecord> {\n    const { currentRecord, reflection, tokenCount } = input;\n    const key = this.getObservationalMemoryKey(currentRecord.threadId, currentRecord.resourceId);\n    const now = new Date();\n\n    const newRecord: ObservationalMemoryRecord = {\n      id: crypto.randomUUID(),\n      scope: currentRecord.scope,\n      threadId: currentRecord.threadId,\n      resourceId: currentRecord.resourceId,\n      // Timestamps at top level\n      createdAt: now,\n      updatedAt: now,\n      lastObservedAt: currentRecord.lastObservedAt ?? now, // Carry over from observation (which always runs before reflection)\n      originType: 'reflection',\n      generationCount: currentRecord.generationCount + 1,\n      activeObservations: reflection,\n      config: currentRecord.config,\n      totalTokensObserved: currentRecord.totalTokensObserved,\n      observationTokenCount: tokenCount,\n      pendingMessageTokens: 0,\n      isReflecting: false,\n      isObserving: false,\n      isBufferingObservation: false,\n      isBufferingReflection: false,\n      lastBufferedAtTokens: 0,\n      lastBufferedAtTime: null,\n      // Timezone used for observation date formatting\n      observedTimezone: currentRecord.observedTimezone,\n      // Extensible metadata (optional)\n      metadata: {},\n    };\n\n    // Add as first record (most recent)\n    const existing = this.db.observationalMemory.get(key) ?? [];\n    this.db.observationalMemory.set(key, [newRecord, ...existing]);\n\n    return newRecord;\n  }\n\n  async updateBufferedReflection(input: UpdateBufferedReflectionInput): Promise<void> {\n    const { id, reflection, tokenCount, inputTokenCount, reflectedObservationLineCount } = input;\n    const record = this.findObservationalMemoryRecordById(id);\n    if (!record) {\n      throw new Error(`Observational memory record not found: ${id}`);\n    }\n\n    const existing = record.bufferedReflection || '';\n    record.bufferedReflection = existing ? `${existing}\\n\\n${reflection}` : reflection;\n    record.bufferedReflectionTokens = (record.bufferedReflectionTokens || 0) + tokenCount;\n    record.bufferedReflectionInputTokens = (record.bufferedReflectionInputTokens || 0) + inputTokenCount;\n    record.reflectedObservationLineCount = reflectedObservationLineCount;\n    record.updatedAt = new Date();\n  }\n\n  async swapBufferedReflectionToActive(input: SwapBufferedReflectionToActiveInput): Promise<ObservationalMemoryRecord> {\n    const { currentRecord } = input;\n    const record = this.findObservationalMemoryRecordById(currentRecord.id);\n    if (!record) {\n      throw new Error(`Observational memory record not found: ${currentRecord.id}`);\n    }\n\n    if (!record.bufferedReflection) {\n      throw new Error('No buffered reflection to swap');\n    }\n\n    const bufferedReflection = record.bufferedReflection;\n    const reflectedLineCount = record.reflectedObservationLineCount ?? 0;\n\n    // Split current activeObservations by the boundary line count.\n    // Lines 0..reflectedLineCount were reflected on  replaced by bufferedReflection.\n    // Lines after reflectedLineCount were added after reflection started  kept as-is.\n    const currentObservations = record.activeObservations ?? '';\n    const allLines = currentObservations.split('\\n');\n    const unreflectedLines = allLines.slice(reflectedLineCount);\n    const unreflectedContent = unreflectedLines.join('\\n').trim();\n\n    // New activeObservations = bufferedReflection + unreflected observations\n    const newObservations = unreflectedContent ? `${bufferedReflection}\\n\\n${unreflectedContent}` : bufferedReflection;\n\n    // Create a new generation with the merged content.\n    // tokenCount is computed by the processor using its token counter on the combined content.\n    const newRecord = await this.createReflectionGeneration({\n      currentRecord: record,\n      reflection: newObservations,\n      tokenCount: input.tokenCount,\n    });\n\n    // Clear buffered state on old record\n    record.bufferedReflection = undefined;\n    record.bufferedReflectionTokens = undefined;\n    record.bufferedReflectionInputTokens = undefined;\n    record.reflectedObservationLineCount = undefined;\n\n    return newRecord;\n  }\n\n  async setReflectingFlag(id: string, isReflecting: boolean): Promise<void> {\n    const record = this.findObservationalMemoryRecordById(id);\n    if (!record) {\n      throw new Error(`Observational memory record not found: ${id}`);\n    }\n\n    record.isReflecting = isReflecting;\n    record.updatedAt = new Date();\n  }\n\n  async setObservingFlag(id: string, isObserving: boolean): Promise<void> {\n    const record = this.findObservationalMemoryRecordById(id);\n    if (!record) {\n      throw new Error(`Observational memory record not found: ${id}`);\n    }\n\n    record.isObserving = isObserving;\n    record.updatedAt = new Date();\n  }\n\n  async setBufferingObservationFlag(id: string, isBuffering: boolean, lastBufferedAtTokens?: number): Promise<void> {\n    const record = this.findObservationalMemoryRecordById(id);\n    if (!record) {\n      throw new Error(`Observational memory record not found: ${id}`);\n    }\n\n    record.isBufferingObservation = isBuffering;\n    if (lastBufferedAtTokens !== undefined) {\n      record.lastBufferedAtTokens = lastBufferedAtTokens;\n    }\n    record.updatedAt = new Date();\n  }\n\n  async setBufferingReflectionFlag(id: string, isBuffering: boolean): Promise<void> {\n    const record = this.findObservationalMemoryRecordById(id);\n    if (!record) {\n      throw new Error(`Observational memory record not found: ${id}`);\n    }\n\n    record.isBufferingReflection = isBuffering;\n    record.updatedAt = new Date();\n  }\n\n  async clearObservationalMemory(threadId: string | null, resourceId: string): Promise<void> {\n    const key = this.getObservationalMemoryKey(threadId, resourceId);\n    this.db.observationalMemory.delete(key);\n  }\n\n  async setPendingMessageTokens(id: string, tokenCount: number): Promise<void> {\n    const record = this.findObservationalMemoryRecordById(id);\n    if (!record) {\n      throw new Error(`Observational memory record not found: ${id}`);\n    }\n\n    record.pendingMessageTokens = tokenCount;\n    record.updatedAt = new Date();\n  }\n\n  /**\n   * Helper to find an observational memory record by ID across all keys\n   */\n  private findObservationalMemoryRecordById(id: string): ObservationalMemoryRecord | null {\n    for (const records of this.db.observationalMemory.values()) {\n      const record = records.find(r => r.id === id);\n      if (record) return record;\n    }\n    return null;\n  }\n}\n","import { ErrorCategory, ErrorDomain, MastraError } from '../../../error';\nimport { StorageDomain } from '../base';\nimport type {\n  BatchCreateSpansArgs,\n  BatchDeleteTracesArgs,\n  BatchUpdateSpansArgs,\n  CreateSpanArgs,\n  GetRootSpanArgs,\n  GetRootSpanResponse,\n  GetSpanArgs,\n  GetSpanResponse,\n  GetTraceArgs,\n  GetTraceResponse,\n  ListTracesArgs,\n  ListTracesResponse,\n  TracingStorageStrategy,\n  UpdateSpanArgs,\n} from './types';\n\n/**\n * ObservabilityStorage is not abstract because it provides default implementations\n * that throw errors - adapters override only the methods they support.\n */\nexport class ObservabilityStorage extends StorageDomain {\n  constructor() {\n    super({\n      component: 'STORAGE',\n      name: 'OBSERVABILITY',\n    });\n  }\n\n  async dangerouslyClearAll(): Promise<void> {\n    // Default no-op - subclasses override\n  }\n\n  /**\n   * Provides hints for tracing strategy selection by the DefaultExporter.\n   * Storage adapters can override this to specify their preferred and supported strategies.\n   */\n  public get tracingStrategy(): {\n    preferred: TracingStorageStrategy;\n    supported: TracingStorageStrategy[];\n  } {\n    return {\n      preferred: 'batch-with-updates', // Default for most SQL stores\n      supported: ['realtime', 'batch-with-updates', 'insert-only'],\n    };\n  }\n\n  /**\n   * Creates a single Span record in the storage provider.\n   */\n  async createSpan(_args: CreateSpanArgs): Promise<void> {\n    throw new MastraError({\n      id: 'OBSERVABILITY_CREATE_SPAN_NOT_IMPLEMENTED',\n      domain: ErrorDomain.MASTRA_OBSERVABILITY,\n      category: ErrorCategory.SYSTEM,\n      text: 'This storage provider does not support creating spans',\n    });\n  }\n\n  /**\n   * Updates a single Span with partial data. Primarily used for realtime trace creation.\n   */\n  async updateSpan(_args: UpdateSpanArgs): Promise<void> {\n    throw new MastraError({\n      id: 'OBSERVABILITY_STORAGE_UPDATE_SPAN_NOT_IMPLEMENTED',\n      domain: ErrorDomain.MASTRA_OBSERVABILITY,\n      category: ErrorCategory.SYSTEM,\n      text: 'This storage provider does not support updating spans',\n    });\n  }\n\n  /**\n   * Retrieves a single span.\n   */\n  async getSpan(_args: GetSpanArgs): Promise<GetSpanResponse | null> {\n    throw new MastraError({\n      id: 'OBSERVABILITY_STORAGE_GET_SPAN_NOT_IMPLEMENTED',\n      domain: ErrorDomain.MASTRA_OBSERVABILITY,\n      category: ErrorCategory.SYSTEM,\n      text: 'This storage provider does not support getting spans',\n    });\n  }\n\n  /**\n   * Retrieves a single root span.\n   */\n  async getRootSpan(_args: GetRootSpanArgs): Promise<GetRootSpanResponse | null> {\n    throw new MastraError({\n      id: 'OBSERVABILITY_STORAGE_GET_ROOT_SPAN_NOT_IMPLEMENTED',\n      domain: ErrorDomain.MASTRA_OBSERVABILITY,\n      category: ErrorCategory.SYSTEM,\n      text: 'This storage provider does not support getting root spans',\n    });\n  }\n\n  /**\n   * Retrieves a single trace with all its associated spans.\n   */\n  async getTrace(_args: GetTraceArgs): Promise<GetTraceResponse | null> {\n    throw new MastraError({\n      id: 'OBSERVABILITY_STORAGE_GET_TRACE_NOT_IMPLEMENTED',\n      domain: ErrorDomain.MASTRA_OBSERVABILITY,\n      category: ErrorCategory.SYSTEM,\n      text: 'This storage provider does not support getting traces',\n    });\n  }\n\n  /**\n   * Retrieves a list of traces with optional filtering.\n   */\n  async listTraces(_args: ListTracesArgs): Promise<ListTracesResponse> {\n    throw new MastraError({\n      id: 'OBSERVABILITY_STORAGE_LIST_TRACES_NOT_IMPLEMENTED',\n      domain: ErrorDomain.MASTRA_OBSERVABILITY,\n      category: ErrorCategory.SYSTEM,\n      text: 'This storage provider does not support listing traces',\n    });\n  }\n\n  /**\n   * Creates multiple Spans in a single batch.\n   */\n  async batchCreateSpans(_args: BatchCreateSpansArgs): Promise<void> {\n    throw new MastraError({\n      id: 'OBSERVABILITY_STORAGE_BATCH_CREATE_SPAN_NOT_IMPLEMENTED',\n      domain: ErrorDomain.MASTRA_OBSERVABILITY,\n      category: ErrorCategory.SYSTEM,\n      text: 'This storage provider does not support batch creating spans',\n    });\n  }\n\n  /**\n   * Updates multiple Spans in a single batch.\n   */\n  async batchUpdateSpans(_args: BatchUpdateSpansArgs): Promise<void> {\n    throw new MastraError({\n      id: 'OBSERVABILITY_STORAGE_BATCH_UPDATE_SPANS_NOT_IMPLEMENTED',\n      domain: ErrorDomain.MASTRA_OBSERVABILITY,\n      category: ErrorCategory.SYSTEM,\n      text: 'This storage provider does not support batch updating spans',\n    });\n  }\n\n  /**\n   * Deletes multiple traces and all their associated spans in a single batch operation.\n   */\n  async batchDeleteTraces(_args: BatchDeleteTracesArgs): Promise<void> {\n    throw new MastraError({\n      id: 'OBSERVABILITY_STORAGE_BATCH_DELETE_TRACES_NOT_IMPLEMENTED',\n      domain: ErrorDomain.MASTRA_OBSERVABILITY,\n      category: ErrorCategory.SYSTEM,\n      text: 'This storage provider does not support batch deleting traces',\n    });\n  }\n}\n","import { ErrorCategory, ErrorDomain, MastraError } from '../../../error';\nimport { jsonValueEquals } from '../../utils';\nimport type { InMemoryDB } from '../inmemory-db';\nimport { ObservabilityStorage } from './base';\nimport type {\n  BatchCreateSpansArgs,\n  BatchDeleteTracesArgs,\n  BatchUpdateSpansArgs,\n  CreateSpanArgs,\n  CreateSpanRecord,\n  GetRootSpanArgs,\n  GetRootSpanResponse,\n  GetSpanArgs,\n  GetSpanResponse,\n  GetTraceArgs,\n  GetTraceResponse,\n  ListTracesArgs,\n  ListTracesResponse,\n  SpanRecord,\n  TracingStorageStrategy,\n  UpdateSpanArgs,\n} from './types';\nimport { listTracesArgsSchema, toTraceSpans, TraceStatus } from './types';\n\n/**\n * Internal structure for storing a trace with computed properties for efficient filtering\n */\nexport interface TraceEntry {\n  /** All spans in this trace, keyed by spanId */\n  spans: Record<string, SpanRecord>;\n  /** Root span for this trace (parentSpanId === null) */\n  rootSpan: SpanRecord | null;\n  /** Computed trace status based on root span state */\n  status: TraceStatus;\n  /** True if any span in the trace has an error */\n  hasChildError: boolean;\n}\n\nexport class ObservabilityInMemory extends ObservabilityStorage {\n  private db: InMemoryDB;\n\n  constructor({ db }: { db: InMemoryDB }) {\n    super();\n    this.db = db;\n  }\n\n  async dangerouslyClearAll(): Promise<void> {\n    this.db.traces.clear();\n  }\n\n  public get tracingStrategy(): {\n    preferred: TracingStorageStrategy;\n    supported: TracingStorageStrategy[];\n  } {\n    return {\n      preferred: 'realtime',\n      supported: ['realtime', 'batch-with-updates', 'insert-only'],\n    };\n  }\n\n  async createSpan(args: CreateSpanArgs): Promise<void> {\n    const { span } = args;\n    this.validateCreateSpan(span);\n    const now = new Date();\n    const record: SpanRecord = {\n      ...span,\n      createdAt: now,\n      updatedAt: now,\n    };\n\n    this.upsertSpanToTrace(record);\n  }\n\n  async batchCreateSpans(args: BatchCreateSpansArgs): Promise<void> {\n    const now = new Date();\n    for (const span of args.records) {\n      this.validateCreateSpan(span);\n      const record: SpanRecord = {\n        ...span,\n        createdAt: now,\n        updatedAt: now,\n      };\n      this.upsertSpanToTrace(record);\n    }\n  }\n\n  private validateCreateSpan(record: CreateSpanRecord): void {\n    if (!record.spanId) {\n      throw new MastraError({\n        id: 'OBSERVABILITY_SPAN_ID_REQUIRED',\n        domain: ErrorDomain.MASTRA_OBSERVABILITY,\n        category: ErrorCategory.SYSTEM,\n        text: 'Span ID is required for creating a span',\n      });\n    }\n\n    if (!record.traceId) {\n      throw new MastraError({\n        id: 'OBSERVABILITY_TRACE_ID_REQUIRED',\n        domain: ErrorDomain.MASTRA_OBSERVABILITY,\n        category: ErrorCategory.SYSTEM,\n        text: 'Trace ID is required for creating a span',\n      });\n    }\n  }\n\n  /**\n   * Inserts or updates a span in the trace and recomputes trace-level properties\n   */\n  private upsertSpanToTrace(span: SpanRecord): void {\n    const { traceId, spanId } = span;\n    let traceEntry = this.db.traces.get(traceId);\n\n    if (!traceEntry) {\n      traceEntry = {\n        spans: {},\n        rootSpan: null,\n        status: TraceStatus.RUNNING,\n        hasChildError: false,\n      };\n      this.db.traces.set(traceId, traceEntry);\n    }\n\n    traceEntry.spans[spanId] = span;\n\n    // Update root span if this is a root span\n    if (span.parentSpanId === null) {\n      traceEntry.rootSpan = span;\n    }\n\n    this.recomputeTraceProperties(traceEntry);\n  }\n\n  /**\n   * Recomputes derived trace properties from all spans\n   */\n  private recomputeTraceProperties(traceEntry: TraceEntry): void {\n    const spans = Object.values(traceEntry.spans);\n    if (spans.length === 0) return;\n\n    // Compute hasChildError (use != null to catch both null and undefined)\n    traceEntry.hasChildError = spans.some(s => s.error != null);\n\n    // Compute status from root span\n    const rootSpan = traceEntry.rootSpan;\n    if (rootSpan) {\n      if (rootSpan.error != null) {\n        traceEntry.status = TraceStatus.ERROR;\n      } else if (rootSpan.endedAt === null) {\n        traceEntry.status = TraceStatus.RUNNING;\n      } else {\n        traceEntry.status = TraceStatus.SUCCESS;\n      }\n    } else {\n      // No root span yet, consider it running\n      traceEntry.status = TraceStatus.RUNNING;\n    }\n  }\n\n  async getSpan(args: GetSpanArgs): Promise<GetSpanResponse | null> {\n    const { traceId, spanId } = args;\n    const traceEntry = this.db.traces.get(traceId);\n    if (!traceEntry) {\n      return null;\n    }\n\n    const span = traceEntry.spans[spanId];\n    if (!span) {\n      return null;\n    }\n\n    return { span };\n  }\n\n  async getRootSpan(args: GetRootSpanArgs): Promise<GetRootSpanResponse | null> {\n    const { traceId } = args;\n    const traceEntry = this.db.traces.get(traceId);\n    if (!traceEntry || !traceEntry.rootSpan) {\n      return null;\n    }\n\n    return { span: traceEntry.rootSpan };\n  }\n\n  async getTrace(args: GetTraceArgs): Promise<GetTraceResponse | null> {\n    const { traceId } = args;\n    const traceEntry = this.db.traces.get(traceId);\n    if (!traceEntry) {\n      return null;\n    }\n\n    const spans = Object.values(traceEntry.spans);\n    if (spans.length === 0) {\n      return null;\n    }\n\n    // Sort spans by startedAt\n    spans.sort((a, b) => a.startedAt.getTime() - b.startedAt.getTime());\n\n    return {\n      traceId,\n      spans,\n    };\n  }\n\n  async listTraces(args: ListTracesArgs): Promise<ListTracesResponse> {\n    // Parse args through schema to apply defaults\n    const { filters, pagination, orderBy } = listTracesArgsSchema.parse(args);\n\n    // Collect all traces that match filters\n    const matchingRootSpans: SpanRecord[] = [];\n\n    for (const [, traceEntry] of this.db.traces) {\n      if (!traceEntry.rootSpan) continue;\n\n      if (this.traceMatchesFilters(traceEntry, filters)) {\n        matchingRootSpans.push(traceEntry.rootSpan);\n      }\n    }\n\n    // Sort by orderBy field\n    const { field: sortField, direction: sortDirection } = orderBy;\n\n    matchingRootSpans.sort((a, b) => {\n      if (sortField === 'endedAt') {\n        const aVal = a.endedAt;\n        const bVal = b.endedAt;\n\n        // Handle nullish values (running spans with null endedAt)\n        // For endedAt DESC: NULLs FIRST (running spans on top when viewing newest)\n        // For endedAt ASC: NULLs LAST (running spans at end when viewing oldest)\n        if (aVal == null && bVal == null) return 0;\n        if (aVal == null) return sortDirection === 'DESC' ? -1 : 1;\n        if (bVal == null) return sortDirection === 'DESC' ? 1 : -1;\n\n        const diff = aVal.getTime() - bVal.getTime();\n        return sortDirection === 'DESC' ? -diff : diff;\n      } else {\n        // startedAt is never null (required field)\n        const diff = a.startedAt.getTime() - b.startedAt.getTime();\n        return sortDirection === 'DESC' ? -diff : diff;\n      }\n    });\n\n    // Apply pagination\n    const total = matchingRootSpans.length;\n    const { page, perPage } = pagination;\n    const start = page * perPage;\n    const end = start + perPage;\n\n    const paged = matchingRootSpans.slice(start, end);\n\n    return {\n      spans: toTraceSpans(paged),\n      pagination: { total, page, perPage, hasMore: end < total },\n    };\n  }\n\n  /**\n   * Check if a trace matches all provided filters\n   */\n  private traceMatchesFilters(traceEntry: TraceEntry, filters: ListTracesArgs['filters']): boolean {\n    if (!filters) return true;\n\n    const rootSpan = traceEntry.rootSpan;\n    if (!rootSpan) return false;\n\n    // Date range filters on startedAt (based on root span)\n    if (filters.startedAt) {\n      if (filters.startedAt.start && rootSpan.startedAt < filters.startedAt.start) {\n        return false;\n      }\n      if (filters.startedAt.end && rootSpan.startedAt > filters.startedAt.end) {\n        return false;\n      }\n    }\n\n    // Date range filters on endedAt (based on root span)\n    if (filters.endedAt) {\n      // If root span is still running (endedAt is nullish), it doesn't match endedAt filters\n      if (rootSpan.endedAt == null) {\n        return false;\n      }\n      if (filters.endedAt.start && rootSpan.endedAt < filters.endedAt.start) {\n        return false;\n      }\n      if (filters.endedAt.end && rootSpan.endedAt > filters.endedAt.end) {\n        return false;\n      }\n    }\n\n    // Span type filter (on root span)\n    if (filters.spanType !== undefined && rootSpan.spanType !== filters.spanType) {\n      return false;\n    }\n\n    // Entity filters\n    if (filters.entityType !== undefined && rootSpan.entityType !== filters.entityType) {\n      return false;\n    }\n    if (filters.entityId !== undefined && rootSpan.entityId !== filters.entityId) {\n      return false;\n    }\n    if (filters.entityName !== undefined && rootSpan.entityName !== filters.entityName) {\n      return false;\n    }\n\n    // Identity & Tenancy filters\n    if (filters.userId !== undefined && rootSpan.userId !== filters.userId) {\n      return false;\n    }\n    if (filters.organizationId !== undefined && rootSpan.organizationId !== filters.organizationId) {\n      return false;\n    }\n    if (filters.resourceId !== undefined && rootSpan.resourceId !== filters.resourceId) {\n      return false;\n    }\n\n    // Correlation ID filters\n    if (filters.runId !== undefined && rootSpan.runId !== filters.runId) {\n      return false;\n    }\n    if (filters.sessionId !== undefined && rootSpan.sessionId !== filters.sessionId) {\n      return false;\n    }\n    if (filters.threadId !== undefined && rootSpan.threadId !== filters.threadId) {\n      return false;\n    }\n    if (filters.requestId !== undefined && rootSpan.requestId !== filters.requestId) {\n      return false;\n    }\n\n    // Deployment context filters\n    if (filters.environment !== undefined && rootSpan.environment !== filters.environment) {\n      return false;\n    }\n    if (filters.source !== undefined && rootSpan.source !== filters.source) {\n      return false;\n    }\n    if (filters.serviceName !== undefined && rootSpan.serviceName !== filters.serviceName) {\n      return false;\n    }\n\n    // Scope filter (partial match - all provided keys must match)\n    // Use != null to handle both null and undefined (nullish filter fields)\n    if (filters.scope != null && rootSpan.scope != null) {\n      for (const [key, value] of Object.entries(filters.scope)) {\n        if (!jsonValueEquals(rootSpan.scope[key], value)) {\n          return false;\n        }\n      }\n    } else if (filters.scope != null && rootSpan.scope == null) {\n      return false;\n    }\n\n    // Metadata filter (partial match - all provided keys must match)\n    // Use != null to handle both null and undefined (nullish filter fields)\n    if (filters.metadata != null && rootSpan.metadata != null) {\n      for (const [key, value] of Object.entries(filters.metadata)) {\n        if (!jsonValueEquals(rootSpan.metadata[key], value)) {\n          return false;\n        }\n      }\n    } else if (filters.metadata != null && rootSpan.metadata == null) {\n      return false;\n    }\n\n    // Tags filter (all provided tags must be present)\n    // Use != null to handle both null and undefined (nullish filter fields)\n    if (filters.tags != null && filters.tags.length > 0) {\n      if (rootSpan.tags == null) {\n        return false;\n      }\n      for (const tag of filters.tags) {\n        if (!rootSpan.tags.includes(tag)) {\n          return false;\n        }\n      }\n    }\n\n    // Derived status filter\n    if (filters.status !== undefined && traceEntry.status !== filters.status) {\n      return false;\n    }\n\n    // Has child error filter\n    if (filters.hasChildError !== undefined && traceEntry.hasChildError !== filters.hasChildError) {\n      return false;\n    }\n\n    return true;\n  }\n\n  async updateSpan(args: UpdateSpanArgs): Promise<void> {\n    const { traceId, spanId, updates } = args;\n    const traceEntry = this.db.traces.get(traceId);\n\n    if (!traceEntry) {\n      throw new MastraError({\n        id: 'OBSERVABILITY_UPDATE_SPAN_NOT_FOUND',\n        domain: ErrorDomain.MASTRA_OBSERVABILITY,\n        category: ErrorCategory.SYSTEM,\n        text: 'Trace not found for span update',\n      });\n    }\n\n    const span = traceEntry.spans[spanId];\n    if (!span) {\n      throw new MastraError({\n        id: 'OBSERVABILITY_UPDATE_SPAN_NOT_FOUND',\n        domain: ErrorDomain.MASTRA_OBSERVABILITY,\n        category: ErrorCategory.SYSTEM,\n        text: 'Span not found for update',\n      });\n    }\n\n    const updatedSpan: SpanRecord = {\n      ...span,\n      ...updates,\n      updatedAt: new Date(),\n    };\n\n    traceEntry.spans[spanId] = updatedSpan;\n\n    // Update root span reference if this is the root span\n    if (updatedSpan.parentSpanId === null) {\n      traceEntry.rootSpan = updatedSpan;\n    }\n\n    this.recomputeTraceProperties(traceEntry);\n  }\n\n  async batchUpdateSpans(args: BatchUpdateSpansArgs): Promise<void> {\n    for (const record of args.records) {\n      await this.updateSpan(record);\n    }\n  }\n\n  async batchDeleteTraces(args: BatchDeleteTracesArgs): Promise<void> {\n    for (const traceId of args.traceIds) {\n      this.db.traces.delete(traceId);\n    }\n  }\n}\n","import type {\n  StoragePromptBlockType,\n  StoragePromptBlockSnapshotType,\n  StorageResolvedPromptBlockType,\n  StorageCreatePromptBlockInput,\n  StorageUpdatePromptBlockInput,\n  StorageListPromptBlocksInput,\n  StorageListPromptBlocksOutput,\n  StorageListPromptBlocksResolvedOutput,\n} from '../../types';\nimport { VersionedStorageDomain } from '../versioned';\nimport type { VersionBase, CreateVersionInputBase, ListVersionsInputBase, ListVersionsOutputBase } from '../versioned';\n\n// ============================================================================\n// Prompt Block Version Types\n// ============================================================================\n\n/**\n * Represents a stored version of a prompt block's content.\n * Config fields are top-level on the version row (no nested snapshot object).\n */\nexport interface PromptBlockVersion extends StoragePromptBlockSnapshotType, VersionBase {\n  /** ID of the prompt block this version belongs to */\n  blockId: string;\n}\n\n/**\n * Input for creating a new prompt block version.\n * Config fields are top-level (no nested snapshot object).\n */\nexport interface CreatePromptBlockVersionInput extends StoragePromptBlockSnapshotType, CreateVersionInputBase {\n  /** ID of the prompt block this version belongs to */\n  blockId: string;\n}\n\n/**\n * Sort direction for version listings.\n */\nexport type PromptBlockVersionSortDirection = 'ASC' | 'DESC';\n\n/**\n * Fields that can be used for ordering version listings.\n */\nexport type PromptBlockVersionOrderBy = 'versionNumber' | 'createdAt';\n\n/**\n * Input for listing prompt block versions with pagination and sorting.\n */\nexport interface ListPromptBlockVersionsInput extends ListVersionsInputBase {\n  /** ID of the prompt block to list versions for */\n  blockId: string;\n}\n\n/**\n * Output for listing prompt block versions with pagination info.\n */\nexport interface ListPromptBlockVersionsOutput extends ListVersionsOutputBase<PromptBlockVersion> {}\n\n// ============================================================================\n// PromptBlocksStorage Base Class\n// ============================================================================\n\nexport abstract class PromptBlocksStorage extends VersionedStorageDomain<\n  StoragePromptBlockType,\n  StoragePromptBlockSnapshotType,\n  StorageResolvedPromptBlockType,\n  PromptBlockVersion,\n  CreatePromptBlockVersionInput,\n  ListPromptBlockVersionsInput,\n  ListPromptBlockVersionsOutput,\n  { promptBlock: StorageCreatePromptBlockInput },\n  StorageUpdatePromptBlockInput,\n  StorageListPromptBlocksInput | undefined,\n  StorageListPromptBlocksOutput,\n  StorageListPromptBlocksResolvedOutput\n> {\n  protected readonly listKey = 'promptBlocks';\n  protected readonly versionMetadataFields = [\n    'id',\n    'blockId',\n    'versionNumber',\n    'changedFields',\n    'changeMessage',\n    'createdAt',\n  ] satisfies (keyof PromptBlockVersion)[];\n\n  constructor() {\n    super({\n      component: 'STORAGE',\n      name: 'PROMPT_BLOCKS',\n    });\n  }\n}\n","import { deepEqual } from '../../../utils';\nimport { normalizePerPage, calculatePagination } from '../../base';\nimport type {\n  StoragePromptBlockType,\n  StorageCreatePromptBlockInput,\n  StorageUpdatePromptBlockInput,\n  StorageListPromptBlocksInput,\n  StorageListPromptBlocksOutput,\n  ThreadOrderBy,\n  ThreadSortDirection,\n} from '../../types';\nimport type { InMemoryDB } from '../inmemory-db';\nimport type {\n  PromptBlockVersion,\n  CreatePromptBlockVersionInput,\n  ListPromptBlockVersionsInput,\n  ListPromptBlockVersionsOutput,\n  PromptBlockVersionOrderBy,\n  PromptBlockVersionSortDirection,\n} from './base';\nimport { PromptBlocksStorage } from './base';\n\nexport class InMemoryPromptBlocksStorage extends PromptBlocksStorage {\n  private db: InMemoryDB;\n\n  constructor({ db }: { db: InMemoryDB }) {\n    super();\n    this.db = db;\n  }\n\n  async dangerouslyClearAll(): Promise<void> {\n    this.db.promptBlocks.clear();\n    this.db.promptBlockVersions.clear();\n  }\n\n  // ==========================================================================\n  // Prompt Block CRUD Methods\n  // ==========================================================================\n\n  async getById(id: string): Promise<StoragePromptBlockType | null> {\n    this.logger.debug(`InMemoryPromptBlocksStorage: getById called for ${id}`);\n    const block = this.db.promptBlocks.get(id);\n    return block ? this.deepCopyBlock(block) : null;\n  }\n\n  async create(input: { promptBlock: StorageCreatePromptBlockInput }): Promise<StoragePromptBlockType> {\n    const { promptBlock } = input;\n    this.logger.debug(`InMemoryPromptBlocksStorage: create called for ${promptBlock.id}`);\n\n    if (this.db.promptBlocks.has(promptBlock.id)) {\n      throw new Error(`Prompt block with id ${promptBlock.id} already exists`);\n    }\n\n    const now = new Date();\n    const newBlock: StoragePromptBlockType = {\n      id: promptBlock.id,\n      status: 'draft',\n      activeVersionId: undefined,\n      authorId: promptBlock.authorId,\n      metadata: promptBlock.metadata,\n      createdAt: now,\n      updatedAt: now,\n    };\n\n    this.db.promptBlocks.set(promptBlock.id, newBlock);\n\n    // Extract config fields from the flat input (everything except block-record fields)\n    const { id: _id, authorId: _authorId, metadata: _metadata, ...snapshotConfig } = promptBlock;\n\n    // Create version 1 from the config\n    const versionId = crypto.randomUUID();\n    await this.createVersion({\n      id: versionId,\n      blockId: promptBlock.id,\n      versionNumber: 1,\n      ...snapshotConfig,\n      changedFields: Object.keys(snapshotConfig),\n      changeMessage: 'Initial version',\n    });\n\n    // Return the thin block record\n    return this.deepCopyBlock(newBlock);\n  }\n\n  async update(input: StorageUpdatePromptBlockInput): Promise<StoragePromptBlockType> {\n    const { id, ...updates } = input;\n    this.logger.debug(`InMemoryPromptBlocksStorage: update called for ${id}`);\n\n    const existingBlock = this.db.promptBlocks.get(id);\n    if (!existingBlock) {\n      throw new Error(`Prompt block with id ${id} not found`);\n    }\n\n    // Separate metadata fields from config fields\n    const { authorId, activeVersionId, metadata, status, ...configFields } = updates;\n\n    // Config field names from StoragePromptBlockSnapshotType\n    const configFieldNames = ['name', 'description', 'content', 'rules'];\n\n    // Check if any config fields are present in the update\n    const hasConfigUpdate = configFieldNames.some(field => field in configFields);\n\n    // Update metadata fields on the block record\n    const updatedBlock: StoragePromptBlockType = {\n      ...existingBlock,\n      ...(authorId !== undefined && { authorId }),\n      ...(activeVersionId !== undefined && { activeVersionId }),\n      ...(status !== undefined && { status: status as StoragePromptBlockType['status'] }),\n      ...(metadata !== undefined && {\n        metadata: { ...existingBlock.metadata, ...metadata },\n      }),\n      updatedAt: new Date(),\n    };\n\n    // If activeVersionId is set, mark as published\n    if (activeVersionId !== undefined) {\n      updatedBlock.status = 'published';\n    }\n\n    // If config fields are being updated, create a new version\n    if (hasConfigUpdate) {\n      // Get the latest version to use as base\n      const latestVersion = await this.getLatestVersion(id);\n      if (!latestVersion) {\n        throw new Error(`No versions found for prompt block ${id}`);\n      }\n\n      // Extract config from latest version\n      const {\n        id: _versionId,\n        blockId: _blockId,\n        versionNumber: _versionNumber,\n        changedFields: _changedFields,\n        changeMessage: _changeMessage,\n        createdAt: _createdAt,\n        ...latestConfig\n      } = latestVersion;\n\n      // Merge updates into latest config\n      const newConfig = {\n        ...latestConfig,\n        ...configFields,\n      };\n\n      // Identify which fields changed\n      const changedFields = configFieldNames.filter(\n        field =>\n          field in configFields &&\n          JSON.stringify(configFields[field as keyof typeof configFields]) !==\n            JSON.stringify(latestConfig[field as keyof typeof latestConfig]),\n      );\n\n      // Only create a new version if something actually changed\n      if (changedFields.length > 0) {\n        const newVersionId = crypto.randomUUID();\n        const newVersionNumber = latestVersion.versionNumber + 1;\n\n        await this.createVersion({\n          id: newVersionId,\n          blockId: id,\n          versionNumber: newVersionNumber,\n          ...newConfig,\n          changedFields,\n          changeMessage: `Updated ${changedFields.join(', ')}`,\n        });\n      }\n    }\n\n    // Save the updated block record\n    this.db.promptBlocks.set(id, updatedBlock);\n    return this.deepCopyBlock(updatedBlock);\n  }\n\n  async delete(id: string): Promise<void> {\n    this.logger.debug(`InMemoryPromptBlocksStorage: delete called for ${id}`);\n    // Idempotent delete\n    this.db.promptBlocks.delete(id);\n    // Also delete all versions for this block\n    await this.deleteVersionsByParentId(id);\n  }\n\n  async list(args?: StorageListPromptBlocksInput): Promise<StorageListPromptBlocksOutput> {\n    const { page = 0, perPage: perPageInput, orderBy, authorId, metadata } = args || {};\n    const { field, direction } = this.parseOrderBy(orderBy);\n\n    this.logger.debug(`InMemoryPromptBlocksStorage: list called`);\n\n    // Normalize perPage for query (false  MAX_SAFE_INTEGER, 0  0, undefined  100)\n    const perPage = normalizePerPage(perPageInput, 100);\n\n    if (page < 0) {\n      throw new Error('page must be >= 0');\n    }\n\n    // Prevent unreasonably large page values\n    const maxOffset = Number.MAX_SAFE_INTEGER / 2;\n    if (page * perPage > maxOffset) {\n      throw new Error('page value too large');\n    }\n\n    // Get all blocks and apply filters\n    let blocks = Array.from(this.db.promptBlocks.values());\n\n    // Filter by authorId if provided\n    if (authorId !== undefined) {\n      blocks = blocks.filter(block => block.authorId === authorId);\n    }\n\n    // Filter by metadata if provided (AND logic)\n    if (metadata && Object.keys(metadata).length > 0) {\n      blocks = blocks.filter(block => {\n        if (!block.metadata) return false;\n        return Object.entries(metadata).every(([key, value]) => deepEqual(block.metadata![key], value));\n      });\n    }\n\n    // Sort filtered blocks\n    const sortedBlocks = this.sortBlocks(blocks, field, direction);\n\n    // Deep clone blocks to avoid mutation\n    const clonedBlocks = sortedBlocks.map(block => this.deepCopyBlock(block));\n\n    const { offset, perPage: perPageForResponse } = calculatePagination(page, perPageInput, perPage);\n\n    return {\n      promptBlocks: clonedBlocks.slice(offset, offset + perPage),\n      total: clonedBlocks.length,\n      page,\n      perPage: perPageForResponse,\n      hasMore: offset + perPage < clonedBlocks.length,\n    };\n  }\n\n  // ==========================================================================\n  // Prompt Block Version Methods\n  // ==========================================================================\n\n  async createVersion(input: CreatePromptBlockVersionInput): Promise<PromptBlockVersion> {\n    this.logger.debug(`InMemoryPromptBlocksStorage: createVersion called for block ${input.blockId}`);\n\n    // Check if version with this ID already exists\n    if (this.db.promptBlockVersions.has(input.id)) {\n      throw new Error(`Version with id ${input.id} already exists`);\n    }\n\n    // Check for duplicate (blockId, versionNumber) pair\n    for (const version of this.db.promptBlockVersions.values()) {\n      if (version.blockId === input.blockId && version.versionNumber === input.versionNumber) {\n        throw new Error(`Version number ${input.versionNumber} already exists for prompt block ${input.blockId}`);\n      }\n    }\n\n    const version: PromptBlockVersion = {\n      ...input,\n      createdAt: new Date(),\n    };\n\n    // Deep clone before storing\n    this.db.promptBlockVersions.set(input.id, this.deepCopyVersion(version));\n    return this.deepCopyVersion(version);\n  }\n\n  async getVersion(id: string): Promise<PromptBlockVersion | null> {\n    this.logger.debug(`InMemoryPromptBlocksStorage: getVersion called for ${id}`);\n    const version = this.db.promptBlockVersions.get(id);\n    return version ? this.deepCopyVersion(version) : null;\n  }\n\n  async getVersionByNumber(blockId: string, versionNumber: number): Promise<PromptBlockVersion | null> {\n    this.logger.debug(`InMemoryPromptBlocksStorage: getVersionByNumber called for block ${blockId}, v${versionNumber}`);\n\n    for (const version of this.db.promptBlockVersions.values()) {\n      if (version.blockId === blockId && version.versionNumber === versionNumber) {\n        return this.deepCopyVersion(version);\n      }\n    }\n    return null;\n  }\n\n  async getLatestVersion(blockId: string): Promise<PromptBlockVersion | null> {\n    this.logger.debug(`InMemoryPromptBlocksStorage: getLatestVersion called for block ${blockId}`);\n\n    let latest: PromptBlockVersion | null = null;\n    for (const version of this.db.promptBlockVersions.values()) {\n      if (version.blockId === blockId) {\n        if (!latest || version.versionNumber > latest.versionNumber) {\n          latest = version;\n        }\n      }\n    }\n    return latest ? this.deepCopyVersion(latest) : null;\n  }\n\n  async listVersions(input: ListPromptBlockVersionsInput): Promise<ListPromptBlockVersionsOutput> {\n    const { blockId, page = 0, perPage: perPageInput, orderBy } = input;\n    const { field, direction } = this.parseVersionOrderBy(orderBy);\n\n    this.logger.debug(`InMemoryPromptBlocksStorage: listVersions called for block ${blockId}`);\n\n    // Normalize perPage (false -> MAX_SAFE_INTEGER, 0 -> 0, undefined -> 20)\n    const perPage = normalizePerPage(perPageInput, 20);\n\n    if (page < 0) {\n      throw new Error('page must be >= 0');\n    }\n\n    const maxOffset = Number.MAX_SAFE_INTEGER / 2;\n    if (page * perPage > maxOffset) {\n      throw new Error('page value too large');\n    }\n\n    // Filter versions by blockId\n    let versions = Array.from(this.db.promptBlockVersions.values()).filter(v => v.blockId === blockId);\n\n    // Sort versions\n    versions = this.sortVersions(versions, field, direction);\n\n    // Deep clone\n    const clonedVersions = versions.map(v => this.deepCopyVersion(v));\n\n    const total = clonedVersions.length;\n    const { offset, perPage: perPageForResponse } = calculatePagination(page, perPageInput, perPage);\n    const paginatedVersions = clonedVersions.slice(offset, offset + perPage);\n\n    return {\n      versions: paginatedVersions,\n      total,\n      page,\n      perPage: perPageForResponse,\n      hasMore: offset + perPage < total,\n    };\n  }\n\n  async deleteVersion(id: string): Promise<void> {\n    this.logger.debug(`InMemoryPromptBlocksStorage: deleteVersion called for ${id}`);\n    this.db.promptBlockVersions.delete(id);\n  }\n\n  async deleteVersionsByParentId(entityId: string): Promise<void> {\n    this.logger.debug(`InMemoryPromptBlocksStorage: deleteVersionsByParentId called for block ${entityId}`);\n\n    const idsToDelete: string[] = [];\n    for (const [id, version] of this.db.promptBlockVersions.entries()) {\n      if (version.blockId === entityId) {\n        idsToDelete.push(id);\n      }\n    }\n\n    for (const id of idsToDelete) {\n      this.db.promptBlockVersions.delete(id);\n    }\n  }\n\n  async countVersions(blockId: string): Promise<number> {\n    this.logger.debug(`InMemoryPromptBlocksStorage: countVersions called for block ${blockId}`);\n\n    let count = 0;\n    for (const version of this.db.promptBlockVersions.values()) {\n      if (version.blockId === blockId) {\n        count++;\n      }\n    }\n    return count;\n  }\n\n  // ==========================================================================\n  // Private Helper Methods\n  // ==========================================================================\n\n  private deepCopyBlock(block: StoragePromptBlockType): StoragePromptBlockType {\n    return {\n      ...block,\n      metadata: block.metadata ? { ...block.metadata } : block.metadata,\n    };\n  }\n\n  private deepCopyVersion(version: PromptBlockVersion): PromptBlockVersion {\n    return {\n      ...version,\n      rules: version.rules ? JSON.parse(JSON.stringify(version.rules)) : version.rules,\n      changedFields: version.changedFields ? [...version.changedFields] : version.changedFields,\n    };\n  }\n\n  private sortBlocks(\n    blocks: StoragePromptBlockType[],\n    field: ThreadOrderBy,\n    direction: ThreadSortDirection,\n  ): StoragePromptBlockType[] {\n    return blocks.sort((a, b) => {\n      const aValue = a[field].getTime();\n      const bValue = b[field].getTime();\n\n      return direction === 'ASC' ? aValue - bValue : bValue - aValue;\n    });\n  }\n\n  private sortVersions(\n    versions: PromptBlockVersion[],\n    field: PromptBlockVersionOrderBy,\n    direction: PromptBlockVersionSortDirection,\n  ): PromptBlockVersion[] {\n    return versions.sort((a, b) => {\n      let aVal: number;\n      let bVal: number;\n\n      if (field === 'createdAt') {\n        aVal = a.createdAt.getTime();\n        bVal = b.createdAt.getTime();\n      } else {\n        // versionNumber\n        aVal = a.versionNumber;\n        bVal = b.versionNumber;\n      }\n\n      return direction === 'ASC' ? aVal - bVal : bVal - aVal;\n    });\n  }\n}\n","import type {\n  StorageScorerDefinitionType,\n  StorageScorerDefinitionSnapshotType,\n  StorageResolvedScorerDefinitionType,\n  StorageCreateScorerDefinitionInput,\n  StorageUpdateScorerDefinitionInput,\n  StorageListScorerDefinitionsInput,\n  StorageListScorerDefinitionsOutput,\n  StorageListScorerDefinitionsResolvedOutput,\n} from '../../types';\nimport { VersionedStorageDomain } from '../versioned';\nimport type { VersionBase, CreateVersionInputBase, ListVersionsInputBase, ListVersionsOutputBase } from '../versioned';\n\n// ============================================================================\n// Scorer Definition Version Types\n// ============================================================================\n\n/**\n * Represents a stored version of a scorer definition's content.\n * Config fields are top-level on the version row (no nested snapshot object).\n */\nexport interface ScorerDefinitionVersion extends StorageScorerDefinitionSnapshotType, VersionBase {\n  /** ID of the scorer definition this version belongs to */\n  scorerDefinitionId: string;\n}\n\n/**\n * Input for creating a new scorer definition version.\n * Config fields are top-level (no nested snapshot object).\n */\nexport interface CreateScorerDefinitionVersionInput\n  extends StorageScorerDefinitionSnapshotType, CreateVersionInputBase {\n  /** ID of the scorer definition this version belongs to */\n  scorerDefinitionId: string;\n}\n\n/**\n * Sort direction for version listings.\n */\nexport type ScorerDefinitionVersionSortDirection = 'ASC' | 'DESC';\n\n/**\n * Fields that can be used for ordering version listings.\n */\nexport type ScorerDefinitionVersionOrderBy = 'versionNumber' | 'createdAt';\n\n/**\n * Input for listing scorer definition versions with pagination and sorting.\n */\nexport interface ListScorerDefinitionVersionsInput extends ListVersionsInputBase {\n  /** ID of the scorer definition to list versions for */\n  scorerDefinitionId: string;\n}\n\n/**\n * Output for listing scorer definition versions with pagination info.\n */\nexport interface ListScorerDefinitionVersionsOutput extends ListVersionsOutputBase<ScorerDefinitionVersion> {}\n\n// ============================================================================\n// ScorerDefinitionsStorage Base Class\n// ============================================================================\n\nexport abstract class ScorerDefinitionsStorage extends VersionedStorageDomain<\n  StorageScorerDefinitionType,\n  StorageScorerDefinitionSnapshotType,\n  StorageResolvedScorerDefinitionType,\n  ScorerDefinitionVersion,\n  CreateScorerDefinitionVersionInput,\n  ListScorerDefinitionVersionsInput,\n  ListScorerDefinitionVersionsOutput,\n  { scorerDefinition: StorageCreateScorerDefinitionInput },\n  StorageUpdateScorerDefinitionInput,\n  StorageListScorerDefinitionsInput | undefined,\n  StorageListScorerDefinitionsOutput,\n  StorageListScorerDefinitionsResolvedOutput\n> {\n  protected readonly listKey = 'scorerDefinitions';\n  protected readonly versionMetadataFields = [\n    'id',\n    'scorerDefinitionId',\n    'versionNumber',\n    'changedFields',\n    'changeMessage',\n    'createdAt',\n  ] satisfies (keyof ScorerDefinitionVersion)[];\n\n  constructor() {\n    super({\n      component: 'STORAGE',\n      name: 'SCORER_DEFINITIONS',\n    });\n  }\n}\n","import { deepEqual } from '../../../utils';\nimport { normalizePerPage, calculatePagination } from '../../base';\nimport type {\n  StorageScorerDefinitionType,\n  StorageCreateScorerDefinitionInput,\n  StorageUpdateScorerDefinitionInput,\n  StorageListScorerDefinitionsInput,\n  StorageListScorerDefinitionsOutput,\n  ThreadOrderBy,\n  ThreadSortDirection,\n} from '../../types';\nimport type { InMemoryDB } from '../inmemory-db';\nimport type {\n  ScorerDefinitionVersion,\n  CreateScorerDefinitionVersionInput,\n  ListScorerDefinitionVersionsInput,\n  ListScorerDefinitionVersionsOutput,\n  ScorerDefinitionVersionOrderBy,\n  ScorerDefinitionVersionSortDirection,\n} from './base';\nimport { ScorerDefinitionsStorage } from './base';\n\nexport class InMemoryScorerDefinitionsStorage extends ScorerDefinitionsStorage {\n  private db: InMemoryDB;\n\n  constructor({ db }: { db: InMemoryDB }) {\n    super();\n    this.db = db;\n  }\n\n  async dangerouslyClearAll(): Promise<void> {\n    this.db.scorerDefinitions.clear();\n    this.db.scorerDefinitionVersions.clear();\n  }\n\n  // ==========================================================================\n  // Scorer Definition CRUD Methods\n  // ==========================================================================\n\n  async getById(id: string): Promise<StorageScorerDefinitionType | null> {\n    this.logger.debug(`InMemoryScorerDefinitionsStorage: getById called for ${id}`);\n    const scorer = this.db.scorerDefinitions.get(id);\n    return scorer ? this.deepCopyScorer(scorer) : null;\n  }\n\n  async create(input: { scorerDefinition: StorageCreateScorerDefinitionInput }): Promise<StorageScorerDefinitionType> {\n    const { scorerDefinition } = input;\n    this.logger.debug(`InMemoryScorerDefinitionsStorage: create called for ${scorerDefinition.id}`);\n\n    if (this.db.scorerDefinitions.has(scorerDefinition.id)) {\n      throw new Error(`Scorer definition with id ${scorerDefinition.id} already exists`);\n    }\n\n    const now = new Date();\n    const newScorer: StorageScorerDefinitionType = {\n      id: scorerDefinition.id,\n      status: 'draft',\n      activeVersionId: undefined,\n      authorId: scorerDefinition.authorId,\n      metadata: scorerDefinition.metadata,\n      createdAt: now,\n      updatedAt: now,\n    };\n\n    this.db.scorerDefinitions.set(scorerDefinition.id, newScorer);\n\n    // Extract config fields from the flat input (everything except scorer-record fields)\n    const { id: _id, authorId: _authorId, metadata: _metadata, ...snapshotConfig } = scorerDefinition;\n\n    // Create version 1 from the config\n    const versionId = crypto.randomUUID();\n    await this.createVersion({\n      id: versionId,\n      scorerDefinitionId: scorerDefinition.id,\n      versionNumber: 1,\n      ...snapshotConfig,\n      changedFields: Object.keys(snapshotConfig),\n      changeMessage: 'Initial version',\n    });\n\n    // Return the thin scorer record\n    return this.deepCopyScorer(newScorer);\n  }\n\n  async update(input: StorageUpdateScorerDefinitionInput): Promise<StorageScorerDefinitionType> {\n    const { id, ...updates } = input;\n    this.logger.debug(`InMemoryScorerDefinitionsStorage: update called for ${id}`);\n\n    const existingScorer = this.db.scorerDefinitions.get(id);\n    if (!existingScorer) {\n      throw new Error(`Scorer definition with id ${id} not found`);\n    }\n\n    // Separate metadata fields from config fields\n    const { authorId, activeVersionId, metadata, status, ...configFields } = updates;\n\n    // Config field names from StorageScorerDefinitionSnapshotType\n    const configFieldNames = [\n      'name',\n      'description',\n      'type',\n      'model',\n      'instructions',\n      'scoreRange',\n      'presetConfig',\n      'defaultSampling',\n    ];\n\n    // Check if any config fields are present in the update\n    const hasConfigUpdate = configFieldNames.some(field => field in configFields);\n\n    // Update metadata fields on the scorer record\n    const updatedScorer: StorageScorerDefinitionType = {\n      ...existingScorer,\n      ...(authorId !== undefined && { authorId }),\n      ...(activeVersionId !== undefined && { activeVersionId }),\n      ...(status !== undefined && { status: status as StorageScorerDefinitionType['status'] }),\n      ...(metadata !== undefined && {\n        metadata: { ...existingScorer.metadata, ...metadata },\n      }),\n      updatedAt: new Date(),\n    };\n\n    // If activeVersionId is set, mark as published\n    if (activeVersionId !== undefined) {\n      updatedScorer.status = 'published';\n    }\n\n    // If config fields are being updated, create a new version\n    if (hasConfigUpdate) {\n      // Get the latest version to use as base\n      const latestVersion = await this.getLatestVersion(id);\n      if (!latestVersion) {\n        throw new Error(`No versions found for scorer definition ${id}`);\n      }\n\n      // Extract config from latest version\n      const {\n        id: _versionId,\n        scorerDefinitionId: _scorerDefinitionId,\n        versionNumber: _versionNumber,\n        changedFields: _changedFields,\n        changeMessage: _changeMessage,\n        createdAt: _createdAt,\n        ...latestConfig\n      } = latestVersion;\n\n      // Merge updates into latest config\n      const newConfig = {\n        ...latestConfig,\n        ...configFields,\n      };\n\n      // Identify which fields changed\n      const changedFields = configFieldNames.filter(\n        field =>\n          field in configFields &&\n          JSON.stringify(configFields[field as keyof typeof configFields]) !==\n            JSON.stringify(latestConfig[field as keyof typeof latestConfig]),\n      );\n\n      // Only create a new version if something actually changed\n      if (changedFields.length > 0) {\n        const newVersionId = crypto.randomUUID();\n        const newVersionNumber = latestVersion.versionNumber + 1;\n\n        await this.createVersion({\n          id: newVersionId,\n          scorerDefinitionId: id,\n          versionNumber: newVersionNumber,\n          ...newConfig,\n          changedFields,\n          changeMessage: `Updated ${changedFields.join(', ')}`,\n        });\n      }\n    }\n\n    // Save the updated scorer record\n    this.db.scorerDefinitions.set(id, updatedScorer);\n    return this.deepCopyScorer(updatedScorer);\n  }\n\n  async delete(id: string): Promise<void> {\n    this.logger.debug(`InMemoryScorerDefinitionsStorage: delete called for ${id}`);\n    // Idempotent delete\n    this.db.scorerDefinitions.delete(id);\n    // Also delete all versions for this scorer definition\n    await this.deleteVersionsByParentId(id);\n  }\n\n  async list(args?: StorageListScorerDefinitionsInput): Promise<StorageListScorerDefinitionsOutput> {\n    const { page = 0, perPage: perPageInput, orderBy, authorId, metadata } = args || {};\n    const { field, direction } = this.parseOrderBy(orderBy);\n\n    this.logger.debug(`InMemoryScorerDefinitionsStorage: list called`);\n\n    // Normalize perPage for query (false  MAX_SAFE_INTEGER, 0  0, undefined  100)\n    const perPage = normalizePerPage(perPageInput, 100);\n\n    if (page < 0) {\n      throw new Error('page must be >= 0');\n    }\n\n    // Prevent unreasonably large page values\n    const maxOffset = Number.MAX_SAFE_INTEGER / 2;\n    if (page * perPage > maxOffset) {\n      throw new Error('page value too large');\n    }\n\n    // Get all scorer definitions and apply filters\n    let scorers = Array.from(this.db.scorerDefinitions.values());\n\n    // Filter by authorId if provided\n    if (authorId !== undefined) {\n      scorers = scorers.filter(scorer => scorer.authorId === authorId);\n    }\n\n    // Filter by metadata if provided (AND logic)\n    if (metadata && Object.keys(metadata).length > 0) {\n      scorers = scorers.filter(scorer => {\n        if (!scorer.metadata) return false;\n        return Object.entries(metadata).every(([key, value]) => deepEqual(scorer.metadata![key], value));\n      });\n    }\n\n    // Sort filtered scorer definitions\n    const sortedScorers = this.sortScorers(scorers, field, direction);\n\n    // Deep clone scorers to avoid mutation\n    const clonedScorers = sortedScorers.map(scorer => this.deepCopyScorer(scorer));\n\n    const { offset, perPage: perPageForResponse } = calculatePagination(page, perPageInput, perPage);\n\n    return {\n      scorerDefinitions: clonedScorers.slice(offset, offset + perPage),\n      total: clonedScorers.length,\n      page,\n      perPage: perPageForResponse,\n      hasMore: offset + perPage < clonedScorers.length,\n    };\n  }\n\n  // ==========================================================================\n  // Scorer Definition Version Methods\n  // ==========================================================================\n\n  async createVersion(input: CreateScorerDefinitionVersionInput): Promise<ScorerDefinitionVersion> {\n    this.logger.debug(\n      `InMemoryScorerDefinitionsStorage: createVersion called for scorer definition ${input.scorerDefinitionId}`,\n    );\n\n    // Check if version with this ID already exists\n    if (this.db.scorerDefinitionVersions.has(input.id)) {\n      throw new Error(`Version with id ${input.id} already exists`);\n    }\n\n    // Check for duplicate (scorerDefinitionId, versionNumber) pair\n    for (const version of this.db.scorerDefinitionVersions.values()) {\n      if (version.scorerDefinitionId === input.scorerDefinitionId && version.versionNumber === input.versionNumber) {\n        throw new Error(\n          `Version number ${input.versionNumber} already exists for scorer definition ${input.scorerDefinitionId}`,\n        );\n      }\n    }\n\n    const version: ScorerDefinitionVersion = {\n      ...input,\n      createdAt: new Date(),\n    };\n\n    // Deep clone before storing\n    this.db.scorerDefinitionVersions.set(input.id, this.deepCopyVersion(version));\n    return this.deepCopyVersion(version);\n  }\n\n  async getVersion(id: string): Promise<ScorerDefinitionVersion | null> {\n    this.logger.debug(`InMemoryScorerDefinitionsStorage: getVersion called for ${id}`);\n    const version = this.db.scorerDefinitionVersions.get(id);\n    return version ? this.deepCopyVersion(version) : null;\n  }\n\n  async getVersionByNumber(scorerDefinitionId: string, versionNumber: number): Promise<ScorerDefinitionVersion | null> {\n    this.logger.debug(\n      `InMemoryScorerDefinitionsStorage: getVersionByNumber called for scorer definition ${scorerDefinitionId}, v${versionNumber}`,\n    );\n\n    for (const version of this.db.scorerDefinitionVersions.values()) {\n      if (version.scorerDefinitionId === scorerDefinitionId && version.versionNumber === versionNumber) {\n        return this.deepCopyVersion(version);\n      }\n    }\n    return null;\n  }\n\n  async getLatestVersion(scorerDefinitionId: string): Promise<ScorerDefinitionVersion | null> {\n    this.logger.debug(\n      `InMemoryScorerDefinitionsStorage: getLatestVersion called for scorer definition ${scorerDefinitionId}`,\n    );\n\n    let latest: ScorerDefinitionVersion | null = null;\n    for (const version of this.db.scorerDefinitionVersions.values()) {\n      if (version.scorerDefinitionId === scorerDefinitionId) {\n        if (!latest || version.versionNumber > latest.versionNumber) {\n          latest = version;\n        }\n      }\n    }\n    return latest ? this.deepCopyVersion(latest) : null;\n  }\n\n  async listVersions(input: ListScorerDefinitionVersionsInput): Promise<ListScorerDefinitionVersionsOutput> {\n    const { scorerDefinitionId, page = 0, perPage: perPageInput, orderBy } = input;\n    const { field, direction } = this.parseVersionOrderBy(orderBy);\n\n    this.logger.debug(\n      `InMemoryScorerDefinitionsStorage: listVersions called for scorer definition ${scorerDefinitionId}`,\n    );\n\n    // Normalize perPage (false -> MAX_SAFE_INTEGER, 0 -> 0, undefined -> 20)\n    const perPage = normalizePerPage(perPageInput, 20);\n\n    if (page < 0) {\n      throw new Error('page must be >= 0');\n    }\n\n    const maxOffset = Number.MAX_SAFE_INTEGER / 2;\n    if (page * perPage > maxOffset) {\n      throw new Error('page value too large');\n    }\n\n    // Filter versions by scorerDefinitionId\n    let versions = Array.from(this.db.scorerDefinitionVersions.values()).filter(\n      v => v.scorerDefinitionId === scorerDefinitionId,\n    );\n\n    // Sort versions\n    versions = this.sortVersions(versions, field, direction);\n\n    // Deep clone\n    const clonedVersions = versions.map(v => this.deepCopyVersion(v));\n\n    const total = clonedVersions.length;\n    const { offset, perPage: perPageForResponse } = calculatePagination(page, perPageInput, perPage);\n    const paginatedVersions = clonedVersions.slice(offset, offset + perPage);\n\n    return {\n      versions: paginatedVersions,\n      total,\n      page,\n      perPage: perPageForResponse,\n      hasMore: offset + perPage < total,\n    };\n  }\n\n  async deleteVersion(id: string): Promise<void> {\n    this.logger.debug(`InMemoryScorerDefinitionsStorage: deleteVersion called for ${id}`);\n    this.db.scorerDefinitionVersions.delete(id);\n  }\n\n  async deleteVersionsByParentId(entityId: string): Promise<void> {\n    this.logger.debug(\n      `InMemoryScorerDefinitionsStorage: deleteVersionsByParentId called for scorer definition ${entityId}`,\n    );\n\n    const idsToDelete: string[] = [];\n    for (const [id, version] of this.db.scorerDefinitionVersions.entries()) {\n      if (version.scorerDefinitionId === entityId) {\n        idsToDelete.push(id);\n      }\n    }\n\n    for (const id of idsToDelete) {\n      this.db.scorerDefinitionVersions.delete(id);\n    }\n  }\n\n  async countVersions(scorerDefinitionId: string): Promise<number> {\n    this.logger.debug(\n      `InMemoryScorerDefinitionsStorage: countVersions called for scorer definition ${scorerDefinitionId}`,\n    );\n\n    let count = 0;\n    for (const version of this.db.scorerDefinitionVersions.values()) {\n      if (version.scorerDefinitionId === scorerDefinitionId) {\n        count++;\n      }\n    }\n    return count;\n  }\n\n  // ==========================================================================\n  // Private Helper Methods\n  // ==========================================================================\n\n  private deepCopyScorer(scorer: StorageScorerDefinitionType): StorageScorerDefinitionType {\n    return {\n      ...scorer,\n      metadata: scorer.metadata ? { ...scorer.metadata } : scorer.metadata,\n    };\n  }\n\n  private deepCopyVersion(version: ScorerDefinitionVersion): ScorerDefinitionVersion {\n    return {\n      ...version,\n      model: version.model ? JSON.parse(JSON.stringify(version.model)) : version.model,\n      scoreRange: version.scoreRange ? JSON.parse(JSON.stringify(version.scoreRange)) : version.scoreRange,\n      presetConfig: version.presetConfig ? JSON.parse(JSON.stringify(version.presetConfig)) : version.presetConfig,\n      defaultSampling: version.defaultSampling\n        ? JSON.parse(JSON.stringify(version.defaultSampling))\n        : version.defaultSampling,\n      changedFields: version.changedFields ? [...version.changedFields] : version.changedFields,\n    };\n  }\n\n  private sortScorers(\n    scorers: StorageScorerDefinitionType[],\n    field: ThreadOrderBy,\n    direction: ThreadSortDirection,\n  ): StorageScorerDefinitionType[] {\n    return scorers.sort((a, b) => {\n      const aValue = a[field].getTime();\n      const bValue = b[field].getTime();\n\n      return direction === 'ASC' ? aValue - bValue : bValue - aValue;\n    });\n  }\n\n  private sortVersions(\n    versions: ScorerDefinitionVersion[],\n    field: ScorerDefinitionVersionOrderBy,\n    direction: ScorerDefinitionVersionSortDirection,\n  ): ScorerDefinitionVersion[] {\n    return versions.sort((a, b) => {\n      let aVal: number;\n      let bVal: number;\n\n      if (field === 'createdAt') {\n        aVal = a.createdAt.getTime();\n        bVal = b.createdAt.getTime();\n      } else {\n        // versionNumber\n        aVal = a.versionNumber;\n        bVal = b.versionNumber;\n      }\n\n      return direction === 'ASC' ? aVal - bVal : bVal - aVal;\n    });\n  }\n}\n","import { ErrorCategory, ErrorDomain, MastraError } from '../../../error';\nimport type { ListScoresResponse, SaveScorePayload, ScoreRowData, ScoringSource } from '../../../evals/types';\nimport type { StoragePagination } from '../../types';\nimport { StorageDomain } from '../base';\n\nexport abstract class ScoresStorage extends StorageDomain {\n  constructor() {\n    super({\n      component: 'STORAGE',\n      name: 'SCORES',\n    });\n  }\n\n  async dangerouslyClearAll(): Promise<void> {\n    // Default no-op - subclasses override\n  }\n\n  abstract getScoreById({ id }: { id: string }): Promise<ScoreRowData | null>;\n\n  abstract saveScore(score: SaveScorePayload): Promise<{ score: ScoreRowData }>;\n\n  abstract listScoresByScorerId({\n    scorerId,\n    pagination,\n    entityId,\n    entityType,\n    source,\n  }: {\n    scorerId: string;\n    pagination: StoragePagination;\n    entityId?: string;\n    entityType?: string;\n    source?: ScoringSource;\n  }): Promise<ListScoresResponse>;\n\n  abstract listScoresByRunId({\n    runId,\n    pagination,\n  }: {\n    runId: string;\n    pagination: StoragePagination;\n  }): Promise<ListScoresResponse>;\n\n  abstract listScoresByEntityId({\n    entityId,\n    entityType,\n    pagination,\n  }: {\n    pagination: StoragePagination;\n    entityId: string;\n    entityType: string;\n  }): Promise<ListScoresResponse>;\n\n  async listScoresBySpan({\n    traceId,\n    spanId,\n    pagination: _pagination,\n  }: {\n    traceId: string;\n    spanId: string;\n    pagination: StoragePagination;\n  }): Promise<ListScoresResponse> {\n    throw new MastraError({\n      id: 'SCORES_STORAGE_GET_SCORES_BY_SPAN_NOT_IMPLEMENTED',\n      domain: ErrorDomain.STORAGE,\n      category: ErrorCategory.SYSTEM,\n      details: { traceId, spanId },\n    });\n  }\n}\n","import type { ListScoresResponse, SaveScorePayload, ScoreRowData, ScoringSource } from '../../../evals/types';\nimport { calculatePagination, normalizePerPage } from '../../base';\nimport type { StoragePagination } from '../../types';\nimport type { InMemoryDB } from '../inmemory-db';\nimport { ScoresStorage } from './base';\n\nexport class ScoresInMemory extends ScoresStorage {\n  private db: InMemoryDB;\n\n  constructor({ db }: { db: InMemoryDB }) {\n    super();\n    this.db = db;\n  }\n\n  async dangerouslyClearAll(): Promise<void> {\n    this.db.scores.clear();\n  }\n\n  async getScoreById({ id }: { id: string }): Promise<ScoreRowData | null> {\n    return this.db.scores.get(id) ?? null;\n  }\n\n  async saveScore(score: SaveScorePayload): Promise<{ score: ScoreRowData }> {\n    const newScore = { id: crypto.randomUUID(), createdAt: new Date(), updatedAt: new Date(), ...score };\n    this.db.scores.set(newScore.id, newScore);\n    return { score: newScore };\n  }\n\n  async listScoresByScorerId({\n    scorerId,\n    pagination,\n    entityId,\n    entityType,\n    source,\n  }: {\n    scorerId: string;\n    pagination: StoragePagination;\n    entityId?: string;\n    entityType?: string;\n    source?: ScoringSource;\n  }): Promise<ListScoresResponse> {\n    const scores = Array.from(this.db.scores.values()).filter(score => {\n      let baseFilter = score.scorerId === scorerId;\n\n      if (entityId) {\n        baseFilter = baseFilter && score.entityId === entityId;\n      }\n\n      if (entityType) {\n        baseFilter = baseFilter && score.entityType === entityType;\n      }\n\n      if (source) {\n        baseFilter = baseFilter && score.source === source;\n      }\n\n      return baseFilter;\n    });\n\n    const { page, perPage: perPageInput } = pagination;\n    const perPage = normalizePerPage(perPageInput, Number.MAX_SAFE_INTEGER);\n    const { offset: start, perPage: perPageForResponse } = calculatePagination(page, perPageInput, perPage);\n    const end = perPageInput === false ? scores.length : start + perPage;\n\n    return {\n      scores: scores.slice(start, end),\n      pagination: {\n        total: scores.length,\n        page: page,\n        perPage: perPageForResponse,\n        hasMore: perPageInput === false ? false : scores.length > end,\n      },\n    };\n  }\n\n  async listScoresByRunId({\n    runId,\n    pagination,\n  }: {\n    runId: string;\n    pagination: StoragePagination;\n  }): Promise<ListScoresResponse> {\n    const scores = Array.from(this.db.scores.values()).filter(score => score.runId === runId);\n\n    const { page, perPage: perPageInput } = pagination;\n    const perPage = normalizePerPage(perPageInput, Number.MAX_SAFE_INTEGER); // false  MAX_SAFE_INTEGER\n    const { offset: start, perPage: perPageForResponse } = calculatePagination(page, perPageInput, perPage);\n    const end = perPageInput === false ? scores.length : start + perPage;\n\n    return {\n      scores: scores.slice(start, end),\n      pagination: {\n        total: scores.length,\n        page: page,\n        perPage: perPageForResponse,\n        hasMore: perPageInput === false ? false : scores.length > end,\n      },\n    };\n  }\n\n  async listScoresByEntityId({\n    entityId,\n    entityType,\n    pagination,\n  }: {\n    entityId: string;\n    entityType: string;\n    pagination: StoragePagination;\n  }): Promise<ListScoresResponse> {\n    const scores = Array.from(this.db.scores.values()).filter(score => {\n      const baseFilter = score.entityId === entityId && score.entityType === entityType;\n\n      return baseFilter;\n    });\n\n    const { page, perPage: perPageInput } = pagination;\n    const perPage = normalizePerPage(perPageInput, Number.MAX_SAFE_INTEGER);\n    const { offset: start, perPage: perPageForResponse } = calculatePagination(page, perPageInput, perPage);\n    const end = perPageInput === false ? scores.length : start + perPage;\n\n    return {\n      scores: scores.slice(start, end),\n      pagination: {\n        total: scores.length,\n        page: page,\n        perPage: perPageForResponse,\n        hasMore: perPageInput === false ? false : scores.length > end,\n      },\n    };\n  }\n\n  async listScoresBySpan({\n    traceId,\n    spanId,\n    pagination,\n  }: {\n    traceId: string;\n    spanId: string;\n    pagination: StoragePagination;\n  }): Promise<ListScoresResponse> {\n    const scores = Array.from(this.db.scores.values()).filter(\n      score => score.traceId === traceId && score.spanId === spanId,\n    );\n    scores.sort((a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime());\n\n    const { page, perPage: perPageInput } = pagination;\n    const perPage = normalizePerPage(perPageInput, Number.MAX_SAFE_INTEGER);\n    const { offset: start, perPage: perPageForResponse } = calculatePagination(page, perPageInput, perPage);\n    const end = perPageInput === false ? scores.length : start + perPage;\n\n    return {\n      scores: scores.slice(start, end),\n      pagination: {\n        total: scores.length,\n        page: page,\n        perPage: perPageForResponse,\n        hasMore: perPageInput === false ? false : scores.length > end,\n      },\n    };\n  }\n}\n","/**\n * Types and utilities for evented workflow execution.\n */\n\n/**\n * String key used to mark pending forEach iterations.\n * Using a string key (not Symbol) ensures the marker survives JSON serialization\n * which is critical for distributed execution where state is persisted to storage\n * and loaded by different engine instances.\n */\nexport const PENDING_MARKER_KEY = '__mastra_pending__' as const;\n\n/**\n * Type for the pending marker object used in forEach iteration tracking.\n */\nexport type PendingMarker = { [PENDING_MARKER_KEY]: true };\n\n/**\n * Creates a new pending marker object.\n * Used to mark forEach iterations that are about to be resumed.\n */\nexport function createPendingMarker(): PendingMarker {\n  return { [PENDING_MARKER_KEY]: true };\n}\n\n/**\n * Type guard to check if a value is a pending marker.\n * Works correctly after JSON serialization/deserialization.\n * @param val - The value to check\n * @returns True if the value is a PendingMarker\n */\nexport function isPendingMarker(val: unknown): val is PendingMarker {\n  return (\n    val !== null &&\n    typeof val === 'object' &&\n    PENDING_MARKER_KEY in val &&\n    (val as Record<string, unknown>)[PENDING_MARKER_KEY] === true\n  );\n}\n","import type { StepResult, WorkflowRunState } from '../../../workflows';\nimport type { UpdateWorkflowStateOptions, WorkflowRun, WorkflowRuns, StorageListWorkflowRunsInput } from '../../types';\nimport { StorageDomain } from '../base';\n\nexport abstract class WorkflowsStorage extends StorageDomain {\n  constructor() {\n    super({\n      component: 'STORAGE',\n      name: 'WORKFLOWS',\n    });\n  }\n\n  abstract updateWorkflowResults({\n    workflowName,\n    runId,\n    stepId,\n    result,\n    requestContext,\n  }: {\n    workflowName: string;\n    runId: string;\n    stepId: string;\n    result: StepResult<any, any, any, any>;\n    requestContext: Record<string, any>;\n  }): Promise<Record<string, StepResult<any, any, any, any>>>;\n\n  abstract updateWorkflowState({\n    workflowName,\n    runId,\n    opts,\n  }: {\n    workflowName: string;\n    runId: string;\n    opts: UpdateWorkflowStateOptions;\n  }): Promise<WorkflowRunState | undefined>;\n\n  abstract persistWorkflowSnapshot(_: {\n    workflowName: string;\n    runId: string;\n    resourceId?: string;\n    snapshot: WorkflowRunState;\n    createdAt?: Date;\n    updatedAt?: Date;\n  }): Promise<void>;\n\n  abstract loadWorkflowSnapshot({\n    workflowName,\n    runId,\n  }: {\n    workflowName: string;\n    runId: string;\n  }): Promise<WorkflowRunState | null>;\n\n  abstract listWorkflowRuns(args?: StorageListWorkflowRunsInput): Promise<WorkflowRuns>;\n\n  abstract getWorkflowRunById(args: { runId: string; workflowName?: string }): Promise<WorkflowRun | null>;\n\n  abstract deleteWorkflowRunById(args: { runId: string; workflowName: string }): Promise<void>;\n}\n","import type { StepResult, WorkflowRunState } from '../../../workflows';\nimport { isPendingMarker } from '../../../workflows/evented/types';\nimport { normalizePerPage } from '../../base';\nimport type {\n  StorageWorkflowRun,\n  WorkflowRun,\n  WorkflowRuns,\n  StorageListWorkflowRunsInput,\n  UpdateWorkflowStateOptions,\n} from '../../types';\nimport type { InMemoryDB } from '../inmemory-db';\nimport { WorkflowsStorage } from './base';\n\nexport class WorkflowsInMemory extends WorkflowsStorage {\n  private db: InMemoryDB;\n\n  constructor({ db }: { db: InMemoryDB }) {\n    super();\n    this.db = db;\n  }\n\n  async dangerouslyClearAll(): Promise<void> {\n    this.db.workflows.clear();\n  }\n\n  private getWorkflowKey(workflowName: string, runId: string): string {\n    return `${workflowName}-${runId}`;\n  }\n\n  async updateWorkflowResults({\n    workflowName,\n    runId,\n    stepId,\n    result,\n    requestContext,\n  }: {\n    workflowName: string;\n    runId: string;\n    stepId: string;\n    result: StepResult<any, any, any, any>;\n    requestContext: Record<string, any>;\n  }): Promise<Record<string, StepResult<any, any, any, any>>> {\n    this.logger.debug(`WorkflowsInMemory: updateWorkflowResults called for ${workflowName} ${runId} ${stepId}`, result);\n    const key = this.getWorkflowKey(workflowName, runId);\n    const run = this.db.workflows.get(key);\n\n    if (!run) {\n      return {};\n    }\n\n    let snapshot: WorkflowRunState;\n    if (!run.snapshot) {\n      snapshot = {\n        context: {},\n        activePaths: [],\n        activeStepsPath: {},\n        timestamp: Date.now(),\n        suspendedPaths: {},\n        resumeLabels: {},\n        serializedStepGraph: [],\n        value: {},\n        waitingPaths: {},\n        status: 'pending',\n        runId: run.run_id,\n      } as WorkflowRunState;\n\n      this.db.workflows.set(key, {\n        ...run,\n        snapshot,\n      });\n    } else {\n      snapshot = typeof run.snapshot === 'string' ? JSON.parse(run.snapshot) : run.snapshot;\n    }\n\n    if (!snapshot || !snapshot?.context) {\n      throw new Error(`Snapshot not found for runId ${runId}`);\n    }\n\n    // For foreach steps with array outputs, merge the arrays atomically\n    // This handles concurrent iteration completions\n    const existingResult = snapshot.context[stepId];\n    if (\n      existingResult &&\n      'output' in existingResult &&\n      Array.isArray(existingResult.output) &&\n      result &&\n      typeof result === 'object' &&\n      'output' in result &&\n      Array.isArray(result.output)\n    ) {\n      const existingOutput = existingResult.output as unknown[];\n      const newOutput = result.output as unknown[];\n      // ForEach iteration result merge logic:\n      //\n      // When forEach runs with concurrency > 1, multiple iterations execute in parallel.\n      // Each iteration writes its result to the same output array. We need to merge carefully:\n      //\n      // - null in newOutput means \"iteration started but not finished\" - keep existing result\n      // - non-null in newOutput means \"iteration completed\" - use the new result\n      // - PendingMarker ({ __mastra_pending__: true }) means \"force reset to null\"\n      //\n      // The PendingMarker is needed for bulk resume: when resuming suspended iterations,\n      // we must reset them to null before re-running. Without the marker, the merge logic\n      // would preserve the old suspended result (since null means \"keep existing\").\n      //\n      // Why a string key instead of Symbol? Symbols don't survive JSON serialization.\n      // In distributed execution where state is persisted to storage and loaded by\n      // different engine instances, a Symbol marker would be silently dropped.\n      const mergedOutput = [...existingOutput];\n      for (let i = 0; i < Math.max(existingOutput.length, newOutput.length); i++) {\n        if (i < newOutput.length) {\n          const newVal = newOutput[i];\n          if (isPendingMarker(newVal)) {\n            // PendingMarker: force reset to null (for bulk resume of suspended iterations)\n            mergedOutput[i] = null;\n          } else if (newVal !== null) {\n            // Completed result: always use the new value\n            mergedOutput[i] = newVal;\n          }\n          // null: iteration in progress, keep existing result (from spread above)\n        }\n        // Index beyond newOutput length: keep existing (from spread above)\n      }\n      snapshot.context[stepId] = {\n        ...existingResult,\n        ...(result as any),\n        output: mergedOutput,\n      };\n    } else {\n      snapshot.context[stepId] = result;\n    }\n    snapshot.requestContext = { ...snapshot.requestContext, ...requestContext };\n\n    this.db.workflows.set(key, {\n      ...run,\n      snapshot: snapshot,\n    });\n\n    return JSON.parse(JSON.stringify(snapshot.context));\n  }\n\n  async updateWorkflowState({\n    workflowName,\n    runId,\n    opts,\n  }: {\n    workflowName: string;\n    runId: string;\n    opts: UpdateWorkflowStateOptions;\n  }): Promise<WorkflowRunState | undefined> {\n    const key = this.getWorkflowKey(workflowName, runId);\n    const run = this.db.workflows.get(key);\n\n    if (!run) {\n      return;\n    }\n\n    let snapshot: WorkflowRunState;\n    if (!run.snapshot) {\n      snapshot = {\n        context: {},\n        activePaths: [],\n        activeStepsPath: {},\n        timestamp: Date.now(),\n        suspendedPaths: {},\n        resumeLabels: {},\n        serializedStepGraph: [],\n        value: {},\n        waitingPaths: {},\n        status: 'pending',\n        runId: run.run_id,\n      } as WorkflowRunState;\n\n      this.db.workflows.set(key, {\n        ...run,\n        snapshot,\n      });\n    } else {\n      snapshot = typeof run.snapshot === 'string' ? JSON.parse(run.snapshot) : run.snapshot;\n    }\n\n    if (!snapshot || !snapshot?.context) {\n      throw new Error(`Snapshot not found for runId ${runId}`);\n    }\n\n    snapshot = { ...snapshot, ...opts };\n    this.db.workflows.set(key, {\n      ...run,\n      snapshot: snapshot,\n    });\n\n    return snapshot;\n  }\n\n  async persistWorkflowSnapshot({\n    workflowName,\n    runId,\n    resourceId,\n    snapshot,\n    createdAt,\n    updatedAt,\n  }: {\n    workflowName: string;\n    runId: string;\n    resourceId?: string;\n    snapshot: WorkflowRunState;\n    createdAt?: Date;\n    updatedAt?: Date;\n  }): Promise<void> {\n    const key = this.getWorkflowKey(workflowName, runId);\n    const now = new Date();\n    const data: StorageWorkflowRun = {\n      workflow_name: workflowName,\n      run_id: runId,\n      resourceId,\n      snapshot,\n      createdAt: createdAt ?? now,\n      updatedAt: updatedAt ?? now,\n    };\n\n    this.db.workflows.set(key, data);\n  }\n\n  async loadWorkflowSnapshot({\n    workflowName,\n    runId,\n  }: {\n    workflowName: string;\n    runId: string;\n  }): Promise<WorkflowRunState | null> {\n    this.logger.debug('Loading workflow snapshot', { workflowName, runId });\n    const key = this.getWorkflowKey(workflowName, runId);\n    const run = this.db.workflows.get(key);\n\n    if (!run) {\n      return null;\n    }\n\n    const snapshot = typeof run.snapshot === 'string' ? JSON.parse(run.snapshot) : run.snapshot;\n    // Return a deep copy to prevent mutation\n    return snapshot ? JSON.parse(JSON.stringify(snapshot)) : null;\n  }\n\n  async listWorkflowRuns({\n    workflowName,\n    fromDate,\n    toDate,\n    perPage,\n    page,\n    resourceId,\n    status,\n  }: StorageListWorkflowRunsInput = {}): Promise<WorkflowRuns> {\n    if (page !== undefined && page < 0) {\n      throw new Error('page must be >= 0');\n    }\n\n    let runs = Array.from(this.db.workflows.values());\n\n    if (workflowName) runs = runs.filter((run: any) => run.workflow_name === workflowName);\n    if (status) {\n      runs = runs.filter((run: any) => {\n        let snapshot: WorkflowRunState | string = run?.snapshot!;\n\n        if (!snapshot) {\n          return false;\n        }\n\n        if (typeof snapshot === 'string') {\n          try {\n            snapshot = JSON.parse(snapshot) as WorkflowRunState;\n          } catch {\n            return false;\n          }\n        } else {\n          snapshot = JSON.parse(JSON.stringify(snapshot)) as WorkflowRunState;\n        }\n\n        return snapshot.status === status;\n      });\n    }\n\n    if (fromDate && toDate) {\n      runs = runs.filter(\n        (run: any) =>\n          new Date(run.createdAt).getTime() >= fromDate.getTime() &&\n          new Date(run.createdAt).getTime() <= toDate.getTime(),\n      );\n    } else if (fromDate) {\n      runs = runs.filter((run: any) => new Date(run.createdAt).getTime() >= fromDate.getTime());\n    } else if (toDate) {\n      runs = runs.filter((run: any) => new Date(run.createdAt).getTime() <= toDate.getTime());\n    }\n    if (resourceId) runs = runs.filter((run: any) => run.resourceId === resourceId);\n\n    const total = runs.length;\n\n    // Sort by createdAt\n    runs.sort((a: any, b: any) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime());\n\n    // Apply pagination\n    if (perPage !== undefined && page !== undefined) {\n      // Use MAX_SAFE_INTEGER as default to maintain \"no pagination\" behavior when undefined\n      const normalizedPerPage = normalizePerPage(perPage, Number.MAX_SAFE_INTEGER);\n      const offset = page * normalizedPerPage;\n      const start = offset;\n      const end = start + normalizedPerPage;\n      runs = runs.slice(start, end);\n    }\n\n    // Deserialize snapshot if it's a string\n    const parsedRuns = runs.map((run: any) => ({\n      ...run,\n      snapshot: typeof run.snapshot === 'string' ? JSON.parse(run.snapshot) : JSON.parse(JSON.stringify(run.snapshot)),\n      createdAt: new Date(run.createdAt),\n      updatedAt: new Date(run.updatedAt),\n      runId: run.run_id,\n      workflowName: run.workflow_name,\n      resourceId: run.resourceId,\n    }));\n\n    return { runs: parsedRuns as WorkflowRun[], total };\n  }\n\n  async getWorkflowRunById({\n    runId,\n    workflowName,\n  }: {\n    runId: string;\n    workflowName?: string;\n  }): Promise<WorkflowRun | null> {\n    const runs = Array.from(this.db.workflows.values()).filter((r: any) => r.run_id === runId);\n    let run = runs.find((r: any) => r.workflow_name === workflowName);\n\n    if (!run) return null;\n\n    // Return a deep copy to prevent mutation\n    const parsedRun = {\n      ...run,\n      snapshot: typeof run.snapshot === 'string' ? JSON.parse(run.snapshot) : JSON.parse(JSON.stringify(run.snapshot)),\n      createdAt: new Date(run.createdAt),\n      updatedAt: new Date(run.updatedAt),\n      runId: run.run_id,\n      workflowName: run.workflow_name,\n      resourceId: run.resourceId,\n    };\n\n    return parsedRun as WorkflowRun;\n  }\n\n  async deleteWorkflowRunById({ runId, workflowName }: { runId: string; workflowName: string }): Promise<void> {\n    const key = this.getWorkflowKey(workflowName, runId);\n    this.db.workflows.delete(key);\n  }\n}\n","import { MastraCompositeStore } from './base';\nimport type { StorageDomains } from './base';\nimport { InMemoryAgentsStorage } from './domains/agents/inmemory';\nimport { InMemoryDB } from './domains/inmemory-db';\nimport { InMemoryMCPClientsStorage } from './domains/mcp-clients/inmemory';\nimport { InMemoryMemory } from './domains/memory/inmemory';\nimport { ObservabilityInMemory } from './domains/observability/inmemory';\nimport { InMemoryPromptBlocksStorage } from './domains/prompt-blocks/inmemory';\nimport { InMemoryScorerDefinitionsStorage } from './domains/scorer-definitions/inmemory';\nimport { ScoresInMemory } from './domains/scores/inmemory';\nimport { WorkflowsInMemory } from './domains/workflows/inmemory';\n/**\n * In-memory storage implementation for testing and development.\n *\n * All data is stored in memory and will be lost when the process ends.\n * Access domain-specific storage via `getStore()`:\n *\n * @example\n * ```typescript\n * const storage = new InMemoryStore();\n *\n * // Access memory domain\n * const memory = await storage.getStore('memory');\n * await memory?.saveThread({ thread });\n *\n * // Access workflows domain\n * const workflows = await storage.getStore('workflows');\n * await workflows?.persistWorkflowSnapshot({ workflowName, runId, snapshot });\n * ```\n */\nexport class InMemoryStore extends MastraCompositeStore {\n  stores: StorageDomains;\n\n  /**\n   * Internal database layer shared across all domains.\n   * This is an implementation detail - domains interact with this\n   * rather than managing their own data structures.\n   */\n  #db: InMemoryDB;\n\n  constructor({ id = 'in-memory' }: { id?: string } = {}) {\n    super({ id, name: 'InMemoryStorage' });\n    // InMemoryStore doesn't need async initialization\n    this.hasInitialized = Promise.resolve(true);\n\n    // Create internal db layer - shared across all domains\n    this.#db = new InMemoryDB();\n\n    // Create all domain instances with the shared db\n    this.stores = {\n      memory: new InMemoryMemory({ db: this.#db }),\n      workflows: new WorkflowsInMemory({ db: this.#db }),\n      scores: new ScoresInMemory({ db: this.#db }),\n      observability: new ObservabilityInMemory({ db: this.#db }),\n      agents: new InMemoryAgentsStorage({ db: this.#db }),\n      promptBlocks: new InMemoryPromptBlocksStorage({ db: this.#db }),\n      scorerDefinitions: new InMemoryScorerDefinitionsStorage({ db: this.#db }),\n      mcpClients: new InMemoryMCPClientsStorage({ db: this.#db }),\n    };\n  }\n\n  /**\n   * Clears all data from the in-memory database.\n   * Useful for testing.\n   * @deprecated Use dangerouslyClearAll() on individual domains instead.\n   */\n  clear(): void {\n    this.#db.clear();\n  }\n}\n\nexport const MockStore = InMemoryStore;\n","import { MastraBase } from '../../../base';\nimport { ErrorCategory, ErrorDomain, MastraError } from '../../../error';\nimport type { TABLE_NAMES } from '../../constants';\nimport type { StorageColumn, CreateIndexOptions, IndexInfo, StorageIndexStats } from '../../types';\n\nexport abstract class StoreOperations extends MastraBase {\n  constructor() {\n    super({\n      component: 'STORAGE',\n      name: 'OPERATIONS',\n    });\n  }\n\n  abstract hasColumn(table: string, column: string): Promise<boolean>;\n\n  protected getSqlType(type: StorageColumn['type']): string {\n    switch (type) {\n      case 'text':\n        return 'TEXT';\n      case 'timestamp':\n        return 'TIMESTAMP';\n      case 'float':\n        return 'FLOAT';\n      case 'integer':\n        return 'INTEGER';\n      case 'bigint':\n        return 'BIGINT';\n      case 'jsonb':\n        return 'JSONB';\n      default:\n        return 'TEXT';\n    }\n  }\n\n  protected getDefaultValue(type: StorageColumn['type']): string {\n    switch (type) {\n      case 'text':\n      case 'uuid':\n        return \"DEFAULT ''\";\n      case 'timestamp':\n        return \"DEFAULT '1970-01-01 00:00:00'\";\n      case 'integer':\n      case 'bigint':\n      case 'float':\n        return 'DEFAULT 0';\n      case 'jsonb':\n        return \"DEFAULT '{}'\";\n      default:\n        return \"DEFAULT ''\";\n    }\n  }\n\n  abstract createTable({ tableName }: { tableName: TABLE_NAMES; schema: Record<string, StorageColumn> }): Promise<void>;\n\n  abstract clearTable({ tableName }: { tableName: TABLE_NAMES }): Promise<void>;\n\n  abstract dropTable({ tableName }: { tableName: TABLE_NAMES }): Promise<void>;\n\n  abstract alterTable(args: {\n    tableName: TABLE_NAMES;\n    schema: Record<string, StorageColumn>;\n    ifNotExists: string[];\n  }): Promise<void>;\n\n  abstract insert({ tableName, record }: { tableName: TABLE_NAMES; record: Record<string, any> }): Promise<void>;\n\n  abstract batchInsert({\n    tableName,\n    records,\n  }: {\n    tableName: TABLE_NAMES;\n    records: Record<string, any>[];\n  }): Promise<void>;\n\n  abstract load<R>({ tableName, keys }: { tableName: TABLE_NAMES; keys: Record<string, any> }): Promise<R | null>;\n\n  /**\n   * DATABASE INDEX MANAGEMENT\n   * Optional methods for database index management.\n   * Storage adapters can override these to provide index management capabilities.\n   */\n\n  /**\n   * Creates a database index on specified columns\n   * @throws {MastraError} if not supported by the storage adapter\n   */\n  async createIndex(_options: CreateIndexOptions): Promise<void> {\n    throw new MastraError({\n      id: 'MASTRA_STORAGE_CREATE_INDEX_NOT_SUPPORTED',\n      domain: ErrorDomain.STORAGE,\n      category: ErrorCategory.SYSTEM,\n      text: `Index management is not supported by this storage adapter`,\n    });\n  }\n\n  /**\n   * Drops a database index by name\n   * @throws {MastraError} if not supported by the storage adapter\n   */\n  async dropIndex(_indexName: string): Promise<void> {\n    throw new MastraError({\n      id: 'MASTRA_STORAGE_DROP_INDEX_NOT_SUPPORTED',\n      domain: ErrorDomain.STORAGE,\n      category: ErrorCategory.SYSTEM,\n      text: `Index management is not supported by this storage adapter`,\n    });\n  }\n\n  /**\n   * Lists database indexes for a table or all tables\n   * @throws {MastraError} if not supported by the storage adapter\n   */\n  async listIndexes(_tableName?: string): Promise<IndexInfo[]> {\n    throw new MastraError({\n      id: 'MASTRA_STORAGE_LIST_INDEXES_NOT_SUPPORTED',\n      domain: ErrorDomain.STORAGE,\n      category: ErrorCategory.SYSTEM,\n      text: `Index management is not supported by this storage adapter`,\n    });\n  }\n\n  /**\n   * Gets detailed statistics for a specific index\n   * @throws {MastraError} if not supported by the storage adapter\n   */\n  async describeIndex(_indexName: string): Promise<StorageIndexStats> {\n    throw new MastraError({\n      id: 'MASTRA_STORAGE_DESCRIBE_INDEX_NOT_SUPPORTED',\n      domain: ErrorDomain.STORAGE,\n      category: ErrorCategory.SYSTEM,\n      text: `Index management is not supported by this storage adapter`,\n    });\n  }\n\n  /**\n   * Returns definitions for automatic performance indexes\n   * Storage adapters can override this to define indexes that should be created during initialization\n   * @returns Array of index definitions to create automatically\n   */\n  protected getAutomaticIndexDefinitions(): CreateIndexOptions[] {\n    return [];\n  }\n}\n","import { TABLE_WORKFLOW_SNAPSHOT } from '../../constants';\nimport type { TABLE_NAMES, TABLE_OBSERVATIONAL_MEMORY } from '../../constants';\nimport type { StorageColumn } from '../../types';\nimport { StoreOperations } from './base';\n\n// InMemory storage supports all tables including observational memory\ntype InMemoryTableNames = TABLE_NAMES | typeof TABLE_OBSERVATIONAL_MEMORY;\n\nexport class StoreOperationsInMemory extends StoreOperations {\n  data: Record<InMemoryTableNames, Map<string, Record<string, any>>>;\n\n  constructor() {\n    super();\n    this.data = {\n      mastra_workflow_snapshot: new Map(),\n      mastra_messages: new Map(),\n      mastra_threads: new Map(),\n      mastra_traces: new Map(),\n      mastra_resources: new Map(),\n      mastra_scorers: new Map(),\n      mastra_ai_spans: new Map(),\n      mastra_agents: new Map(),\n      mastra_agent_versions: new Map(),\n      mastra_observational_memory: new Map(),\n      mastra_prompt_blocks: new Map(),\n      mastra_prompt_block_versions: new Map(),\n      mastra_scorer_definitions: new Map(),\n      mastra_scorer_definition_versions: new Map(),\n      mastra_mcp_clients: new Map(),\n      mastra_mcp_client_versions: new Map(),\n      mastra_datasets: new Map(),\n      mastra_dataset_items: new Map(),\n      mastra_dataset_versions: new Map(),\n      mastra_experiments: new Map(),\n      mastra_experiment_results: new Map(),\n    };\n  }\n\n  getDatabase() {\n    return this.data;\n  }\n\n  async insert({ tableName, record }: { tableName: TABLE_NAMES; record: Record<string, any> }): Promise<void> {\n    const table = this.data[tableName];\n    let key = record.id;\n    if ([TABLE_WORKFLOW_SNAPSHOT].includes(tableName) && !record.id && record.run_id) {\n      key = record.workflow_name ? `${record.workflow_name}-${record.run_id}` : record.run_id;\n      record.id = key;\n    } else if (!record.id) {\n      key = `auto-${Date.now()}-${Math.random()}`;\n      record.id = key;\n    }\n    table.set(key, record);\n  }\n\n  async batchInsert({ tableName, records }: { tableName: TABLE_NAMES; records: Record<string, any>[] }): Promise<void> {\n    const table = this.data[tableName];\n    for (const record of records) {\n      let key = record.id;\n      if ([TABLE_WORKFLOW_SNAPSHOT].includes(tableName) && !record.id && record.run_id) {\n        key = record.run_id;\n        record.id = key;\n      } else if (!record.id) {\n        key = `auto-${Date.now()}-${Math.random()}`;\n        record.id = key;\n      }\n      table.set(key, record);\n    }\n  }\n\n  async load<R>({ tableName, keys }: { tableName: TABLE_NAMES; keys: Record<string, string> }): Promise<R | null> {\n    this.logger.debug(`MockStore: load called for ${tableName} with keys`, keys);\n\n    const table = this.data[tableName];\n\n    const records = Array.from(table.values());\n\n    return records.filter(record => Object.keys(keys).every(key => record[key] === keys[key]))?.[0] as R | null;\n  }\n\n  async createTable({\n    tableName,\n    schema,\n  }: {\n    tableName: TABLE_NAMES;\n    schema: Record<string, StorageColumn>;\n  }): Promise<void> {\n    this.logger.debug(`MockStore: createTable called for ${tableName} with schema`, schema);\n\n    this.data[tableName] = new Map();\n  }\n\n  async clearTable({ tableName }: { tableName: TABLE_NAMES }): Promise<void> {\n    this.logger.debug(`MockStore: clearTable called for ${tableName}`);\n\n    this.data[tableName].clear();\n  }\n\n  async dropTable({ tableName }: { tableName: TABLE_NAMES }): Promise<void> {\n    this.logger.debug(`MockStore: dropTable called for ${tableName}`);\n    this.data[tableName].clear();\n  }\n\n  async alterTable({\n    tableName,\n    schema,\n  }: {\n    tableName: TABLE_NAMES;\n    schema: Record<string, StorageColumn>;\n    ifNotExists: string[];\n  }): Promise<void> {\n    this.logger.debug(`MockStore: alterTable called for ${tableName} with schema`, schema);\n  }\n\n  async hasColumn(table: string, column: string): Promise<boolean> {\n    this.logger.debug(`MockStore: hasColumn called for ${table} with column ${column}`);\n    return true;\n  }\n}\n","/** Field-level validation error */\nexport interface FieldError {\n  /** JSON Pointer path, e.g., \"/name\" or \"/address/city\" */\n  path: string;\n  /** Zod error code, e.g., \"invalid_type\", \"too_small\" */\n  code: string;\n  /** Human-readable error message */\n  message: string;\n}\n\n/** Schema validation error with field details */\nexport class SchemaValidationError extends Error {\n  constructor(\n    public readonly field: 'input' | 'groundTruth',\n    public readonly errors: FieldError[],\n  ) {\n    const summary = errors\n      .slice(0, 3)\n      .map(e => e.message)\n      .join('; ');\n    super(`Validation failed for ${field}: ${summary}`);\n    this.name = 'SchemaValidationError';\n  }\n}\n\n/** Batch validation result for multiple items */\nexport interface BatchValidationResult {\n  valid: Array<{ index: number; data: unknown }>;\n  invalid: Array<{\n    index: number;\n    data: unknown;\n    field: 'input' | 'groundTruth';\n    errors: FieldError[];\n  }>;\n}\n\n/** Error thrown when schema update would invalidate existing items */\nexport class SchemaUpdateValidationError extends Error {\n  constructor(\n    public readonly failingItems: Array<{\n      index: number;\n      data: unknown;\n      field: 'input' | 'groundTruth';\n      errors: FieldError[];\n    }>,\n  ) {\n    const count = failingItems.length;\n    super(`Cannot update schema: ${count} existing item(s) would fail validation`);\n    this.name = 'SchemaUpdateValidationError';\n  }\n}\n","import { jsonSchemaToZod } from '@mastra/schema-compat/json-to-zod';\nimport type { JSONSchema7 } from 'json-schema';\nimport { z } from 'zod';\nimport type { ZodSchema, ZodError, ZodIssue } from 'zod';\nimport { SchemaValidationError } from './errors';\nimport type { FieldError, BatchValidationResult } from './errors';\n\n/**\n * Convert JSON Schema string to runtime Zod schema.\n * Uses Function() to evaluate the generated Zod code - same pattern as workflow validation.\n */\nfunction resolveZodSchema(zodString: string): ZodSchema {\n  return Function('z', `\"use strict\";return (${zodString});`)(z);\n}\n\n/** Schema validator with compilation caching */\nexport class SchemaValidator {\n  private cache = new Map<string, ZodSchema>();\n\n  /** Get or compile validator for schema */\n  private getValidator(schema: JSONSchema7, cacheKey: string): ZodSchema {\n    let zodSchema = this.cache.get(cacheKey);\n    if (!zodSchema) {\n      const zodString = jsonSchemaToZod(schema);\n      zodSchema = resolveZodSchema(zodString);\n      this.cache.set(cacheKey, zodSchema);\n    }\n    return zodSchema;\n  }\n\n  /** Clear cached validator (call when schema changes) */\n  clearCache(cacheKey: string): void {\n    this.cache.delete(cacheKey);\n  }\n\n  /** Validate data against schema */\n  validate(data: unknown, schema: JSONSchema7, field: 'input' | 'groundTruth', cacheKey: string): void {\n    const zodSchema = this.getValidator(schema, cacheKey);\n    const result = zodSchema.safeParse(data);\n    if (!result.success) {\n      throw new SchemaValidationError(field, this.formatErrors(result.error));\n    }\n  }\n\n  /** Validate multiple items, returning valid/invalid split */\n  validateBatch(\n    items: Array<{ input: unknown; groundTruth?: unknown }>,\n    inputSchema: JSONSchema7 | null | undefined,\n    outputSchema: JSONSchema7 | null | undefined,\n    cacheKeyPrefix: string,\n    maxErrors = 10,\n  ): BatchValidationResult {\n    const result: BatchValidationResult = { valid: [], invalid: [] };\n\n    // Pre-compile schemas for performance\n    const inputValidator = inputSchema ? this.getValidator(inputSchema, `${cacheKeyPrefix}:input`) : null;\n    const outputValidator = outputSchema ? this.getValidator(outputSchema, `${cacheKeyPrefix}:output`) : null;\n\n    for (const [i, item] of items.entries()) {\n      let hasError = false;\n\n      // Validate input if schema enabled\n      if (inputValidator) {\n        const inputResult = inputValidator.safeParse(item.input);\n        if (!inputResult.success) {\n          result.invalid.push({\n            index: i,\n            data: item,\n            field: 'input',\n            errors: this.formatErrors(inputResult.error),\n          });\n          hasError = true;\n          if (result.invalid.length >= maxErrors) break;\n        }\n      }\n\n      // Validate groundTruth if schema enabled and value provided\n      if (!hasError && outputValidator && item.groundTruth !== undefined) {\n        const outputResult = outputValidator.safeParse(item.groundTruth);\n        if (!outputResult.success) {\n          result.invalid.push({\n            index: i,\n            data: item,\n            field: 'groundTruth',\n            errors: this.formatErrors(outputResult.error),\n          });\n          hasError = true;\n          if (result.invalid.length >= maxErrors) break;\n        }\n      }\n\n      if (!hasError) {\n        result.valid.push({ index: i, data: item });\n      }\n    }\n\n    return result;\n  }\n\n  /** Format Zod errors to FieldError array */\n  private formatErrors(error: ZodError): FieldError[] {\n    return error.issues.slice(0, 5).map((issue: ZodIssue) => ({\n      // Convert Zod path array to JSON Pointer string\n      path: issue.path.length > 0 ? '/' + issue.path.join('/') : '/',\n      code: issue.code,\n      message: issue.message,\n    }));\n  }\n}\n\n/** Singleton validator instance */\nlet validatorInstance: SchemaValidator | null = null;\n\n/** Get or create validator instance */\nexport function getSchemaValidator(): SchemaValidator {\n  if (!validatorInstance) {\n    validatorInstance = new SchemaValidator();\n  }\n  return validatorInstance;\n}\n\n/** Create new validator (for testing) */\nexport function createValidator(): SchemaValidator {\n  return new SchemaValidator();\n}\n","import { getSchemaValidator, SchemaUpdateValidationError } from '../../../datasets/validation';\nimport type {\n  DatasetRecord,\n  DatasetItem,\n  DatasetItemRow,\n  DatasetVersion,\n  CreateDatasetInput,\n  UpdateDatasetInput,\n  AddDatasetItemInput,\n  UpdateDatasetItemInput,\n  ListDatasetsInput,\n  ListDatasetsOutput,\n  ListDatasetItemsInput,\n  ListDatasetItemsOutput,\n  ListDatasetVersionsInput,\n  ListDatasetVersionsOutput,\n  BatchInsertItemsInput,\n  BatchDeleteItemsInput,\n} from '../../types';\nimport { StorageDomain } from '../base';\n\n/**\n * Abstract base class for datasets storage domain.\n * Provides the contract for dataset and dataset item CRUD operations.\n *\n * Schema validation is handled in this base class via Template Method pattern.\n * Subclasses implement protected _do* methods for actual storage operations,\n * including SCD-2 versioning (version bump, row ops, dataset_version insert).\n */\nexport abstract class DatasetsStorage extends StorageDomain {\n  constructor() {\n    super({\n      component: 'STORAGE',\n      name: 'DATASETS',\n    });\n  }\n\n  async dangerouslyClearAll(): Promise<void> {\n    // Default no-op - subclasses override\n  }\n\n  // Dataset CRUD\n  abstract createDataset(input: CreateDatasetInput): Promise<DatasetRecord>;\n  abstract getDatasetById(args: { id: string }): Promise<DatasetRecord | null>;\n  abstract deleteDataset(args: { id: string }): Promise<void>;\n  abstract listDatasets(args: ListDatasetsInput): Promise<ListDatasetsOutput>;\n\n  /**\n   * Update a dataset. Validates existing items against new schemas if schemas are changing.\n   * Subclasses implement _doUpdateDataset for actual storage operation.\n   */\n  async updateDataset(args: UpdateDatasetInput): Promise<DatasetRecord> {\n    const existing = await this.getDatasetById({ id: args.id });\n    if (!existing) {\n      throw new Error(`Dataset not found: ${args.id}`);\n    }\n\n    // Check if schemas are being added or modified\n    const inputSchemaChanging =\n      args.inputSchema !== undefined && JSON.stringify(args.inputSchema) !== JSON.stringify(existing.inputSchema);\n    const groundTruthSchemaChanging =\n      args.groundTruthSchema !== undefined &&\n      JSON.stringify(args.groundTruthSchema) !== JSON.stringify(existing.groundTruthSchema);\n\n    // If schemas changing, validate all existing items against new schemas\n    if (inputSchemaChanging || groundTruthSchemaChanging) {\n      const itemsResult = await this.listItems({\n        datasetId: args.id,\n        pagination: { page: 0, perPage: false }, // Get all items\n      });\n      const items = itemsResult.items;\n\n      if (items.length > 0) {\n        const validator = getSchemaValidator();\n        const newInputSchema = args.inputSchema !== undefined ? args.inputSchema : existing.inputSchema;\n        const newOutputSchema =\n          args.groundTruthSchema !== undefined ? args.groundTruthSchema : existing.groundTruthSchema;\n\n        const result = validator.validateBatch(\n          items.map(i => ({ input: i.input, groundTruth: i.groundTruth })),\n          newInputSchema,\n          newOutputSchema,\n          `dataset:${args.id}:schema-update`,\n          10, // Max 10 errors to report\n        );\n\n        if (result.invalid.length > 0) {\n          throw new SchemaUpdateValidationError(result.invalid);\n        }\n\n        // Clear old cache since schema changed\n        validator.clearCache(`dataset:${args.id}:input`);\n        validator.clearCache(`dataset:${args.id}:output`);\n      }\n    }\n\n    return this._doUpdateDataset(args);\n  }\n\n  /** Subclasses implement actual storage update logic */\n  protected abstract _doUpdateDataset(args: UpdateDatasetInput): Promise<DatasetRecord>;\n\n  /**\n   * Add an item to a dataset. Validates input/groundTruth against dataset schemas.\n   * Subclasses implement _doAddItem which handles SCD-2 versioning internally.\n   */\n  async addItem(args: AddDatasetItemInput): Promise<DatasetItem> {\n    const dataset = await this.getDatasetById({ id: args.datasetId });\n    if (!dataset) {\n      throw new Error(`Dataset not found: ${args.datasetId}`);\n    }\n\n    // Validate against schemas if enabled\n    const validator = getSchemaValidator();\n    const cacheKey = `dataset:${args.datasetId}`;\n\n    if (dataset.inputSchema) {\n      validator.validate(args.input, dataset.inputSchema, 'input', `${cacheKey}:input`);\n    }\n\n    if (dataset.groundTruthSchema && args.groundTruth !== undefined) {\n      validator.validate(args.groundTruth, dataset.groundTruthSchema, 'groundTruth', `${cacheKey}:output`);\n    }\n\n    return this._doAddItem(args);\n  }\n\n  /** Subclasses implement actual storage add logic with SCD-2 versioning */\n  protected abstract _doAddItem(args: AddDatasetItemInput): Promise<DatasetItem>;\n\n  /**\n   * Update an item in a dataset. Validates changed fields against dataset schemas.\n   * Subclasses implement _doUpdateItem which handles SCD-2 versioning internally.\n   */\n  async updateItem(args: UpdateDatasetItemInput): Promise<DatasetItem> {\n    const dataset = await this.getDatasetById({ id: args.datasetId });\n    if (!dataset) {\n      throw new Error(`Dataset not found: ${args.datasetId}`);\n    }\n\n    // Validate new values against schemas if enabled\n    const validator = getSchemaValidator();\n    const cacheKey = `dataset:${args.datasetId}`;\n\n    if (args.input !== undefined && dataset.inputSchema) {\n      validator.validate(args.input, dataset.inputSchema, 'input', `${cacheKey}:input`);\n    }\n\n    if (args.groundTruth !== undefined && dataset.groundTruthSchema) {\n      validator.validate(args.groundTruth, dataset.groundTruthSchema, 'groundTruth', `${cacheKey}:output`);\n    }\n\n    return this._doUpdateItem(args);\n  }\n\n  /** Subclasses implement actual storage update logic with SCD-2 versioning */\n  protected abstract _doUpdateItem(args: UpdateDatasetItemInput): Promise<DatasetItem>;\n\n  /**\n   * Delete an item from a dataset. Creates a tombstone row via SCD-2.\n   * Subclasses implement _doDeleteItem which handles SCD-2 versioning internally.\n   */\n  async deleteItem(args: { id: string; datasetId: string }): Promise<void> {\n    return this._doDeleteItem(args);\n  }\n\n  /** Subclasses implement actual storage delete logic with SCD-2 versioning */\n  protected abstract _doDeleteItem(args: { id: string; datasetId: string }): Promise<void>;\n\n  abstract listItems(args: ListDatasetItemsInput): Promise<ListDatasetItemsOutput>;\n  abstract getItemById(args: { id: string; datasetVersion?: number }): Promise<DatasetItem | null>;\n\n  // SCD-2 queries\n  abstract getItemsByVersion(args: { datasetId: string; version: number }): Promise<DatasetItem[]>;\n  abstract getItemHistory(itemId: string): Promise<DatasetItemRow[]>;\n\n  // Dataset version methods\n  abstract createDatasetVersion(datasetId: string, version: number): Promise<DatasetVersion>;\n  abstract listDatasetVersions(input: ListDatasetVersionsInput): Promise<ListDatasetVersionsOutput>;\n\n  /**\n   * Batch insert items to a dataset. Validates all items against dataset schemas,\n   * then delegates to subclass which handles SCD-2 versioning internally.\n   */\n  async batchInsertItems(input: BatchInsertItemsInput): Promise<DatasetItem[]> {\n    const dataset = await this.getDatasetById({ id: input.datasetId });\n    if (!dataset) {\n      throw new Error(`Dataset not found: ${input.datasetId}`);\n    }\n\n    // Validate all items against schemas\n    const validator = getSchemaValidator();\n    const cacheKey = `dataset:${input.datasetId}`;\n\n    for (const itemData of input.items) {\n      if (dataset.inputSchema) {\n        validator.validate(itemData.input, dataset.inputSchema, 'input', `${cacheKey}:input`);\n      }\n      if (dataset.groundTruthSchema && itemData.groundTruth !== undefined) {\n        validator.validate(itemData.groundTruth, dataset.groundTruthSchema, 'groundTruth', `${cacheKey}:output`);\n      }\n    }\n\n    return this._doBatchInsertItems(input);\n  }\n\n  /** Subclasses implement batch insert with SCD-2 versioning */\n  protected abstract _doBatchInsertItems(input: BatchInsertItemsInput): Promise<DatasetItem[]>;\n\n  /**\n   * Batch delete items from a dataset. Creates tombstone rows via SCD-2.\n   * Subclasses implement _doBatchDeleteItems which handles SCD-2 versioning internally.\n   */\n  async batchDeleteItems(input: BatchDeleteItemsInput): Promise<void> {\n    const dataset = await this.getDatasetById({ id: input.datasetId });\n    if (!dataset) {\n      throw new Error(`Dataset not found: ${input.datasetId}`);\n    }\n\n    return this._doBatchDeleteItems(input);\n  }\n\n  /** Subclasses implement batch delete with SCD-2 versioning */\n  protected abstract _doBatchDeleteItems(input: BatchDeleteItemsInput): Promise<void>;\n}\n","import { calculatePagination, normalizePerPage } from '../../base';\nimport type {\n  DatasetRecord,\n  DatasetItem,\n  DatasetItemRow,\n  DatasetVersion,\n  CreateDatasetInput,\n  UpdateDatasetInput,\n  AddDatasetItemInput,\n  UpdateDatasetItemInput,\n  ListDatasetsInput,\n  ListDatasetsOutput,\n  ListDatasetItemsInput,\n  ListDatasetItemsOutput,\n  ListDatasetVersionsInput,\n  ListDatasetVersionsOutput,\n  BatchInsertItemsInput,\n  BatchDeleteItemsInput,\n} from '../../types';\nimport type { InMemoryDB } from '../inmemory-db';\nimport { DatasetsStorage } from './base';\n\n/** Convert a storage row to the public DatasetItem type (strips validTo/isDeleted) */\nfunction toDatasetItem(row: DatasetItemRow): DatasetItem {\n  return {\n    id: row.id,\n    datasetId: row.datasetId,\n    datasetVersion: row.datasetVersion,\n    input: row.input,\n    groundTruth: row.groundTruth,\n    metadata: row.metadata,\n    createdAt: row.createdAt,\n    updatedAt: row.updatedAt,\n  };\n}\n\nexport class DatasetsInMemory extends DatasetsStorage {\n  private db: InMemoryDB;\n\n  constructor({ db }: { db: InMemoryDB }) {\n    super();\n    this.db = db;\n  }\n\n  async dangerouslyClearAll(): Promise<void> {\n    this.db.datasets.clear();\n    this.db.datasetItems.clear();\n    this.db.datasetVersions.clear();\n  }\n\n  // Dataset CRUD\n  async createDataset(input: CreateDatasetInput): Promise<DatasetRecord> {\n    const id = crypto.randomUUID();\n    const now = new Date();\n    const dataset: DatasetRecord = {\n      id,\n      name: input.name,\n      description: input.description,\n      metadata: input.metadata,\n      inputSchema: input.inputSchema,\n      groundTruthSchema: input.groundTruthSchema,\n      version: 0,\n      createdAt: now,\n      updatedAt: now,\n    };\n    this.db.datasets.set(id, dataset);\n    return dataset;\n  }\n\n  async getDatasetById({ id }: { id: string }): Promise<DatasetRecord | null> {\n    return this.db.datasets.get(id) ?? null;\n  }\n\n  protected async _doUpdateDataset(args: UpdateDatasetInput): Promise<DatasetRecord> {\n    const existing = this.db.datasets.get(args.id);\n    if (!existing) {\n      throw new Error(`Dataset not found: ${args.id}`);\n    }\n\n    const updated: DatasetRecord = {\n      ...existing,\n      name: args.name ?? existing.name,\n      description: args.description ?? existing.description,\n      metadata: args.metadata ?? existing.metadata,\n      inputSchema: args.inputSchema !== undefined ? args.inputSchema : existing.inputSchema,\n      groundTruthSchema: args.groundTruthSchema !== undefined ? args.groundTruthSchema : existing.groundTruthSchema,\n      updatedAt: new Date(),\n    };\n    this.db.datasets.set(args.id, updated);\n    return updated;\n  }\n\n  async deleteDataset({ id }: { id: string }): Promise<void> {\n    // Cascade: delete items and versions\n    for (const [itemId, rows] of this.db.datasetItems) {\n      if (rows.length > 0 && rows[0]!.datasetId === id) {\n        this.db.datasetItems.delete(itemId);\n      }\n    }\n    for (const [vId, v] of this.db.datasetVersions) {\n      if (v.datasetId === id) {\n        this.db.datasetVersions.delete(vId);\n      }\n    }\n\n    // F3 fix: detach experiments (SET NULL) instead of deleting them\n    for (const [expId, exp] of this.db.experiments) {\n      if (exp.datasetId === id) {\n        this.db.experiments.set(expId, { ...exp, datasetId: null, datasetVersion: null });\n      }\n    }\n\n    this.db.datasets.delete(id);\n  }\n\n  async listDatasets(args: ListDatasetsInput): Promise<ListDatasetsOutput> {\n    const datasets = Array.from(this.db.datasets.values());\n    // Sort by createdAt descending (newest first)\n    datasets.sort((a, b) => b.createdAt.getTime() - a.createdAt.getTime());\n\n    const { page, perPage: perPageInput } = args.pagination;\n    const perPage = normalizePerPage(perPageInput, 100);\n    const { offset: start, perPage: perPageForResponse } = calculatePagination(page, perPageInput, perPage);\n    const end = perPageInput === false ? datasets.length : start + perPage;\n\n    return {\n      datasets: datasets.slice(start, end),\n      pagination: {\n        total: datasets.length,\n        page,\n        perPage: perPageForResponse,\n        hasMore: perPageInput === false ? false : datasets.length > end,\n      },\n    };\n  }\n\n  // --- SCD-2 item mutations ---\n\n  protected async _doAddItem(args: AddDatasetItemInput): Promise<DatasetItem> {\n    const dataset = this.db.datasets.get(args.datasetId);\n    if (!dataset) {\n      throw new Error(`Dataset not found: ${args.datasetId}`);\n    }\n\n    // Bump version (T3.7, T3.26  only bumps version, not updatedAt)\n    const newVersion = dataset.version + 1;\n    this.db.datasets.set(args.datasetId, { ...dataset, version: newVersion });\n\n    const now = new Date();\n    const id = crypto.randomUUID();\n    const row: DatasetItemRow = {\n      id,\n      datasetId: args.datasetId,\n      datasetVersion: newVersion,\n      validTo: null,\n      isDeleted: false,\n      input: args.input,\n      groundTruth: args.groundTruth,\n      metadata: args.metadata,\n      createdAt: now,\n      updatedAt: now,\n    };\n\n    this.db.datasetItems.set(id, [row]);\n\n    // T3.11  every mutation inserts exactly one dataset_version row\n    await this.createDatasetVersion(args.datasetId, newVersion);\n\n    return toDatasetItem(row);\n  }\n\n  protected async _doUpdateItem(args: UpdateDatasetItemInput): Promise<DatasetItem> {\n    const rows = this.db.datasetItems.get(args.id);\n    if (!rows || rows.length === 0) {\n      throw new Error(`Item not found: ${args.id}`);\n    }\n\n    const currentRow = rows.find(r => r.validTo === null && !r.isDeleted);\n    if (!currentRow) {\n      throw new Error(`Item not found: ${args.id}`);\n    }\n    if (currentRow.datasetId !== args.datasetId) {\n      throw new Error(`Item ${args.id} does not belong to dataset ${args.datasetId}`);\n    }\n\n    const dataset = this.db.datasets.get(args.datasetId);\n    if (!dataset) {\n      throw new Error(`Dataset not found: ${args.datasetId}`);\n    }\n\n    // Bump version (T3.26)\n    const newVersion = dataset.version + 1;\n    this.db.datasets.set(args.datasetId, { ...dataset, version: newVersion });\n\n    // T3.8  close old row\n    currentRow.validTo = newVersion;\n\n    // T3.8  insert new row with same id\n    const now = new Date();\n    const newRow: DatasetItemRow = {\n      id: args.id,\n      datasetId: args.datasetId,\n      datasetVersion: newVersion,\n      validTo: null,\n      isDeleted: false,\n      input: args.input ?? currentRow.input,\n      groundTruth: args.groundTruth ?? currentRow.groundTruth,\n      metadata: args.metadata ?? currentRow.metadata,\n      createdAt: currentRow.createdAt,\n      updatedAt: now,\n    };\n    rows.push(newRow);\n\n    // T3.11\n    await this.createDatasetVersion(args.datasetId, newVersion);\n\n    return toDatasetItem(newRow);\n  }\n\n  protected async _doDeleteItem({ id, datasetId }: { id: string; datasetId: string }): Promise<void> {\n    const rows = this.db.datasetItems.get(id);\n    if (!rows || rows.length === 0) {\n      return; // no-op if item doesn't exist\n    }\n\n    const currentRow = rows.find(r => r.validTo === null && !r.isDeleted);\n    if (!currentRow) {\n      return; // already deleted\n    }\n    if (currentRow.datasetId !== datasetId) {\n      throw new Error(`Item ${id} does not belong to dataset ${datasetId}`);\n    }\n\n    const dataset = this.db.datasets.get(datasetId);\n    if (!dataset) {\n      throw new Error(`Dataset not found: ${datasetId}`);\n    }\n\n    // Bump version (T3.26)\n    const newVersion = dataset.version + 1;\n    this.db.datasets.set(datasetId, { ...dataset, version: newVersion });\n\n    // T3.9  close old row\n    currentRow.validTo = newVersion;\n\n    // T3.9  insert tombstone\n    const now = new Date();\n    rows.push({\n      id,\n      datasetId,\n      datasetVersion: newVersion,\n      validTo: null,\n      isDeleted: true,\n      input: currentRow.input,\n      groundTruth: currentRow.groundTruth,\n      metadata: currentRow.metadata,\n      createdAt: currentRow.createdAt,\n      updatedAt: now,\n    });\n\n    // T3.11\n    await this.createDatasetVersion(datasetId, newVersion);\n  }\n\n  // --- SCD-2 queries ---\n\n  async getItemById(args: { id: string; datasetVersion?: number }): Promise<DatasetItem | null> {\n    const rows = this.db.datasetItems.get(args.id);\n    if (!rows || rows.length === 0) return null;\n\n    if (args.datasetVersion !== undefined) {\n      // T3.13  exact version match, exclude deleted\n      const row = rows.find(r => r.datasetVersion === args.datasetVersion && !r.isDeleted);\n      return row ? toDatasetItem(row) : null;\n    }\n\n    // T3.12  current row (validTo IS NULL AND isDeleted = false)\n    const current = rows.find(r => r.validTo === null && !r.isDeleted);\n    return current ? toDatasetItem(current) : null;\n  }\n\n  async getItemsByVersion({ datasetId, version }: { datasetId: string; version: number }): Promise<DatasetItem[]> {\n    // T3.14  SCD-2 range query: items visible at version N\n    const items: DatasetItem[] = [];\n\n    for (const rows of this.db.datasetItems.values()) {\n      if (rows.length === 0 || rows[0]!.datasetId !== datasetId) continue;\n\n      // Find the row visible at this version:\n      // datasetVersion <= N AND (validTo IS NULL OR validTo > N) AND isDeleted = false\n      const visible = rows.find(\n        r => r.datasetVersion <= version && (r.validTo === null || r.validTo > version) && !r.isDeleted,\n      );\n      if (visible) {\n        items.push(toDatasetItem(visible));\n      }\n    }\n\n    items.sort((a, b) => b.createdAt.getTime() - a.createdAt.getTime() || b.id.localeCompare(a.id));\n    return items;\n  }\n\n  async getItemHistory(itemId: string): Promise<DatasetItemRow[]> {\n    // ALL rows including tombstones, ordered by datasetVersion DESC (newest first)\n    const rows = this.db.datasetItems.get(itemId);\n    if (!rows) return [];\n    return [...rows].sort((a, b) => b.datasetVersion - a.datasetVersion);\n  }\n\n  async listItems(args: ListDatasetItemsInput): Promise<ListDatasetItemsOutput> {\n    let items: DatasetItem[];\n\n    if (args.version !== undefined) {\n      // SCD-2 time-travel query\n      items = await this.getItemsByVersion({ datasetId: args.datasetId, version: args.version });\n    } else {\n      // T3.16  current items only (validTo IS NULL AND isDeleted = false)\n      items = [];\n      for (const rows of this.db.datasetItems.values()) {\n        if (rows.length === 0 || rows[0]!.datasetId !== args.datasetId) continue;\n        const current = rows.find(r => r.validTo === null && !r.isDeleted);\n        if (current) {\n          items.push(toDatasetItem(current));\n        }\n      }\n    }\n\n    // Filter by search term if specified (case-insensitive partial match on input/groundTruth)\n    if (args.search) {\n      const searchLower = args.search.toLowerCase();\n      items = items.filter(item => {\n        const inputStr = typeof item.input === 'string' ? item.input : JSON.stringify(item.input);\n        const outputStr = item.groundTruth\n          ? typeof item.groundTruth === 'string'\n            ? item.groundTruth\n            : JSON.stringify(item.groundTruth)\n          : '';\n        return inputStr.toLowerCase().includes(searchLower) || outputStr.toLowerCase().includes(searchLower);\n      });\n    }\n\n    // Sort by createdAt descending, then by id descending for stability\n    items.sort((a, b) => b.createdAt.getTime() - a.createdAt.getTime() || b.id.localeCompare(a.id));\n\n    const { page, perPage: perPageInput } = args.pagination;\n    const perPage = normalizePerPage(perPageInput, 100);\n    const { offset: start, perPage: perPageForResponse } = calculatePagination(page, perPageInput, perPage);\n    const end = perPageInput === false ? items.length : start + perPage;\n\n    return {\n      items: items.slice(start, end),\n      pagination: {\n        total: items.length,\n        page,\n        perPage: perPageForResponse,\n        hasMore: perPageInput === false ? false : items.length > end,\n      },\n    };\n  }\n\n  // --- Dataset version methods ---\n\n  async createDatasetVersion(datasetId: string, version: number): Promise<DatasetVersion> {\n    const id = crypto.randomUUID();\n    const dsVersion: DatasetVersion = {\n      id,\n      datasetId,\n      version,\n      createdAt: new Date(),\n    };\n    this.db.datasetVersions.set(id, dsVersion);\n    return dsVersion;\n  }\n\n  async listDatasetVersions(input: ListDatasetVersionsInput): Promise<ListDatasetVersionsOutput> {\n    const versions: DatasetVersion[] = [];\n    for (const v of this.db.datasetVersions.values()) {\n      if (v.datasetId === input.datasetId) {\n        versions.push(v);\n      }\n    }\n    versions.sort((a, b) => b.version - a.version);\n\n    const { page, perPage: perPageInput } = input.pagination;\n    const perPage = normalizePerPage(perPageInput, 100);\n    const { offset: start, perPage: perPageForResponse } = calculatePagination(page, perPageInput, perPage);\n    const end = perPageInput === false ? versions.length : start + perPage;\n\n    return {\n      versions: versions.slice(start, end),\n      pagination: {\n        total: versions.length,\n        page,\n        perPage: perPageForResponse,\n        hasMore: perPageInput === false ? false : versions.length > end,\n      },\n    };\n  }\n\n  // --- Bulk operations (SCD-2 internally) ---\n\n  protected async _doBatchInsertItems(input: BatchInsertItemsInput): Promise<DatasetItem[]> {\n    const dataset = this.db.datasets.get(input.datasetId);\n    if (!dataset) {\n      throw new Error(`Dataset not found: ${input.datasetId}`);\n    }\n\n    // T3.19  single version increment for all items\n    const newVersion = dataset.version + 1;\n    this.db.datasets.set(input.datasetId, { ...dataset, version: newVersion });\n\n    const now = new Date();\n    const items: DatasetItem[] = [];\n\n    for (const itemInput of input.items) {\n      const id = crypto.randomUUID();\n      const row: DatasetItemRow = {\n        id,\n        datasetId: input.datasetId,\n        datasetVersion: newVersion,\n        validTo: null,\n        isDeleted: false,\n        input: itemInput.input,\n        groundTruth: itemInput.groundTruth,\n        metadata: itemInput.metadata,\n        createdAt: now,\n        updatedAt: now,\n      };\n      this.db.datasetItems.set(id, [row]);\n      items.push(toDatasetItem(row));\n    }\n\n    // T3.11  single dataset version for the bulk operation\n    await this.createDatasetVersion(input.datasetId, newVersion);\n\n    return items;\n  }\n\n  protected async _doBatchDeleteItems(input: BatchDeleteItemsInput): Promise<void> {\n    const dataset = this.db.datasets.get(input.datasetId);\n    if (!dataset) {\n      throw new Error(`Dataset not found: ${input.datasetId}`);\n    }\n\n    // T3.20  single version increment\n    const newVersion = dataset.version + 1;\n    this.db.datasets.set(input.datasetId, { ...dataset, version: newVersion });\n\n    const now = new Date();\n\n    for (const itemId of input.itemIds) {\n      const rows = this.db.datasetItems.get(itemId);\n      if (!rows) continue;\n\n      const currentRow = rows.find(r => r.validTo === null && !r.isDeleted);\n      if (!currentRow || currentRow.datasetId !== input.datasetId) continue;\n\n      // Close old row\n      currentRow.validTo = newVersion;\n\n      // Insert tombstone\n      rows.push({\n        id: itemId,\n        datasetId: input.datasetId,\n        datasetVersion: newVersion,\n        validTo: null,\n        isDeleted: true,\n        input: currentRow.input,\n        groundTruth: currentRow.groundTruth,\n        metadata: currentRow.metadata,\n        createdAt: currentRow.createdAt,\n        updatedAt: now,\n      });\n    }\n\n    // T3.11\n    await this.createDatasetVersion(input.datasetId, newVersion);\n  }\n}\n","import type {\n  Experiment,\n  ExperimentResult,\n  CreateExperimentInput,\n  UpdateExperimentInput,\n  AddExperimentResultInput,\n  ListExperimentsInput,\n  ListExperimentsOutput,\n  ListExperimentResultsInput,\n  ListExperimentResultsOutput,\n} from '../../types';\nimport { StorageDomain } from '../base';\n\n/**\n * Abstract base class for dataset experiments storage domain.\n * Provides the contract for experiment lifecycle and result tracking.\n */\nexport abstract class ExperimentsStorage extends StorageDomain {\n  constructor() {\n    super({\n      component: 'STORAGE',\n      name: 'EXPERIMENTS',\n    });\n  }\n\n  async dangerouslyClearAll(): Promise<void> {\n    // Default no-op - subclasses override\n  }\n\n  // Experiment lifecycle\n  abstract createExperiment(input: CreateExperimentInput): Promise<Experiment>;\n  abstract updateExperiment(input: UpdateExperimentInput): Promise<Experiment>;\n  abstract getExperimentById(args: { id: string }): Promise<Experiment | null>;\n  abstract listExperiments(args: ListExperimentsInput): Promise<ListExperimentsOutput>;\n  abstract deleteExperiment(args: { id: string }): Promise<void>;\n\n  // Results (per-item)\n  abstract addExperimentResult(input: AddExperimentResultInput): Promise<ExperimentResult>;\n  abstract getExperimentResultById(args: { id: string }): Promise<ExperimentResult | null>;\n  abstract listExperimentResults(args: ListExperimentResultsInput): Promise<ListExperimentResultsOutput>;\n  abstract deleteExperimentResults(args: { experimentId: string }): Promise<void>;\n}\n","import { calculatePagination, normalizePerPage } from '../../base';\nimport type {\n  Experiment,\n  ExperimentResult,\n  CreateExperimentInput,\n  UpdateExperimentInput,\n  AddExperimentResultInput,\n  ListExperimentsInput,\n  ListExperimentsOutput,\n  ListExperimentResultsInput,\n  ListExperimentResultsOutput,\n} from '../../types';\nimport type { InMemoryDB } from '../inmemory-db';\nimport { ExperimentsStorage } from './base';\n\nexport class ExperimentsInMemory extends ExperimentsStorage {\n  private db: InMemoryDB;\n\n  constructor({ db }: { db: InMemoryDB }) {\n    super();\n    this.db = db;\n  }\n\n  async dangerouslyClearAll(): Promise<void> {\n    this.db.experiments.clear();\n    this.db.experimentResults.clear();\n  }\n\n  // Experiment lifecycle\n  async createExperiment(input: CreateExperimentInput): Promise<Experiment> {\n    const now = new Date();\n    const experiment: Experiment = {\n      id: input.id ?? crypto.randomUUID(),\n      datasetId: input.datasetId,\n      datasetVersion: input.datasetVersion,\n      targetType: input.targetType,\n      targetId: input.targetId,\n      name: input.name,\n      description: input.description,\n      metadata: input.metadata,\n      status: 'pending',\n      totalItems: input.totalItems,\n      succeededCount: 0,\n      failedCount: 0,\n      skippedCount: 0,\n      startedAt: null,\n      completedAt: null,\n      createdAt: now,\n      updatedAt: now,\n    };\n    this.db.experiments.set(experiment.id, experiment);\n    return experiment;\n  }\n\n  async updateExperiment(input: UpdateExperimentInput): Promise<Experiment> {\n    const existing = this.db.experiments.get(input.id);\n    if (!existing) {\n      throw new Error(`Experiment not found: ${input.id}`);\n    }\n    const updated: Experiment = {\n      ...existing,\n      status: input.status ?? existing.status,\n      succeededCount: input.succeededCount ?? existing.succeededCount,\n      failedCount: input.failedCount ?? existing.failedCount,\n      skippedCount: input.skippedCount ?? existing.skippedCount,\n      startedAt: input.startedAt ?? existing.startedAt,\n      completedAt: input.completedAt ?? existing.completedAt,\n      name: input.name ?? existing.name,\n      description: input.description ?? existing.description,\n      metadata: input.metadata ?? existing.metadata,\n      updatedAt: new Date(),\n    };\n    this.db.experiments.set(input.id, updated);\n    return updated;\n  }\n\n  async getExperimentById(args: { id: string }): Promise<Experiment | null> {\n    return this.db.experiments.get(args.id) ?? null;\n  }\n\n  async listExperiments(args: ListExperimentsInput): Promise<ListExperimentsOutput> {\n    let experiments = Array.from(this.db.experiments.values());\n\n    // Filter by datasetId if provided\n    if (args.datasetId) {\n      experiments = experiments.filter(r => r.datasetId === args.datasetId);\n    }\n\n    // Sort by createdAt descending (newest first)\n    experiments.sort((a, b) => b.createdAt.getTime() - a.createdAt.getTime());\n\n    const { page, perPage: perPageInput } = args.pagination;\n    const perPage = normalizePerPage(perPageInput, 100);\n    const { offset: start, perPage: perPageForResponse } = calculatePagination(page, perPageInput, perPage);\n    const end = perPageInput === false ? experiments.length : start + perPage;\n\n    return {\n      experiments: experiments.slice(start, end),\n      pagination: {\n        total: experiments.length,\n        page,\n        perPage: perPageForResponse,\n        hasMore: perPageInput === false ? false : experiments.length > end,\n      },\n    };\n  }\n\n  async deleteExperiment(args: { id: string }): Promise<void> {\n    this.db.experiments.delete(args.id);\n    // Also delete associated results\n    for (const [resultId, result] of this.db.experimentResults) {\n      if (result.experimentId === args.id) {\n        this.db.experimentResults.delete(resultId);\n      }\n    }\n  }\n\n  // Results (per-item)\n  async addExperimentResult(input: AddExperimentResultInput): Promise<ExperimentResult> {\n    const now = new Date();\n    const result: ExperimentResult = {\n      id: input.id ?? crypto.randomUUID(),\n      experimentId: input.experimentId,\n      itemId: input.itemId,\n      itemDatasetVersion: input.itemDatasetVersion,\n      input: input.input,\n      output: input.output,\n      groundTruth: input.groundTruth,\n      error: input.error,\n      startedAt: input.startedAt,\n      completedAt: input.completedAt,\n      retryCount: input.retryCount,\n      traceId: input.traceId ?? null,\n      createdAt: now,\n    };\n    this.db.experimentResults.set(result.id, result);\n    return result;\n  }\n\n  async getExperimentResultById(args: { id: string }): Promise<ExperimentResult | null> {\n    return this.db.experimentResults.get(args.id) ?? null;\n  }\n\n  async listExperimentResults(args: ListExperimentResultsInput): Promise<ListExperimentResultsOutput> {\n    let results = Array.from(this.db.experimentResults.values()).filter(r => r.experimentId === args.experimentId);\n\n    // Sort by startedAt ascending (execution order)\n    results.sort((a, b) => a.startedAt.getTime() - b.startedAt.getTime());\n\n    const { page, perPage: perPageInput } = args.pagination;\n    const perPage = normalizePerPage(perPageInput, 100);\n    const { offset: start, perPage: perPageForResponse } = calculatePagination(page, perPageInput, perPage);\n    const end = perPageInput === false ? results.length : start + perPage;\n\n    return {\n      results: results.slice(start, end),\n      pagination: {\n        total: results.length,\n        page,\n        perPage: perPageForResponse,\n        hasMore: perPageInput === false ? false : results.length > end,\n      },\n    };\n  }\n\n  async deleteExperimentResults(args: { experimentId: string }): Promise<void> {\n    for (const [resultId, result] of this.db.experimentResults) {\n      if (result.experimentId === args.experimentId) {\n        this.db.experimentResults.delete(resultId);\n      }\n    }\n  }\n}\n"]}