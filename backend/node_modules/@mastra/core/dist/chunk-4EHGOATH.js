import { createTool } from './chunk-RS6CZXGA.js';
import { MastraBase } from './chunk-WCAFTXGK.js';
import { RegisteredLogger } from './chunk-X2WMFSPB.js';
import { constants } from 'fs';
import * as fs2 from 'fs/promises';
import * as nodePath from 'path';
import * as crypto from 'crypto';
import { createHash } from 'crypto';
import matter from 'gray-matter';
import * as childProcess from 'child_process';
import { execFileSync } from 'child_process';
import * as os from 'os';
import os__default from 'os';
import { z } from 'zod';

// src/workspace/errors.ts
var WorkspaceError = class extends Error {
  constructor(message, code, workspaceId) {
    super(message);
    this.code = code;
    this.workspaceId = workspaceId;
    this.name = "WorkspaceError";
  }
};
var FilesystemNotAvailableError = class extends WorkspaceError {
  constructor() {
    super("Workspace does not have a filesystem configured", "NO_FILESYSTEM");
    this.name = "FilesystemNotAvailableError";
  }
};
var SandboxNotAvailableError = class extends WorkspaceError {
  constructor(message) {
    super(message ?? "Workspace does not have a sandbox configured", "NO_SANDBOX");
    this.name = "SandboxNotAvailableError";
  }
};
var SandboxFeatureNotSupportedError = class extends WorkspaceError {
  constructor(feature) {
    super(`Sandbox does not support ${feature}`, "FEATURE_NOT_SUPPORTED");
    this.name = "SandboxFeatureNotSupportedError";
  }
};
var SearchNotAvailableError = class extends WorkspaceError {
  constructor() {
    super("Workspace does not have search configured (enable bm25 or provide vectorStore + embedder)", "NO_SEARCH");
    this.name = "SearchNotAvailableError";
  }
};
var WorkspaceNotReadyError = class extends WorkspaceError {
  constructor(workspaceId, status) {
    super(`Workspace is not ready (status: ${status})`, "NOT_READY", workspaceId);
    this.name = "WorkspaceNotReadyError";
  }
};
var WorkspaceReadOnlyError = class extends WorkspaceError {
  constructor(operation) {
    super(`Workspace is in read-only mode. Cannot perform: ${operation}`, "READ_ONLY");
    this.name = "WorkspaceReadOnlyError";
  }
};
var FilesystemError = class extends Error {
  constructor(message, code, path4) {
    super(message);
    this.code = code;
    this.path = path4;
    this.name = "FilesystemError";
  }
};
var FileNotFoundError = class extends FilesystemError {
  constructor(path4) {
    super(`File not found: ${path4}`, "ENOENT", path4);
    this.name = "FileNotFoundError";
  }
};
var DirectoryNotFoundError = class extends FilesystemError {
  constructor(path4) {
    super(`Directory not found: ${path4}`, "ENOENT", path4);
    this.name = "DirectoryNotFoundError";
  }
};
var FileExistsError = class extends FilesystemError {
  constructor(path4) {
    super(`File already exists: ${path4}`, "EEXIST", path4);
    this.name = "FileExistsError";
  }
};
var IsDirectoryError = class extends FilesystemError {
  constructor(path4) {
    super(`Path is a directory: ${path4}`, "EISDIR", path4);
    this.name = "IsDirectoryError";
  }
};
var NotDirectoryError = class extends FilesystemError {
  constructor(path4) {
    super(`Path is not a directory: ${path4}`, "ENOTDIR", path4);
    this.name = "NotDirectoryError";
  }
};
var DirectoryNotEmptyError = class extends FilesystemError {
  constructor(path4) {
    super(`Directory not empty: ${path4}`, "ENOTEMPTY", path4);
    this.name = "DirectoryNotEmptyError";
  }
};
var PermissionError = class extends FilesystemError {
  constructor(path4, operation) {
    super(`Permission denied: ${operation} on ${path4}`, "EACCES", path4);
    this.operation = operation;
    this.name = "PermissionError";
  }
};
var FileReadRequiredError = class extends FilesystemError {
  constructor(path4, reason) {
    super(reason, "EREAD_REQUIRED", path4);
    this.name = "FileReadRequiredError";
  }
};
var FilesystemNotReadyError = class extends FilesystemError {
  constructor(id) {
    super(`Filesystem "${id}" is not ready. Call init() first or use ensureReady().`, "ENOTREADY", id);
    this.name = "FilesystemNotReadyError";
  }
};

// src/workspace/lifecycle.ts
async function callLifecycle(provider, method) {
  const wrapped = `_${method}`;
  const wrappedFn = provider[wrapped];
  if (typeof wrappedFn === "function") {
    await wrappedFn.call(provider);
  } else {
    const plainFn = provider[method];
    if (typeof plainFn === "function") {
      await plainFn.call(provider);
    }
  }
}

// src/workspace/filesystem/composite-filesystem.ts
var CompositeFilesystem = class {
  id;
  name = "CompositeFilesystem";
  provider = "composite";
  status = "ready";
  _mounts;
  constructor(config) {
    this.id = `cfs-${Date.now().toString(36)}`;
    this._mounts = /* @__PURE__ */ new Map();
    for (const [path4, fs5] of Object.entries(config.mounts)) {
      const normalized = this.normalizePath(path4);
      this._mounts.set(normalized, fs5);
    }
    if (this._mounts.size === 0) {
      throw new Error("CompositeFilesystem requires at least one mount");
    }
    const mountPaths = [...this._mounts.keys()];
    for (const a of mountPaths) {
      for (const b of mountPaths) {
        if (a !== b && b.startsWith(a + "/")) {
          throw new Error(`Nested mount paths are not supported: "${b}" is nested under "${a}"`);
        }
      }
    }
  }
  /**
   * Get all mount paths.
   */
  get mountPaths() {
    return Array.from(this._mounts.keys());
  }
  /**
   * Get the mounts map.
   */
  get mounts() {
    return this._mounts;
  }
  /**
   * Get the underlying filesystem for a given path.
   * Returns undefined if the path doesn't resolve to any mount.
   */
  getFilesystemForPath(path4) {
    const resolved = this.resolveMount(path4);
    return resolved?.fs;
  }
  /**
   * Get the mount path for a given path.
   * Returns undefined if the path doesn't resolve to any mount.
   */
  getMountPathForPath(path4) {
    const resolved = this.resolveMount(path4);
    return resolved?.mountPath;
  }
  normalizePath(path4) {
    if (!path4 || path4 === "/") return "/";
    let n = path4.startsWith("/") ? path4 : `/${path4}`;
    if (n.length > 1 && n.endsWith("/")) n = n.slice(0, -1);
    return n;
  }
  resolveMount(path4) {
    const normalized = this.normalizePath(path4);
    let best = null;
    for (const [mountPath, fs5] of this._mounts) {
      if (normalized === mountPath || normalized.startsWith(mountPath + "/")) {
        if (!best || mountPath.length > best.mountPath.length) {
          best = { mountPath, fs: fs5 };
        }
      }
    }
    if (!best) return null;
    let fsPath = normalized.slice(best.mountPath.length);
    if (!fsPath) fsPath = "/";
    if (!fsPath.startsWith("/")) fsPath = "/" + fsPath;
    return { fs: best.fs, fsPath, mountPath: best.mountPath };
  }
  getVirtualEntries(path4) {
    const normalized = this.normalizePath(path4);
    if (this.resolveMount(normalized)) return null;
    const entriesMap = /* @__PURE__ */ new Map();
    for (const [mountPath, fs5] of this._mounts.entries()) {
      const isUnder = normalized === "/" ? mountPath.startsWith("/") : mountPath.startsWith(normalized + "/");
      if (isUnder) {
        const remaining = normalized === "/" ? mountPath.slice(1) : mountPath.slice(normalized.length + 1);
        const next = remaining.split("/")[0];
        if (next && !entriesMap.has(next)) {
          const isDirectMount = remaining === next;
          const entry = { name: next, type: "directory" };
          if (isDirectMount) {
            entry.mount = {
              provider: fs5.provider,
              icon: fs5.icon,
              displayName: fs5.displayName,
              description: fs5.description,
              status: fs5.status,
              error: fs5.error
            };
          }
          entriesMap.set(next, entry);
        }
      }
    }
    return entriesMap.size > 0 ? Array.from(entriesMap.values()) : null;
  }
  isVirtualPath(path4) {
    const normalized = this.normalizePath(path4);
    if (normalized === "/" && !this._mounts.has("/")) return true;
    for (const mountPath of this._mounts.keys()) {
      if (mountPath.startsWith(normalized + "/")) return true;
    }
    return false;
  }
  /**
   * Assert that a filesystem is writable (not read-only).
   * @throws {PermissionError} if the filesystem is read-only
   */
  assertWritable(fs5, path4, operation) {
    if (fs5.readOnly) {
      throw new PermissionError(path4, `${operation} (filesystem is read-only)`);
    }
  }
  // ===========================================================================
  // WorkspaceFilesystem Implementation
  // ===========================================================================
  async init() {
    this.status = "initializing";
    for (const [mountPath, fs5] of this._mounts.entries()) {
      try {
        await callLifecycle(fs5, "init");
      } catch (e) {
        const message = e instanceof Error ? e.message : String(e);
        console.warn(`[CompositeFilesystem] Mount "${mountPath}" failed to initialize: ${message}`);
      }
    }
    this.status = "ready";
  }
  async destroy() {
    this.status = "destroying";
    const errors = [];
    for (const fs5 of this._mounts.values()) {
      try {
        await callLifecycle(fs5, "destroy");
      } catch (e) {
        errors.push(e instanceof Error ? e : new Error(String(e)));
      }
    }
    if (errors.length > 0) {
      this.status = "error";
      throw new AggregateError(errors, "Some filesystems failed to destroy");
    }
    this.status = "destroyed";
  }
  async readFile(path4, options) {
    const r = this.resolveMount(path4);
    if (!r) throw new Error(`No mount for path: ${path4}`);
    return r.fs.readFile(r.fsPath, options);
  }
  async writeFile(path4, content, options) {
    const r = this.resolveMount(path4);
    if (!r) throw new Error(`No mount for path: ${path4}`);
    this.assertWritable(r.fs, path4, "writeFile");
    return r.fs.writeFile(r.fsPath, content, options);
  }
  async appendFile(path4, content) {
    const r = this.resolveMount(path4);
    if (!r) throw new Error(`No mount for path: ${path4}`);
    this.assertWritable(r.fs, path4, "appendFile");
    return r.fs.appendFile(r.fsPath, content);
  }
  async deleteFile(path4, options) {
    const r = this.resolveMount(path4);
    if (!r) throw new Error(`No mount for path: ${path4}`);
    this.assertWritable(r.fs, path4, "deleteFile");
    return r.fs.deleteFile(r.fsPath, options);
  }
  async copyFile(src, dest, options) {
    const srcR = this.resolveMount(src);
    const destR = this.resolveMount(dest);
    if (!srcR) throw new Error(`No mount for source: ${src}`);
    if (!destR) throw new Error(`No mount for dest: ${dest}`);
    this.assertWritable(destR.fs, dest, "copyFile");
    if (srcR.mountPath === destR.mountPath) {
      return srcR.fs.copyFile(srcR.fsPath, destR.fsPath, options);
    }
    const content = await srcR.fs.readFile(srcR.fsPath);
    await destR.fs.writeFile(destR.fsPath, content, { overwrite: options?.overwrite });
  }
  async moveFile(src, dest, options) {
    const srcR = this.resolveMount(src);
    const destR = this.resolveMount(dest);
    if (!srcR) throw new Error(`No mount for source: ${src}`);
    if (!destR) throw new Error(`No mount for dest: ${dest}`);
    this.assertWritable(destR.fs, dest, "moveFile");
    this.assertWritable(srcR.fs, src, "moveFile");
    if (srcR.mountPath === destR.mountPath) {
      return srcR.fs.moveFile(srcR.fsPath, destR.fsPath, options);
    }
    await this.copyFile(src, dest, options);
    await srcR.fs.deleteFile(srcR.fsPath);
  }
  async readdir(path4, options) {
    const virtual = this.getVirtualEntries(path4);
    if (virtual) return virtual;
    const r = this.resolveMount(path4);
    if (!r) throw new Error(`No mount for path: ${path4}`);
    return r.fs.readdir(r.fsPath, options);
  }
  async mkdir(path4, options) {
    const r = this.resolveMount(path4);
    if (!r) throw new Error(`No mount for path: ${path4}`);
    this.assertWritable(r.fs, path4, "mkdir");
    return r.fs.mkdir(r.fsPath, options);
  }
  async rmdir(path4, options) {
    const r = this.resolveMount(path4);
    if (!r) throw new Error(`No mount for path: ${path4}`);
    this.assertWritable(r.fs, path4, "rmdir");
    return r.fs.rmdir(r.fsPath, options);
  }
  async exists(path4) {
    if (this.isVirtualPath(path4)) return true;
    const r = this.resolveMount(path4);
    if (!r) return false;
    if (r.fsPath === "/") return true;
    return r.fs.exists(r.fsPath);
  }
  async stat(path4) {
    const normalized = this.normalizePath(path4);
    if (this.isVirtualPath(path4)) {
      const parts = normalized.split("/").filter(Boolean);
      const now = /* @__PURE__ */ new Date();
      return {
        name: parts[parts.length - 1] || "",
        path: normalized,
        type: "directory",
        size: 0,
        createdAt: now,
        modifiedAt: now
      };
    }
    const r = this.resolveMount(path4);
    if (!r) throw new Error(`No mount for path: ${path4}`);
    if (r.fsPath === "/") {
      const parts = normalized.split("/").filter(Boolean);
      const now = /* @__PURE__ */ new Date();
      return {
        name: parts[parts.length - 1] || "",
        path: normalized,
        type: "directory",
        size: 0,
        createdAt: now,
        modifiedAt: now
      };
    }
    return r.fs.stat(r.fsPath);
  }
  async isFile(path4) {
    if (this.isVirtualPath(path4)) return false;
    const r = this.resolveMount(path4);
    if (!r) return false;
    try {
      const stat3 = await r.fs.stat(r.fsPath);
      return stat3.type === "file";
    } catch {
      return false;
    }
  }
  async isDirectory(path4) {
    if (this.isVirtualPath(path4)) return true;
    const r = this.resolveMount(path4);
    if (!r) return false;
    if (r.fsPath === "/") return true;
    try {
      const stat3 = await r.fs.stat(r.fsPath);
      return stat3.type === "directory";
    } catch {
      return false;
    }
  }
  /**
   * Get instructions describing the mounted filesystems.
   * Used by agents to understand available storage locations.
   */
  getInstructions() {
    const mountDescriptions = Array.from(this._mounts.entries()).map(([mountPath, fs5]) => {
      const name = fs5.displayName || fs5.provider;
      const access2 = fs5.readOnly ? "(read-only)" : "(read-write)";
      return `- ${mountPath}: ${name} ${access2}`;
    }).join("\n");
    return `Mounted filesystems:
${mountDescriptions}
Files written via workspace tools are accessible at the same paths in sandbox commands.`;
  }
};

// src/workspace/filesystem/mastra-filesystem.ts
var MastraFilesystem = class extends MastraBase {
  /** Error message when status is 'error' */
  error;
  // ---------------------------------------------------------------------------
  // Lifecycle Promise Tracking (prevents race conditions)
  // ---------------------------------------------------------------------------
  /** Promise for _init() to prevent race conditions from concurrent calls */
  _initPromise;
  /** Promise for _destroy() to prevent race conditions from concurrent calls */
  _destroyPromise;
  /** Lifecycle callbacks */
  _onInit;
  _onDestroy;
  constructor(options) {
    super({ name: options.name, component: RegisteredLogger.WORKSPACE });
    this._onInit = options.onInit;
    this._onDestroy = options.onDestroy;
  }
  // ---------------------------------------------------------------------------
  // Lifecycle Wrappers (race-condition-safe)
  // ---------------------------------------------------------------------------
  /**
   * Initialize the filesystem (wrapper with status management and race-condition safety).
   *
   * This method is race-condition-safe - concurrent calls will return the same promise.
   * Handles status management automatically.
   *
   * Subclasses override `init()` to provide their initialization logic.
   */
  async _init() {
    if (this.status === "ready") {
      return;
    }
    if (this._destroyPromise) {
      try {
        await this._destroyPromise;
      } catch {
      }
    }
    if (this._initPromise) {
      return this._initPromise;
    }
    this._initPromise = this._executeInit();
    try {
      await this._initPromise;
    } finally {
      this._initPromise = void 0;
    }
  }
  /**
   * Internal init execution - handles status.
   */
  async _executeInit() {
    this.status = "initializing";
    this.error = void 0;
    try {
      await this.init();
      this.status = "ready";
      try {
        await this._onInit?.({ filesystem: this });
      } catch (error) {
        this.logger.warn("onInit callback failed", { error });
      }
    } catch (error) {
      this.status = "error";
      this.error = error instanceof Error ? error.message : String(error);
      this.logger.error("Failed to initialize filesystem", { error, id: this.id });
      throw error;
    }
  }
  /**
   * Override this method to implement filesystem initialization logic.
   *
   * Called by `_init()` after status is set to 'initializing'.
   * Status will be set to 'ready' on success, 'error' on failure.
   *
   * @example
   * ```typescript
   * async init(): Promise<void> {
   *   this._client = new StorageClient({ ... });
   *   await this._client.connect();
   * }
   * ```
   */
  async init() {
  }
  /**
   * Ensure the filesystem is ready.
   *
   * Calls `_init()` if status is not 'ready'. Useful for lazy initialization
   * where operations should automatically initialize the filesystem if needed.
   *
   * @throws {FilesystemNotReadyError} if the filesystem fails to reach 'ready' status
   *
   * @example
   * ```typescript
   * async readFile(path: string): Promise<string | Buffer> {
   *   await this.ensureReady();
   *   // Now safe to use the filesystem
   * }
   * ```
   */
  async ensureReady() {
    if (this.status !== "ready") {
      await this._init();
    }
    if (this.status !== "ready") {
      throw new FilesystemNotReadyError(this.id);
    }
  }
  /**
   * Destroy the filesystem and clean up all resources (wrapper with status management).
   *
   * This method is race-condition-safe - concurrent calls will return the same promise.
   * Handles status management.
   *
   * Subclasses override `destroy()` to provide their destroy logic.
   */
  async _destroy() {
    if (this.status === "destroyed") {
      return;
    }
    if (this.status === "pending") {
      this.status = "destroyed";
      return;
    }
    if (this._destroyPromise) {
      return this._destroyPromise;
    }
    this._destroyPromise = this._executeDestroy();
    try {
      await this._destroyPromise;
    } finally {
      this._destroyPromise = void 0;
    }
  }
  /**
   * Internal destroy execution - handles status.
   */
  async _executeDestroy() {
    if (this._initPromise) {
      try {
        await this._initPromise;
      } catch {
      }
    }
    this.status = "destroying";
    try {
      await this._onDestroy?.({ filesystem: this });
      await this.destroy();
      this.status = "destroyed";
    } catch (error) {
      this.status = "error";
      this.logger.error("Failed to destroy filesystem", { error, id: this.id });
      throw error;
    }
  }
  /**
   * Override this method to implement filesystem destroy logic.
   *
   * Called by `_destroy()` after status is set to 'destroying'.
   * Status will be set to 'destroyed' on success, 'error' on failure.
   */
  async destroy() {
  }
};
function isEnoentError(error) {
  return error !== null && typeof error === "object" && "code" in error && error.code === "ENOENT";
}
function isEexistError(error) {
  return error !== null && typeof error === "object" && "code" in error && error.code === "EEXIST";
}
var MIME_TYPES = {
  // Text
  txt: "text/plain",
  html: "text/html",
  htm: "text/html",
  css: "text/css",
  csv: "text/csv",
  md: "text/markdown",
  // Code
  js: "application/javascript",
  mjs: "application/javascript",
  ts: "application/typescript",
  tsx: "application/typescript",
  jsx: "application/javascript",
  json: "application/json",
  xml: "application/xml",
  yaml: "text/yaml",
  yml: "text/yaml",
  // Programming languages
  py: "text/x-python",
  rb: "text/x-ruby",
  go: "text/x-go",
  rs: "text/x-rust",
  java: "text/x-java",
  c: "text/x-c",
  cpp: "text/x-c++",
  h: "text/x-c",
  hpp: "text/x-c++",
  sh: "text/x-sh",
  bash: "text/x-sh",
  zsh: "text/x-sh",
  // Config
  toml: "text/toml",
  ini: "text/plain",
  env: "text/plain",
  // Database/Query
  sql: "text/x-sql",
  graphql: "application/graphql",
  gql: "application/graphql",
  // Frameworks
  vue: "text/x-vue",
  // Images
  png: "image/png",
  jpg: "image/jpeg",
  jpeg: "image/jpeg",
  gif: "image/gif",
  svg: "image/svg+xml",
  webp: "image/webp",
  ico: "image/x-icon",
  // Documents
  pdf: "application/pdf"
};
function getMimeType(filename) {
  const ext = nodePath.extname(filename).slice(1).toLowerCase();
  return MIME_TYPES[ext] ?? "application/octet-stream";
}
var TEXT_EXTENSIONS = /* @__PURE__ */ new Set([
  ".md",
  ".txt",
  ".json",
  ".yaml",
  ".yml",
  ".js",
  ".mjs",
  ".ts",
  ".tsx",
  ".jsx",
  ".py",
  ".rb",
  ".go",
  ".rs",
  ".java",
  ".c",
  ".cpp",
  ".h",
  ".hpp",
  ".sh",
  ".bash",
  ".zsh",
  ".html",
  ".htm",
  ".css",
  ".xml",
  ".toml",
  ".ini",
  ".env",
  ".csv",
  ".sql",
  ".graphql",
  ".gql",
  ".vue",
  ".svg"
]);
function isTextFile(filename) {
  const ext = nodePath.extname(filename).toLowerCase();
  return TEXT_EXTENSIONS.has(ext);
}
async function fsExists(absolutePath) {
  try {
    await fs2.access(absolutePath);
    return true;
  } catch {
    return false;
  }
}
async function fsStat(absolutePath, userPath) {
  try {
    const stats = await fs2.stat(absolutePath);
    return {
      name: nodePath.basename(absolutePath),
      type: stats.isDirectory() ? "directory" : "file",
      size: stats.size,
      createdAt: stats.birthtime,
      modifiedAt: stats.mtime,
      mimeType: stats.isFile() ? getMimeType(absolutePath) : void 0
    };
  } catch (error) {
    if (isEnoentError(error)) {
      throw new FileNotFoundError(userPath);
    }
    throw error;
  }
}

// src/workspace/filesystem/local-filesystem.ts
var LocalFilesystem = class extends MastraFilesystem {
  id;
  name = "LocalFilesystem";
  provider = "local";
  readOnly;
  status = "pending";
  _basePath;
  _contained;
  /**
   * The absolute base path on disk where files are stored.
   * Useful for understanding how workspace paths map to disk paths.
   */
  get basePath() {
    return this._basePath;
  }
  constructor(options) {
    super({ ...options, name: "LocalFilesystem" });
    this.id = options.id ?? this.generateId();
    this._basePath = nodePath.resolve(options.basePath);
    this._contained = options.contained ?? true;
    this.readOnly = options.readOnly;
  }
  generateId() {
    return `local-fs-${Date.now().toString(36)}-${Math.random().toString(36).slice(2, 8)}`;
  }
  toBuffer(content) {
    if (Buffer.isBuffer(content)) return content;
    if (content instanceof Uint8Array) return Buffer.from(content);
    return Buffer.from(content, "utf-8");
  }
  resolvePath(inputPath) {
    let absolutePath;
    if (!this._contained && nodePath.isAbsolute(inputPath)) {
      absolutePath = nodePath.normalize(inputPath);
    } else if (this._contained && nodePath.isAbsolute(inputPath)) {
      const normalized = nodePath.normalize(inputPath);
      const relative2 = nodePath.relative(this._basePath, normalized);
      if (!relative2.startsWith("..") && !nodePath.isAbsolute(relative2)) {
        absolutePath = normalized;
      } else {
        const cleanedPath = inputPath.replace(/^\/+/, "");
        absolutePath = nodePath.resolve(this._basePath, nodePath.normalize(cleanedPath));
      }
    } else {
      const cleanedPath = inputPath.replace(/^\/+/, "");
      absolutePath = nodePath.resolve(this._basePath, nodePath.normalize(cleanedPath));
    }
    if (this._contained) {
      const relative2 = nodePath.relative(this._basePath, absolutePath);
      if (relative2.startsWith("..") || nodePath.isAbsolute(relative2)) {
        throw new PermissionError(inputPath, "access");
      }
    }
    return absolutePath;
  }
  toRelativePath(absolutePath) {
    return "/" + nodePath.relative(this._basePath, absolutePath).replace(/\\/g, "/");
  }
  assertWritable(operation) {
    if (this.readOnly) {
      throw new WorkspaceReadOnlyError(operation);
    }
  }
  /**
   * Verify that the resolved path doesn't escape basePath via symlinks.
   * Uses realpath to resolve symlinks and check the actual target.
   */
  async assertPathContained(absolutePath) {
    if (!this._contained) return;
    let baseReal;
    try {
      baseReal = await fs2.realpath(this._basePath);
    } catch (error) {
      if (isEnoentError(error)) {
        throw new DirectoryNotFoundError(this._basePath);
      }
      throw error;
    }
    let targetReal;
    try {
      targetReal = await fs2.realpath(absolutePath);
    } catch (error) {
      if (isEnoentError(error)) {
        let parentPath = absolutePath;
        while (true) {
          const nextParent = nodePath.dirname(parentPath);
          if (nextParent === parentPath) {
            throw new DirectoryNotFoundError(absolutePath);
          }
          parentPath = nextParent;
          try {
            targetReal = await fs2.realpath(parentPath);
            break;
          } catch (parentError) {
            if (!isEnoentError(parentError)) {
              throw parentError;
            }
          }
        }
      } else {
        throw error;
      }
    }
    if (targetReal !== baseReal && !targetReal.startsWith(baseReal + nodePath.sep)) {
      throw new PermissionError(absolutePath, "access");
    }
  }
  async readFile(inputPath, options) {
    this.logger.debug("Reading file", { path: inputPath, encoding: options?.encoding });
    await this.ensureReady();
    const absolutePath = this.resolvePath(inputPath);
    await this.assertPathContained(absolutePath);
    try {
      const stats = await fs2.stat(absolutePath);
      if (stats.isDirectory()) {
        throw new IsDirectoryError(inputPath);
      }
      if (options?.encoding) {
        return await fs2.readFile(absolutePath, { encoding: options.encoding });
      }
      return await fs2.readFile(absolutePath);
    } catch (error) {
      if (error instanceof IsDirectoryError) throw error;
      if (isEnoentError(error)) {
        throw new FileNotFoundError(inputPath);
      }
      throw error;
    }
  }
  async writeFile(inputPath, content, options) {
    const contentSize = Buffer.isBuffer(content) ? content.length : content.length;
    this.logger.debug("Writing file", { path: inputPath, size: contentSize, recursive: options?.recursive });
    await this.ensureReady();
    this.assertWritable("writeFile");
    const absolutePath = this.resolvePath(inputPath);
    await this.assertPathContained(absolutePath);
    if (options?.recursive === false) {
      const dir = nodePath.dirname(absolutePath);
      const parentPath = nodePath.dirname(inputPath);
      try {
        const stat3 = await fs2.stat(dir);
        if (!stat3.isDirectory()) {
          throw new NotDirectoryError(parentPath);
        }
      } catch (error) {
        if (error instanceof NotDirectoryError) throw error;
        if (isEnoentError(error)) {
          throw new DirectoryNotFoundError(parentPath);
        }
        throw error;
      }
    }
    if (options?.recursive !== false) {
      const dir = nodePath.dirname(absolutePath);
      await fs2.mkdir(dir, { recursive: true });
    }
    const writeFlag = options?.overwrite === false ? "wx" : "w";
    try {
      await fs2.writeFile(absolutePath, this.toBuffer(content), { flag: writeFlag });
    } catch (error) {
      if (options?.overwrite === false && isEexistError(error)) {
        throw new FileExistsError(inputPath);
      }
      throw error;
    }
  }
  async appendFile(inputPath, content) {
    const contentSize = Buffer.isBuffer(content) ? content.length : content.length;
    this.logger.debug("Appending to file", { path: inputPath, size: contentSize });
    await this.ensureReady();
    this.assertWritable("appendFile");
    const absolutePath = this.resolvePath(inputPath);
    await this.assertPathContained(absolutePath);
    const dir = nodePath.dirname(absolutePath);
    await fs2.mkdir(dir, { recursive: true });
    await fs2.appendFile(absolutePath, this.toBuffer(content));
  }
  async deleteFile(inputPath, options) {
    this.logger.debug("Deleting file", { path: inputPath, force: options?.force });
    await this.ensureReady();
    this.assertWritable("deleteFile");
    const absolutePath = this.resolvePath(inputPath);
    await this.assertPathContained(absolutePath);
    try {
      const stats = await fs2.stat(absolutePath);
      if (stats.isDirectory()) {
        throw new IsDirectoryError(inputPath);
      }
      await fs2.unlink(absolutePath);
    } catch (error) {
      if (error instanceof IsDirectoryError) throw error;
      if (isEnoentError(error)) {
        if (!options?.force) {
          throw new FileNotFoundError(inputPath);
        }
      } else {
        throw error;
      }
    }
  }
  async copyFile(src, dest, options) {
    this.logger.debug("Copying file", { src, dest, recursive: options?.recursive });
    await this.ensureReady();
    this.assertWritable("copyFile");
    const srcPath = this.resolvePath(src);
    const destPath = this.resolvePath(dest);
    await this.assertPathContained(srcPath);
    await this.assertPathContained(destPath);
    try {
      const stats = await fs2.stat(srcPath);
      if (stats.isDirectory()) {
        if (!options?.recursive) {
          throw new IsDirectoryError(src);
        }
        await this.copyDirectory(srcPath, destPath, options);
      } else {
        await fs2.mkdir(nodePath.dirname(destPath), { recursive: true });
        const copyFlags = options?.overwrite === false ? constants.COPYFILE_EXCL : 0;
        try {
          await fs2.copyFile(srcPath, destPath, copyFlags);
        } catch (error) {
          if (options?.overwrite === false && isEexistError(error)) {
            throw new FileExistsError(dest);
          }
          throw error;
        }
      }
    } catch (error) {
      if (error instanceof IsDirectoryError || error instanceof FileExistsError) throw error;
      if (isEnoentError(error)) {
        throw new FileNotFoundError(src);
      }
      throw error;
    }
  }
  async copyDirectory(src, dest, options) {
    await this.ensureReady();
    await fs2.mkdir(dest, { recursive: true });
    const entries = await fs2.readdir(src, { withFileTypes: true });
    for (const entry of entries) {
      const srcEntry = nodePath.join(src, entry.name);
      const destEntry = nodePath.join(dest, entry.name);
      await this.assertPathContained(srcEntry);
      await this.assertPathContained(destEntry);
      if (entry.isDirectory()) {
        await this.copyDirectory(srcEntry, destEntry, options);
      } else {
        const copyFlags = options?.overwrite === false ? constants.COPYFILE_EXCL : 0;
        try {
          await fs2.copyFile(srcEntry, destEntry, copyFlags);
        } catch (error) {
          if (options?.overwrite === false && isEexistError(error)) {
            continue;
          }
          throw error;
        }
      }
    }
  }
  async moveFile(src, dest, options) {
    this.logger.debug("Moving file", { src, dest, overwrite: options?.overwrite });
    await this.ensureReady();
    this.assertWritable("moveFile");
    const srcPath = this.resolvePath(src);
    const destPath = this.resolvePath(dest);
    await this.assertPathContained(srcPath);
    await this.assertPathContained(destPath);
    try {
      await fs2.mkdir(nodePath.dirname(destPath), { recursive: true });
      if (options?.overwrite === false) {
        await this.copyFile(src, dest, { ...options, overwrite: false });
        await fs2.rm(srcPath, { recursive: true, force: true });
        return;
      }
      try {
        await fs2.rename(srcPath, destPath);
      } catch (error) {
        const code = error.code;
        if (code !== "EXDEV") {
          throw error;
        }
        await this.copyFile(src, dest, options);
        await fs2.rm(srcPath, { recursive: true, force: true });
      }
    } catch (error) {
      if (error instanceof FileExistsError) throw error;
      if (isEnoentError(error)) {
        throw new FileNotFoundError(src);
      }
      throw error;
    }
  }
  async mkdir(inputPath, options) {
    this.logger.debug("Creating directory", { path: inputPath, recursive: options?.recursive });
    await this.ensureReady();
    this.assertWritable("mkdir");
    const absolutePath = this.resolvePath(inputPath);
    await this.assertPathContained(absolutePath);
    try {
      await fs2.mkdir(absolutePath, { recursive: options?.recursive ?? true });
    } catch (error) {
      if (isEexistError(error)) {
        const stats = await fs2.stat(absolutePath);
        if (!stats.isDirectory()) {
          throw new FileExistsError(inputPath);
        }
      } else if (isEnoentError(error)) {
        const parentPath = nodePath.dirname(inputPath);
        throw new DirectoryNotFoundError(parentPath);
      } else {
        throw error;
      }
    }
  }
  async rmdir(inputPath, options) {
    this.logger.debug("Removing directory", { path: inputPath, recursive: options?.recursive, force: options?.force });
    await this.ensureReady();
    this.assertWritable("rmdir");
    const absolutePath = this.resolvePath(inputPath);
    await this.assertPathContained(absolutePath);
    try {
      const stats = await fs2.stat(absolutePath);
      if (!stats.isDirectory()) {
        throw new NotDirectoryError(inputPath);
      }
      if (options?.recursive) {
        await fs2.rm(absolutePath, { recursive: true, force: options?.force ?? false });
      } else {
        const entries = await fs2.readdir(absolutePath);
        if (entries.length > 0) {
          throw new DirectoryNotEmptyError(inputPath);
        }
        await fs2.rmdir(absolutePath);
      }
    } catch (error) {
      if (error instanceof NotDirectoryError || error instanceof DirectoryNotEmptyError) {
        throw error;
      }
      if (isEnoentError(error)) {
        if (!options?.force) {
          throw new DirectoryNotFoundError(inputPath);
        }
      } else {
        throw error;
      }
    }
  }
  async readdir(inputPath, options) {
    this.logger.debug("Reading directory", { path: inputPath, recursive: options?.recursive });
    await this.ensureReady();
    const absolutePath = this.resolvePath(inputPath);
    await this.assertPathContained(absolutePath);
    try {
      const stats = await fs2.stat(absolutePath);
      if (!stats.isDirectory()) {
        throw new NotDirectoryError(inputPath);
      }
      const entries = await fs2.readdir(absolutePath, { withFileTypes: true });
      const result = [];
      for (const entry of entries) {
        const entryPath = nodePath.join(absolutePath, entry.name);
        if (options?.extension) {
          const extensions = Array.isArray(options.extension) ? options.extension : [options.extension];
          if (entry.isFile()) {
            const ext = nodePath.extname(entry.name);
            if (!extensions.some((e) => e === ext || e === ext.slice(1))) {
              continue;
            }
          }
        }
        const isSymlink = entry.isSymbolicLink();
        let symlinkTarget;
        let resolvedType = "file";
        if (isSymlink) {
          try {
            symlinkTarget = await fs2.readlink(entryPath);
            const targetStat = await fs2.stat(entryPath);
            resolvedType = targetStat.isDirectory() ? "directory" : "file";
          } catch {
            resolvedType = "file";
          }
        } else {
          resolvedType = entry.isDirectory() ? "directory" : "file";
        }
        const fileEntry = {
          name: entry.name,
          type: resolvedType,
          isSymlink: isSymlink || void 0,
          symlinkTarget
        };
        if (resolvedType === "file" && !isSymlink) {
          try {
            const stat3 = await fs2.stat(entryPath);
            fileEntry.size = stat3.size;
          } catch {
          }
        }
        result.push(fileEntry);
        if (options?.recursive && resolvedType === "directory") {
          const depth = options.maxDepth ?? 100;
          if (depth > 0) {
            const subEntries = await this.readdir(this.toRelativePath(entryPath), { ...options, maxDepth: depth - 1 });
            result.push(
              ...subEntries.map((e) => ({
                ...e,
                name: `${entry.name}/${e.name}`
              }))
            );
          }
        }
      }
      return result;
    } catch (error) {
      if (error instanceof NotDirectoryError) throw error;
      if (isEnoentError(error)) {
        throw new DirectoryNotFoundError(inputPath);
      }
      throw error;
    }
  }
  async exists(inputPath) {
    await this.ensureReady();
    const absolutePath = this.resolvePath(inputPath);
    await this.assertPathContained(absolutePath);
    return fsExists(absolutePath);
  }
  async stat(inputPath) {
    await this.ensureReady();
    const absolutePath = this.resolvePath(inputPath);
    await this.assertPathContained(absolutePath);
    const result = await fsStat(absolutePath, inputPath);
    return {
      ...result,
      path: this.toRelativePath(absolutePath)
    };
  }
  /**
   * Initialize the local filesystem by creating the base directory.
   * Status management is handled by the base class.
   */
  async init() {
    this.logger.debug("Initializing filesystem", { basePath: this._basePath });
    await fs2.mkdir(this._basePath, { recursive: true });
    this.logger.debug("Filesystem initialized", { basePath: this._basePath });
  }
  /**
   * Clean up the local filesystem.
   * LocalFilesystem doesn't delete files on destroy by default.
   * Status management is handled by the base class.
   */
  async destroy() {
  }
  getInfo() {
    return {
      id: this.id,
      name: this.name,
      provider: this.provider,
      readOnly: this.readOnly,
      status: this.status,
      error: this.error,
      metadata: {
        basePath: this.basePath,
        contained: this._contained
      }
    };
  }
  getInstructions() {
    if (this._contained) {
      return `Local filesystem at "${this.basePath}". Files at workspace path "/foo" are stored at "${this.basePath}/foo" on disk.`;
    }
    return `Local filesystem rooted at "${this.basePath}". Containment is disabled so absolute paths access the real filesystem. Use paths relative to "${this.basePath}" (e.g. "foo/bar.txt") for workspace files. Avoid unnecessary listing "/" as it would traverse the entire host filesystem.`;
  }
};
var InMemoryFileReadTracker = class {
  records = /* @__PURE__ */ new Map();
  recordRead(path4, modifiedAt) {
    const normalizedPath = this.normalizePath(path4);
    this.records.set(normalizedPath, {
      path: normalizedPath,
      readAt: /* @__PURE__ */ new Date(),
      modifiedAtRead: modifiedAt
    });
  }
  getReadRecord(path4) {
    return this.records.get(this.normalizePath(path4));
  }
  needsReRead(path4, currentModifiedAt) {
    const record = this.getReadRecord(path4);
    if (!record) {
      return {
        needsReRead: true,
        reason: `File "${path4}" has not been read. You must read a file before writing to it.`
      };
    }
    if (currentModifiedAt.getTime() > record.modifiedAtRead.getTime()) {
      return {
        needsReRead: true,
        reason: `File "${path4}" was modified since last read (read at: ${record.modifiedAtRead.toISOString()}, current: ${currentModifiedAt.toISOString()}). Please re-read the file to get the latest contents.`
      };
    }
    return { needsReRead: false };
  }
  clearReadRecord(path4) {
    this.records.delete(this.normalizePath(path4));
  }
  clear() {
    this.records.clear();
  }
  normalizePath(pathStr) {
    const normalized = nodePath.posix.normalize(pathStr.replace(/\\/g, "/"));
    return normalized.replace(/\/$/, "") || "/";
  }
};

// src/workspace/sandbox/errors.ts
var SandboxError = class extends Error {
  constructor(message, code, details) {
    super(message);
    this.code = code;
    this.details = details;
    this.name = "SandboxError";
  }
};
var SandboxExecutionError = class extends SandboxError {
  constructor(message, exitCode, stdout, stderr) {
    super(message, "EXECUTION_FAILED", { exitCode, stdout, stderr });
    this.exitCode = exitCode;
    this.stdout = stdout;
    this.stderr = stderr;
    this.name = "SandboxExecutionError";
  }
};
var SandboxTimeoutError = class extends SandboxError {
  constructor(timeoutMs, operation) {
    super(`Execution timed out after ${timeoutMs}ms`, "TIMEOUT", { timeoutMs, operation });
    this.timeoutMs = timeoutMs;
    this.operation = operation;
    this.name = "SandboxTimeoutError";
  }
};
var SandboxNotReadyError = class extends SandboxError {
  constructor(idOrStatus) {
    super(`Sandbox is not ready: ${idOrStatus}`, "NOT_READY", { id: idOrStatus });
    this.name = "SandboxNotReadyError";
  }
};
var IsolationUnavailableError = class extends SandboxError {
  constructor(backend, reason) {
    super(`Isolation backend '${backend}' is not available: ${reason}`, "ISOLATION_UNAVAILABLE", { backend, reason });
    this.backend = backend;
    this.reason = reason;
    this.name = "IsolationUnavailableError";
  }
};
var MountError = class extends SandboxError {
  constructor(message, mountPath, details) {
    super(message, "MOUNT_ERROR", { ...details, mountPath });
    this.mountPath = mountPath;
    this.name = "MountError";
  }
};
var MountNotSupportedError = class extends SandboxError {
  constructor(sandboxProvider) {
    super(`Sandbox provider '${sandboxProvider}' does not support mounting`, "MOUNT_NOT_SUPPORTED", {
      sandboxProvider
    });
    this.name = "MountNotSupportedError";
  }
};
var FilesystemNotMountableError = class extends SandboxError {
  constructor(filesystemProvider, reason) {
    const message = reason ? `Filesystem '${filesystemProvider}' cannot be mounted: ${reason}` : `Filesystem '${filesystemProvider}' does not support mounting`;
    super(message, "FILESYSTEM_NOT_MOUNTABLE", { filesystemProvider, reason });
    this.name = "FilesystemNotMountableError";
  }
};
var MountManager = class {
  _entries = /* @__PURE__ */ new Map();
  _mountFn;
  _onMount;
  _sandbox;
  _workspace;
  logger;
  constructor(config) {
    this._mountFn = config.mount;
    this.logger = config.logger;
  }
  /**
   * Set the sandbox and workspace references for onMount hook args.
   * Called by Workspace during construction.
   */
  setContext(context) {
    this._sandbox = context.sandbox;
    this._workspace = context.workspace;
  }
  /**
   * Set the onMount hook for custom mount handling.
   * Called before each mount - can skip, handle, or defer to default.
   */
  setOnMount(hook) {
    this._onMount = hook;
  }
  /**
   * Update the logger instance.
   * Called when the sandbox receives a logger from Mastra.
   * @internal
   */
  __setLogger(logger) {
    this.logger = logger;
  }
  // ---------------------------------------------------------------------------
  // Entry Access
  // ---------------------------------------------------------------------------
  /**
   * Get all mount entries.
   */
  get entries() {
    return this._entries;
  }
  /**
   * Get a mount entry by path.
   */
  get(path4) {
    return this._entries.get(path4);
  }
  /**
   * Check if a mount exists at the given path.
   */
  has(path4) {
    return this._entries.has(path4);
  }
  // ---------------------------------------------------------------------------
  // Entry Modification
  // ---------------------------------------------------------------------------
  /**
   * Add pending mounts from workspace config.
   * These will be processed when `processPending()` is called.
   */
  add(mounts) {
    const paths = Object.keys(mounts);
    this.logger.debug(`Adding ${paths.length} pending mount(s)`, { paths });
    for (const [path4, filesystem] of Object.entries(mounts)) {
      this._entries.set(path4, {
        filesystem,
        state: "pending"
      });
    }
  }
  /**
   * Update a mount entry's state.
   * Creates the entry if it doesn't exist.
   */
  set(path4, updates) {
    const existing = this._entries.get(path4);
    if (existing) {
      existing.state = updates.state;
      if (updates.config) {
        existing.config = updates.config;
        existing.configHash = this.hashConfig(updates.config);
      }
      if ("error" in updates) {
        existing.error = updates.error;
      }
    } else if (updates.filesystem) {
      this._entries.set(path4, {
        filesystem: updates.filesystem,
        state: updates.state,
        config: updates.config,
        configHash: updates.config ? this.hashConfig(updates.config) : void 0,
        error: updates.error
      });
    } else {
      this.logger.debug(`set() called for unknown path "${path4}" without filesystem \u2014 no entry created`);
    }
  }
  /**
   * Delete a mount entry.
   */
  delete(path4) {
    return this._entries.delete(path4);
  }
  /**
   * Clear all mount entries.
   */
  clear() {
    this._entries.clear();
  }
  // ---------------------------------------------------------------------------
  // Mount Processing
  // ---------------------------------------------------------------------------
  /**
   * Process all pending mounts.
   * Call this after sandbox is ready (in start()).
   */
  async processPending() {
    const pendingCount = [...this._entries.values()].filter((e) => e.state === "pending").length;
    if (pendingCount === 0) {
      return;
    }
    this.logger.debug(`Processing ${pendingCount} pending mount(s)`);
    for (const [path4, entry] of this._entries) {
      if (entry.state !== "pending") {
        continue;
      }
      const fsProvider = entry.filesystem.provider;
      const config = entry.filesystem.getMountConfig?.();
      if (this._onMount) {
        try {
          const hookResult = await this._onMount({
            filesystem: entry.filesystem,
            mountPath: path4,
            config,
            sandbox: this._sandbox,
            workspace: this._workspace
          });
          if (hookResult === false) {
            entry.state = "unsupported";
            entry.error = "Skipped by onMount hook";
            this.logger.debug(`Mount skipped by onMount hook`, { path: path4, provider: fsProvider });
            continue;
          }
          if (hookResult && typeof hookResult === "object") {
            if (hookResult.success) {
              entry.state = "mounted";
              entry.config = config;
              entry.configHash = config ? this.hashConfig(config) : void 0;
              this.logger.info(`Mount handled by onMount hook`, { path: path4, provider: fsProvider });
            } else {
              entry.state = "error";
              entry.error = hookResult.error ?? "Mount hook failed";
              this.logger.error(`Mount hook failed`, { path: path4, provider: fsProvider, error: entry.error });
            }
            continue;
          }
        } catch (err) {
          entry.state = "error";
          entry.error = `Mount hook error: ${String(err)}`;
          this.logger.error(`Mount hook threw error`, { path: path4, provider: fsProvider, error: entry.error });
          continue;
        }
      }
      if (!config) {
        entry.state = "unsupported";
        entry.error = "Filesystem does not support mounting";
        this.logger.debug(`Filesystem does not support mounting`, { path: path4, provider: fsProvider });
        continue;
      }
      entry.config = config;
      entry.configHash = this.hashConfig(config);
      entry.state = "mounting";
      this.logger.debug(`Mounting filesystem`, { path: path4, provider: fsProvider, type: config.type });
      try {
        const result = await this._mountFn(entry.filesystem, path4);
        if (result.success) {
          entry.state = "mounted";
          this.logger.info(`Mount successful`, { path: path4, provider: fsProvider });
        } else {
          entry.state = "error";
          entry.error = result.error ?? "Mount failed";
          this.logger.error(`Mount failed`, { path: path4, provider: fsProvider, error: entry.error });
        }
      } catch (err) {
        entry.state = "error";
        entry.error = String(err);
        this.logger.error(`Mount threw error`, { path: path4, provider: fsProvider, error: entry.error });
      }
    }
  }
  // ---------------------------------------------------------------------------
  // Marker File Helpers
  // ---------------------------------------------------------------------------
  /**
   * Generate a marker filename for a mount path.
   * Used by sandboxes to store mount metadata for reconnection detection.
   *
   * @param mountPath - The mount path to generate a filename for
   * @returns A safe filename like "mount-abc123"
   */
  markerFilename(mountPath) {
    let hash = 0;
    for (let i = 0; i < mountPath.length; i++) {
      const char = mountPath.charCodeAt(i);
      hash = (hash << 5) - hash + char;
      hash |= 0;
    }
    return `mount-${Math.abs(hash).toString(36)}`;
  }
  /**
   * Generate marker file content for a mount path.
   * Format: "path|configHash" - used for detecting config changes on reconnect.
   *
   * @param mountPath - The mount path
   * @returns Marker content string, or null if no config hash available
   */
  getMarkerContent(mountPath) {
    const entry = this._entries.get(mountPath);
    if (!entry?.configHash) {
      return null;
    }
    return `${mountPath}|${entry.configHash}`;
  }
  /**
   * Parse marker file content.
   *
   * @param content - The marker file content (format: "path|configHash")
   * @returns Parsed path and configHash, or null if invalid format
   */
  parseMarkerContent(content) {
    const separatorIndex = content.lastIndexOf("|");
    if (separatorIndex <= 0) {
      return null;
    }
    const path4 = content.slice(0, separatorIndex);
    const configHash = content.slice(separatorIndex + 1);
    if (!path4 || !configHash) return null;
    return { path: path4, configHash };
  }
  /**
   * Check if a config hash matches the expected hash for a mount path.
   *
   * @param mountPath - The mount path to check
   * @param storedHash - The hash from the marker file
   * @returns true if the hashes match
   */
  isConfigMatching(mountPath, storedHash) {
    const entry = this._entries.get(mountPath);
    return entry?.configHash === storedHash;
  }
  /**
   * Compute a hash for a mount config. Used for comparing configs across mounts.
   *
   * @param config - The config to hash
   * @returns A hash string suitable for comparison
   */
  computeConfigHash(config) {
    return this.hashConfig(config);
  }
  // ---------------------------------------------------------------------------
  // Internal
  // ---------------------------------------------------------------------------
  /**
   * Hash a mount config for comparison.
   */
  hashConfig(config) {
    const normalized = JSON.stringify(this.sortKeysDeep(config));
    return createHash("sha256").update(normalized).digest("hex").slice(0, 16);
  }
  sortKeysDeep(obj) {
    if (obj === null || typeof obj !== "object") return obj;
    if (Array.isArray(obj)) return obj.map((item) => this.sortKeysDeep(item));
    return Object.keys(obj).sort().reduce(
      (acc, key) => {
        acc[key] = this.sortKeysDeep(obj[key]);
        return acc;
      },
      {}
    );
  }
};

// src/workspace/sandbox/mastra-sandbox.ts
var MastraSandbox = class extends MastraBase {
  /** Mount manager - automatically created if subclass implements mount() */
  mounts;
  // ---------------------------------------------------------------------------
  // Lifecycle Promise Tracking (prevents race conditions)
  // ---------------------------------------------------------------------------
  /** Promise for _start() to prevent race conditions from concurrent calls */
  _startPromise;
  /** Promise for _stop() to prevent race conditions from concurrent calls */
  _stopPromise;
  /** Promise for _destroy() to prevent race conditions from concurrent calls */
  _destroyPromise;
  /** Lifecycle callbacks */
  _onStart;
  _onStop;
  _onDestroy;
  constructor(options) {
    super({ name: options.name, component: RegisteredLogger.WORKSPACE });
    this._onStart = options.onStart;
    this._onStop = options.onStop;
    this._onDestroy = options.onDestroy;
    if (this.mount) {
      this.mounts = new MountManager({
        mount: this.mount.bind(this),
        logger: this.logger
      });
    }
  }
  // ---------------------------------------------------------------------------
  // Lifecycle Wrappers (race-condition-safe)
  // ---------------------------------------------------------------------------
  /**
   * Start the sandbox (wrapper with status management and race-condition safety).
   *
   * This method is race-condition-safe - concurrent calls will return the same promise.
   * Handles status management and automatically processes pending mounts after startup.
   *
   * Subclasses override `start()` to provide their startup logic.
   */
  async _start() {
    if (this.status === "running") {
      return;
    }
    if (this._stopPromise) await this._stopPromise;
    if (this._destroyPromise) await this._destroyPromise;
    if (this.status === "destroyed") {
      throw new Error("Cannot start a destroyed sandbox");
    }
    if (this._startPromise) {
      return this._startPromise;
    }
    this._startPromise = this._executeStart();
    try {
      await this._startPromise;
    } finally {
      this._startPromise = void 0;
    }
  }
  /**
   * Internal start execution - handles status and mount processing.
   */
  async _executeStart() {
    this.status = "starting";
    try {
      await this.start();
      this.status = "running";
      try {
        await this._onStart?.({ sandbox: this });
      } catch (error) {
        this.logger.warn("onStart callback failed", { error });
      }
    } catch (error) {
      this.status = "error";
      throw error;
    }
    try {
      await this.mounts?.processPending();
    } catch (error) {
      this.logger.warn("Unexpected error processing pending mounts", { error });
    }
  }
  /**
   * Override this method to implement sandbox startup logic.
   *
   * Called by `_start()` after status is set to 'starting'.
   * Status will be set to 'running' on success, 'error' on failure.
   *
   * @example
   * ```typescript
   * async start(): Promise<void> {
   *   this._sandbox = await Sandbox.create({ ... });
   * }
   * ```
   */
  async start() {
  }
  /**
   * Ensure the sandbox is running.
   *
   * Calls `_start()` if status is not 'running'. Useful for lazy initialization
   * where operations should automatically start the sandbox if needed.
   *
   * @throws {SandboxNotReadyError} if the sandbox fails to reach 'running' status
   *
   * @example
   * ```typescript
   * async executeCommand(command: string): Promise<CommandResult> {
   *   await this.ensureRunning();
   *   // Now safe to use the sandbox
   * }
   * ```
   */
  async ensureRunning() {
    if (this.status !== "running") {
      await this._start();
    }
    if (this.status !== "running") {
      throw new SandboxNotReadyError(this.id);
    }
  }
  /**
   * Stop the sandbox (wrapper with status management and race-condition safety).
   *
   * This method is race-condition-safe - concurrent calls will return the same promise.
   * Handles status management.
   *
   * Subclasses override `stop()` to provide their stop logic.
   */
  async _stop() {
    if (this.status === "stopped") {
      return;
    }
    if (this._startPromise) await this._startPromise.catch(() => {
    });
    if (this._stopPromise) {
      return this._stopPromise;
    }
    this._stopPromise = this._executeStop();
    try {
      await this._stopPromise;
    } finally {
      this._stopPromise = void 0;
    }
  }
  /**
   * Internal stop execution - handles status.
   */
  async _executeStop() {
    this.status = "stopping";
    try {
      await this._onStop?.({ sandbox: this });
      await this.stop();
      this.status = "stopped";
    } catch (error) {
      this.status = "error";
      throw error;
    }
  }
  /**
   * Override this method to implement sandbox stop logic.
   *
   * Called by `_stop()` after status is set to 'stopping'.
   * Status will be set to 'stopped' on success, 'error' on failure.
   */
  async stop() {
  }
  /**
   * Destroy the sandbox and clean up all resources (wrapper with status management).
   *
   * This method is race-condition-safe - concurrent calls will return the same promise.
   * Handles status management.
   *
   * Subclasses override `destroy()` to provide their destroy logic.
   */
  async _destroy() {
    if (this.status === "destroyed") {
      return;
    }
    if (this._startPromise) await this._startPromise.catch(() => {
    });
    if (this._stopPromise) await this._stopPromise.catch(() => {
    });
    if (this._destroyPromise) {
      return this._destroyPromise;
    }
    this._destroyPromise = this._executeDestroy();
    try {
      await this._destroyPromise;
    } finally {
      this._destroyPromise = void 0;
    }
  }
  /**
   * Internal destroy execution - handles status.
   */
  async _executeDestroy() {
    this.status = "destroying";
    try {
      await this._onDestroy?.({ sandbox: this });
      await this.destroy();
      this.status = "destroyed";
    } catch (error) {
      this.status = "error";
      throw error;
    }
  }
  /**
   * Override this method to implement sandbox destroy logic.
   *
   * Called by `_destroy()` after status is set to 'destroying'.
   * Status will be set to 'destroyed' on success, 'error' on failure.
   */
  async destroy() {
  }
  // ---------------------------------------------------------------------------
  // Logger Propagation
  // ---------------------------------------------------------------------------
  /**
   * Override to propagate logger to MountManager.
   * @internal
   */
  __setLogger(logger) {
    super.__setLogger(logger);
    this.mounts?.__setLogger(logger);
  }
};

// src/workspace/line-utils.ts
function extractLines(content, startLine, endLine) {
  const allLines = content.split("\n");
  const totalLines = allLines.length;
  const start = Math.max(1, startLine ?? 1);
  const end = Math.min(totalLines, endLine ?? totalLines);
  const extractedLines = allLines.slice(start - 1, end);
  return {
    content: extractedLines.join("\n"),
    lines: { start, end },
    totalLines
  };
}
function extractLinesWithLimit(content, offset, limit) {
  const startLine = offset ?? 1;
  const endLine = limit ? startLine + limit - 1 : void 0;
  return extractLines(content, startLine, endLine);
}
function formatWithLineNumbers(content, startLineNumber = 1) {
  const lines = content.split("\n");
  const maxLineNum = startLineNumber + lines.length - 1;
  const padWidth = Math.max(6, String(maxLineNum).length + 1);
  return lines.map((line, i) => {
    const lineNum = startLineNumber + i;
    return `${String(lineNum).padStart(padWidth)}\u2192${line}`;
  }).join("\n");
}
function countOccurrences(content, searchString) {
  if (!searchString) return 0;
  let count = 0;
  let position = 0;
  while ((position = content.indexOf(searchString, position)) !== -1) {
    count++;
    position += searchString.length;
  }
  return count;
}
function replaceString(content, oldString, newString, replaceAll = false) {
  const count = countOccurrences(content, oldString);
  if (count === 0) {
    throw new StringNotFoundError(oldString);
  }
  if (!replaceAll && count > 1) {
    throw new StringNotUniqueError(oldString, count);
  }
  if (replaceAll) {
    const result = content.split(oldString).join(newString);
    return { content: result, replacements: count };
  } else {
    const result = content.replace(oldString, newString);
    return { content: result, replacements: 1 };
  }
}
var StringNotFoundError = class extends Error {
  constructor(searchString) {
    super(`The specified text was not found. Make sure you use the exact text from the file.`);
    this.searchString = searchString;
    this.name = "StringNotFoundError";
  }
};
var StringNotUniqueError = class extends Error {
  constructor(searchString, occurrences) {
    super(
      `The specified text appears ${occurrences} times. Provide more surrounding context to make the match unique, or use replace_all to replace all occurrences.`
    );
    this.searchString = searchString;
    this.occurrences = occurrences;
    this.name = "StringNotUniqueError";
  }
};

// src/workspace/search/bm25.ts
var DEFAULT_STOPWORDS = /* @__PURE__ */ new Set([
  "a",
  "an",
  "and",
  "are",
  "as",
  "at",
  "be",
  "by",
  "for",
  "from",
  "has",
  "he",
  "in",
  "is",
  "it",
  "its",
  "of",
  "on",
  "or",
  "that",
  "the",
  "to",
  "was",
  "were",
  "will",
  "with"
]);
var DEFAULT_TOKENIZE_OPTIONS = {
  lowercase: true,
  removePunctuation: true,
  minLength: 2,
  stopwords: DEFAULT_STOPWORDS,
  splitPattern: /\s+/
};
function tokenize(text, options = {}) {
  const opts = { ...DEFAULT_TOKENIZE_OPTIONS, ...options };
  let processed = text;
  if (opts.lowercase) {
    processed = processed.toLowerCase();
  }
  if (opts.removePunctuation) {
    processed = processed.replace(/[^\w\s]/g, " ");
  }
  const tokens = processed.split(opts.splitPattern).filter((token) => {
    if (token.length < opts.minLength) {
      return false;
    }
    if (opts.stopwords?.has(token)) {
      return false;
    }
    return true;
  });
  return tokens;
}
function findLineRange(content, queryTerms, options = {}) {
  if (queryTerms.length === 0) return void 0;
  const lines = content.split("\n");
  const defaultOpts = { lowercase: true, removePunctuation: true, minLength: 2 };
  const opts = { ...defaultOpts, ...options };
  const normalizedTerms = new Set(queryTerms.map((t) => opts.lowercase ? t.toLowerCase() : t));
  let firstMatchLine;
  let lastMatchLine;
  for (let i = 0; i < lines.length; i++) {
    const lineTokens = tokenize(lines[i], options);
    for (const token of lineTokens) {
      if (normalizedTerms.has(token)) {
        const lineNum = i + 1;
        if (firstMatchLine === void 0) {
          firstMatchLine = lineNum;
        }
        lastMatchLine = lineNum;
        break;
      }
    }
  }
  if (firstMatchLine !== void 0 && lastMatchLine !== void 0) {
    return { start: firstMatchLine, end: lastMatchLine };
  }
  return void 0;
}
function computeTermFrequencies(tokens) {
  const frequencies = /* @__PURE__ */ new Map();
  for (const token of tokens) {
    frequencies.set(token, (frequencies.get(token) || 0) + 1);
  }
  return frequencies;
}
var BM25Index = class _BM25Index {
  /** BM25 k1 parameter */
  k1;
  /** BM25 b parameter */
  b;
  /** Documents in the index */
  #documents = /* @__PURE__ */ new Map();
  /** Inverted index: term -> document IDs containing the term */
  #invertedIndex = /* @__PURE__ */ new Map();
  /** Document frequency: term -> number of documents containing the term */
  #documentFrequency = /* @__PURE__ */ new Map();
  /** Average document length */
  #avgDocLength = 0;
  /** Total number of documents */
  #docCount = 0;
  /** Tokenization options */
  #tokenizeOptions;
  constructor(config = {}, tokenizeOptions = {}) {
    this.k1 = config.k1 ?? 1.5;
    this.b = config.b ?? 0.75;
    this.#tokenizeOptions = tokenizeOptions;
  }
  /**
   * Add a document to the index
   */
  add(id, content, metadata) {
    if (this.#documents.has(id)) {
      this.remove(id);
    }
    const tokens = tokenize(content, this.#tokenizeOptions);
    const termFrequencies = computeTermFrequencies(tokens);
    const doc = {
      id,
      content,
      tokens,
      termFrequencies,
      length: tokens.length,
      metadata
    };
    this.#documents.set(id, doc);
    this.#docCount++;
    for (const term of termFrequencies.keys()) {
      if (!this.#invertedIndex.has(term)) {
        this.#invertedIndex.set(term, /* @__PURE__ */ new Set());
      }
      this.#invertedIndex.get(term).add(id);
      this.#documentFrequency.set(term, (this.#documentFrequency.get(term) || 0) + 1);
    }
    this.#updateAvgDocLength();
  }
  /**
   * Remove a document from the index
   */
  remove(id) {
    const doc = this.#documents.get(id);
    if (!doc) {
      return false;
    }
    for (const term of doc.termFrequencies.keys()) {
      const docIds = this.#invertedIndex.get(term);
      if (docIds) {
        docIds.delete(id);
        if (docIds.size === 0) {
          this.#invertedIndex.delete(term);
          this.#documentFrequency.delete(term);
        } else {
          this.#documentFrequency.set(term, (this.#documentFrequency.get(term) || 1) - 1);
        }
      }
    }
    this.#documents.delete(id);
    this.#docCount--;
    this.#updateAvgDocLength();
    return true;
  }
  /**
   * Clear all documents from the index
   */
  clear() {
    this.#documents.clear();
    this.#invertedIndex.clear();
    this.#documentFrequency.clear();
    this.#docCount = 0;
    this.#avgDocLength = 0;
  }
  /**
   * Search for documents matching the query
   */
  search(query, topK = 10, minScore = 0) {
    const queryTokens = tokenize(query, this.#tokenizeOptions);
    if (queryTokens.length === 0 || this.#docCount === 0) {
      return [];
    }
    const scores = /* @__PURE__ */ new Map();
    for (const queryTerm of queryTokens) {
      const docIds = this.#invertedIndex.get(queryTerm);
      if (!docIds) {
        continue;
      }
      const df = this.#documentFrequency.get(queryTerm) || 0;
      const idf = this.#computeIDF(df);
      for (const docId of docIds) {
        const doc = this.#documents.get(docId);
        const tf = doc.termFrequencies.get(queryTerm) || 0;
        const termScore = this.#computeTermScore(tf, doc.length, idf);
        scores.set(docId, (scores.get(docId) || 0) + termScore);
      }
    }
    const results = [];
    for (const [docId, score] of scores.entries()) {
      if (score >= minScore) {
        const doc = this.#documents.get(docId);
        results.push({
          id: docId,
          content: doc.content,
          score,
          metadata: doc.metadata
        });
      }
    }
    results.sort((a, b) => b.score - a.score);
    return results.slice(0, topK);
  }
  /**
   * Get a document by ID
   */
  get(id) {
    return this.#documents.get(id);
  }
  /**
   * Check if a document exists in the index
   */
  has(id) {
    return this.#documents.has(id);
  }
  /**
   * Get the number of documents in the index
   */
  get size() {
    return this.#docCount;
  }
  /**
   * Get all document IDs
   */
  get documentIds() {
    return Array.from(this.#documents.keys());
  }
  /**
   * Serialize the index to a JSON-compatible object
   */
  serialize() {
    const documents = [];
    for (const [id, doc] of this.#documents.entries()) {
      documents.push({
        id,
        content: doc.content,
        tokens: doc.tokens,
        termFrequencies: Object.fromEntries(doc.termFrequencies),
        length: doc.length,
        metadata: doc.metadata
      });
    }
    return {
      k1: this.k1,
      b: this.b,
      documents,
      avgDocLength: this.#avgDocLength
    };
  }
  /**
   * Deserialize an index from a JSON object
   */
  static deserialize(data, tokenizeOptions = {}) {
    const index = new _BM25Index({ k1: data.k1, b: data.b }, tokenizeOptions);
    for (const doc of data.documents) {
      const termFrequencies = new Map(Object.entries(doc.termFrequencies));
      const document = {
        id: doc.id,
        content: doc.content,
        tokens: doc.tokens,
        termFrequencies,
        length: doc.length,
        metadata: doc.metadata
      };
      index.#documents.set(doc.id, document);
      index.#docCount++;
      for (const term of termFrequencies.keys()) {
        if (!index.#invertedIndex.has(term)) {
          index.#invertedIndex.set(term, /* @__PURE__ */ new Set());
        }
        index.#invertedIndex.get(term).add(doc.id);
        index.#documentFrequency.set(term, (index.#documentFrequency.get(term) || 0) + 1);
      }
    }
    index.#avgDocLength = data.avgDocLength;
    return index;
  }
  /**
   * Update average document length after add/remove operations
   */
  #updateAvgDocLength() {
    if (this.#docCount === 0) {
      this.#avgDocLength = 0;
      return;
    }
    let totalLength = 0;
    for (const doc of this.#documents.values()) {
      totalLength += doc.length;
    }
    this.#avgDocLength = totalLength / this.#docCount;
  }
  /**
   * Compute IDF (Inverse Document Frequency) for a term
   */
  #computeIDF(df) {
    return Math.log((this.#docCount - df + 0.5) / (df + 0.5) + 1);
  }
  /**
   * Compute the BM25 score component for a single term
   */
  #computeTermScore(tf, docLength, idf) {
    const numerator = tf * (this.k1 + 1);
    const denominator = tf + this.k1 * (1 - this.b + this.b * (docLength / this.#avgDocLength));
    return idf * (numerator / denominator);
  }
};

// src/workspace/search/search-engine.ts
var SearchEngine = class {
  /** BM25 index for keyword search */
  #bm25Index;
  /** Tokenization options (stored for lineRange computation) */
  #tokenizeOptions;
  /** Vector configuration */
  #vectorConfig;
  /** Whether to use lazy vector indexing */
  #lazyVectorIndex;
  /** Documents pending vector indexing (for lazy mode) */
  #pendingVectorDocs = [];
  /** Whether vector index has been built (for lazy mode) */
  #vectorIndexBuilt = false;
  constructor(config = {}) {
    if (config.bm25 !== void 0) {
      this.#tokenizeOptions = config.bm25.tokenize;
      this.#bm25Index = new BM25Index(config.bm25.bm25, this.#tokenizeOptions);
    }
    if (config.vector) {
      this.#vectorConfig = config.vector;
    }
    this.#lazyVectorIndex = config.lazyVectorIndex ?? false;
  }
  // ===========================================================================
  // Public API
  // ===========================================================================
  /**
   * Index a document for search
   */
  async index(doc) {
    const metadata = {
      ...doc.metadata
    };
    if (doc.startLineOffset !== void 0) {
      metadata._startLineOffset = doc.startLineOffset;
    }
    if (this.#bm25Index) {
      this.#bm25Index.add(doc.id, doc.content, metadata);
    }
    if (this.#vectorConfig) {
      const docWithMergedMetadata = { ...doc, metadata };
      if (this.#lazyVectorIndex) {
        this.#pendingVectorDocs.push(docWithMergedMetadata);
        this.#vectorIndexBuilt = false;
      } else {
        await this.#indexVector(docWithMergedMetadata);
      }
    }
  }
  /**
   * Index multiple documents
   */
  async indexMany(docs) {
    for (const doc of docs) {
      await this.index(doc);
    }
  }
  /**
   * Remove a document from the index
   */
  async remove(id) {
    if (this.#bm25Index) {
      this.#bm25Index.remove(id);
    }
    if (this.#vectorConfig) {
      try {
        await this.#vectorConfig.vectorStore.deleteVector({
          indexName: this.#vectorConfig.indexName,
          id
        });
      } catch {
      }
      if (this.#lazyVectorIndex) {
        this.#pendingVectorDocs = this.#pendingVectorDocs.filter((d) => d.id !== id);
      }
    }
  }
  /**
   * Clear all indexed documents
   */
  clear() {
    if (this.#bm25Index) {
      this.#bm25Index.clear();
    }
    this.#pendingVectorDocs = [];
    this.#vectorIndexBuilt = false;
  }
  /**
   * Search for documents
   */
  async search(query, options = {}) {
    const { topK = 10, minScore, mode, vectorWeight = 0.5, filter } = options;
    const effectiveMode = this.#determineSearchMode(mode);
    if (effectiveMode === "bm25") {
      return this.#searchBM25(query, topK, minScore);
    }
    if (effectiveMode === "vector") {
      return this.#searchVector(query, topK, minScore, filter);
    }
    return this.#searchHybrid(query, topK, minScore, vectorWeight, filter);
  }
  /**
   * Check if BM25 search is available
   */
  get canBM25() {
    return !!this.#bm25Index;
  }
  /**
   * Check if vector search is available
   */
  get canVector() {
    return !!this.#vectorConfig;
  }
  /**
   * Check if hybrid search is available
   */
  get canHybrid() {
    return this.canBM25 && this.canVector;
  }
  /**
   * Get the BM25 index (for serialization/debugging)
   */
  get bm25Index() {
    return this.#bm25Index;
  }
  // ===========================================================================
  // Private Methods
  // ===========================================================================
  /**
   * Determine the effective search mode
   */
  #determineSearchMode(requestedMode) {
    if (requestedMode) {
      if (requestedMode === "vector" && !this.canVector) {
        throw new Error("Vector search requires vector configuration.");
      }
      if (requestedMode === "bm25" && !this.canBM25) {
        throw new Error("BM25 search requires BM25 configuration.");
      }
      if (requestedMode === "hybrid" && !this.canHybrid) {
        throw new Error("Hybrid search requires both vector and BM25 configuration.");
      }
      return requestedMode;
    }
    if (this.canHybrid) {
      return "hybrid";
    }
    if (this.canVector) {
      return "vector";
    }
    if (this.canBM25) {
      return "bm25";
    }
    throw new Error("No search configuration available. Provide bm25 or vector config.");
  }
  /**
   * Index a single document in the vector store
   */
  async #indexVector(doc) {
    if (!this.#vectorConfig) return;
    const { vectorStore, embedder, indexName } = this.#vectorConfig;
    const embedding = await embedder(doc.content);
    await vectorStore.upsert({
      indexName,
      vectors: [embedding],
      metadata: [
        {
          id: doc.id,
          text: doc.content,
          ...doc.metadata
        }
      ],
      ids: [doc.id]
    });
  }
  /**
   * Ensure vector index is built (for lazy mode)
   */
  async #ensureVectorIndex() {
    if (!this.#lazyVectorIndex || this.#vectorIndexBuilt || this.#pendingVectorDocs.length === 0) {
      return;
    }
    for (const doc of this.#pendingVectorDocs) {
      await this.#indexVector(doc);
    }
    this.#pendingVectorDocs = [];
    this.#vectorIndexBuilt = true;
  }
  /**
   * BM25 keyword search
   */
  #searchBM25(query, topK, minScore) {
    if (!this.#bm25Index) {
      throw new Error("BM25 search requires BM25 configuration.");
    }
    const results = this.#bm25Index.search(query, topK, minScore);
    const queryTokens = tokenize(query, this.#tokenizeOptions);
    return results.map((result) => {
      const rawLineRange = findLineRange(result.content, queryTokens, this.#tokenizeOptions);
      const lineRange = this.#adjustLineRange(rawLineRange, result.metadata);
      const { _startLineOffset, ...cleanMetadata } = result.metadata ?? {};
      return {
        id: result.id,
        content: result.content,
        score: result.score,
        lineRange,
        metadata: Object.keys(cleanMetadata).length > 0 ? cleanMetadata : void 0,
        scoreDetails: { bm25: result.score }
      };
    });
  }
  /**
   * Vector semantic search
   */
  async #searchVector(query, topK, minScore, filter) {
    if (!this.#vectorConfig) {
      throw new Error("Vector search requires vector configuration.");
    }
    await this.#ensureVectorIndex();
    const { vectorStore, embedder, indexName } = this.#vectorConfig;
    const queryEmbedding = await embedder(query);
    const vectorResults = await vectorStore.query({
      indexName,
      queryVector: queryEmbedding,
      topK,
      filter
    });
    const queryTokens = tokenize(query, this.#tokenizeOptions);
    const results = [];
    for (const result of vectorResults) {
      if (minScore !== void 0 && result.score < minScore) {
        continue;
      }
      const id = result.metadata?.id ?? result.id;
      const content = result.metadata?.text ?? "";
      const { id: _id, text: _text, _startLineOffset, ...restMetadata } = result.metadata ?? {};
      const rawLineRange = findLineRange(content, queryTokens, this.#tokenizeOptions);
      const lineRange = this.#adjustLineRange(rawLineRange, result.metadata);
      results.push({
        id,
        content,
        score: result.score,
        lineRange,
        metadata: Object.keys(restMetadata).length > 0 ? restMetadata : void 0,
        scoreDetails: { vector: result.score }
      });
    }
    return results;
  }
  /**
   * Hybrid search combining vector and BM25 scores
   */
  async #searchHybrid(query, topK, minScore, vectorWeight = 0.5, filter) {
    const expandedTopK = Math.min(topK * 2, 50);
    const [vectorResults, bm25Results] = await Promise.all([
      this.#searchVector(query, expandedTopK, void 0, filter),
      Promise.resolve(this.#searchBM25(query, expandedTopK, void 0))
    ]);
    const normalizedBM25 = this.#normalizeBM25Scores(bm25Results);
    const bm25Map = /* @__PURE__ */ new Map();
    for (const result of normalizedBM25) {
      bm25Map.set(result.id, result);
    }
    const vectorMap = /* @__PURE__ */ new Map();
    for (const result of vectorResults) {
      vectorMap.set(result.id, result);
    }
    const combinedResults = /* @__PURE__ */ new Map();
    const allIds = /* @__PURE__ */ new Set([...vectorMap.keys(), ...bm25Map.keys()]);
    const bm25Weight = 1 - vectorWeight;
    for (const id of allIds) {
      const vectorResult = vectorMap.get(id);
      const bm25Result = bm25Map.get(id);
      const vectorScore = vectorResult?.scoreDetails?.vector ?? 0;
      const bm25Score = bm25Result?.score ?? 0;
      const combinedScore = vectorWeight * vectorScore + bm25Weight * bm25Score;
      const baseResult = vectorResult ?? bm25Result;
      combinedResults.set(id, {
        id,
        content: baseResult.content,
        score: combinedScore,
        lineRange: bm25Result?.lineRange ?? vectorResult?.lineRange,
        metadata: baseResult.metadata,
        scoreDetails: {
          vector: vectorResult?.scoreDetails?.vector,
          bm25: bm25Result?.scoreDetails?.bm25
        }
      });
    }
    let results = Array.from(combinedResults.values());
    results.sort((a, b) => b.score - a.score);
    if (minScore !== void 0) {
      results = results.filter((r) => r.score >= minScore);
    }
    return results.slice(0, topK);
  }
  /**
   * Normalize BM25 scores to 0-1 range using min-max normalization
   */
  #normalizeBM25Scores(results) {
    if (results.length === 0) return results;
    const scores = results.map((r) => r.scoreDetails?.bm25 ?? r.score);
    const maxScore = Math.max(...scores);
    const minScore = Math.min(...scores);
    const range = maxScore - minScore;
    if (range === 0) {
      return results.map((r) => ({ ...r, score: 1 }));
    }
    return results.map((r) => ({
      ...r,
      score: ((r.scoreDetails?.bm25 ?? r.score) - minScore) / range
    }));
  }
  /**
   * Adjust line range for chunked documents.
   * If the document has a _startLineOffset in metadata, adjust the line range
   * to reflect the original document's line numbers.
   */
  #adjustLineRange(lineRange, metadata) {
    if (!lineRange) return void 0;
    const startLineOffset = metadata?._startLineOffset;
    if (typeof startLineOffset !== "number") {
      return lineRange;
    }
    return {
      start: lineRange.start + startLineOffset - 1,
      end: lineRange.end + startLineOffset - 1
    };
  }
};

// src/workspace/skills/schemas.ts
var SKILL_LIMITS = {
  /** Recommended max tokens for instructions */
  MAX_INSTRUCTION_TOKENS: 5e3,
  /** Recommended max lines for SKILL.md */
  MAX_INSTRUCTION_LINES: 500,
  /** Max characters for name field */
  MAX_NAME_LENGTH: 64,
  /** Max characters for description field */
  MAX_DESCRIPTION_LENGTH: 1024};
function validateSkillName(name) {
  const errors = [];
  const fieldPath = "name";
  if (typeof name !== "string") {
    errors.push(`${fieldPath}: Expected string, received ${typeof name}`);
    return errors;
  }
  if (name.length === 0) {
    errors.push(`${fieldPath}: Skill name cannot be empty`);
    return errors;
  }
  if (name.length > SKILL_LIMITS.MAX_NAME_LENGTH) {
    errors.push(`${fieldPath}: Skill name must be ${SKILL_LIMITS.MAX_NAME_LENGTH} characters or less`);
  }
  if (!/^[a-z0-9-]+$/.test(name)) {
    errors.push(`${fieldPath}: Skill name must contain only lowercase letters, numbers, and hyphens`);
  }
  if (name.startsWith("-") || name.endsWith("-")) {
    errors.push(`${fieldPath}: Skill name must not start or end with a hyphen`);
  }
  if (name.includes("--")) {
    errors.push(`${fieldPath}: Skill name must not contain consecutive hyphens`);
  }
  return errors;
}
function validateSkillDescription(description) {
  const errors = [];
  const fieldPath = "description";
  if (typeof description !== "string") {
    errors.push(`${fieldPath}: Expected string, received ${typeof description}`);
    return errors;
  }
  if (description.length === 0) {
    errors.push(`${fieldPath}: Skill description cannot be empty`);
    return errors;
  }
  if (description.length > SKILL_LIMITS.MAX_DESCRIPTION_LENGTH) {
    errors.push(`${fieldPath}: Skill description must be ${SKILL_LIMITS.MAX_DESCRIPTION_LENGTH} characters or less`);
  }
  if (description.trim().length === 0) {
    errors.push(`${fieldPath}: Skill description cannot be only whitespace`);
  }
  return errors;
}
function validateSkillLicense(license) {
  const errors = [];
  const fieldPath = "license";
  if (license === void 0 || license === null) {
    return errors;
  }
  if (typeof license !== "string") {
    errors.push(`${fieldPath}: Expected string, received ${typeof license}`);
  }
  return errors;
}
function validateSkillCompatibility(_compatibility) {
  return [];
}
function validateSkillMetadataField(metadata) {
  const errors = [];
  const fieldPath = "metadata";
  if (metadata === void 0 || metadata === null) {
    return errors;
  }
  if (typeof metadata !== "object" || Array.isArray(metadata)) {
    errors.push(`${fieldPath}: Expected object, received ${Array.isArray(metadata) ? "array" : typeof metadata}`);
    return errors;
  }
  return errors;
}
function estimateTokens(text) {
  const words = text.split(/\s+/).filter(Boolean).length;
  return Math.ceil(words * 1.3);
}
function countLines(text) {
  return text.split("\n").length;
}
function validateSkillMetadata(metadata, dirName, instructions) {
  const errors = [];
  const warnings = [];
  if (typeof metadata !== "object" || metadata === null || Array.isArray(metadata)) {
    errors.push(
      `Expected object, received ${metadata === null ? "null" : Array.isArray(metadata) ? "array" : typeof metadata}`
    );
    return { valid: false, errors, warnings };
  }
  const data = metadata;
  errors.push(...validateSkillName(data.name));
  errors.push(...validateSkillDescription(data.description));
  errors.push(...validateSkillLicense(data.license));
  errors.push(...validateSkillCompatibility());
  errors.push(...validateSkillMetadataField(data.metadata));
  if (dirName && typeof data.name === "string" && data.name !== dirName) {
    errors.push(`Skill name "${data.name}" must match directory name "${dirName}"`);
  }
  if (instructions) {
    const lineCount = countLines(instructions);
    const tokenEstimate = estimateTokens(instructions);
    if (lineCount > SKILL_LIMITS.MAX_INSTRUCTION_LINES) {
      warnings.push(
        `Instructions have ${lineCount} lines (recommended: <${SKILL_LIMITS.MAX_INSTRUCTION_LINES}). Consider moving content to references/.`
      );
    }
    if (tokenEstimate > SKILL_LIMITS.MAX_INSTRUCTION_TOKENS) {
      warnings.push(
        `Instructions have ~${tokenEstimate} estimated tokens (recommended: <${SKILL_LIMITS.MAX_INSTRUCTION_TOKENS}). Consider moving content to references/.`
      );
    }
  }
  return {
    valid: errors.length === 0,
    errors,
    warnings
  };
}
var LocalSkillSource = class {
  #basePath;
  constructor(options = {}) {
    this.#basePath = options.basePath ?? process.cwd();
  }
  /**
   * Resolve a path relative to the base path.
   * Handles both absolute and relative paths.
   */
  #resolvePath(skillPath) {
    if (nodePath.isAbsolute(skillPath)) {
      return skillPath;
    }
    return nodePath.resolve(this.#basePath, skillPath);
  }
  async exists(skillPath) {
    return fsExists(this.#resolvePath(skillPath));
  }
  async stat(skillPath) {
    return fsStat(this.#resolvePath(skillPath), skillPath);
  }
  async readFile(skillPath) {
    const resolved = this.#resolvePath(skillPath);
    const content = await fs2.readFile(resolved);
    if (isTextFile(skillPath)) {
      return content.toString("utf-8");
    }
    return content;
  }
  async readdir(skillPath) {
    const resolved = this.#resolvePath(skillPath);
    const entries = await fs2.readdir(resolved, { withFileTypes: true });
    return entries.map((entry) => ({
      name: entry.name,
      type: entry.isDirectory() ? "directory" : "file"
    }));
  }
};
var WorkspaceSkillsImpl = class {
  #source;
  #skillsResolver;
  #searchEngine;
  #validateOnLoad;
  /** Map of skill name -> full skill data */
  #skills = /* @__PURE__ */ new Map();
  /** Whether skills have been discovered */
  #initialized = false;
  /** Promise for ongoing initialization (prevents concurrent discovery) */
  #initPromise = null;
  /** Timestamp of last skills discovery (for staleness check) */
  #lastDiscoveryTime = 0;
  /** Currently resolved skills paths (used to detect changes) */
  #resolvedPaths = [];
  constructor(config) {
    this.#source = config.source;
    this.#skillsResolver = config.skills;
    this.#searchEngine = config.searchEngine;
    this.#validateOnLoad = config.validateOnLoad ?? true;
  }
  // ===========================================================================
  // Discovery
  // ===========================================================================
  async list() {
    await this.#ensureInitialized();
    return Array.from(this.#skills.values()).map((skill) => ({
      name: skill.name,
      description: skill.description,
      license: skill.license,
      compatibility: skill.compatibility,
      metadata: skill.metadata
    }));
  }
  async get(name) {
    await this.#ensureInitialized();
    const skill = this.#skills.get(name);
    if (!skill) return null;
    const { indexableContent: _, ...skillData } = skill;
    return skillData;
  }
  async has(name) {
    await this.#ensureInitialized();
    return this.#skills.has(name);
  }
  async refresh() {
    this.#skills.clear();
    this.#searchEngine?.clear();
    this.#initialized = false;
    this.#initPromise = null;
    await this.#discoverSkills();
    this.#initialized = true;
  }
  async maybeRefresh(context) {
    await this.#ensureInitialized();
    const currentPaths = await this.#resolvePaths(context);
    const pathsChanged = !this.#arePathsEqual(this.#resolvedPaths, currentPaths);
    if (pathsChanged) {
      this.#resolvedPaths = currentPaths;
      await this.refresh();
      return;
    }
    const isStale = await this.#isSkillsPathStale();
    if (isStale) {
      await this.refresh();
    }
  }
  /**
   * Resolve skills paths from the resolver (static array or function).
   */
  async #resolvePaths(context) {
    if (Array.isArray(this.#skillsResolver)) {
      return this.#skillsResolver;
    }
    return this.#skillsResolver(context ?? {});
  }
  /**
   * Compare two path arrays for equality (order-independent).
   */
  #arePathsEqual(a, b) {
    if (a.length !== b.length) return false;
    const sortedA = [...a].sort();
    const sortedB = [...b].sort();
    return sortedA.every((path4, i) => path4 === sortedB[i]);
  }
  // ===========================================================================
  // Search
  // ===========================================================================
  async search(query, options = {}) {
    await this.#ensureInitialized();
    if (!this.#searchEngine) {
      return this.#simpleSearch(query, options);
    }
    const { topK = 5, minScore, skillNames, includeReferences = true, mode } = options;
    const expandedTopK = skillNames ? topK * 3 : topK;
    const searchResults = await this.#searchEngine.search(query, {
      topK: expandedTopK,
      minScore,
      mode
    });
    const results = [];
    for (const result of searchResults) {
      const skillName = result.metadata?.skillName;
      const source = result.metadata?.source;
      if (!skillName || !source) continue;
      if (skillNames && !skillNames.includes(skillName)) {
        continue;
      }
      if (!includeReferences && source !== "SKILL.md") {
        continue;
      }
      results.push({
        skillName,
        source,
        content: result.content,
        score: result.score,
        lineRange: result.lineRange,
        scoreDetails: result.scoreDetails
      });
      if (results.length >= topK) break;
    }
    return results;
  }
  // ===========================================================================
  // Single-item Accessors
  // ===========================================================================
  async getReference(skillName, referencePath) {
    await this.#ensureInitialized();
    const skill = this.#skills.get(skillName);
    if (!skill) return null;
    const safeRefPath = this.#assertRelativePath(referencePath, "reference");
    const refFilePath = this.#joinPath(skill.path, "references", safeRefPath);
    if (!await this.#source.exists(refFilePath)) {
      return null;
    }
    try {
      const content = await this.#source.readFile(refFilePath);
      return typeof content === "string" ? content : content.toString("utf-8");
    } catch {
      return null;
    }
  }
  async getScript(skillName, scriptPath) {
    await this.#ensureInitialized();
    const skill = this.#skills.get(skillName);
    if (!skill) return null;
    const safeScriptPath = this.#assertRelativePath(scriptPath, "script");
    const scriptFilePath = this.#joinPath(skill.path, "scripts", safeScriptPath);
    if (!await this.#source.exists(scriptFilePath)) {
      return null;
    }
    try {
      const content = await this.#source.readFile(scriptFilePath);
      return typeof content === "string" ? content : content.toString("utf-8");
    } catch {
      return null;
    }
  }
  async getAsset(skillName, assetPath) {
    await this.#ensureInitialized();
    const skill = this.#skills.get(skillName);
    if (!skill) return null;
    const safeAssetPath = this.#assertRelativePath(assetPath, "asset");
    const assetFilePath = this.#joinPath(skill.path, "assets", safeAssetPath);
    if (!await this.#source.exists(assetFilePath)) {
      return null;
    }
    try {
      const content = await this.#source.readFile(assetFilePath);
      return typeof content === "string" ? Buffer.from(content, "utf-8") : content;
    } catch {
      return null;
    }
  }
  // ===========================================================================
  // Listing Accessors
  // ===========================================================================
  async listReferences(skillName) {
    await this.#ensureInitialized();
    const skill = this.#skills.get(skillName);
    return skill?.references ?? [];
  }
  async listScripts(skillName) {
    await this.#ensureInitialized();
    const skill = this.#skills.get(skillName);
    return skill?.scripts ?? [];
  }
  async listAssets(skillName) {
    await this.#ensureInitialized();
    const skill = this.#skills.get(skillName);
    return skill?.assets ?? [];
  }
  // ===========================================================================
  // Private Methods
  // ===========================================================================
  /**
   * Ensure skills have been discovered.
   * Uses a promise to prevent concurrent discovery.
   */
  async #ensureInitialized() {
    if (this.#initialized) {
      return;
    }
    if (this.#initPromise) {
      await this.#initPromise;
      return;
    }
    this.#initPromise = (async () => {
      try {
        if (this.#resolvedPaths.length === 0) {
          this.#resolvedPaths = await this.#resolvePaths();
        }
        await this.#discoverSkills();
        this.#initialized = true;
      } finally {
        this.#initPromise = null;
      }
    })();
    await this.#initPromise;
  }
  /**
   * Discover skills from all skills paths.
   * Uses currently resolved paths (must be set before calling).
   */
  async #discoverSkills() {
    for (const skillsPath of this.#resolvedPaths) {
      const source = this.#determineSource(skillsPath);
      await this.#discoverSkillsInPath(skillsPath, source);
    }
    this.#lastDiscoveryTime = Date.now();
  }
  /**
   * Discover skills in a single path
   */
  async #discoverSkillsInPath(skillsPath, source) {
    if (!await this.#source.exists(skillsPath)) {
      return;
    }
    try {
      const entries = await this.#source.readdir(skillsPath);
      for (const entry of entries) {
        if (entry.type !== "directory") continue;
        const entryPath = this.#joinPath(skillsPath, entry.name);
        const skillFilePath = this.#joinPath(entryPath, "SKILL.md");
        if (await this.#source.exists(skillFilePath)) {
          try {
            const skill = await this.#parseSkillFile(skillFilePath, entry.name, source);
            this.#skills.set(skill.name, skill);
            await this.#indexSkill(skill);
          } catch (error) {
            if (error instanceof Error) {
              console.error(`[WorkspaceSkills] Failed to load skill from ${skillFilePath}:`, error.message);
            }
          }
        }
      }
    } catch (error) {
      if (error instanceof Error) {
        console.error(`[WorkspaceSkills] Failed to scan skills directory ${skillsPath}:`, error.message);
      }
    }
  }
  /**
   * Check if any skills path directory has been modified since last discovery.
   * Compares directory mtime to lastDiscoveryTime.
   */
  async #isSkillsPathStale() {
    if (this.#lastDiscoveryTime === 0) {
      return true;
    }
    for (const skillsPath of this.#resolvedPaths) {
      try {
        const stat3 = await this.#source.stat(skillsPath);
        const mtime = stat3.modifiedAt.getTime();
        if (mtime > this.#lastDiscoveryTime) {
          return true;
        }
        const entries = await this.#source.readdir(skillsPath);
        for (const entry of entries) {
          if (entry.type !== "directory") continue;
          const entryPath = this.#joinPath(skillsPath, entry.name);
          try {
            const entryStat = await this.#source.stat(entryPath);
            if (entryStat.modifiedAt.getTime() > this.#lastDiscoveryTime) {
              return true;
            }
          } catch {
          }
        }
      } catch {
        continue;
      }
    }
    return false;
  }
  /**
   * Parse a SKILL.md file
   */
  async #parseSkillFile(filePath, dirName, source) {
    const rawContent = await this.#source.readFile(filePath);
    const content = typeof rawContent === "string" ? rawContent : rawContent.toString("utf-8");
    const parsed = matter(content);
    const frontmatter = parsed.data;
    const body = parsed.content.trim();
    const metadata = {
      name: frontmatter.name,
      description: frontmatter.description,
      license: frontmatter.license,
      compatibility: frontmatter.compatibility,
      metadata: frontmatter.metadata
    };
    if (this.#validateOnLoad) {
      const validation = this.#validateSkillMetadata(metadata, dirName, body);
      if (!validation.valid) {
        throw new Error(`Invalid skill metadata in ${filePath}:
${validation.errors.join("\n")}`);
      }
    }
    const skillPath = this.#getParentPath(filePath);
    const references = await this.#discoverFilesInSubdir(skillPath, "references");
    const scripts = await this.#discoverFilesInSubdir(skillPath, "scripts");
    const assets = await this.#discoverFilesInSubdir(skillPath, "assets");
    const indexableContent = await this.#buildIndexableContent(body, skillPath, references);
    return {
      ...metadata,
      path: skillPath,
      instructions: body,
      source,
      references,
      scripts,
      assets,
      indexableContent
    };
  }
  /**
   * Validate skill metadata (delegates to shared validation function)
   */
  #validateSkillMetadata(metadata, dirName, instructions) {
    const result = validateSkillMetadata(metadata, dirName, instructions);
    if (result.warnings.length > 0) {
      for (const warning of result.warnings) {
        console.warn(`[WorkspaceSkills] ${metadata.name}: ${warning}`);
      }
    }
    return result;
  }
  /**
   * Discover files in a subdirectory of a skill (references/, scripts/, assets/)
   */
  async #discoverFilesInSubdir(skillPath, subdir) {
    const subdirPath = this.#joinPath(skillPath, subdir);
    const files = [];
    if (!await this.#source.exists(subdirPath)) {
      return files;
    }
    try {
      await this.#walkDirectory(subdirPath, subdirPath, (relativePath) => {
        files.push(relativePath);
      });
    } catch {
    }
    return files;
  }
  /**
   * Walk a directory recursively and call callback for each file.
   * Limited to maxDepth (default 20) to prevent stack overflow on deep hierarchies.
   */
  async #walkDirectory(basePath, dirPath, callback, depth = 0, maxDepth = 20) {
    if (depth >= maxDepth) {
      return;
    }
    const entries = await this.#source.readdir(dirPath);
    for (const entry of entries) {
      const entryPath = this.#joinPath(dirPath, entry.name);
      if (entry.type === "directory") {
        await this.#walkDirectory(basePath, entryPath, callback, depth + 1, maxDepth);
      } else {
        const relativePath = entryPath.substring(basePath.length + 1);
        callback(relativePath);
      }
    }
  }
  /**
   * Build indexable content from instructions and references
   */
  async #buildIndexableContent(instructions, skillPath, references) {
    const parts = [instructions];
    for (const refPath of references) {
      const fullPath = this.#joinPath(skillPath, "references", refPath);
      try {
        const rawContent = await this.#source.readFile(fullPath);
        const content = typeof rawContent === "string" ? rawContent : rawContent.toString("utf-8");
        parts.push(content);
      } catch {
      }
    }
    return parts.join("\n\n");
  }
  /**
   * Index a skill for search
   */
  async #indexSkill(skill) {
    if (!this.#searchEngine) return;
    await this.#searchEngine.index({
      id: `skill:${skill.name}:SKILL.md`,
      content: skill.instructions,
      metadata: {
        skillName: skill.name,
        source: "SKILL.md"
      }
    });
    for (const refPath of skill.references) {
      const fullPath = this.#joinPath(skill.path, "references", refPath);
      try {
        const rawContent = await this.#source.readFile(fullPath);
        const content = typeof rawContent === "string" ? rawContent : rawContent.toString("utf-8");
        await this.#searchEngine.index({
          id: `skill:${skill.name}:${refPath}`,
          content,
          metadata: {
            skillName: skill.name,
            source: `references/${refPath}`
          }
        });
      } catch {
      }
    }
  }
  /**
   * Simple text search fallback when no search engine is configured
   */
  async #simpleSearch(query, options) {
    const { topK = 5, skillNames, includeReferences = true } = options;
    const queryLower = query.toLowerCase();
    const results = [];
    for (const skill of this.#skills.values()) {
      if (skillNames && !skillNames.includes(skill.name)) {
        continue;
      }
      if (skill.instructions.toLowerCase().includes(queryLower)) {
        results.push({
          skillName: skill.name,
          source: "SKILL.md",
          content: skill.instructions.substring(0, 200),
          score: 1
        });
      }
      if (includeReferences) {
        for (const refPath of skill.references) {
          if (results.length >= topK) break;
          const content = await this.getReference(skill.name, refPath);
          if (content && content.toLowerCase().includes(queryLower)) {
            results.push({
              skillName: skill.name,
              source: `references/${refPath}`,
              content: content.substring(0, 200),
              score: 0.8
            });
          }
        }
      }
      if (results.length >= topK) break;
    }
    return results.slice(0, topK);
  }
  /**
   * Determine the source type based on the path
   */
  #determineSource(skillsPath) {
    const segments = skillsPath.split("/");
    if (segments.includes("node_modules")) {
      return { type: "external", packagePath: skillsPath };
    }
    if (skillsPath.includes("/.mastra/skills") || skillsPath.startsWith(".mastra/skills")) {
      return { type: "managed", mastraPath: skillsPath };
    }
    return { type: "local", projectPath: skillsPath };
  }
  /**
   * Join path segments (workspace paths use forward slashes)
   */
  #joinPath(...segments) {
    return segments.map((seg, i) => {
      if (i === 0) return seg.replace(/\/+$/, "");
      return seg.replace(/^\/+|\/+$/g, "");
    }).filter(Boolean).join("/");
  }
  /**
   * Validate and normalize a relative path to prevent directory traversal.
   * Throws if the path contains traversal segments (..) or is absolute.
   */
  #assertRelativePath(input, label) {
    const normalized = input.replace(/\\/g, "/");
    const segments = normalized.split("/").filter(Boolean);
    if (normalized.startsWith("/") || segments.some((seg) => seg === "." || seg === "..")) {
      throw new Error(`Invalid ${label} path: ${input}`);
    }
    return segments.join("/");
  }
  /**
   * Get parent path
   */
  #getParentPath(path4) {
    const lastSlash = path4.lastIndexOf("/");
    return lastSlash > 0 ? path4.substring(0, lastSlash) : "/";
  }
};

// src/workspace/workspace.ts
var Workspace = class {
  id;
  name;
  createdAt;
  lastAccessedAt;
  _status = "pending";
  _fs;
  _sandbox;
  _config;
  _searchEngine;
  _skills;
  constructor(config) {
    this.id = config.id ?? this.generateId();
    this.name = config.name ?? `workspace-${this.id.slice(0, 8)}`;
    this.createdAt = /* @__PURE__ */ new Date();
    this.lastAccessedAt = /* @__PURE__ */ new Date();
    this._config = config;
    this._sandbox = config.sandbox;
    if (config.mounts && Object.keys(config.mounts).length > 0) {
      if (config.filesystem) {
        throw new WorkspaceError('Cannot use both "filesystem" and "mounts"', "INVALID_CONFIG");
      }
      this._fs = new CompositeFilesystem({ mounts: config.mounts });
      if (this._sandbox?.mounts) {
        this._sandbox.mounts.setContext({ sandbox: this._sandbox, workspace: this });
        this._sandbox.mounts.add(config.mounts);
        if (config.onMount) {
          this._sandbox.mounts.setOnMount(config.onMount);
        }
      }
    } else {
      this._fs = config.filesystem;
    }
    if (config.vectorStore && !config.embedder) {
      throw new WorkspaceError("vectorStore requires an embedder", "INVALID_SEARCH_CONFIG");
    }
    if (config.bm25 || config.vectorStore && config.embedder) {
      const buildIndexName = () => {
        const defaultName = `${this.id}_search`.replace(/[^a-zA-Z0-9_]/g, "_");
        const indexName = config.searchIndexName ?? defaultName;
        if (!/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(indexName)) {
          throw new WorkspaceError(
            `Invalid searchIndexName: "${indexName}". Must start with a letter or underscore, and contain only letters, numbers, or underscores.`,
            "INVALID_SEARCH_CONFIG",
            this.id
          );
        }
        if (indexName.length > 63) {
          throw new WorkspaceError(
            `searchIndexName exceeds 63 characters (got ${indexName.length})`,
            "INVALID_SEARCH_CONFIG",
            this.id
          );
        }
        return indexName;
      };
      this._searchEngine = new SearchEngine({
        bm25: config.bm25 ? {
          bm25: typeof config.bm25 === "object" ? config.bm25 : void 0
        } : void 0,
        vector: config.vectorStore && config.embedder ? {
          vectorStore: config.vectorStore,
          embedder: config.embedder,
          indexName: buildIndexName()
        } : void 0
      });
    }
    if (!this._fs && !this._sandbox && !this.hasSkillsConfig()) {
      throw new WorkspaceError("Workspace requires at least a filesystem, sandbox, or skills", "NO_PROVIDERS");
    }
  }
  generateId() {
    return `ws-${Date.now().toString(36)}-${Math.random().toString(36).slice(2, 8)}`;
  }
  hasSkillsConfig() {
    return this._config.skills !== void 0 && (typeof this._config.skills === "function" || this._config.skills.length > 0);
  }
  get status() {
    return this._status;
  }
  /**
   * The filesystem provider (if configured).
   */
  get filesystem() {
    return this._fs;
  }
  /**
   * The sandbox provider (if configured).
   */
  get sandbox() {
    return this._sandbox;
  }
  /**
   * Get the per-tool configuration for this workspace.
   * Returns undefined if no tools config was provided.
   */
  getToolsConfig() {
    return this._config.tools;
  }
  /**
   * Access skills stored in this workspace.
   * Skills are SKILL.md files discovered from the configured skillPaths.
   *
   * Returns undefined if no skillPaths are configured.
   *
   * @example
   * ```typescript
   * const skills = await workspace.skills?.list();
   * const skill = await workspace.skills?.get('brand-guidelines');
   * const results = await workspace.skills?.search('brand colors');
   * ```
   */
  get skills() {
    if (!this.hasSkillsConfig()) {
      return void 0;
    }
    if (!this._skills) {
      const source = this._fs ?? new LocalSkillSource();
      this._skills = new WorkspaceSkillsImpl({
        source,
        skills: this._config.skills,
        searchEngine: this._searchEngine,
        validateOnLoad: true
      });
    }
    return this._skills;
  }
  // ---------------------------------------------------------------------------
  // Search Capabilities
  // ---------------------------------------------------------------------------
  /**
   * Check if BM25 keyword search is available.
   */
  get canBM25() {
    return this._searchEngine?.canBM25 ?? false;
  }
  /**
   * Check if vector semantic search is available.
   */
  get canVector() {
    return this._searchEngine?.canVector ?? false;
  }
  /**
   * Check if hybrid search is available.
   */
  get canHybrid() {
    return this._searchEngine?.canHybrid ?? false;
  }
  // ---------------------------------------------------------------------------
  // Search Operations
  // ---------------------------------------------------------------------------
  /**
   * Index content for search.
   * The path becomes the document ID in search results.
   *
   * @param path - File path (used as document ID)
   * @param content - Text content to index
   * @param options - Index options (metadata, type hints)
   * @throws {SearchNotAvailableError} if search is not configured
   */
  async index(path4, content, options) {
    if (!this._searchEngine) {
      throw new SearchNotAvailableError();
    }
    this.lastAccessedAt = /* @__PURE__ */ new Date();
    const doc = {
      id: path4,
      content,
      metadata: {
        type: options?.type,
        mimeType: options?.mimeType,
        ...options?.metadata
      },
      startLineOffset: options?.startLineOffset
    };
    await this._searchEngine.index(doc);
  }
  /**
   * Search indexed content.
   *
   * @param query - Search query string
   * @param options - Search options (topK, mode, filters)
   * @returns Array of search results
   * @throws {SearchNotAvailableError} if search is not configured
   */
  async search(query, options) {
    if (!this._searchEngine) {
      throw new SearchNotAvailableError();
    }
    this.lastAccessedAt = /* @__PURE__ */ new Date();
    return this._searchEngine.search(query, options);
  }
  /**
   * Rebuild the search index from filesystem paths.
   * Used internally for auto-indexing on init.
   */
  async rebuildSearchIndex(paths) {
    if (!this._searchEngine || !this._fs || paths.length === 0) {
      return;
    }
    this._searchEngine.clear();
    for (const basePath of paths) {
      try {
        const files = await this.getAllFiles(basePath);
        for (const filePath of files) {
          try {
            const content = await this._fs.readFile(filePath, { encoding: "utf-8" });
            await this._searchEngine.index({
              id: filePath,
              content
            });
          } catch {
          }
        }
      } catch {
      }
    }
  }
  async getAllFiles(dir) {
    if (!this._fs) return [];
    const files = [];
    const entries = await this._fs.readdir(dir);
    for (const entry of entries) {
      const fullPath = dir === "/" ? `/${entry.name}` : `${dir}/${entry.name}`;
      if (entry.type === "file") {
        files.push(fullPath);
      } else if (entry.type === "directory" && !entry.isSymlink) {
        files.push(...await this.getAllFiles(fullPath));
      }
    }
    return files;
  }
  // ---------------------------------------------------------------------------
  // Lifecycle
  // ---------------------------------------------------------------------------
  /**
   * Initialize the workspace.
   * Starts the sandbox, initializes the filesystem, and auto-mounts filesystems.
   */
  async init() {
    this._status = "initializing";
    try {
      if (this._fs) {
        await callLifecycle(this._fs, "init");
      }
      if (this._sandbox) {
        await callLifecycle(this._sandbox, "start");
      }
      if (this._searchEngine && this._config.autoIndexPaths && this._config.autoIndexPaths.length > 0) {
        await this.rebuildSearchIndex(this._config.autoIndexPaths ?? []);
      }
      this._status = "ready";
    } catch (error) {
      this._status = "error";
      throw error;
    }
  }
  /**
   * Destroy the workspace and clean up all resources.
   */
  async destroy() {
    this._status = "destroying";
    try {
      if (this._sandbox) {
        await callLifecycle(this._sandbox, "destroy");
      }
      if (this._fs) {
        await callLifecycle(this._fs, "destroy");
      }
      this._status = "destroyed";
    } catch (error) {
      this._status = "error";
      throw error;
    }
  }
  /**
   * Get workspace information.
   * @param options.includeFileCount - Whether to count total files (can be slow for large workspaces)
   */
  async getInfo(options) {
    const info = {
      id: this.id,
      name: this.name,
      status: this._status,
      createdAt: this.createdAt,
      lastAccessedAt: this.lastAccessedAt
    };
    if (this._fs) {
      const fsInfo = await this._fs.getInfo?.();
      info.filesystem = {
        id: fsInfo?.id ?? this._fs.id,
        name: fsInfo?.name ?? this._fs.name,
        provider: fsInfo?.provider ?? this._fs.provider,
        readOnly: fsInfo?.readOnly ?? this._fs.readOnly,
        status: fsInfo?.status,
        error: fsInfo?.error,
        icon: fsInfo?.icon,
        metadata: fsInfo?.metadata
      };
      if (options?.includeFileCount) {
        try {
          const files = await this.getAllFiles("/");
          info.filesystem.totalFiles = files.length;
        } catch {
        }
      }
    }
    if (this._sandbox) {
      const sandboxInfo = await this._sandbox.getInfo?.();
      info.sandbox = {
        provider: this._sandbox.provider,
        status: sandboxInfo?.status ?? this._sandbox.status,
        resources: sandboxInfo?.resources
      };
    }
    return info;
  }
  /**
   * Get information about how filesystem and sandbox paths relate.
   * Useful for understanding how to access workspace files from sandbox code.
   *
   * @returns PathContext with paths and instructions from providers
   */
  getPathContext() {
    const fsInstructions = this._fs?.getInstructions?.();
    const sandboxInstructions = this._sandbox?.getInstructions?.();
    const instructions = [fsInstructions, sandboxInstructions].filter(Boolean).join(" ");
    return {
      filesystem: this._fs ? {
        provider: this._fs.provider,
        basePath: this._fs.basePath
      } : void 0,
      sandbox: this._sandbox ? {
        provider: this._sandbox.provider,
        workingDirectory: this._sandbox.workingDirectory
      } : void 0,
      instructions
    };
  }
  // ---------------------------------------------------------------------------
  // Logger Integration
  // ---------------------------------------------------------------------------
  /**
   * Set the logger for this workspace and propagate to providers.
   * Called by Mastra when the logger is set.
   * @internal
   */
  __setLogger(logger) {
    if (this._fs instanceof MastraFilesystem) {
      this._fs.__setLogger(logger);
    }
    if (this._sandbox instanceof MastraSandbox) {
      this._sandbox.__setLogger(logger);
    }
  }
};
function commandExists(command) {
  try {
    execFileSync("which", [command], { stdio: "ignore" });
    return true;
  } catch {
    return false;
  }
}
function isSeatbeltAvailable() {
  if (os__default.platform() !== "darwin") {
    return false;
  }
  return commandExists("sandbox-exec");
}
function isBwrapAvailable() {
  if (os__default.platform() !== "linux") {
    return false;
  }
  return commandExists("bwrap");
}
function detectIsolation() {
  const platform2 = os__default.platform();
  if (platform2 === "darwin") {
    const available = isSeatbeltAvailable();
    return {
      backend: "seatbelt",
      available,
      message: available ? "macOS seatbelt (sandbox-exec) is available" : "macOS seatbelt (sandbox-exec) not found - this is unexpected on macOS"
    };
  }
  if (platform2 === "linux") {
    const available = isBwrapAvailable();
    return {
      backend: "bwrap",
      available,
      message: available ? "Linux bubblewrap (bwrap) is available" : "Linux bubblewrap (bwrap) not found. Install with: apt install bubblewrap (Debian/Ubuntu) or dnf install bubblewrap (Fedora)"
    };
  }
  return {
    backend: "none",
    available: false,
    message: `Native sandboxing is not supported on ${platform2}. Commands will run without isolation.`
  };
}
function isIsolationAvailable(backend) {
  switch (backend) {
    case "seatbelt":
      return isSeatbeltAvailable();
    case "bwrap":
      return isBwrapAvailable();
    case "none":
      return true;
    default:
      return false;
  }
}
function getRecommendedIsolation() {
  const result = detectIsolation();
  return result.available ? result.backend : "none";
}

// src/workspace/sandbox/native-sandbox/seatbelt.ts
var MACH_SERVICES = [
  "com.apple.distributed_notifications@Uv3",
  "com.apple.logd",
  "com.apple.system.logger",
  "com.apple.system.notification_center",
  "com.apple.system.opendirectoryd.libinfo",
  "com.apple.system.opendirectoryd.membership",
  "com.apple.bsd.dirhelper",
  "com.apple.securityd.xpc",
  "com.apple.SecurityServer",
  "com.apple.trustd.agent"
];
function escapePath(pathStr) {
  return JSON.stringify(pathStr);
}
function generateSeatbeltProfile(workspacePath, config) {
  if (config.allowSystemBinaries === false) {
    throw new Error(
      "allowSystemBinaries: false is not supported by seatbelt (macOS). Use bubblewrap on Linux or remove this restriction."
    );
  }
  const lines = [];
  lines.push("(version 1)");
  lines.push('(deny default (with message "mastra-sandbox"))');
  lines.push("");
  lines.push("; Process permissions");
  lines.push("(allow process-exec)");
  lines.push("(allow process-fork)");
  lines.push("(allow process-info* (target same-sandbox))");
  lines.push("(allow signal (target same-sandbox))");
  lines.push("");
  lines.push("; Mach IPC");
  lines.push("(allow mach-lookup");
  for (const service of MACH_SERVICES) {
    lines.push(`  (global-name "${service}")`);
  }
  lines.push(")");
  lines.push("");
  lines.push("; IPC");
  lines.push("(allow ipc-posix-shm)");
  lines.push("(allow ipc-posix-sem)");
  lines.push("");
  lines.push("; User preferences");
  lines.push("(allow user-preference-read)");
  lines.push("");
  lines.push("; sysctl");
  lines.push("(allow sysctl-read)");
  lines.push("");
  lines.push("; Device files");
  lines.push('(allow file-ioctl (literal "/dev/null"))');
  lines.push('(allow file-ioctl (literal "/dev/zero"))');
  lines.push('(allow file-ioctl (literal "/dev/random"))');
  lines.push('(allow file-ioctl (literal "/dev/urandom"))');
  lines.push('(allow file-ioctl (literal "/dev/tty"))');
  lines.push("");
  lines.push("; File read access (allow all - macOS sandbox limitation)");
  lines.push("(allow file-read*)");
  for (const p of config.readOnlyPaths ?? []) {
    lines.push(`(allow file-read* (subpath ${escapePath(p)}))`);
  }
  lines.push("");
  lines.push("; File write access (restricted to workspace and temp)");
  lines.push(`(allow file-write* (subpath ${escapePath(workspacePath)}))`);
  lines.push('(allow file-write* (subpath "/private/tmp"))');
  lines.push('(allow file-write* (subpath "/var/folders"))');
  lines.push('(allow file-write* (subpath "/private/var/folders"))');
  for (const p of config.readWritePaths ?? []) {
    lines.push(`(allow file-write* (subpath ${escapePath(p)}))`);
  }
  lines.push("");
  lines.push("; Network");
  if (config.allowNetwork) {
    lines.push("(allow network*)");
  } else {
    lines.push('(deny network* (with message "mastra-sandbox-network"))');
  }
  return lines.join("\n");
}
function buildSeatbeltCommand(command, args, profile) {
  return {
    command: "sandbox-exec",
    args: ["-p", profile, command, ...args]
  };
}

// src/workspace/sandbox/native-sandbox/bubblewrap.ts
var DEFAULT_READONLY_BINDS = [
  "/usr",
  "/lib",
  "/lib64",
  "/bin",
  "/sbin",
  "/etc/alternatives",
  "/etc/ssl",
  "/etc/ca-certificates",
  "/etc/resolv.conf",
  "/etc/hosts",
  "/etc/passwd",
  "/etc/group",
  "/etc/nsswitch.conf",
  "/etc/ld.so.cache",
  "/etc/localtime"
];
function buildBwrapCommand(command, args, workspacePath, config) {
  if (config.bwrapArgs && config.bwrapArgs.length > 0) {
    return {
      command: "bwrap",
      args: [...config.bwrapArgs, "--", command, ...args]
    };
  }
  const bwrapArgs = [];
  bwrapArgs.push("--unshare-pid");
  bwrapArgs.push("--unshare-ipc");
  bwrapArgs.push("--unshare-uts");
  if (!config.allowNetwork) {
    bwrapArgs.push("--unshare-net");
  }
  bwrapArgs.push("--proc", "/proc");
  bwrapArgs.push("--tmpfs", "/tmp");
  for (const path4 of DEFAULT_READONLY_BINDS) {
    bwrapArgs.push("--ro-bind-try", path4, path4);
  }
  for (const path4 of config.readOnlyPaths ?? []) {
    bwrapArgs.push("--ro-bind", path4, path4);
  }
  if (config.allowSystemBinaries !== false) {
    const nodePath3 = process.execPath;
    const nodeDir = nodePath3.substring(0, nodePath3.lastIndexOf("/"));
    if (!DEFAULT_READONLY_BINDS.some((p) => nodeDir.startsWith(p))) {
      bwrapArgs.push("--ro-bind", nodeDir, nodeDir);
    }
    bwrapArgs.push("--ro-bind-try", "/opt", "/opt");
    bwrapArgs.push("--ro-bind-try", "/snap", "/snap");
  }
  bwrapArgs.push("--bind", workspacePath, workspacePath);
  for (const path4 of config.readWritePaths ?? []) {
    bwrapArgs.push("--bind", path4, path4);
  }
  bwrapArgs.push("--chdir", workspacePath);
  bwrapArgs.push("--die-with-parent");
  bwrapArgs.push("--", command, ...args);
  return {
    command: "bwrap",
    args: bwrapArgs
  };
}

// src/workspace/sandbox/native-sandbox/wrapper.ts
function wrapCommand(command, args, options) {
  switch (options.backend) {
    case "seatbelt": {
      const profile = options.seatbeltProfile ?? generateSeatbeltProfile(options.workspacePath, options.config);
      return buildSeatbeltCommand(command, args, profile);
    }
    case "bwrap": {
      return buildBwrapCommand(command, args, options.workspacePath, options.config);
    }
    case "none":
    default:
      return { command, args };
  }
}

// src/workspace/sandbox/local-sandbox.ts
function execWithStreaming(command, args, options) {
  const { timeout, onStdout, onStderr, cwd, env, ...spawnOptions } = options;
  return new Promise((resolve3, reject) => {
    const proc = childProcess.spawn(command, args, { cwd, env, ...spawnOptions });
    let stdout = "";
    let stderr = "";
    let killed = false;
    const timeoutId = timeout ? setTimeout(() => {
      killed = true;
      proc.kill("SIGTERM");
    }, timeout) : void 0;
    proc.stdout.on("data", (data) => {
      const str = data.toString();
      stdout += str;
      onStdout?.(str);
    });
    proc.stderr.on("data", (data) => {
      const str = data.toString();
      stderr += str;
      onStderr?.(str);
    });
    proc.on("error", (err) => {
      if (timeoutId) clearTimeout(timeoutId);
      const errorMsg = err.message;
      stderr += errorMsg;
      onStderr?.(errorMsg);
      reject(err);
    });
    proc.on("close", (code, signal) => {
      if (timeoutId) clearTimeout(timeoutId);
      if (killed) {
        const timeoutMsg = `
Process timed out after ${timeout}ms`;
        onStderr?.(timeoutMsg);
        resolve3({ stdout, stderr: stderr + timeoutMsg, exitCode: 124 });
      } else if (signal) {
        const signalMsg = `
Process terminated by ${signal}`;
        onStderr?.(signalMsg);
        resolve3({ stdout, stderr: stderr + signalMsg, exitCode: 128 });
      } else {
        resolve3({ stdout, stderr, exitCode: code ?? 0 });
      }
    });
  });
}
var LocalSandbox = class extends MastraSandbox {
  id;
  name = "LocalSandbox";
  provider = "local";
  status = "pending";
  _workingDirectory;
  env;
  timeout;
  _isolation;
  _nativeSandboxConfig;
  _seatbeltProfile;
  _seatbeltProfilePath;
  _sandboxFolderPath;
  _userProvidedProfilePath = false;
  _createdAt;
  /**
   * The working directory where commands are executed.
   */
  get workingDirectory() {
    return this._workingDirectory;
  }
  /**
   * The isolation backend being used.
   */
  get isolation() {
    return this._isolation;
  }
  /**
   * Detect the best available isolation backend for this platform.
   * Returns detection result with backend recommendation and availability.
   *
   * @example
   * ```typescript
   * const result = LocalSandbox.detectIsolation();
   * const sandbox = new LocalSandbox({
   *   isolation: result.available ? result.backend : 'none',
   * });
   * ```
   */
  static detectIsolation() {
    return detectIsolation();
  }
  constructor(options = {}) {
    super({ ...options, name: "LocalSandbox" });
    this.id = options.id ?? this.generateId();
    this._createdAt = /* @__PURE__ */ new Date();
    this._workingDirectory = options.workingDirectory ?? nodePath.join(process.cwd(), ".sandbox");
    this.env = options.env ?? {};
    this.timeout = options.timeout;
    this._nativeSandboxConfig = options.nativeSandbox ?? {};
    const requestedIsolation = options.isolation ?? "none";
    if (requestedIsolation !== "none" && !isIsolationAvailable(requestedIsolation)) {
      const detection = detectIsolation();
      throw new IsolationUnavailableError(requestedIsolation, detection.message);
    }
    this._isolation = requestedIsolation;
  }
  generateId() {
    return `local-sandbox-${Date.now().toString(36)}-${Math.random().toString(36).slice(2, 8)}`;
  }
  /**
   * Build the environment object for execution.
   * Always includes PATH by default (needed for finding executables).
   * Merges the sandbox's configured env with any additional env from the command.
   */
  buildEnv(additionalEnv) {
    return {
      PATH: process.env.PATH,
      // Always include PATH for finding executables
      ...this.env,
      ...additionalEnv
    };
  }
  /**
   * Start the local sandbox.
   * Creates working directory and sets up seatbelt profile if using macOS isolation.
   * Status management is handled by the base class.
   */
  async start() {
    this.logger.debug("Starting sandbox", { workingDirectory: this._workingDirectory, isolation: this._isolation });
    await fs2.mkdir(this.workingDirectory, { recursive: true });
    if (this._isolation === "seatbelt") {
      const userProvidedPath = this._nativeSandboxConfig.seatbeltProfilePath;
      if (userProvidedPath) {
        this._seatbeltProfilePath = userProvidedPath;
        this._userProvidedProfilePath = true;
        try {
          this._seatbeltProfile = await fs2.readFile(userProvidedPath, "utf-8");
        } catch (err) {
          if (err instanceof Error && "code" in err && err.code !== "ENOENT") {
            throw err;
          }
          this._seatbeltProfile = generateSeatbeltProfile(this.workingDirectory, this._nativeSandboxConfig);
          await fs2.mkdir(nodePath.dirname(userProvidedPath), { recursive: true });
          await fs2.writeFile(userProvidedPath, this._seatbeltProfile, "utf-8");
        }
      } else {
        this._seatbeltProfile = generateSeatbeltProfile(this.workingDirectory, this._nativeSandboxConfig);
        const configHash = crypto.createHash("sha256").update(this.workingDirectory).update(JSON.stringify(this._nativeSandboxConfig)).digest("hex").slice(0, 8);
        this._sandboxFolderPath = nodePath.join(process.cwd(), ".sandbox-profiles");
        await fs2.mkdir(this._sandboxFolderPath, { recursive: true });
        this._seatbeltProfilePath = nodePath.join(this._sandboxFolderPath, `seatbelt-${configHash}.sb`);
        await fs2.writeFile(this._seatbeltProfilePath, this._seatbeltProfile, "utf-8");
      }
    }
    this.logger.debug("Sandbox started", { workingDirectory: this._workingDirectory });
  }
  /**
   * Stop the local sandbox.
   * Status management is handled by the base class.
   */
  async stop() {
    this.logger.debug("Stopping sandbox", { workingDirectory: this._workingDirectory });
  }
  /**
   * Destroy the local sandbox and clean up resources.
   * Cleans up seatbelt profile if auto-generated.
   * Status management is handled by the base class.
   */
  async destroy() {
    this.logger.debug("Destroying sandbox", { workingDirectory: this._workingDirectory });
    if (this._seatbeltProfilePath && !this._userProvidedProfilePath) {
      try {
        await fs2.unlink(this._seatbeltProfilePath);
      } catch {
      }
    }
    this._seatbeltProfilePath = void 0;
    this._seatbeltProfile = void 0;
    this._userProvidedProfilePath = false;
    if (this._sandboxFolderPath) {
      try {
        await fs2.rmdir(this._sandboxFolderPath);
      } catch {
      }
      this._sandboxFolderPath = void 0;
    }
  }
  async isReady() {
    return this.status === "running";
  }
  async getInfo() {
    return {
      id: this.id,
      name: this.name,
      provider: this.provider,
      status: this.status,
      createdAt: this._createdAt,
      resources: {
        memoryMB: Math.round(os.totalmem() / 1024 / 1024),
        cpuCores: os.cpus().length
      },
      metadata: {
        workingDirectory: this.workingDirectory,
        platform: os.platform(),
        nodeVersion: process.version,
        isolation: this._isolation,
        isolationConfig: this._isolation !== "none" ? {
          allowNetwork: this._nativeSandboxConfig.allowNetwork ?? false,
          readOnlyPaths: this._nativeSandboxConfig.readOnlyPaths,
          readWritePaths: this._nativeSandboxConfig.readWritePaths
        } : void 0
      }
    };
  }
  getInstructions() {
    if (this.workingDirectory) {
      return `Local command execution. Working directory: "${this.workingDirectory}".`;
    }
    return "Local command execution on the host machine.";
  }
  /**
   * Wrap a command with the configured isolation backend.
   */
  wrapCommandForIsolation(command, args) {
    if (this._isolation === "none") {
      return { command, args };
    }
    return wrapCommand(command, args, {
      backend: this._isolation,
      workspacePath: this.workingDirectory,
      seatbeltProfile: this._seatbeltProfile,
      config: this._nativeSandboxConfig
    });
  }
  async executeCommand(command, args = [], options = {}) {
    this.logger.debug("Executing command", { command, args, cwd: options.cwd ?? this.workingDirectory });
    await this.ensureRunning();
    const startTime = Date.now();
    const wrapped = this.wrapCommandForIsolation(command, args);
    try {
      const result = await execWithStreaming(wrapped.command, wrapped.args, {
        cwd: options.cwd ?? this.workingDirectory,
        timeout: options.timeout ?? this.timeout ?? 3e4,
        env: this.buildEnv(options.env),
        onStdout: options.onStdout,
        onStderr: options.onStderr
      });
      const commandResult = {
        success: result.exitCode === 0,
        stdout: result.stdout,
        stderr: result.stderr,
        exitCode: result.exitCode,
        executionTimeMs: Date.now() - startTime
      };
      this.logger.info("Command completed", {
        command,
        exitCode: commandResult.exitCode,
        executionTimeMs: commandResult.executionTimeMs
      });
      return commandResult;
    } catch (error) {
      const executionTimeMs = Date.now() - startTime;
      this.logger.error("Command failed", { command, error, executionTimeMs });
      return {
        success: false,
        stdout: "",
        stderr: error instanceof Error ? error.message : String(error),
        exitCode: 1,
        executionTimeMs
      };
    }
  }
};

// src/workspace/constants/index.ts
var WORKSPACE_TOOLS_PREFIX = "mastra_workspace";
var WORKSPACE_TOOLS = {
  FILESYSTEM: {
    READ_FILE: `${WORKSPACE_TOOLS_PREFIX}_read_file`,
    WRITE_FILE: `${WORKSPACE_TOOLS_PREFIX}_write_file`,
    EDIT_FILE: `${WORKSPACE_TOOLS_PREFIX}_edit_file`,
    LIST_FILES: `${WORKSPACE_TOOLS_PREFIX}_list_files`,
    DELETE: `${WORKSPACE_TOOLS_PREFIX}_delete`,
    FILE_STAT: `${WORKSPACE_TOOLS_PREFIX}_file_stat`,
    MKDIR: `${WORKSPACE_TOOLS_PREFIX}_mkdir`
  },
  SANDBOX: {
    EXECUTE_COMMAND: `${WORKSPACE_TOOLS_PREFIX}_execute_command`
  },
  SEARCH: {
    SEARCH: `${WORKSPACE_TOOLS_PREFIX}_search`,
    INDEX: `${WORKSPACE_TOOLS_PREFIX}_index`
  }
};

// src/workspace/tools/tree-formatter.ts
var BRANCH = "\u251C\u2500\u2500 ";
var LAST_BRANCH = "\u2514\u2500\u2500 ";
var VERTICAL = "\u2502   ";
var SPACE = "    ";
async function formatAsTree(fs5, path4, options) {
  const maxDepth = options?.maxDepth ?? Infinity;
  const showHidden = options?.showHidden ?? false;
  const dirsOnly = options?.dirsOnly ?? false;
  const exclude = options?.exclude;
  const extension = options?.extension;
  const lines = ["."];
  let dirCount = 0;
  let fileCount = 0;
  let truncated = false;
  async function buildTree(currentPath, prefix, depth) {
    if (depth >= maxDepth) {
      truncated = true;
      return;
    }
    let entries;
    try {
      entries = await fs5.readdir(currentPath);
    } catch (error) {
      if (depth === 0) {
        throw error;
      }
      return;
    }
    let filtered = entries;
    if (!showHidden) {
      filtered = filtered.filter((e) => !e.name.startsWith("."));
    }
    if (exclude) {
      const patterns = Array.isArray(exclude) ? exclude : [exclude];
      filtered = filtered.filter((e) => {
        return !patterns.some((pattern) => e.name.includes(pattern));
      });
    }
    if (dirsOnly) {
      filtered = filtered.filter((e) => e.type === "directory");
    }
    if (extension && !dirsOnly) {
      const extensions = Array.isArray(extension) ? extension : [extension];
      filtered = filtered.filter((e) => {
        if (e.type === "directory") return true;
        return extensions.some((ext) => {
          const normalizedExt = ext.startsWith(".") ? ext : `.${ext}`;
          return e.name.endsWith(normalizedExt);
        });
      });
    }
    filtered.sort((a, b) => {
      if (a.type === "directory" && b.type !== "directory") return -1;
      if (a.type !== "directory" && b.type === "directory") return 1;
      return a.name < b.name ? -1 : a.name > b.name ? 1 : 0;
    });
    for (let i = 0; i < filtered.length; i++) {
      const entry = filtered[i];
      const isLast = i === filtered.length - 1;
      const connector = isLast ? LAST_BRANCH : BRANCH;
      const childPrefix = prefix + (isLast ? SPACE : VERTICAL);
      const displayName = entry.isSymlink && entry.symlinkTarget ? `${entry.name} -> ${entry.symlinkTarget}` : entry.name;
      lines.push(prefix + connector + displayName);
      if (entry.type === "directory") {
        dirCount++;
        if (!entry.isSymlink) {
          const childPath = joinPath(currentPath, entry.name);
          await buildTree(childPath, childPrefix, depth + 1);
        }
      } else {
        fileCount++;
      }
    }
  }
  await buildTree(path4, "", 0);
  const dirPart = dirCount === 1 ? "1 directory" : `${dirCount} directories`;
  const filePart = fileCount === 1 ? "1 file" : `${fileCount} files`;
  let summary = `${dirPart}, ${filePart}`;
  if (truncated) {
    summary += ` (truncated at depth ${maxDepth})`;
  }
  return {
    tree: lines.join("\n"),
    summary,
    dirCount,
    fileCount,
    truncated
  };
}
function joinPath(base, name) {
  if (base === "/" || base === "") {
    return `/${name}`;
  }
  return `${base}/${name}`;
}

// src/workspace/tools/tools.ts
function resolveToolConfig(toolsConfig, toolName) {
  let enabled = true;
  let requireApproval = false;
  let requireReadBeforeWrite;
  if (toolsConfig) {
    if (toolsConfig.enabled !== void 0) {
      enabled = toolsConfig.enabled;
    }
    if (toolsConfig.requireApproval !== void 0) {
      requireApproval = toolsConfig.requireApproval;
    }
    const perToolConfig = toolsConfig[toolName];
    if (perToolConfig) {
      if (perToolConfig.enabled !== void 0) {
        enabled = perToolConfig.enabled;
      }
      if (perToolConfig.requireApproval !== void 0) {
        requireApproval = perToolConfig.requireApproval;
      }
      if (perToolConfig.requireReadBeforeWrite !== void 0) {
        requireReadBeforeWrite = perToolConfig.requireReadBeforeWrite;
      }
    }
  }
  return { enabled, requireApproval, requireReadBeforeWrite };
}
function createWorkspaceTools(workspace) {
  const tools = {};
  const toolsConfig = workspace.getToolsConfig();
  const isReadOnly = workspace.filesystem?.readOnly ?? false;
  let readTracker;
  const writeFileConfig = resolveToolConfig(toolsConfig, WORKSPACE_TOOLS.FILESYSTEM.WRITE_FILE);
  const editFileConfig = resolveToolConfig(toolsConfig, WORKSPACE_TOOLS.FILESYSTEM.EDIT_FILE);
  if (writeFileConfig.requireReadBeforeWrite || editFileConfig.requireReadBeforeWrite) {
    readTracker = new InMemoryFileReadTracker();
  }
  if (workspace.filesystem) {
    const readFileConfig = resolveToolConfig(toolsConfig, WORKSPACE_TOOLS.FILESYSTEM.READ_FILE);
    if (readFileConfig.enabled) {
      tools[WORKSPACE_TOOLS.FILESYSTEM.READ_FILE] = createTool({
        id: WORKSPACE_TOOLS.FILESYSTEM.READ_FILE,
        description: "Read the contents of a file from the workspace filesystem. Use offset/limit parameters to read specific line ranges for large files.",
        requireApproval: readFileConfig.requireApproval,
        inputSchema: z.object({
          path: z.string().describe('The path to the file to read (e.g., "/data/config.json")'),
          encoding: z.enum(["utf-8", "utf8", "base64", "hex", "binary"]).optional().describe("The encoding to use when reading the file. Defaults to utf-8 for text files."),
          offset: z.number().optional().describe("Line number to start reading from (1-indexed). If omitted, starts from line 1."),
          limit: z.number().optional().describe("Maximum number of lines to read. If omitted, reads to the end of the file."),
          showLineNumbers: z.boolean().optional().default(true).describe("Whether to prefix each line with its line number (default: true)")
        }),
        outputSchema: z.object({
          content: z.string().describe("The file contents (with optional line number prefixes)"),
          size: z.number().describe("The file size in bytes"),
          path: z.string().describe("The full path to the file"),
          lines: z.object({
            start: z.number().describe("First line number returned"),
            end: z.number().describe("Last line number returned")
          }).optional().describe("Line range information (when offset/limit used)"),
          totalLines: z.number().optional().describe("Total number of lines in the file")
        }),
        execute: async ({ path: path4, encoding, offset, limit, showLineNumbers }) => {
          const effectiveEncoding = encoding ?? "utf-8";
          const fullContent = await workspace.filesystem.readFile(path4, {
            encoding: effectiveEncoding
          });
          const stat3 = await workspace.filesystem.stat(path4);
          if (readTracker) {
            readTracker.recordRead(path4, stat3.modifiedAt);
          }
          const isTextEncoding = !encoding || encoding === "utf-8" || encoding === "utf8";
          if (!isTextEncoding) {
            return {
              content: fullContent,
              size: stat3.size,
              path: stat3.path
            };
          }
          if (typeof fullContent !== "string") {
            return {
              content: fullContent.toString("base64"),
              size: stat3.size,
              path: stat3.path
            };
          }
          const hasLineRange = offset !== void 0 || limit !== void 0;
          const result = extractLinesWithLimit(fullContent, offset, limit);
          const shouldShowLineNumbers = showLineNumbers !== false;
          const formattedContent = shouldShowLineNumbers ? formatWithLineNumbers(result.content, result.lines.start) : result.content;
          return {
            content: formattedContent,
            size: stat3.size,
            path: stat3.path,
            ...hasLineRange && {
              lines: result.lines,
              totalLines: result.totalLines
            }
          };
        }
      });
    }
    if (!isReadOnly && writeFileConfig.enabled) {
      tools[WORKSPACE_TOOLS.FILESYSTEM.WRITE_FILE] = createTool({
        id: WORKSPACE_TOOLS.FILESYSTEM.WRITE_FILE,
        description: "Write content to a file in the workspace filesystem. Creates parent directories if needed.",
        requireApproval: writeFileConfig.requireApproval,
        inputSchema: z.object({
          path: z.string().describe('The path where to write the file (e.g., "/data/output.txt")'),
          content: z.string().describe("The content to write to the file"),
          overwrite: z.boolean().optional().default(true).describe("Whether to overwrite the file if it already exists")
        }),
        outputSchema: z.object({
          success: z.boolean(),
          path: z.string().describe("The path where the file was written"),
          size: z.number().describe("The size of the written content in bytes")
        }),
        execute: async ({ path: path4, content, overwrite }) => {
          if (readTracker && writeFileConfig.requireReadBeforeWrite) {
            try {
              const stat3 = await workspace.filesystem.stat(path4);
              const check = readTracker.needsReRead(path4, stat3.modifiedAt);
              if (check.needsReRead) {
                throw new FileReadRequiredError(path4, check.reason);
              }
            } catch (error) {
              if (!(error instanceof FileNotFoundError)) {
                throw error;
              }
            }
          }
          await workspace.filesystem.writeFile(path4, content, { overwrite });
          if (readTracker) {
            readTracker.clearReadRecord(path4);
          }
          return {
            success: true,
            path: path4,
            size: Buffer.byteLength(content, "utf-8")
          };
        }
      });
    }
    if (!isReadOnly && editFileConfig.enabled) {
      tools[WORKSPACE_TOOLS.FILESYSTEM.EDIT_FILE] = createTool({
        id: WORKSPACE_TOOLS.FILESYSTEM.EDIT_FILE,
        description: `Edit a file by replacing specific text. The old_string must match exactly and be unique in the file.

Usage:
- Read the file first to get the exact text to replace.
- By default, ${WORKSPACE_TOOLS.FILESYSTEM.READ_FILE} output includes line number prefixes (e.g., "     1\u2192"). Ensure you preserve the exact indentation as it appears AFTER the arrow. Never include any part of the line number prefix in old_string or new_string.
- Include enough surrounding context (multiple lines) to make old_string unique. If it still isn't unique, include more lines.
- Use replace_all only when intentionally replacing all occurrences.`,
        requireApproval: editFileConfig.requireApproval,
        inputSchema: z.object({
          path: z.string().describe("The path to the file to edit"),
          old_string: z.string().describe("The exact text to find and replace. Must be unique in the file."),
          new_string: z.string().describe("The text to replace old_string with"),
          replace_all: z.boolean().optional().default(false).describe("If true, replace all occurrences. If false (default), old_string must be unique.")
        }),
        outputSchema: z.object({
          success: z.boolean(),
          path: z.string().describe("The path to the edited file"),
          replacements: z.number().describe("Number of replacements made"),
          error: z.string().optional().describe("Error message if the edit failed")
        }),
        execute: async ({ path: path4, old_string, new_string, replace_all }) => {
          try {
            if (readTracker && editFileConfig.requireReadBeforeWrite) {
              const stat3 = await workspace.filesystem.stat(path4);
              const check = readTracker.needsReRead(path4, stat3.modifiedAt);
              if (check.needsReRead) {
                throw new FileReadRequiredError(path4, check.reason);
              }
            }
            const content = await workspace.filesystem.readFile(path4, { encoding: "utf-8" });
            if (typeof content !== "string") {
              return {
                success: false,
                path: path4,
                replacements: 0,
                error: "Cannot edit binary files. Use workspace_write_file instead."
              };
            }
            const result = replaceString(content, old_string, new_string, replace_all);
            await workspace.filesystem.writeFile(path4, result.content, { overwrite: true });
            if (readTracker) {
              readTracker.clearReadRecord(path4);
            }
            return {
              success: true,
              path: path4,
              replacements: result.replacements
            };
          } catch (error) {
            if (error instanceof FileReadRequiredError) {
              throw error;
            }
            if (error instanceof StringNotFoundError) {
              return {
                success: false,
                path: path4,
                replacements: 0,
                error: error.message
              };
            }
            if (error instanceof StringNotUniqueError) {
              return {
                success: false,
                path: path4,
                replacements: 0,
                error: error.message
              };
            }
            throw error;
          }
        }
      });
    }
    const listFilesConfig = resolveToolConfig(toolsConfig, WORKSPACE_TOOLS.FILESYSTEM.LIST_FILES);
    if (listFilesConfig.enabled) {
      tools[WORKSPACE_TOOLS.FILESYSTEM.LIST_FILES] = createTool({
        id: WORKSPACE_TOOLS.FILESYSTEM.LIST_FILES,
        description: `List files and directories in the workspace filesystem.
Returns a tree-style view (like the Unix "tree" command) for easy visualization.
The output is displayed to the user as a tree-like structure in the tool result.
Options mirror common tree command flags for familiarity.

Examples:
- List root: { path: "/" }
- Deep listing: { path: "/src", maxDepth: 5 }
- Directories only: { path: "/", dirsOnly: true }
- Exclude node_modules: { path: "/", exclude: "node_modules" }`,
        requireApproval: listFilesConfig.requireApproval,
        inputSchema: z.object({
          path: z.string().default("/").describe("Directory path to list"),
          maxDepth: z.number().optional().default(3).describe("Maximum depth to descend (default: 3). Similar to tree -L flag."),
          showHidden: z.boolean().optional().default(false).describe('Show hidden files starting with "." (default: false). Similar to tree -a flag.'),
          dirsOnly: z.boolean().optional().default(false).describe("List directories only, no files (default: false). Similar to tree -d flag."),
          exclude: z.string().optional().describe('Pattern to exclude (e.g., "node_modules"). Similar to tree -I flag.'),
          extension: z.string().optional().describe('Filter by file extension (e.g., ".ts"). Similar to tree -P flag.')
        }),
        outputSchema: z.object({
          tree: z.string().describe("Tree-style directory listing"),
          summary: z.string().describe('Summary of directories and files (e.g., "3 directories, 12 files")'),
          metadata: z.object({
            workspace: z.object({
              id: z.string().optional(),
              name: z.string().optional()
            }).optional(),
            filesystem: z.object({
              id: z.string().optional(),
              name: z.string().optional(),
              provider: z.string().optional()
            }).optional()
          }).optional().describe("Metadata about the workspace and filesystem")
        }),
        execute: async ({ path: path4 = "/", maxDepth = 3, showHidden, dirsOnly, exclude, extension }) => {
          const result = await formatAsTree(workspace.filesystem, path4, {
            maxDepth,
            showHidden,
            dirsOnly,
            exclude: exclude || void 0,
            extension: extension || void 0
          });
          const fs5 = workspace.filesystem;
          const metadata = {
            workspace: {
              id: workspace.id,
              name: workspace.name
            },
            filesystem: {
              id: fs5.id,
              name: fs5.name,
              provider: fs5.provider
            }
          };
          return {
            tree: result.tree,
            summary: result.summary,
            metadata
          };
        }
      });
    }
    const deleteConfig = resolveToolConfig(toolsConfig, WORKSPACE_TOOLS.FILESYSTEM.DELETE);
    if (!isReadOnly && deleteConfig.enabled) {
      tools[WORKSPACE_TOOLS.FILESYSTEM.DELETE] = createTool({
        id: WORKSPACE_TOOLS.FILESYSTEM.DELETE,
        description: "Delete a file or directory from the workspace filesystem",
        requireApproval: deleteConfig.requireApproval,
        inputSchema: z.object({
          path: z.string().describe("The path to the file or directory to delete"),
          recursive: z.boolean().optional().default(false).describe(
            "If true, delete directories and their contents recursively. Required for non-empty directories."
          )
        }),
        outputSchema: z.object({
          success: z.boolean(),
          path: z.string()
        }),
        execute: async ({ path: path4, recursive }) => {
          const stat3 = await workspace.filesystem.stat(path4);
          if (stat3.type === "directory") {
            await workspace.filesystem.rmdir(path4, { recursive, force: recursive });
          } else {
            await workspace.filesystem.deleteFile(path4);
          }
          return { success: true, path: path4 };
        }
      });
    }
    const fileStatConfig = resolveToolConfig(toolsConfig, WORKSPACE_TOOLS.FILESYSTEM.FILE_STAT);
    if (fileStatConfig.enabled) {
      tools[WORKSPACE_TOOLS.FILESYSTEM.FILE_STAT] = createTool({
        id: WORKSPACE_TOOLS.FILESYSTEM.FILE_STAT,
        description: "Get file or directory metadata from the workspace. Returns existence, type, size, and modification time.",
        requireApproval: fileStatConfig.requireApproval,
        inputSchema: z.object({
          path: z.string().describe("The path to check")
        }),
        outputSchema: z.object({
          exists: z.boolean().describe("Whether the path exists"),
          type: z.enum(["file", "directory", "none"]).describe("The type of the path if it exists"),
          size: z.number().optional().describe("Size in bytes (for files)"),
          modifiedAt: z.string().optional().describe("Last modification time (ISO string)")
        }),
        execute: async ({ path: path4 }) => {
          try {
            const stat3 = await workspace.filesystem.stat(path4);
            return {
              exists: true,
              type: stat3.type,
              size: stat3.size,
              modifiedAt: stat3.modifiedAt.toISOString()
            };
          } catch (error) {
            if (error instanceof FileNotFoundError) {
              return { exists: false, type: "none" };
            }
            throw error;
          }
        }
      });
    }
    const mkdirConfig = resolveToolConfig(toolsConfig, WORKSPACE_TOOLS.FILESYSTEM.MKDIR);
    if (!isReadOnly && mkdirConfig.enabled) {
      tools[WORKSPACE_TOOLS.FILESYSTEM.MKDIR] = createTool({
        id: WORKSPACE_TOOLS.FILESYSTEM.MKDIR,
        description: "Create a directory in the workspace filesystem",
        requireApproval: mkdirConfig.requireApproval,
        inputSchema: z.object({
          path: z.string().describe("The path of the directory to create"),
          recursive: z.boolean().optional().default(true).describe("Whether to create parent directories if they do not exist")
        }),
        outputSchema: z.object({
          success: z.boolean(),
          path: z.string()
        }),
        execute: async ({ path: path4, recursive }) => {
          await workspace.filesystem.mkdir(path4, { recursive });
          return { success: true, path: path4 };
        }
      });
    }
  }
  if (workspace.canBM25 || workspace.canVector) {
    const searchConfig = resolveToolConfig(toolsConfig, WORKSPACE_TOOLS.SEARCH.SEARCH);
    if (searchConfig.enabled) {
      tools[WORKSPACE_TOOLS.SEARCH.SEARCH] = createTool({
        id: WORKSPACE_TOOLS.SEARCH.SEARCH,
        description: "Search indexed content in the workspace. Supports keyword (BM25), semantic (vector), and hybrid search modes.",
        requireApproval: searchConfig.requireApproval,
        inputSchema: z.object({
          query: z.string().describe("The search query string"),
          topK: z.number().optional().default(5).describe("Maximum number of results to return"),
          mode: z.enum(["bm25", "vector", "hybrid"]).optional().describe("Search mode: bm25 for keyword search, vector for semantic search, hybrid for both combined"),
          minScore: z.number().optional().describe("Minimum score threshold (0-1 for normalized scores)")
        }),
        outputSchema: z.object({
          results: z.array(
            z.object({
              id: z.string().describe("Document/file path"),
              content: z.string().describe("The matching content"),
              score: z.number().describe("Relevance score"),
              lineRange: z.object({
                start: z.number(),
                end: z.number()
              }).optional().describe("Line range where query terms were found")
            })
          ),
          count: z.number().describe("Number of results returned"),
          mode: z.string().describe("The search mode that was used")
        }),
        execute: async ({ query, topK, mode, minScore }) => {
          const results = await workspace.search(query, {
            topK,
            mode,
            minScore
          });
          return {
            results: results.map((r) => ({
              id: r.id,
              content: r.content,
              score: r.score,
              lineRange: r.lineRange
            })),
            count: results.length,
            mode: mode ?? (workspace.canHybrid ? "hybrid" : workspace.canVector ? "vector" : "bm25")
          };
        }
      });
    }
    const indexConfig = resolveToolConfig(toolsConfig, WORKSPACE_TOOLS.SEARCH.INDEX);
    if (!isReadOnly && indexConfig.enabled) {
      tools[WORKSPACE_TOOLS.SEARCH.INDEX] = createTool({
        id: WORKSPACE_TOOLS.SEARCH.INDEX,
        description: "Index content for search. The path becomes the document ID in search results.",
        requireApproval: indexConfig.requireApproval,
        inputSchema: z.object({
          path: z.string().describe("The document ID/path for search results"),
          content: z.string().describe("The text content to index"),
          metadata: z.record(z.unknown()).optional().describe("Optional metadata to store with the document")
        }),
        outputSchema: z.object({
          success: z.boolean(),
          path: z.string().describe("The indexed document ID")
        }),
        execute: async ({ path: path4, content, metadata }) => {
          await workspace.index(path4, content, { metadata });
          return { success: true, path: path4 };
        }
      });
    }
  }
  if (workspace.sandbox) {
    const pathContext = workspace.getPathContext();
    const pathInfo = pathContext.instructions ? ` ${pathContext.instructions}` : "";
    const executeCommandConfig = resolveToolConfig(toolsConfig, WORKSPACE_TOOLS.SANDBOX.EXECUTE_COMMAND);
    if (workspace.sandbox.executeCommand && executeCommandConfig.enabled) {
      tools[WORKSPACE_TOOLS.SANDBOX.EXECUTE_COMMAND] = createTool({
        id: WORKSPACE_TOOLS.SANDBOX.EXECUTE_COMMAND,
        description: `Execute a shell command in the workspace sandbox.${pathInfo}

Usage:
- Verify parent directories exist before running commands that create files or directories.
- Always quote file paths that contain spaces (e.g., cd "/path/with spaces").
- Use the timeout parameter to limit execution time. Behavior when omitted depends on the sandbox provider.
- Use cwd to set the working directory, or commands run from the sandbox default.`,
        requireApproval: executeCommandConfig.requireApproval,
        inputSchema: z.object({
          command: z.string().describe('The command to execute (e.g., "ls", "npm", "python")'),
          args: z.array(z.string()).nullish().default([]).describe("Arguments to pass to the command"),
          timeout: z.number().nullish().describe("Maximum execution time in milliseconds. Example: 60000 for 1 minute."),
          cwd: z.string().nullish().describe("Working directory for the command")
        }),
        outputSchema: z.object({
          success: z.boolean().describe("Whether the command executed successfully (exit code 0)"),
          stdout: z.string().describe("Standard output from the command"),
          stderr: z.string().describe("Standard error output"),
          exitCode: z.number().describe("Exit code (0 = success)"),
          executionTimeMs: z.number().describe("How long the execution took in milliseconds")
        }),
        execute: async ({ command, args, timeout, cwd }, context) => {
          const getExecutionMetadata = () => ({
            workspace: {
              id: workspace.id,
              name: workspace.name
            },
            sandbox: {
              id: workspace.sandbox?.id,
              name: workspace.sandbox?.name,
              provider: workspace.sandbox?.provider,
              status: workspace.sandbox?.status
            }
          });
          const startedAt = Date.now();
          try {
            const result = await workspace.sandbox.executeCommand(command, args ?? [], {
              timeout: timeout ?? void 0,
              cwd: cwd ?? void 0,
              // Stream stdout/stderr as tool-output chunks for proper UI integration
              onStdout: async (data) => {
                await context?.writer?.write({
                  type: "sandbox-stdout",
                  data,
                  timestamp: Date.now(),
                  metadata: getExecutionMetadata()
                });
              },
              onStderr: async (data) => {
                await context?.writer?.write({
                  type: "sandbox-stderr",
                  data,
                  timestamp: Date.now(),
                  metadata: getExecutionMetadata()
                });
              }
            });
            await context?.writer?.write({
              type: "sandbox-exit",
              exitCode: result.exitCode,
              success: result.success,
              executionTimeMs: result.executionTimeMs,
              metadata: getExecutionMetadata()
            });
            return {
              success: result.success,
              stdout: result.stdout,
              stderr: result.stderr,
              exitCode: result.exitCode,
              executionTimeMs: result.executionTimeMs
            };
          } catch (error) {
            await context?.writer?.write({
              type: "sandbox-exit",
              exitCode: -1,
              success: false,
              executionTimeMs: Date.now() - startedAt,
              metadata: getExecutionMetadata()
            });
            throw error;
          }
        }
      });
    }
  }
  return tools;
}

export { BM25Index, CompositeFilesystem, DirectoryNotEmptyError, DirectoryNotFoundError, FileExistsError, FileNotFoundError, FileReadRequiredError, FilesystemError, FilesystemNotAvailableError, FilesystemNotMountableError, FilesystemNotReadyError, IsDirectoryError, IsolationUnavailableError, LocalFilesystem, LocalSandbox, MastraFilesystem, MastraSandbox, MountError, MountManager, MountNotSupportedError, NotDirectoryError, PermissionError, SandboxError, SandboxExecutionError, SandboxFeatureNotSupportedError, SandboxNotAvailableError, SandboxNotReadyError, SandboxTimeoutError, SearchNotAvailableError, WORKSPACE_TOOLS, WORKSPACE_TOOLS_PREFIX, Workspace, WorkspaceError, WorkspaceNotReadyError, WorkspaceReadOnlyError, callLifecycle, createWorkspaceTools, detectIsolation, extractLines, getRecommendedIsolation, isIsolationAvailable, resolveToolConfig };
//# sourceMappingURL=chunk-4EHGOATH.js.map
//# sourceMappingURL=chunk-4EHGOATH.js.map