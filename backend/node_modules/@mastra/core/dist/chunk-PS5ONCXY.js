import { EntityType, SpanType } from './chunk-Y3TQ52UE.js';
import { getZodTypeName, getZodInnerType } from './chunk-S53FKKVL.js';
import { z } from 'zod';

var createdAtField = z.date().describe("Database record creation time");
var updatedAtField = z.date().describe("Database record last update time");
var dbTimestamps = {
  createdAt: createdAtField,
  updatedAt: updatedAtField.nullable()
};
var paginationArgsSchema = z.object({
  page: z.coerce.number().int().min(0).optional().default(0).describe("Zero-indexed page number"),
  perPage: z.coerce.number().int().min(1).max(100).optional().default(10).describe("Number of items per page")
}).describe("Pagination options for list queries");
var paginationInfoSchema = z.object({
  total: z.number().describe("Total number of items available"),
  page: z.number().describe("Current page"),
  perPage: z.union([z.number(), z.literal(false)]).describe("Number of items per page, or false if pagination is disabled"),
  hasMore: z.boolean().describe("True if more pages are available")
});
var dateRangeSchema = z.object({
  start: z.coerce.date().optional().describe("Start of date range (inclusive by default)"),
  end: z.coerce.date().optional().describe("End of date range (inclusive by default)"),
  startExclusive: z.boolean().optional().describe("When true, excludes the start date from results (uses > instead of >=)"),
  endExclusive: z.boolean().optional().describe("When true, excludes the end date from results (uses < instead of <=)")
}).describe("Date range filter for timestamps");
var sortDirectionSchema = z.enum(["ASC", "DESC"]).describe("Sort direction: 'ASC' | 'DESC'");
var entityTypeField = z.nativeEnum(EntityType).describe(`Entity type (e.g., 'agent' | 'processor' | 'tool' | 'workflow')`);
var entityIdField = z.string().describe('ID of the entity (e.g., "weatherAgent", "orderWorkflow")');
var entityNameField = z.string().describe("Name of the entity");
var userIdField = z.string().describe("Human end-user who triggered execution");
var organizationIdField = z.string().describe("Multi-tenant organization/account");
var resourceIdField = z.string().describe("Broader resource context (Mastra memory compatibility)");
var runIdField = z.string().describe("Unique execution run identifier");
var sessionIdField = z.string().describe("Session identifier for grouping traces");
var threadIdField = z.string().describe("Conversation thread identifier");
var requestIdField = z.string().describe("HTTP request ID for log correlation");
var environmentField = z.string().describe(`Environment (e.g., "production" | "staging" | "development")`);
var sourceField = z.string().describe(`Source of execution (e.g., "local" | "cloud" | "ci")`);
var serviceNameField = z.string().describe("Name of the service");

// src/evals/types.ts
var scoringSourceSchema = z.enum(["LIVE", "TEST"]);
var scoringEntityTypeSchema = z.enum(["AGENT", "WORKFLOW", ...Object.values(SpanType)]);
var scoringPromptsSchema = z.object({
  description: z.string(),
  prompt: z.string()
});
var recordSchema = z.record(z.string(), z.unknown());
var optionalRecordSchema = recordSchema.optional();
var scoringInputSchema = z.object({
  runId: z.string().optional(),
  input: z.unknown().optional(),
  output: z.unknown(),
  additionalContext: optionalRecordSchema,
  requestContext: optionalRecordSchema
  // Note: tracingContext is not serializable, so we don't include it in the schema
  // It's added at runtime when needed
});
var scoringHookInputSchema = z.object({
  runId: z.string().optional(),
  scorer: recordSchema,
  input: z.unknown(),
  output: z.unknown(),
  metadata: optionalRecordSchema,
  additionalContext: optionalRecordSchema,
  source: scoringSourceSchema,
  entity: recordSchema,
  entityType: scoringEntityTypeSchema,
  requestContext: optionalRecordSchema,
  structuredOutput: z.boolean().optional(),
  traceId: z.string().optional(),
  spanId: z.string().optional(),
  resourceId: z.string().optional(),
  threadId: z.string().optional()
  // Note: tracingContext is not serializable, so we don't include it in the schema
});
var scoringExtractStepResultSchema = optionalRecordSchema;
var scoringValueSchema = z.number();
var scoreResultSchema = z.object({
  result: optionalRecordSchema,
  score: scoringValueSchema,
  prompt: z.string().optional()
});
var scoringInputWithExtractStepResultSchema = scoringInputSchema.extend({
  runId: z.string(),
  // Required in this context
  extractStepResult: optionalRecordSchema,
  extractPrompt: z.string().optional()
});
var scoringInputWithExtractStepResultAndAnalyzeStepResultSchema = scoringInputWithExtractStepResultSchema.extend({
  score: z.number(),
  analyzeStepResult: optionalRecordSchema,
  analyzePrompt: z.string().optional()
});
var scoringInputWithExtractStepResultAndScoreAndReasonSchema = scoringInputWithExtractStepResultAndAnalyzeStepResultSchema.extend({
  reason: z.string().optional(),
  reasonPrompt: z.string().optional()
});
var scoreRowDataSchema = z.object({
  id: z.string(),
  scorerId: z.string(),
  entityId: z.string(),
  // From ScoringInputWithExtractStepResultAndScoreAndReason
  runId: z.string(),
  input: z.unknown().optional(),
  output: z.unknown(),
  additionalContext: optionalRecordSchema,
  requestContext: optionalRecordSchema,
  extractStepResult: optionalRecordSchema,
  extractPrompt: z.string().optional(),
  score: z.number(),
  analyzeStepResult: optionalRecordSchema,
  analyzePrompt: z.string().optional(),
  reason: z.string().optional(),
  reasonPrompt: z.string().optional(),
  // From ScoringHookInput
  scorer: recordSchema,
  metadata: optionalRecordSchema,
  source: scoringSourceSchema,
  entity: recordSchema,
  entityType: scoringEntityTypeSchema.optional(),
  structuredOutput: z.boolean().optional(),
  traceId: z.string().optional(),
  spanId: z.string().optional(),
  resourceId: z.string().optional(),
  threadId: z.string().optional(),
  // Additional ScoreRowData fields
  preprocessStepResult: optionalRecordSchema,
  preprocessPrompt: z.string().optional(),
  generateScorePrompt: z.string().optional(),
  generateReasonPrompt: z.string().optional(),
  // Timestamps
  ...dbTimestamps
});
var saveScorePayloadSchema = scoreRowDataSchema.omit({
  id: true,
  createdAt: true,
  updatedAt: true
});
var listScoresResponseSchema = z.object({
  pagination: paginationInfoSchema,
  scores: z.array(scoreRowDataSchema)
});

// src/storage/domains/observability/types.ts
var createOmitKeys = (shape) => Object.fromEntries(Object.keys(shape).map((k) => [k, true]));
var traceIdField = z.string().describe("Unique trace identifier");
var spanIdField = z.string().describe("Unique span identifier within a trace");
var spanNameField = z.string().describe("Human-readable span name");
var parentSpanIdField = z.string().describe("Parent span reference (null = root span)");
var spanTypeField = z.nativeEnum(SpanType).describe("Span type (e.g., WORKFLOW_RUN, AGENT_RUN, TOOL_CALL, etc.)");
var attributesField = z.record(z.unknown()).describe("Span-type specific attributes (e.g., model, tokens, tools)");
var metadataField = z.record(z.unknown()).describe("User-defined metadata for custom filtering");
var tagsField = z.array(z.string()).describe("Labels for filtering traces (only on the root span)");
var scopeField = z.record(z.unknown()).describe('Arbitrary package/app version info (e.g., {"core": "1.0.0", "memory": "1.0.0", "gitSha": "abcd1234"})');
var linksField = z.array(z.unknown()).describe("References to related spans in other traces");
var inputField = z.unknown().describe("Input data passed to the span");
var outputField = z.unknown().describe("Output data returned from the span");
var errorField = z.unknown().describe("Error info - presence indicates failure (status derived from this)");
var isEventField = z.boolean().describe("Whether this is an event (point-in-time) vs a span (duration)");
var startedAtField = z.date().describe("When the span started");
var endedAtField = z.date().describe("When the span ended (null = running, status derived from this)");
var TraceStatus = /* @__PURE__ */ ((TraceStatus2) => {
  TraceStatus2["SUCCESS"] = "success";
  TraceStatus2["ERROR"] = "error";
  TraceStatus2["RUNNING"] = "running";
  return TraceStatus2;
})(TraceStatus || {});
var traceStatusField = z.nativeEnum(TraceStatus).describe("Current status of the trace");
var hasChildErrorField = z.preprocess((v) => {
  if (v === "true") return true;
  if (v === "false") return false;
  return v;
}, z.boolean()).describe("True if any span in the trace encountered an error");
var sharedFields = {
  // Entity identification - first-class fields for filtering (e.g., agent, workflow, tool)
  entityType: entityTypeField.nullish(),
  entityId: entityIdField.nullish(),
  entityName: entityNameField.nullish(),
  // Identity & tenancy - for multi-tenant applications
  userId: userIdField.nullish(),
  organizationId: organizationIdField.nullish(),
  resourceId: resourceIdField.nullish(),
  // Correlation IDs - for linking related operations
  runId: runIdField.nullish(),
  sessionId: sessionIdField.nullish(),
  threadId: threadIdField.nullish(),
  requestId: requestIdField.nullish(),
  // Deployment context - these fields only exist on the root span
  environment: environmentField.nullish(),
  source: sourceField.nullish(),
  serviceName: serviceNameField.nullish(),
  scope: scopeField.nullish(),
  // Filterable data - user-defined metadata and tags (tags only on root span)
  metadata: metadataField.nullish(),
  tags: tagsField.nullish()
};
var spanIds = {
  traceId: traceIdField,
  spanId: spanIdField
};
var spanIdsSchema = z.object({
  ...spanIds
});
var omitDbTimestamps = createOmitKeys(dbTimestamps);
var omitSpanIds = createOmitKeys(spanIds);
var spanRecordSchema = z.object({
  // Required identifiers
  ...spanIds,
  name: spanNameField,
  spanType: spanTypeField,
  isEvent: isEventField,
  startedAt: startedAtField,
  // Shared fields
  parentSpanId: parentSpanIdField.nullish(),
  ...sharedFields,
  // Additional span-specific nullish fields
  attributes: attributesField.nullish(),
  links: linksField.nullish(),
  input: inputField.nullish(),
  output: outputField.nullish(),
  error: errorField.nullish(),
  endedAt: endedAtField.nullish(),
  // Database timestamps
  ...dbTimestamps
}).describe("Span record data");
function computeTraceStatus(span) {
  if (span.error != null) return "error" /* ERROR */;
  if (span.endedAt == null) return "running" /* RUNNING */;
  return "success" /* SUCCESS */;
}
var traceSpanSchema = spanRecordSchema.extend({
  status: traceStatusField
}).describe("Trace span with computed status (root spans only)");
function toTraceSpan(span) {
  return {
    ...span,
    status: computeTraceStatus(span)
  };
}
function toTraceSpans(spans) {
  return spans.map(toTraceSpan);
}
var createSpanRecordSchema = spanRecordSchema.omit(omitDbTimestamps);
var createSpanArgsSchema = z.object({
  span: createSpanRecordSchema
}).describe("Arguments for creating a single span");
var batchCreateSpansArgsSchema = z.object({
  records: z.array(createSpanRecordSchema)
}).describe("Arguments for batch creating spans");
var getSpanArgsSchema = z.object({
  traceId: traceIdField.min(1),
  spanId: spanIdField.min(1)
}).describe("Arguments for getting a single span");
var getSpanResponseSchema = z.object({
  span: spanRecordSchema
});
var getRootSpanArgsSchema = z.object({
  traceId: traceIdField.min(1)
}).describe("Arguments for getting a root span");
var getRootSpanResponseSchema = z.object({
  span: spanRecordSchema
});
var getTraceArgsSchema = z.object({
  traceId: traceIdField.min(1)
}).describe("Arguments for getting a single trace");
var getTraceResponseSchema = z.object({
  traceId: traceIdField,
  spans: z.array(spanRecordSchema)
});
var tracesFilterSchema = z.object({
  // Date range filters
  startedAt: dateRangeSchema.optional().describe("Filter by span start time range"),
  endedAt: dateRangeSchema.optional().describe("Filter by span end time range"),
  // Span type filter
  spanType: spanTypeField.optional(),
  // Shared fields
  ...sharedFields,
  // Filter-specific derived status fields
  status: traceStatusField.optional(),
  hasChildError: hasChildErrorField.optional()
}).describe("Filters for querying traces");
var tracesOrderByFieldSchema = z.enum(["startedAt", "endedAt"]).describe("Field to order by: 'startedAt' | 'endedAt'");
var tracesOrderBySchema = z.object({
  field: tracesOrderByFieldSchema.default("startedAt").describe("Field to order by"),
  direction: sortDirectionSchema.default("DESC").describe("Sort direction")
}).describe("Order by configuration");
var listTracesArgsSchema = z.object({
  filters: tracesFilterSchema.optional().describe("Optional filters to apply"),
  pagination: paginationArgsSchema.default({}).describe("Pagination settings"),
  orderBy: tracesOrderBySchema.default({}).describe("Ordering configuration (defaults to startedAt desc)")
}).describe("Arguments for listing traces");
var listTracesResponseSchema = z.object({
  pagination: paginationInfoSchema,
  spans: z.array(traceSpanSchema)
});
var updateSpanRecordSchema = createSpanRecordSchema.omit(omitSpanIds);
var updateSpanArgsSchema = z.object({
  spanId: spanIdField,
  traceId: traceIdField,
  updates: updateSpanRecordSchema.partial()
}).describe("Arguments for updating a single span");
var batchUpdateSpansArgsSchema = z.object({
  records: z.array(
    z.object({
      traceId: traceIdField,
      spanId: spanIdField,
      updates: updateSpanRecordSchema.partial()
    })
  )
}).describe("Arguments for batch updating spans");
var batchDeleteTracesArgsSchema = z.object({
  traceIds: z.array(traceIdField)
}).describe("Arguments for batch deleting traces");
var listScoresBySpanResponseSchema = z.object({
  pagination: paginationInfoSchema,
  scores: z.array(scoreRowDataSchema)
});
var scoreTracesRequestSchema = z.object({
  scorerName: z.string().min(1),
  targets: z.array(
    z.object({
      traceId: traceIdField,
      spanId: spanIdField.optional()
    })
  ).min(1)
});
var scoreTracesResponseSchema = z.object({
  status: z.string(),
  message: z.string(),
  traceCount: z.number()
});

// src/storage/types.ts
function unwrapSchema(schema) {
  let current = schema;
  let nullable = false;
  while (true) {
    const typeName = getZodTypeName(current);
    if (!typeName) break;
    if (typeName === "ZodNullable" || typeName === "ZodOptional") {
      nullable = true;
    }
    const inner = getZodInnerType(current, typeName);
    if (!inner) break;
    current = inner;
  }
  return { base: current, nullable };
}
function getZodChecks(schema) {
  const schemaAny = schema;
  if (schemaAny._zod?.def?.checks) {
    return schemaAny._zod.def.checks;
  }
  if (schemaAny._def?.checks) {
    return schemaAny._def.checks;
  }
  return [];
}
function zodToStorageType(schema) {
  const typeName = getZodTypeName(schema);
  if (typeName === "ZodString") {
    const checks = getZodChecks(schema);
    if (checks.some((c) => c.kind === "uuid")) {
      return "uuid";
    }
    return "text";
  }
  if (typeName === "ZodNativeEnum" || typeName === "ZodEnum") {
    return "text";
  }
  if (typeName === "ZodNumber") {
    const checks = getZodChecks(schema);
    return checks.some((c) => c.kind === "int") ? "integer" : "float";
  }
  if (typeName === "ZodBigInt") {
    return "bigint";
  }
  if (typeName === "ZodDate") {
    return "timestamp";
  }
  if (typeName === "ZodBoolean") {
    return "boolean";
  }
  return "jsonb";
}
function buildStorageSchema(zObject) {
  const shape = zObject.shape;
  const result = {};
  for (const [key, field] of Object.entries(shape)) {
    const { base, nullable } = unwrapSchema(field);
    result[key] = {
      type: zodToStorageType(base),
      nullable
    };
  }
  return result;
}

// src/storage/constants.ts
var TABLE_WORKFLOW_SNAPSHOT = "mastra_workflow_snapshot";
var TABLE_MESSAGES = "mastra_messages";
var TABLE_THREADS = "mastra_threads";
var TABLE_TRACES = "mastra_traces";
var TABLE_RESOURCES = "mastra_resources";
var TABLE_SCORERS = "mastra_scorers";
var TABLE_SPANS = "mastra_ai_spans";
var TABLE_AGENTS = "mastra_agents";
var TABLE_AGENT_VERSIONS = "mastra_agent_versions";
var TABLE_OBSERVATIONAL_MEMORY = "mastra_observational_memory";
var TABLE_PROMPT_BLOCKS = "mastra_prompt_blocks";
var TABLE_PROMPT_BLOCK_VERSIONS = "mastra_prompt_block_versions";
var TABLE_SCORER_DEFINITIONS = "mastra_scorer_definitions";
var TABLE_SCORER_DEFINITION_VERSIONS = "mastra_scorer_definition_versions";
var TABLE_MCP_CLIENTS = "mastra_mcp_clients";
var TABLE_MCP_CLIENT_VERSIONS = "mastra_mcp_client_versions";
var TABLE_DATASETS = "mastra_datasets";
var TABLE_DATASET_ITEMS = "mastra_dataset_items";
var TABLE_DATASET_VERSIONS = "mastra_dataset_versions";
var TABLE_EXPERIMENTS = "mastra_experiments";
var TABLE_EXPERIMENT_RESULTS = "mastra_experiment_results";
var SCORERS_SCHEMA = {
  id: { type: "text", nullable: false, primaryKey: true },
  scorerId: { type: "text" },
  traceId: { type: "text", nullable: true },
  spanId: { type: "text", nullable: true },
  runId: { type: "text" },
  scorer: { type: "jsonb" },
  preprocessStepResult: { type: "jsonb", nullable: true },
  extractStepResult: { type: "jsonb", nullable: true },
  analyzeStepResult: { type: "jsonb", nullable: true },
  score: { type: "float" },
  reason: { type: "text", nullable: true },
  metadata: { type: "jsonb", nullable: true },
  preprocessPrompt: { type: "text", nullable: true },
  extractPrompt: { type: "text", nullable: true },
  generateScorePrompt: { type: "text", nullable: true },
  generateReasonPrompt: { type: "text", nullable: true },
  analyzePrompt: { type: "text", nullable: true },
  // Deprecated
  reasonPrompt: { type: "text", nullable: true },
  input: { type: "jsonb" },
  output: { type: "jsonb" },
  // MESSAGE OUTPUT
  additionalContext: { type: "jsonb", nullable: true },
  // DATA FROM THE CONTEXT PARAM ON AN AGENT
  requestContext: { type: "jsonb", nullable: true },
  // THE EVALUATE Request Context FOR THE RUN
  /**
   * Things you can evaluate
   */
  entityType: { type: "text", nullable: true },
  // WORKFLOW, AGENT, TOOL, STEP, NETWORK
  entity: { type: "jsonb", nullable: true },
  // MINIMAL JSON DATA ABOUT WORKFLOW, AGENT, TOOL, STEP, NETWORK
  entityId: { type: "text", nullable: true },
  source: { type: "text" },
  resourceId: { type: "text", nullable: true },
  threadId: { type: "text", nullable: true },
  createdAt: { type: "timestamp" },
  updatedAt: { type: "timestamp" }
};
var SPAN_SCHEMA = buildStorageSchema(spanRecordSchema);
var OLD_SPAN_SCHEMA = {
  // Composite primary key of traceId and spanId
  traceId: { type: "text", nullable: false },
  spanId: { type: "text", nullable: false },
  parentSpanId: { type: "text", nullable: true },
  name: { type: "text", nullable: false },
  scope: { type: "jsonb", nullable: true },
  // Mastra package info {"core-version": "0.1.0"}
  spanType: { type: "text", nullable: false },
  // WORKFLOW_RUN, WORKFLOW_STEP, AGENT_RUN, AGENT_STEP, TOOL_RUN, TOOL_STEP, etc.
  attributes: { type: "jsonb", nullable: true },
  metadata: { type: "jsonb", nullable: true },
  links: { type: "jsonb", nullable: true },
  input: { type: "jsonb", nullable: true },
  output: { type: "jsonb", nullable: true },
  error: { type: "jsonb", nullable: true },
  startedAt: { type: "timestamp", nullable: false },
  // When the span started
  endedAt: { type: "timestamp", nullable: true },
  // When the span ended
  createdAt: { type: "timestamp", nullable: false },
  // The time the database record was created
  updatedAt: { type: "timestamp", nullable: true },
  // The time the database record was last updated
  isEvent: { type: "boolean", nullable: false }
};
var AGENTS_SCHEMA = {
  id: { type: "text", nullable: false, primaryKey: true },
  status: { type: "text", nullable: false },
  // 'draft' or 'published'
  activeVersionId: { type: "text", nullable: true },
  // FK to agent_versions.id
  authorId: { type: "text", nullable: true },
  // Author identifier for multi-tenant filtering
  metadata: { type: "jsonb", nullable: true },
  // Additional metadata for the agent
  createdAt: { type: "timestamp", nullable: false },
  updatedAt: { type: "timestamp", nullable: false }
};
var AGENT_VERSIONS_SCHEMA = {
  id: { type: "text", nullable: false, primaryKey: true },
  // UUID
  agentId: { type: "text", nullable: false },
  versionNumber: { type: "integer", nullable: false },
  // Agent config fields
  name: { type: "text", nullable: false },
  // Agent display name
  description: { type: "text", nullable: true },
  instructions: { type: "text", nullable: false },
  model: { type: "jsonb", nullable: false },
  tools: { type: "jsonb", nullable: true },
  defaultOptions: { type: "jsonb", nullable: true },
  workflows: { type: "jsonb", nullable: true },
  agents: { type: "jsonb", nullable: true },
  integrationTools: { type: "jsonb", nullable: true },
  inputProcessors: { type: "jsonb", nullable: true },
  outputProcessors: { type: "jsonb", nullable: true },
  memory: { type: "jsonb", nullable: true },
  scorers: { type: "jsonb", nullable: true },
  mcpClients: { type: "jsonb", nullable: true },
  requestContextSchema: { type: "jsonb", nullable: true },
  // Version metadata
  changedFields: { type: "jsonb", nullable: true },
  // Array of field names
  changeMessage: { type: "text", nullable: true },
  createdAt: { type: "timestamp", nullable: false }
};
var PROMPT_BLOCKS_SCHEMA = {
  id: { type: "text", nullable: false, primaryKey: true },
  status: { type: "text", nullable: false },
  // 'draft', 'published', or 'archived'
  activeVersionId: { type: "text", nullable: true },
  // FK to prompt_block_versions.id
  authorId: { type: "text", nullable: true },
  metadata: { type: "jsonb", nullable: true },
  createdAt: { type: "timestamp", nullable: false },
  updatedAt: { type: "timestamp", nullable: false }
};
var PROMPT_BLOCK_VERSIONS_SCHEMA = {
  id: { type: "text", nullable: false, primaryKey: true },
  blockId: { type: "text", nullable: false },
  versionNumber: { type: "integer", nullable: false },
  name: { type: "text", nullable: false },
  description: { type: "text", nullable: true },
  content: { type: "text", nullable: false },
  rules: { type: "jsonb", nullable: true },
  changedFields: { type: "jsonb", nullable: true },
  changeMessage: { type: "text", nullable: true },
  createdAt: { type: "timestamp", nullable: false }
};
var SCORER_DEFINITIONS_SCHEMA = {
  id: { type: "text", nullable: false, primaryKey: true },
  status: { type: "text", nullable: false },
  // 'draft', 'published', or 'archived'
  activeVersionId: { type: "text", nullable: true },
  // FK to scorer_definition_versions.id
  authorId: { type: "text", nullable: true },
  metadata: { type: "jsonb", nullable: true },
  createdAt: { type: "timestamp", nullable: false },
  updatedAt: { type: "timestamp", nullable: false }
};
var SCORER_DEFINITION_VERSIONS_SCHEMA = {
  id: { type: "text", nullable: false, primaryKey: true },
  scorerDefinitionId: { type: "text", nullable: false },
  versionNumber: { type: "integer", nullable: false },
  name: { type: "text", nullable: false },
  description: { type: "text", nullable: true },
  type: { type: "text", nullable: false },
  // 'llm-judge', 'bias', 'toxicity', etc.
  model: { type: "jsonb", nullable: true },
  instructions: { type: "text", nullable: true },
  scoreRange: { type: "jsonb", nullable: true },
  presetConfig: { type: "jsonb", nullable: true },
  defaultSampling: { type: "jsonb", nullable: true },
  changedFields: { type: "jsonb", nullable: true },
  changeMessage: { type: "text", nullable: true },
  createdAt: { type: "timestamp", nullable: false }
};
var MCP_CLIENTS_SCHEMA = {
  id: { type: "text", nullable: false, primaryKey: true },
  status: { type: "text", nullable: false },
  // 'draft', 'published', or 'archived'
  activeVersionId: { type: "text", nullable: true },
  // FK to mcp_client_versions.id
  authorId: { type: "text", nullable: true },
  metadata: { type: "jsonb", nullable: true },
  createdAt: { type: "timestamp", nullable: false },
  updatedAt: { type: "timestamp", nullable: false }
};
var MCP_CLIENT_VERSIONS_SCHEMA = {
  id: { type: "text", nullable: false, primaryKey: true },
  mcpClientId: { type: "text", nullable: false },
  versionNumber: { type: "integer", nullable: false },
  name: { type: "text", nullable: false },
  description: { type: "text", nullable: true },
  servers: { type: "jsonb", nullable: false },
  changedFields: { type: "jsonb", nullable: true },
  changeMessage: { type: "text", nullable: true },
  createdAt: { type: "timestamp", nullable: false }
};
var OBSERVATIONAL_MEMORY_SCHEMA = {
  id: { type: "text", nullable: false, primaryKey: true },
  lookupKey: { type: "text", nullable: false },
  // 'resource:{resourceId}' or 'thread:{threadId}'
  scope: { type: "text", nullable: false },
  // 'resource' or 'thread'
  resourceId: { type: "text", nullable: true },
  threadId: { type: "text", nullable: true },
  activeObservations: { type: "text", nullable: false },
  // JSON array of observations
  activeObservationsPendingUpdate: { type: "text", nullable: true },
  // JSON array, used during updates
  originType: { type: "text", nullable: false },
  // 'initialization', 'observation', or 'reflection'
  config: { type: "text", nullable: false },
  // JSON object
  generationCount: { type: "integer", nullable: false },
  lastObservedAt: { type: "timestamp", nullable: true },
  lastReflectionAt: { type: "timestamp", nullable: true },
  pendingMessageTokens: { type: "integer", nullable: false },
  // Token count
  totalTokensObserved: { type: "integer", nullable: false },
  // Running total of all observed tokens
  observationTokenCount: { type: "integer", nullable: false },
  // Current observation size in tokens
  isObserving: { type: "boolean", nullable: false },
  isReflecting: { type: "boolean", nullable: false },
  observedMessageIds: { type: "jsonb", nullable: true },
  // JSON array of message IDs already observed
  observedTimezone: { type: "text", nullable: true },
  // Timezone used for Observer date formatting (e.g., "America/Los_Angeles")
  // Async buffering columns
  bufferedObservations: { type: "text", nullable: true },
  // JSON string of buffered observation content
  bufferedObservationTokens: { type: "integer", nullable: true },
  // Token count of buffered observations
  bufferedMessageIds: { type: "jsonb", nullable: true },
  // JSON array of message IDs in the buffer
  bufferedReflection: { type: "text", nullable: true },
  // JSON string of buffered reflection content
  bufferedReflectionTokens: { type: "integer", nullable: true },
  // Token count of buffered reflection (post-compression)
  bufferedReflectionInputTokens: { type: "integer", nullable: true },
  // Token count of observations fed to reflector (pre-compression)
  reflectedObservationLineCount: { type: "integer", nullable: true },
  // Number of observation lines that were reflected on during async buffering
  bufferedObservationChunks: { type: "jsonb", nullable: true },
  // JSON array of BufferedObservationChunk objects
  isBufferingObservation: { type: "boolean", nullable: false },
  isBufferingReflection: { type: "boolean", nullable: false },
  lastBufferedAtTokens: { type: "integer", nullable: false },
  lastBufferedAtTime: { type: "timestamp", nullable: true },
  createdAt: { type: "timestamp", nullable: false },
  updatedAt: { type: "timestamp", nullable: false }
};
var DATASETS_SCHEMA = {
  id: { type: "text", nullable: false, primaryKey: true },
  name: { type: "text", nullable: false },
  description: { type: "text", nullable: true },
  metadata: { type: "jsonb", nullable: true },
  inputSchema: { type: "jsonb", nullable: true },
  groundTruthSchema: { type: "jsonb", nullable: true },
  version: { type: "integer", nullable: false },
  createdAt: { type: "timestamp", nullable: false },
  updatedAt: { type: "timestamp", nullable: false }
};
var DATASET_ITEMS_SCHEMA = {
  id: { type: "text", nullable: false },
  datasetId: { type: "text", nullable: false, references: { table: "mastra_datasets", column: "id" } },
  datasetVersion: { type: "integer", nullable: false },
  validTo: { type: "integer", nullable: true },
  isDeleted: { type: "boolean", nullable: false },
  input: { type: "jsonb", nullable: false },
  groundTruth: { type: "jsonb", nullable: true },
  metadata: { type: "jsonb", nullable: true },
  createdAt: { type: "timestamp", nullable: false },
  updatedAt: { type: "timestamp", nullable: false }
};
var DATASET_VERSIONS_SCHEMA = {
  id: { type: "text", nullable: false, primaryKey: true },
  datasetId: { type: "text", nullable: false, references: { table: "mastra_datasets", column: "id" } },
  version: { type: "integer", nullable: false },
  createdAt: { type: "timestamp", nullable: false }
};
var EXPERIMENTS_SCHEMA = {
  id: { type: "text", nullable: false, primaryKey: true },
  name: { type: "text", nullable: true },
  description: { type: "text", nullable: true },
  metadata: { type: "jsonb", nullable: true },
  datasetId: { type: "text", nullable: true, references: { table: "mastra_datasets", column: "id" } },
  datasetVersion: { type: "integer", nullable: true },
  targetType: { type: "text", nullable: false },
  targetId: { type: "text", nullable: false },
  status: { type: "text", nullable: false },
  totalItems: { type: "integer", nullable: false },
  succeededCount: { type: "integer", nullable: false },
  failedCount: { type: "integer", nullable: false },
  skippedCount: { type: "integer", nullable: false },
  startedAt: { type: "timestamp", nullable: true },
  completedAt: { type: "timestamp", nullable: true },
  createdAt: { type: "timestamp", nullable: false },
  updatedAt: { type: "timestamp", nullable: false }
};
var EXPERIMENT_RESULTS_SCHEMA = {
  id: { type: "text", nullable: false, primaryKey: true },
  experimentId: { type: "text", nullable: false, references: { table: "mastra_experiments", column: "id" } },
  itemId: { type: "text", nullable: false, references: { table: "mastra_dataset_items", column: "id" } },
  itemDatasetVersion: { type: "integer", nullable: true },
  input: { type: "jsonb", nullable: false },
  output: { type: "jsonb", nullable: true },
  groundTruth: { type: "jsonb", nullable: true },
  error: { type: "jsonb", nullable: true },
  startedAt: { type: "timestamp", nullable: false },
  completedAt: { type: "timestamp", nullable: false },
  retryCount: { type: "integer", nullable: false },
  traceId: { type: "text", nullable: true },
  createdAt: { type: "timestamp", nullable: false }
};
var TABLE_SCHEMAS = {
  [TABLE_WORKFLOW_SNAPSHOT]: {
    workflow_name: {
      type: "text"
    },
    run_id: {
      type: "text"
    },
    resourceId: { type: "text", nullable: true },
    snapshot: {
      type: "jsonb"
    },
    createdAt: {
      type: "timestamp"
    },
    updatedAt: {
      type: "timestamp"
    }
  },
  [TABLE_SCORERS]: SCORERS_SCHEMA,
  [TABLE_THREADS]: {
    id: { type: "text", nullable: false, primaryKey: true },
    resourceId: { type: "text", nullable: false },
    title: { type: "text", nullable: false },
    metadata: { type: "jsonb", nullable: true },
    createdAt: { type: "timestamp", nullable: false },
    updatedAt: { type: "timestamp", nullable: false }
  },
  [TABLE_MESSAGES]: {
    id: { type: "text", nullable: false, primaryKey: true },
    thread_id: { type: "text", nullable: false },
    content: { type: "text", nullable: false },
    role: { type: "text", nullable: false },
    type: { type: "text", nullable: false },
    createdAt: { type: "timestamp", nullable: false },
    resourceId: { type: "text", nullable: true }
  },
  [TABLE_SPANS]: SPAN_SCHEMA,
  [TABLE_TRACES]: {
    id: { type: "text", nullable: false, primaryKey: true },
    parentSpanId: { type: "text", nullable: true },
    name: { type: "text", nullable: false },
    traceId: { type: "text", nullable: false },
    scope: { type: "text", nullable: false },
    kind: { type: "integer", nullable: false },
    attributes: { type: "jsonb", nullable: true },
    status: { type: "jsonb", nullable: true },
    events: { type: "jsonb", nullable: true },
    links: { type: "jsonb", nullable: true },
    other: { type: "text", nullable: true },
    startTime: { type: "bigint", nullable: false },
    endTime: { type: "bigint", nullable: false },
    createdAt: { type: "timestamp", nullable: false }
  },
  [TABLE_RESOURCES]: {
    id: { type: "text", nullable: false, primaryKey: true },
    workingMemory: { type: "text", nullable: true },
    metadata: { type: "jsonb", nullable: true },
    createdAt: { type: "timestamp", nullable: false },
    updatedAt: { type: "timestamp", nullable: false }
  },
  [TABLE_AGENTS]: AGENTS_SCHEMA,
  [TABLE_AGENT_VERSIONS]: AGENT_VERSIONS_SCHEMA,
  [TABLE_PROMPT_BLOCKS]: PROMPT_BLOCKS_SCHEMA,
  [TABLE_PROMPT_BLOCK_VERSIONS]: PROMPT_BLOCK_VERSIONS_SCHEMA,
  [TABLE_SCORER_DEFINITIONS]: SCORER_DEFINITIONS_SCHEMA,
  [TABLE_SCORER_DEFINITION_VERSIONS]: SCORER_DEFINITION_VERSIONS_SCHEMA,
  [TABLE_MCP_CLIENTS]: MCP_CLIENTS_SCHEMA,
  [TABLE_MCP_CLIENT_VERSIONS]: MCP_CLIENT_VERSIONS_SCHEMA,
  [TABLE_DATASETS]: DATASETS_SCHEMA,
  [TABLE_DATASET_ITEMS]: DATASET_ITEMS_SCHEMA,
  [TABLE_DATASET_VERSIONS]: DATASET_VERSIONS_SCHEMA,
  [TABLE_EXPERIMENTS]: EXPERIMENTS_SCHEMA,
  [TABLE_EXPERIMENT_RESULTS]: EXPERIMENT_RESULTS_SCHEMA
};
var TABLE_CONFIGS = {
  [TABLE_DATASET_ITEMS]: { columns: DATASET_ITEMS_SCHEMA, compositePrimaryKey: ["id", "datasetVersion"] }
};
var OBSERVATIONAL_MEMORY_TABLE_SCHEMA = {
  [TABLE_OBSERVATIONAL_MEMORY]: OBSERVATIONAL_MEMORY_SCHEMA
};

export { AGENTS_SCHEMA, AGENT_VERSIONS_SCHEMA, DATASETS_SCHEMA, DATASET_ITEMS_SCHEMA, DATASET_VERSIONS_SCHEMA, EXPERIMENTS_SCHEMA, EXPERIMENT_RESULTS_SCHEMA, MCP_CLIENTS_SCHEMA, MCP_CLIENT_VERSIONS_SCHEMA, OBSERVATIONAL_MEMORY_SCHEMA, OBSERVATIONAL_MEMORY_TABLE_SCHEMA, OLD_SPAN_SCHEMA, PROMPT_BLOCKS_SCHEMA, PROMPT_BLOCK_VERSIONS_SCHEMA, SCORERS_SCHEMA, SCORER_DEFINITIONS_SCHEMA, SCORER_DEFINITION_VERSIONS_SCHEMA, SPAN_SCHEMA, TABLE_AGENTS, TABLE_AGENT_VERSIONS, TABLE_CONFIGS, TABLE_DATASETS, TABLE_DATASET_ITEMS, TABLE_DATASET_VERSIONS, TABLE_EXPERIMENTS, TABLE_EXPERIMENT_RESULTS, TABLE_MCP_CLIENTS, TABLE_MCP_CLIENT_VERSIONS, TABLE_MESSAGES, TABLE_OBSERVATIONAL_MEMORY, TABLE_PROMPT_BLOCKS, TABLE_PROMPT_BLOCK_VERSIONS, TABLE_RESOURCES, TABLE_SCHEMAS, TABLE_SCORERS, TABLE_SCORER_DEFINITIONS, TABLE_SCORER_DEFINITION_VERSIONS, TABLE_SPANS, TABLE_THREADS, TABLE_TRACES, TABLE_WORKFLOW_SNAPSHOT, TraceStatus, batchCreateSpansArgsSchema, batchDeleteTracesArgsSchema, batchUpdateSpansArgsSchema, buildStorageSchema, computeTraceStatus, createSpanArgsSchema, createSpanRecordSchema, createdAtField, dateRangeSchema, dbTimestamps, entityIdField, entityNameField, entityTypeField, environmentField, getRootSpanArgsSchema, getRootSpanResponseSchema, getSpanArgsSchema, getSpanResponseSchema, getTraceArgsSchema, getTraceResponseSchema, listScoresBySpanResponseSchema, listScoresResponseSchema, listTracesArgsSchema, listTracesResponseSchema, organizationIdField, paginationArgsSchema, paginationInfoSchema, requestIdField, resourceIdField, runIdField, saveScorePayloadSchema, scoreResultSchema, scoreRowDataSchema, scoreTracesRequestSchema, scoreTracesResponseSchema, scoringEntityTypeSchema, scoringExtractStepResultSchema, scoringHookInputSchema, scoringInputSchema, scoringInputWithExtractStepResultAndAnalyzeStepResultSchema, scoringInputWithExtractStepResultAndScoreAndReasonSchema, scoringInputWithExtractStepResultSchema, scoringPromptsSchema, scoringSourceSchema, scoringValueSchema, serviceNameField, sessionIdField, sortDirectionSchema, sourceField, spanIdField, spanIds, spanIdsSchema, spanRecordSchema, threadIdField, toTraceSpan, toTraceSpans, traceIdField, traceSpanSchema, tracesFilterSchema, tracesOrderByFieldSchema, tracesOrderBySchema, updateSpanArgsSchema, updateSpanRecordSchema, updatedAtField, userIdField };
//# sourceMappingURL=chunk-PS5ONCXY.js.map
//# sourceMappingURL=chunk-PS5ONCXY.js.map