{"version":3,"sources":["../src/datasets/experiment/executor.ts","../src/datasets/experiment/scorer.ts","../src/datasets/experiment/analytics/aggregate.ts","../src/datasets/experiment/analytics/compare.ts","../src/datasets/experiment/index.ts","../src/datasets/dataset.ts","../src/datasets/manager.ts"],"names":["isSupportedLanguageModel","validateAndSaveScore","completedAt","skippedCount","MastraError","isZodType","zodToJsonSchema"],"mappings":"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","file":"chunk-3JVFFAJX.cjs","sourcesContent":["import type { Agent } from '../../agent';\nimport { isSupportedLanguageModel } from '../../agent';\nimport type { MastraScorer } from '../../evals/base';\nimport type { ScorerRunInputForAgent, ScorerRunOutputForAgent } from '../../evals/types';\nimport type { TargetType } from '../../storage/types';\nimport type { Workflow } from '../../workflows';\n\n/**\n * Target types supported for dataset execution.\n * Agent and Workflow are Phase 2; scorer and processor are Phase 4.\n */\nexport type Target = Agent | Workflow | MastraScorer<any, any, any, any>;\n\n/**\n * Result from executing a target against a dataset item.\n */\nexport interface ExecutionResult {\n  /** Output from the target (null if failed) */\n  output: unknown;\n  /** Structured error if execution failed */\n  error: { message: string; stack?: string; code?: string } | null;\n  /** Trace ID from agent/workflow execution (null for scorers or errors) */\n  traceId: string | null;\n  /** Structured input for scorers (extracted from agent scoring data) */\n  scorerInput?: ScorerRunInputForAgent;\n  /** Structured output for scorers (extracted from agent scoring data) */\n  scorerOutput?: ScorerRunOutputForAgent;\n}\n\n/**\n * Execute a dataset item against a scorer (LLM-as-judge calibration).\n * item.input should contain exactly what the scorer expects - direct passthrough.\n * For calibration: item.input = { input, output, groundTruth } (user structures it)\n */\nasync function executeScorer(\n  scorer: MastraScorer<any, any, any, any>,\n  item: { input: unknown; groundTruth?: unknown },\n): Promise<ExecutionResult> {\n  try {\n    // Direct passthrough - scorer receives item.input exactly as provided\n    // User structures item.input to match scorer's expected shape (e.g., { input, output, groundTruth })\n    const result = await scorer.run(item.input as any);\n\n    // Validate score is a number\n    const score = typeof result.score === 'number' && !isNaN(result.score) ? result.score : null;\n\n    if (score === null && result.score !== undefined) {\n      console.warn(`Scorer ${scorer.id} returned invalid score: ${result.score}`);\n    }\n\n    return {\n      output: {\n        score,\n        reason: typeof result.reason === 'string' ? result.reason : null,\n      },\n      error: null,\n      traceId: null, // Scorers don't produce traces\n    };\n  } catch (error) {\n    return {\n      output: null,\n      error: {\n        message: error instanceof Error ? error.message : String(error),\n        stack: error instanceof Error ? error.stack : undefined,\n      },\n      traceId: null,\n    };\n  }\n}\n\n/**\n * Execute a dataset item against a target (agent, workflow, scorer, processor).\n * Phase 2: agent/workflow. Phase 4: scorer. Processor deferred.\n */\nexport async function executeTarget(\n  target: Target,\n  targetType: TargetType,\n  item: { input: unknown; groundTruth?: unknown },\n  options?: { signal?: AbortSignal },\n): Promise<ExecutionResult> {\n  try {\n    const signal = options?.signal;\n\n    // Check if already aborted before starting\n    if (signal?.aborted) {\n      throw signal.reason ?? new DOMException('The operation was aborted.', 'AbortError');\n    }\n\n    let executionPromise: Promise<ExecutionResult>;\n    switch (targetType) {\n      case 'agent':\n        executionPromise = executeAgent(target as Agent, item, signal);\n        break;\n      case 'workflow':\n        executionPromise = executeWorkflow(target as Workflow, item);\n        break;\n      case 'scorer':\n        executionPromise = executeScorer(target as MastraScorer<any, any, any, any>, item);\n        break;\n      case 'processor':\n        // Processor targets dropped from roadmap - not a core use case\n        throw new Error(`Target type '${targetType}' not yet supported.`);\n      default:\n        throw new Error(`Unknown target type: ${targetType}`);\n    }\n\n    // Race execution against signal abort (ensures timeout works even if target ignores signal)\n    if (signal) {\n      return await raceWithSignal(executionPromise, signal);\n    }\n\n    return await executionPromise;\n  } catch (error) {\n    return {\n      output: null,\n      error: {\n        message: error instanceof Error ? error.message : String(error),\n        stack: error instanceof Error ? error.stack : undefined,\n      },\n      traceId: null,\n    };\n  }\n}\n\n/**\n * Race a promise against an AbortSignal. Rejects with the signal's reason when aborted.\n */\nfunction raceWithSignal<T>(promise: Promise<T>, signal: AbortSignal): Promise<T> {\n  if (signal.aborted) {\n    return Promise.reject(signal.reason ?? new DOMException('The operation was aborted.', 'AbortError'));\n  }\n\n  return new Promise<T>((resolve, reject) => {\n    const onAbort = () => {\n      reject(signal.reason ?? new DOMException('The operation was aborted.', 'AbortError'));\n    };\n\n    signal.addEventListener('abort', onAbort, { once: true });\n\n    promise.then(\n      value => {\n        signal.removeEventListener('abort', onAbort);\n        resolve(value);\n      },\n      err => {\n        signal.removeEventListener('abort', onAbort);\n        reject(err);\n      },\n    );\n  });\n}\n\n/**\n * Execute a dataset item against an agent.\n * Uses generate() for both v1 and v2 models.\n */\nasync function executeAgent(\n  agent: Agent,\n  item: { input: unknown; groundTruth?: unknown },\n  signal?: AbortSignal,\n): Promise<ExecutionResult> {\n  const model = await agent.getModel();\n\n  // Use generate() - works for both v1 and v2 models\n  // Pass input as-is - let agent handle normalization\n  const result = isSupportedLanguageModel(model)\n    ? await agent.generate(item.input as any, {\n        scorers: {},\n        returnScorerData: true,\n        abortSignal: signal,\n      })\n    : await (agent as any).generateLegacy?.(item.input as any, {\n        scorers: {},\n        returnScorerData: true,\n      });\n\n  if (result == null) {\n    throw new Error(`Agent \"${agent.name}\" does not support generateLegacy for this model type`);\n  }\n\n  // Capture traceId and scoring data from agent result\n  const traceId = (result as any)?.traceId ?? null;\n  const scoringData = (result as any)?.scoringData as\n    | { input: ScorerRunInputForAgent; output: ScorerRunOutputForAgent }\n    | undefined;\n\n  return {\n    output: result,\n    error: null,\n    traceId,\n    scorerInput: scoringData?.input,\n    scorerOutput: scoringData?.output,\n  };\n}\n\n/**\n * Execute a dataset item against a workflow.\n * Creates a run with scorers disabled to avoid double-scoring.\n */\nasync function executeWorkflow(\n  workflow: Workflow,\n  item: { input: unknown; groundTruth?: unknown },\n): Promise<ExecutionResult> {\n  const run = await workflow.createRun({ disableScorers: true });\n  const result = await run.start({\n    inputData: item.input,\n  });\n\n  // Capture traceId from workflow result\n  const traceId = (result as any)?.traceId ?? null;\n\n  if (result.status === 'success') {\n    return { output: result.result, error: null, traceId };\n  }\n\n  // Handle all non-success statuses (still include traceId for debugging)\n  if (result.status === 'failed') {\n    return {\n      output: null,\n      error: { message: result.error?.message ?? 'Workflow failed', stack: result.error?.stack },\n      traceId,\n    };\n  }\n\n  if (result.status === 'tripwire') {\n    return {\n      output: null,\n      error: { message: `Workflow tripwire: ${result.tripwire?.reason ?? 'Unknown reason'}` },\n      traceId,\n    };\n  }\n\n  if (result.status === 'suspended') {\n    return {\n      output: null,\n      error: { message: 'Workflow suspended - not yet supported in dataset experiments' },\n      traceId,\n    };\n  }\n\n  if (result.status === 'paused') {\n    return { output: null, error: { message: 'Workflow paused - not yet supported in dataset experiments' }, traceId };\n  }\n\n  // Exhaustive check - should never reach here\n  const _exhaustiveCheck: never = result;\n  return {\n    output: null,\n    error: { message: `Workflow ended with unexpected status: ${(_exhaustiveCheck as any).status}` },\n    traceId,\n  };\n}\n","import type { MastraScorer } from '../../evals/base';\nimport type { ScorerRunInputForAgent, ScorerRunOutputForAgent } from '../../evals/types';\nimport type { Mastra } from '../../mastra';\nimport { validateAndSaveScore } from '../../mastra/hooks';\nimport type { MastraCompositeStore } from '../../storage/base';\nimport type { TargetType } from '../../storage/types';\nimport type { ScorerResult } from './types';\n\n/**\n * Resolve scorers from mixed array of instances and string IDs.\n * String IDs are looked up from Mastra's scorer registry.\n */\nexport function resolveScorers(\n  mastra: Mastra,\n  scorers?: (MastraScorer<any, any, any, any> | string)[],\n): MastraScorer<any, any, any, any>[] {\n  if (!scorers || scorers.length === 0) return [];\n\n  return scorers\n    .map(scorer => {\n      if (typeof scorer === 'string') {\n        const resolved = mastra.getScorerById(scorer);\n        if (!resolved) {\n          console.warn(`Scorer not found: ${scorer}`);\n          return null;\n        }\n        return resolved;\n      }\n      return scorer;\n    })\n    .filter((s): s is MastraScorer<any, any, any, any> => s !== null);\n}\n\n/**\n * Run all scorers for a single item result.\n * Errors are isolated per scorer - one failing scorer doesn't affect others.\n */\nexport async function runScorersForItem(\n  scorers: MastraScorer<any, any, any, any>[],\n  item: { input: unknown; groundTruth?: unknown; metadata?: Record<string, unknown> },\n  output: unknown,\n  storage: MastraCompositeStore | null,\n  runId: string,\n  targetType: TargetType,\n  targetId: string,\n  itemId: string,\n  scorerInput?: ScorerRunInputForAgent,\n  scorerOutput?: ScorerRunOutputForAgent,\n): Promise<ScorerResult[]> {\n  if (scorers.length === 0) return [];\n\n  const settled = await Promise.allSettled(\n    scorers.map(async scorer => {\n      const result = await runScorerSafe(scorer, item, output, scorerInput, scorerOutput);\n\n      // Persist score if storage available and score was computed\n      if (storage && result.score !== null) {\n        try {\n          await validateAndSaveScore(storage, {\n            scorerId: scorer.id,\n            score: result.score,\n            reason: result.reason ?? undefined,\n            input: item.input,\n            output,\n            additionalContext: item.metadata,\n            entityType: targetType.toUpperCase(),\n            entityId: itemId,\n            source: 'TEST',\n            runId,\n            scorer: {\n              id: scorer.id,\n              name: scorer.name,\n              description: scorer.description ?? '',\n            },\n            entity: {\n              id: targetId,\n              name: targetId,\n            },\n          });\n        } catch (saveError) {\n          // Log but don't fail - score persistence is best-effort\n          console.warn(`Failed to save score for scorer ${scorer.id}:`, saveError);\n        }\n      }\n\n      return result;\n    }),\n  );\n\n  return settled.map((s, i) =>\n    s.status === 'fulfilled'\n      ? s.value\n      : { scorerId: scorers[i]!.id, scorerName: scorers[i]!.name, score: null, reason: null, error: String(s.reason) },\n  );\n}\n\n/**\n * Run a single scorer safely, catching any errors.\n */\nasync function runScorerSafe(\n  scorer: MastraScorer<any, any, any, any>,\n  item: { input: unknown; groundTruth?: unknown; metadata?: Record<string, unknown> },\n  output: unknown,\n  scorerInput?: ScorerRunInputForAgent,\n  scorerOutput?: ScorerRunOutputForAgent,\n): Promise<ScorerResult> {\n  try {\n    const scoreResult = await scorer.run({\n      input: scorerInput ?? item.input,\n      output: scorerOutput ?? output,\n      groundTruth: item.groundTruth,\n    });\n\n    // Extract score and reason with proper null handling\n    // Scorer run result types are complex generics, so we cast through any\n    const score = (scoreResult as any).score;\n    const reason = (scoreResult as any).reason;\n\n    return {\n      scorerId: scorer.id,\n      scorerName: scorer.name,\n      score: typeof score === 'number' ? score : null,\n      reason: typeof reason === 'string' ? reason : null,\n      error: null,\n    };\n  } catch (error) {\n    return {\n      scorerId: scorer.id,\n      scorerName: scorer.name,\n      score: null,\n      reason: null,\n      error: error instanceof Error ? error.message : String(error),\n    };\n  }\n}\n","/**\n * Experiment Analytics Aggregation Helpers\n *\n * Pure functions for computing statistics from raw score data.\n * Used by compareExperiments to build ScorerStats and detect regressions.\n */\n\nimport type { ScoreRowData } from '../../../evals/types';\nimport type { ScorerStats } from './types';\n\n/**\n * Compute the arithmetic mean of an array of numbers.\n *\n * @param values - Array of numbers to average\n * @returns Mean value, or 0 if array is empty\n */\nexport function computeMean(values: number[]): number {\n  if (values.length === 0) {\n    return 0;\n  }\n  const sum = values.reduce((acc, val) => acc + val, 0);\n  return sum / values.length;\n}\n\n/**\n * Compute aggregate statistics for a set of scores.\n *\n * Metrics:\n * - errorRate: proportion of items with null scores (errors)\n * - passRate: proportion of scored items meeting threshold\n * - avgScore: mean of non-null scores\n *\n * @param scores - Score records from storage\n * @param passThreshold - Absolute threshold for pass (score >= threshold)\n * @returns ScorerStats with all computed metrics\n */\nexport function computeScorerStats(scores: ScoreRowData[], passThreshold: number = 0.5): ScorerStats {\n  const totalItems = scores.length;\n\n  if (totalItems === 0) {\n    return {\n      errorRate: 0,\n      errorCount: 0,\n      passRate: 0,\n      passCount: 0,\n      avgScore: 0,\n      scoreCount: 0,\n      totalItems: 0,\n    };\n  }\n\n  // Separate null scores (errors) from valid scores\n  const validScores: number[] = [];\n  let errorCount = 0;\n\n  for (const score of scores) {\n    if (score.score === null || score.score === undefined) {\n      errorCount++;\n    } else {\n      validScores.push(score.score);\n    }\n  }\n\n  const scoreCount = validScores.length;\n  const errorRate = errorCount / totalItems;\n\n  // Pass rate is computed over items with valid scores only\n  const passCount = validScores.filter(s => s >= passThreshold).length;\n  const passRate = scoreCount > 0 ? passCount / scoreCount : 0;\n\n  // Average score excludes errors\n  const avgScore = computeMean(validScores);\n\n  return {\n    errorRate,\n    errorCount,\n    passRate,\n    passCount,\n    avgScore,\n    scoreCount,\n    totalItems,\n  };\n}\n\n/**\n * Determine if a score delta represents a regression.\n *\n * @param delta - Score difference (experiment B - experiment A)\n * @param threshold - Absolute threshold for regression detection\n * @param direction - Score direction ('higher-is-better' or 'lower-is-better')\n * @returns True if delta represents a regression\n *\n * @example\n * // Higher is better (default): negative delta is bad\n * isRegression(-0.1, 0.05, 'higher-is-better') // true (dropped more than 0.05)\n * isRegression(-0.01, 0.05, 'higher-is-better') // false (within tolerance)\n *\n * // Lower is better: positive delta is bad\n * isRegression(0.1, 0.05, 'lower-is-better') // true (increased more than 0.05)\n */\nexport function isRegression(\n  delta: number,\n  threshold: number,\n  direction: 'higher-is-better' | 'lower-is-better' = 'higher-is-better',\n): boolean {\n  if (direction === 'higher-is-better') {\n    // Regression if score dropped below threshold\n    // delta < -threshold means score dropped by more than threshold\n    return delta < -threshold;\n  } else {\n    // Regression if score increased above threshold\n    // delta > threshold means score increased by more than threshold\n    return delta > threshold;\n  }\n}\n","/**\n * Experiment Comparison\n *\n * Compare two experiments to detect score regressions.\n * Returns per-scorer deltas and per-item score diffs.\n */\n\nimport type { ScoreRowData } from '../../../evals/types';\nimport type { Mastra } from '../../../mastra';\nimport { computeScorerStats, isRegression } from './aggregate';\nimport type {\n  CompareExperimentsConfig,\n  ComparisonResult,\n  ItemComparison,\n  ScorerComparison,\n  ScorerThreshold,\n} from './types';\n\n/**\n * Default threshold when not specified: no tolerance for regression.\n */\nconst DEFAULT_THRESHOLD: ScorerThreshold = {\n  value: 0,\n  direction: 'higher-is-better',\n};\n\n/**\n * Default pass threshold for computing pass rate.\n */\nconst DEFAULT_PASS_THRESHOLD = 0.5;\n\n/**\n * Compare two experiments to detect score regressions.\n *\n * @param mastra - Mastra instance for storage access\n * @param config - Comparison configuration\n * @returns ComparisonResult with per-scorer and per-item comparisons\n *\n * @example\n * ```typescript\n * const result = await compareExperiments(mastra, {\n *   experimentIdA: 'baseline-experiment-id',\n *   experimentIdB: 'candidate-experiment-id',\n *   thresholds: {\n *     'accuracy': { value: 0.05, direction: 'higher-is-better' },\n *     'latency': { value: 100, direction: 'lower-is-better' },\n *   },\n * });\n *\n * if (result.hasRegression) {\n *   console.log('Quality regression detected!');\n * }\n * ```\n */\nexport async function compareExperiments(mastra: Mastra, config: CompareExperimentsConfig): Promise<ComparisonResult> {\n  const { experimentIdA, experimentIdB, thresholds = {} } = config;\n  const warnings: string[] = [];\n\n  // 1. Get storage\n  const storage = mastra.getStorage();\n  if (!storage) {\n    throw new Error('Storage not configured. Configure storage in Mastra instance.');\n  }\n\n  const experimentsStore = await storage.getStore('experiments');\n  const scoresStore = await storage.getStore('scores');\n\n  if (!experimentsStore) {\n    throw new Error('ExperimentsStorage not configured.');\n  }\n  if (!scoresStore) {\n    throw new Error('ScoresStorage not configured.');\n  }\n\n  // 2. Load both experiments\n  const [experimentA, experimentB] = await Promise.all([\n    experimentsStore.getExperimentById({ id: experimentIdA }),\n    experimentsStore.getExperimentById({ id: experimentIdB }),\n  ]);\n\n  if (!experimentA) {\n    throw new Error(`Experiment not found: ${experimentIdA}`);\n  }\n  if (!experimentB) {\n    throw new Error(`Experiment not found: ${experimentIdB}`);\n  }\n\n  // 3. Check version mismatch\n  const versionMismatch = experimentA.datasetVersion !== experimentB.datasetVersion;\n  if (versionMismatch) {\n    warnings.push(\n      `Experiments have different dataset versions: ${experimentA.datasetVersion} vs ${experimentB.datasetVersion}`,\n    );\n  }\n\n  // 4. Load results for both experiments\n  const [resultsA, resultsB] = await Promise.all([\n    experimentsStore.listExperimentResults({ experimentId: experimentIdA, pagination: { page: 0, perPage: false } }),\n    experimentsStore.listExperimentResults({ experimentId: experimentIdB, pagination: { page: 0, perPage: false } }),\n  ]);\n\n  // 5. Load scores for both experiments\n  const [scoresA, scoresB] = await Promise.all([\n    scoresStore.listScoresByRunId({ runId: experimentIdA, pagination: { page: 0, perPage: false } }),\n    scoresStore.listScoresByRunId({ runId: experimentIdB, pagination: { page: 0, perPage: false } }),\n  ]);\n\n  // 6. Handle empty experiments\n  if (resultsA.results.length === 0 && resultsB.results.length === 0) {\n    warnings.push('Both experiments have no results.');\n    return buildEmptyResult(experimentA, experimentB, versionMismatch, warnings);\n  }\n  if (resultsA.results.length === 0) {\n    warnings.push('Experiment A has no results.');\n  }\n  if (resultsB.results.length === 0) {\n    warnings.push('Experiment B has no results.');\n  }\n\n  // 7. Find overlapping items\n  const itemIdsA = new Set(resultsA.results.map(r => r.itemId));\n  const itemIdsB = new Set(resultsB.results.map(r => r.itemId));\n  const overlappingItemIds = [...itemIdsA].filter(id => itemIdsB.has(id));\n\n  if (overlappingItemIds.length === 0) {\n    warnings.push('No overlapping items between experiments.');\n  }\n\n  // 8. Group scores by scorer and item\n  const scoresMapA = groupScoresByScorerAndItem(scoresA.scores);\n  const scoresMapB = groupScoresByScorerAndItem(scoresB.scores);\n\n  // 9. Find all unique scorers\n  const allScorerIds = new Set([...Object.keys(scoresMapA), ...Object.keys(scoresMapB)]);\n\n  // 10. Build per-scorer comparison\n  const scorers: Record<string, ScorerComparison> = {};\n  let hasRegression = false;\n\n  for (const scorerId of allScorerIds) {\n    const scorerScoresA = scoresMapA[scorerId] ?? {};\n    const scorerScoresB = scoresMapB[scorerId] ?? {};\n\n    // Get scores as arrays for stats computation\n    const scoresArrayA = Object.values(scorerScoresA);\n    const scoresArrayB = Object.values(scorerScoresB);\n\n    // Get threshold config for this scorer\n    const thresholdConfig = thresholds[scorerId] ?? DEFAULT_THRESHOLD;\n    const threshold = thresholdConfig.value;\n    const direction = thresholdConfig.direction ?? 'higher-is-better';\n\n    // Compute stats\n    const statsA = computeScorerStats(scoresArrayA, DEFAULT_PASS_THRESHOLD);\n    const statsB = computeScorerStats(scoresArrayB, DEFAULT_PASS_THRESHOLD);\n\n    // Compute delta and check regression\n    const delta = statsB.avgScore - statsA.avgScore;\n    const regressed = isRegression(delta, threshold, direction);\n\n    if (regressed) {\n      hasRegression = true;\n    }\n\n    scorers[scorerId] = {\n      statsA,\n      statsB,\n      delta,\n      regressed,\n      threshold,\n    };\n  }\n\n  // 11. Build per-item comparison\n  const allItemIds = new Set([...itemIdsA, ...itemIdsB]);\n  const items: ItemComparison[] = [];\n\n  for (const itemId of allItemIds) {\n    const inBothExperiments = itemIdsA.has(itemId) && itemIdsB.has(itemId);\n\n    // Build scores for this item\n    const itemScoresA: Record<string, number | null> = {};\n    const itemScoresB: Record<string, number | null> = {};\n\n    for (const scorerId of allScorerIds) {\n      const scoreA = scoresMapA[scorerId]?.[itemId];\n      const scoreB = scoresMapB[scorerId]?.[itemId];\n\n      itemScoresA[scorerId] = scoreA?.score ?? null;\n      itemScoresB[scorerId] = scoreB?.score ?? null;\n    }\n\n    items.push({\n      itemId,\n      inBothExperiments,\n      scoresA: itemScoresA,\n      scoresB: itemScoresB,\n    });\n  }\n\n  return {\n    experimentA: {\n      id: experimentA.id,\n      datasetVersion: experimentA.datasetVersion,\n    },\n    experimentB: {\n      id: experimentB.id,\n      datasetVersion: experimentB.datasetVersion,\n    },\n    versionMismatch,\n    hasRegression,\n    scorers,\n    items,\n    warnings,\n  };\n}\n\n/**\n * Group scores by scorer ID, then by item ID.\n */\nfunction groupScoresByScorerAndItem(scores: ScoreRowData[]): Record<string, Record<string, ScoreRowData>> {\n  const result: Record<string, Record<string, ScoreRowData>> = {};\n\n  for (const score of scores) {\n    const scorerId = score.scorerId;\n    const itemId = score.entityId; // entityId is the item ID for experiment scores\n\n    if (!result[scorerId]) {\n      result[scorerId] = {};\n    }\n    result[scorerId][itemId] = score;\n  }\n\n  return result;\n}\n\n/**\n * Build an empty comparison result for edge cases.\n */\nfunction buildEmptyResult(\n  experimentA: { id: string; datasetVersion: number | null },\n  experimentB: { id: string; datasetVersion: number | null },\n  versionMismatch: boolean,\n  warnings: string[],\n): ComparisonResult {\n  return {\n    experimentA: {\n      id: experimentA.id,\n      datasetVersion: experimentA.datasetVersion,\n    },\n    experimentB: {\n      id: experimentB.id,\n      datasetVersion: experimentB.datasetVersion,\n    },\n    versionMismatch,\n    hasRegression: false,\n    scorers: {},\n    items: [],\n    warnings,\n  };\n}\n","import type { Mastra } from '../../mastra';\n\n/** Unified item shape used within experiment execution (bridges inline + versioned data) */\ntype ExperimentItem = {\n  id: string; // item id (or generated for inline)\n  datasetVersion: number | null; // null for inline experiments\n  input: unknown;\n  groundTruth?: unknown;\n  metadata?: Record<string, unknown>;\n};\nimport { executeTarget } from './executor';\nimport type { Target, ExecutionResult } from './executor';\nimport { resolveScorers, runScorersForItem } from './scorer';\nimport type { ExperimentConfig, ExperimentSummary, ItemWithScores, ItemResult } from './types';\n\n// Re-export types and helpers\nexport type {\n  DataItem,\n  ExperimentConfig,\n  ExperimentSummary,\n  ItemWithScores,\n  ItemResult,\n  ScorerResult,\n  StartExperimentConfig,\n} from './types';\nexport { executeTarget, type Target, type ExecutionResult } from './executor';\nexport { resolveScorers, runScorersForItem } from './scorer';\n\n// Re-export analytics\nexport * from './analytics';\n\n/**\n * Run a dataset experiment against a target with optional scoring.\n *\n * Executes all items in the dataset concurrently (up to maxConcurrency) against\n * the specified target (agent or workflow). Optionally applies scorers to each\n * result and persists both results and scores to storage.\n *\n * @param mastra - Mastra instance for storage and target resolution\n * @param config - Experiment configuration\n * @returns ExperimentSummary with results and scores\n *\n * @example\n * ```typescript\n * const summary = await runExperiment(mastra, {\n *   datasetId: 'my-dataset',\n *   targetType: 'agent',\n *   targetId: 'my-agent',\n *   scorers: [accuracyScorer, latencyScorer],\n *   maxConcurrency: 10,\n * });\n * console.log(`${summary.succeededCount}/${summary.totalItems} succeeded`);\n * ```\n */\nexport async function runExperiment(mastra: Mastra, config: ExperimentConfig): Promise<ExperimentSummary> {\n  const {\n    datasetId,\n    targetType,\n    targetId,\n    scorers: scorerInput,\n    version,\n    maxConcurrency = 5,\n    signal,\n    itemTimeout,\n    maxRetries = 0,\n    experimentId: providedExperimentId,\n    name,\n    description,\n    metadata,\n  } = config;\n\n  const startedAt = new Date();\n  // Use provided experimentId (async trigger) or generate new one\n  const experimentId = providedExperimentId ?? crypto.randomUUID();\n\n  // 1. Get storage and resolve components\n  const storage = mastra.getStorage();\n  const datasetsStore = await storage?.getStore('datasets');\n  const experimentsStore = await storage?.getStore('experiments');\n\n  // Phase A  Resolve items\n  let items: ExperimentItem[];\n  let datasetVersion: number | null;\n\n  if (config.data) {\n    // Inline data path  array or factory function\n    const rawData = typeof config.data === 'function' ? await config.data() : config.data;\n    items = rawData.map(dataItem => {\n      const id = dataItem.id ?? crypto.randomUUID();\n      return {\n        id,\n        datasetVersion: null,\n        input: dataItem.input,\n        groundTruth: dataItem.groundTruth,\n        metadata: dataItem.metadata,\n      };\n    });\n    datasetVersion = null;\n  } else if (datasetId) {\n    // Storage-backed data path (existing)\n    if (!datasetsStore) {\n      throw new Error('DatasetsStorage not configured. Configure storage in Mastra instance.');\n    }\n\n    const dataset = await datasetsStore.getDatasetById({ id: datasetId });\n    if (!dataset) {\n      throw new Error(`Dataset not found: ${datasetId}`);\n    }\n\n    datasetVersion = version ?? dataset.version;\n    const versionItems = await datasetsStore.getItemsByVersion({\n      datasetId,\n      version: datasetVersion,\n    });\n\n    if (versionItems.length === 0) {\n      throw new Error(`No items in dataset ${datasetId} at version ${datasetVersion}`);\n    }\n\n    items = versionItems.map(v => ({\n      id: v.id,\n      datasetVersion: v.datasetVersion,\n      input: v.input,\n      groundTruth: v.groundTruth,\n      metadata: v.metadata,\n    }));\n  } else {\n    throw new Error('No data source: provide datasetId or data');\n  }\n\n  // Phase B  Resolve task function\n  let execFn: (item: ExperimentItem, signal?: AbortSignal) => Promise<ExecutionResult>;\n\n  if (config.task) {\n    // Inline task path\n    const taskFn = config.task;\n    execFn = async (item, itemSignal) => {\n      try {\n        const result = await taskFn({\n          input: item.input,\n          mastra,\n          groundTruth: item.groundTruth,\n          metadata: item.metadata,\n          signal: itemSignal,\n        });\n        return { output: result, error: null, traceId: null };\n      } catch (err: unknown) {\n        return {\n          output: null,\n          error: {\n            message: err instanceof Error ? err.message : String(err),\n            stack: err instanceof Error ? err.stack : undefined,\n          },\n          traceId: null,\n        };\n      }\n    };\n  } else if (targetType && targetId) {\n    // Registry-based target path (existing)\n    const target = resolveTarget(mastra, targetType, targetId);\n    if (!target) {\n      throw new Error(`Target not found: ${targetType}/${targetId}`);\n    }\n    execFn = (item, itemSignal) => executeTarget(target, targetType, item, { signal: itemSignal });\n  } else {\n    throw new Error('No task: provide targetType+targetId or task');\n  }\n\n  // Resolve scorers\n  const scorers = resolveScorers(mastra, scorerInput);\n\n  // 5. Create experiment record (if storage available and not pre-created)\n  if (experimentsStore) {\n    if (!providedExperimentId) {\n      // Create new experiment record (sync trigger path)\n      await experimentsStore.createExperiment({\n        id: experimentId,\n        name,\n        description,\n        metadata,\n        datasetId: datasetId ?? null,\n        datasetVersion,\n        targetType: targetType ?? 'agent',\n        targetId: targetId ?? 'inline',\n        totalItems: items.length,\n      });\n    }\n    // Update status to running (both sync and async paths)\n    await experimentsStore.updateExperiment({\n      id: experimentId,\n      status: 'running',\n      startedAt,\n    });\n  }\n\n  // 6. Execute items with p-map\n  let succeededCount = 0;\n  let failedCount = 0;\n  // Pre-allocate for deterministic ordering (results[i] matches items[i])\n  const results: ItemWithScores[] = new Array(items.length);\n\n  // Throttled progress updates\n  const PROGRESS_UPDATE_INTERVAL = 2000;\n  let lastProgressUpdate = 0;\n\n  try {\n    const pMap = (await import('p-map')).default;\n\n    await pMap(\n      items.map((item, idx) => ({ item, idx })),\n      async ({ item, idx }) => {\n        // Check for cancellation\n        if (signal?.aborted) {\n          throw new DOMException('Aborted', 'AbortError');\n        }\n\n        const itemStartedAt = new Date();\n        // Compose per-item signal (timeout + run-level abort)\n        let itemSignal: AbortSignal | undefined = signal;\n        if (itemTimeout) {\n          const timeoutSignal = AbortSignal.timeout(itemTimeout);\n          itemSignal = signal ? AbortSignal.any([signal, timeoutSignal]) : timeoutSignal;\n        }\n\n        // Retry loop\n        let retryCount = 0;\n        let execResult = await execFn(item, itemSignal);\n\n        while (execResult.error && retryCount < maxRetries) {\n          // Don't retry abort errors\n          if (execResult.error.message.toLowerCase().includes('abort')) break;\n\n          retryCount++;\n          const delay = Math.min(1000 * Math.pow(2, retryCount - 1), 30000);\n          const jitter = delay * 0.2 * Math.random();\n          await new Promise(r => setTimeout(r, delay + jitter));\n\n          // Re-check cancellation before retry\n          if (signal?.aborted) {\n            throw new DOMException('Aborted', 'AbortError');\n          }\n\n          execResult = await execFn(item, itemSignal);\n        }\n\n        const itemCompletedAt = new Date();\n\n        // Track success/failure\n        if (execResult.error) {\n          failedCount++;\n        } else {\n          succeededCount++;\n        }\n\n        // Build item result\n        const itemResult: ItemResult = {\n          itemId: item.id,\n          itemVersion: item.datasetVersion ?? 0,\n          input: item.input,\n          output: execResult.output,\n          groundTruth: item.groundTruth ?? null,\n          error: execResult.error,\n          startedAt: itemStartedAt,\n          completedAt: itemCompletedAt,\n          retryCount,\n        };\n\n        // Run scorers (inline, after target completes)\n        const itemScores = await runScorersForItem(\n          scorers,\n          item,\n          execResult.output,\n          storage ?? null,\n          experimentId,\n          targetType ?? 'agent',\n          targetId ?? 'inline',\n          item.id,\n          execResult.scorerInput,\n          execResult.scorerOutput,\n        );\n\n        // Persist result with scores (if storage available)\n        if (experimentsStore) {\n          try {\n            await experimentsStore.addExperimentResult({\n              experimentId,\n              itemId: item.id,\n              itemDatasetVersion: item.datasetVersion,\n              input: item.input,\n              output: execResult.output,\n              groundTruth: item.groundTruth ?? null,\n              error: execResult.error,\n              startedAt: itemStartedAt,\n              completedAt: itemCompletedAt,\n              retryCount,\n              traceId: execResult.traceId,\n            });\n          } catch (persistError) {\n            console.warn(`Failed to persist result for item ${item.id}:`, persistError);\n          }\n\n          // Throttled progress update\n          const now = Date.now();\n          if (now - lastProgressUpdate >= PROGRESS_UPDATE_INTERVAL) {\n            lastProgressUpdate = now;\n            try {\n              await experimentsStore.updateExperiment({\n                id: experimentId,\n                succeededCount,\n                failedCount,\n              });\n            } catch {\n              // Non-fatal  progress updates are best-effort\n            }\n          }\n        }\n\n        // Store at original index for deterministic ordering\n        results[idx] = {\n          ...itemResult,\n          scores: itemScores,\n        };\n      },\n      { concurrency: maxConcurrency },\n    );\n  } catch {\n    // Handle abort or other fatal errors  return partial summary instead of throwing\n    const completedAt = new Date();\n    const skippedCount = items.length - succeededCount - failedCount;\n\n    if (experimentsStore) {\n      await experimentsStore.updateExperiment({\n        id: experimentId,\n        status: 'failed',\n        succeededCount,\n        failedCount,\n        skippedCount,\n        completedAt,\n      });\n    }\n\n    return {\n      experimentId,\n      status: 'failed' as const,\n      totalItems: items.length,\n      succeededCount,\n      failedCount,\n      skippedCount,\n      completedWithErrors: false,\n      startedAt,\n      completedAt,\n      results: results.filter(Boolean),\n    };\n  }\n\n  // 7. Finalize experiment record\n  const completedAt = new Date();\n  const status = failedCount === items.length ? 'failed' : 'completed';\n  const completedWithErrors = status === 'completed' && failedCount > 0;\n\n  const skippedCount = items.length - succeededCount - failedCount;\n  if (experimentsStore) {\n    await experimentsStore.updateExperiment({\n      id: experimentId,\n      status,\n      succeededCount,\n      failedCount,\n      skippedCount,\n      completedAt,\n    });\n  }\n\n  return {\n    experimentId,\n    status,\n    totalItems: items.length,\n    succeededCount,\n    failedCount,\n    skippedCount,\n    completedWithErrors,\n    startedAt,\n    completedAt,\n    results,\n  };\n}\n\n/**\n * Resolve a target from Mastra's registries by type and ID.\n */\nfunction resolveTarget(mastra: Mastra, targetType: string, targetId: string): Target | null {\n  switch (targetType) {\n    case 'agent':\n      try {\n        return mastra.getAgentById(targetId as any);\n      } catch {\n        // Try by name if ID lookup fails\n        try {\n          return mastra.getAgent(targetId);\n        } catch {\n          return null;\n        }\n      }\n    case 'workflow':\n      try {\n        return mastra.getWorkflowById(targetId as any);\n      } catch {\n        // Try by name if ID lookup fails\n        try {\n          return mastra.getWorkflow(targetId);\n        } catch {\n          return null;\n        }\n      }\n    case 'scorer':\n      try {\n        return mastra.getScorerById(targetId as any) ?? null;\n      } catch {\n        return null;\n      }\n    case 'processor':\n      // Processors not yet in registry - Phase 4\n      return null;\n    default:\n      return null;\n  }\n}\n","import { isZodType } from '@mastra/schema-compat';\nimport { zodToJsonSchema } from '@mastra/schema-compat/zod-to-json';\nimport { MastraError } from '../error/index.js';\nimport type { Mastra } from '../mastra/index.js';\nimport type { DatasetsStorage } from '../storage/domains/datasets/base.js';\nimport type { ExperimentsStorage } from '../storage/domains/experiments/base.js';\nimport type { DatasetRecord, DatasetItem, DatasetItemRow, DatasetVersion } from '../storage/types.js';\nimport { runExperiment } from './experiment/index.js';\nimport type { ExperimentConfig, StartExperimentConfig, ExperimentSummary } from './experiment/types.js';\n\n/**\n * Public API for interacting with a single dataset.\n *\n * Provides methods for item CRUD, versioning, and experiment management.\n * Obtained via `DatasetsManager.get()` or `DatasetsManager.create()`.\n */\nexport class Dataset {\n  readonly id: string;\n  #mastra: Mastra;\n  #datasetsStore?: DatasetsStorage;\n  #experimentsStore?: ExperimentsStorage;\n\n  constructor(id: string, mastra: Mastra) {\n    this.id = id;\n    this.#mastra = mastra;\n  }\n\n  // ---------------------------------------------------------------------------\n  // Lazy storage resolution\n  // ---------------------------------------------------------------------------\n\n  async #getDatasetsStore(): Promise<DatasetsStorage> {\n    if (this.#datasetsStore) return this.#datasetsStore;\n\n    const storage = this.#mastra.getStorage();\n    if (!storage) {\n      throw new MastraError({\n        id: 'DATASETS_STORAGE_NOT_CONFIGURED',\n        text: 'Storage not configured. Configure storage in Mastra instance.',\n        domain: 'STORAGE',\n        category: 'USER',\n      });\n    }\n\n    const store = await storage.getStore('datasets');\n    if (!store) {\n      throw new MastraError({\n        id: 'DATASETS_STORE_NOT_AVAILABLE',\n        text: 'Datasets store not available. Ensure your storage adapter provides a datasets domain.',\n        domain: 'STORAGE',\n        category: 'USER',\n      });\n    }\n\n    this.#datasetsStore = store;\n    return store;\n  }\n\n  async #getExperimentsStore(): Promise<ExperimentsStorage> {\n    if (this.#experimentsStore) return this.#experimentsStore;\n\n    const storage = this.#mastra.getStorage();\n    if (!storage) {\n      throw new MastraError({\n        id: 'DATASETS_STORAGE_NOT_CONFIGURED',\n        text: 'Storage not configured. Configure storage in Mastra instance.',\n        domain: 'STORAGE',\n        category: 'USER',\n      });\n    }\n\n    const store = await storage.getStore('experiments');\n    if (!store) {\n      throw new MastraError({\n        id: 'EXPERIMENTS_STORE_NOT_AVAILABLE',\n        text: 'Experiments store not available. Ensure your storage adapter provides an experiments domain.',\n        domain: 'STORAGE',\n        category: 'USER',\n      });\n    }\n\n    this.#experimentsStore = store;\n    return store;\n  }\n\n  // ---------------------------------------------------------------------------\n  // Dataset metadata\n  // ---------------------------------------------------------------------------\n\n  /**\n   * Get the full dataset record from storage.\n   */\n  async getDetails(): Promise<DatasetRecord> {\n    const store = await this.#getDatasetsStore();\n    const record = await store.getDatasetById({ id: this.id });\n    if (!record) {\n      throw new MastraError({\n        id: 'DATASET_NOT_FOUND',\n        text: `Dataset not found: ${this.id}`,\n        domain: 'STORAGE',\n        category: 'USER',\n      });\n    }\n    return record;\n  }\n\n  /**\n   * Update dataset metadata and/or schemas.\n   * Zod schemas are automatically converted to JSON Schema.\n   */\n  async update(input: {\n    name?: string;\n    description?: string;\n    metadata?: Record<string, unknown>;\n    inputSchema?: unknown;\n    groundTruthSchema?: unknown;\n  }): Promise<DatasetRecord> {\n    const store = await this.#getDatasetsStore();\n\n    let { inputSchema, groundTruthSchema, ...rest } = input;\n\n    if (inputSchema !== undefined && isZodType(inputSchema)) {\n      inputSchema = zodToJsonSchema(inputSchema);\n    }\n    if (groundTruthSchema !== undefined && isZodType(groundTruthSchema)) {\n      groundTruthSchema = zodToJsonSchema(groundTruthSchema);\n    }\n\n    return store.updateDataset({\n      id: this.id,\n      ...rest,\n      inputSchema: inputSchema as Record<string, unknown> | undefined,\n      groundTruthSchema: groundTruthSchema as Record<string, unknown> | undefined,\n    });\n  }\n\n  // ---------------------------------------------------------------------------\n  // Item CRUD\n  // ---------------------------------------------------------------------------\n\n  /**\n   * Add a single item to the dataset.\n   */\n  async addItem(input: {\n    input: unknown;\n    groundTruth?: unknown;\n    metadata?: Record<string, unknown>;\n  }): Promise<DatasetItem> {\n    const store = await this.#getDatasetsStore();\n    return store.addItem({\n      datasetId: this.id,\n      input: input.input,\n      groundTruth: input.groundTruth,\n      metadata: input.metadata,\n    });\n  }\n\n  /**\n   * Add multiple items to the dataset in bulk.\n   */\n  async addItems(input: {\n    items: Array<{\n      input: unknown;\n      groundTruth?: unknown;\n      metadata?: Record<string, unknown>;\n    }>;\n  }): Promise<DatasetItem[]> {\n    const store = await this.#getDatasetsStore();\n    return store.batchInsertItems({\n      datasetId: this.id,\n      items: input.items,\n    });\n  }\n\n  /**\n   * Get a single item by ID, optionally at a specific version.\n   */\n  async getItem(args: { itemId: string; version?: number }): Promise<DatasetItem | null> {\n    const store = await this.#getDatasetsStore();\n    return store.getItemById({ id: args.itemId, datasetVersion: args.version });\n  }\n\n  /**\n   * List items in the dataset, optionally at a specific version.\n   */\n  async listItems(args?: {\n    version?: number;\n    page?: number;\n    perPage?: number;\n    search?: string;\n  }): Promise<\n    | DatasetItem[]\n    | { items: DatasetItem[]; pagination: { total: number; page: number; perPage: number | false; hasMore: boolean } }\n  > {\n    const store = await this.#getDatasetsStore();\n    if (args?.version) {\n      return store.getItemsByVersion({ datasetId: this.id, version: args.version });\n    }\n    return store.listItems({\n      datasetId: this.id,\n      search: args?.search,\n      pagination: { page: args?.page ?? 0, perPage: args?.perPage ?? 20 },\n    });\n  }\n\n  /**\n   * Update an existing item in the dataset.\n   */\n  async updateItem(input: {\n    itemId: string;\n    input?: unknown;\n    groundTruth?: unknown;\n    metadata?: Record<string, unknown>;\n  }): Promise<DatasetItem> {\n    const store = await this.#getDatasetsStore();\n    return store.updateItem({\n      id: input.itemId,\n      datasetId: this.id,\n      input: input.input,\n      groundTruth: input.groundTruth,\n      metadata: input.metadata,\n    });\n  }\n\n  /**\n   * Delete a single item from the dataset.\n   */\n  async deleteItem(args: { itemId: string }): Promise<void> {\n    const store = await this.#getDatasetsStore();\n    return store.deleteItem({ id: args.itemId, datasetId: this.id });\n  }\n\n  /**\n   * Delete multiple items from the dataset in bulk.\n   */\n  async deleteItems(args: { itemIds: string[] }): Promise<void> {\n    const store = await this.#getDatasetsStore();\n    return store.batchDeleteItems({ datasetId: this.id, itemIds: args.itemIds });\n  }\n\n  // ---------------------------------------------------------------------------\n  // Versioning\n  // ---------------------------------------------------------------------------\n\n  /**\n   * List all versions of this dataset.\n   */\n  async listVersions(args?: { page?: number; perPage?: number }): Promise<{\n    versions: DatasetVersion[];\n    pagination: { total: number; page: number; perPage: number | false; hasMore: boolean };\n  }> {\n    const store = await this.#getDatasetsStore();\n    return store.listDatasetVersions({\n      datasetId: this.id,\n      pagination: { page: args?.page ?? 0, perPage: args?.perPage ?? 20 },\n    });\n  }\n\n  /**\n   * Get full SCD-2 history of a specific item across all dataset versions.\n   */\n  async getItemHistory(args: { itemId: string }): Promise<DatasetItemRow[]> {\n    const store = await this.#getDatasetsStore();\n    return store.getItemHistory(args.itemId);\n  }\n\n  // ---------------------------------------------------------------------------\n  // Experiments\n  // ---------------------------------------------------------------------------\n\n  /**\n   * Run an experiment on this dataset and wait for completion.\n   */\n  async startExperiment<I = unknown, O = unknown, E = unknown>(\n    config: StartExperimentConfig<I, O, E>,\n  ): Promise<ExperimentSummary> {\n    return runExperiment(this.#mastra, { datasetId: this.id, ...config } as ExperimentConfig);\n  }\n\n  /**\n   * Start an experiment asynchronously (fire-and-forget).\n   * Returns immediately with the experiment ID and pending status.\n   */\n  async startExperimentAsync<I = unknown, O = unknown, E = unknown>(\n    config: StartExperimentConfig<I, O, E>,\n  ): Promise<{ experimentId: string; status: 'pending' }> {\n    const experimentsStore = await this.#getExperimentsStore();\n    const datasetsStore = await this.#getDatasetsStore();\n\n    const dataset = await datasetsStore.getDatasetById({ id: this.id });\n    if (!dataset) {\n      throw new MastraError({\n        id: 'DATASET_NOT_FOUND',\n        text: `Dataset not found: ${this.id}`,\n        domain: 'STORAGE',\n        category: 'USER',\n      });\n    }\n\n    const run = await experimentsStore.createExperiment({\n      datasetId: this.id,\n      datasetVersion: dataset.version,\n      targetType: config.targetType ?? 'agent',\n      targetId: config.targetId ?? 'inline',\n      totalItems: 0,\n      name: config.name,\n      description: config.description,\n      metadata: config.metadata,\n    });\n\n    const experimentId = run.id;\n\n    // Fire-and-forget  errors are silently caught\n    void runExperiment(this.#mastra, {\n      datasetId: this.id,\n      experimentId,\n      ...config,\n    } as ExperimentConfig).catch(() => {});\n\n    return { experimentId, status: 'pending' as const };\n  }\n\n  /**\n   * List all experiments (runs) for this dataset.\n   */\n  async listExperiments(args?: { page?: number; perPage?: number }) {\n    const experimentsStore = await this.#getExperimentsStore();\n    return experimentsStore.listExperiments({\n      datasetId: this.id,\n      pagination: { page: args?.page ?? 0, perPage: args?.perPage ?? 20 },\n    });\n  }\n\n  /**\n   * Get a specific experiment (run) by ID.\n   */\n  async getExperiment(args: { experimentId: string }) {\n    const experimentsStore = await this.#getExperimentsStore();\n    return experimentsStore.getExperimentById({ id: args.experimentId });\n  }\n\n  /**\n   * List results for a specific experiment.\n   */\n  async listExperimentResults(args: { experimentId: string; page?: number; perPage?: number }) {\n    const experimentsStore = await this.#getExperimentsStore();\n    return experimentsStore.listExperimentResults({\n      experimentId: args.experimentId,\n      pagination: { page: args?.page ?? 0, perPage: args?.perPage ?? 20 },\n    });\n  }\n\n  /**\n   * Delete an experiment (run) by ID.\n   */\n  async deleteExperiment(args: { experimentId: string }) {\n    const experimentsStore = await this.#getExperimentsStore();\n    return experimentsStore.deleteExperiment({ id: args.experimentId });\n  }\n}\n","import { isZodType } from '@mastra/schema-compat';\nimport { zodToJsonSchema } from '@mastra/schema-compat/zod-to-json';\nimport { MastraError } from '../error/index.js';\nimport type { Mastra } from '../mastra/index.js';\nimport type { DatasetsStorage } from '../storage/domains/datasets/base.js';\nimport type { ExperimentsStorage } from '../storage/domains/experiments/base.js';\nimport { Dataset } from './dataset.js';\nimport { compareExperiments as compareExperimentsInternal } from './experiment/analytics/compare.js';\n\n/**\n * Public API for managing datasets.\n *\n * Provides methods for dataset CRUD and cross-dataset experiment operations.\n * Typically accessed via `mastra.datasets` (Phase 4).\n */\nexport class DatasetsManager {\n  #mastra: Mastra;\n  #datasetsStore?: DatasetsStorage;\n  #experimentsStore?: ExperimentsStorage;\n\n  constructor(mastra: Mastra) {\n    this.#mastra = mastra;\n  }\n\n  // ---------------------------------------------------------------------------\n  // Lazy storage resolution\n  // ---------------------------------------------------------------------------\n\n  async #getDatasetsStore(): Promise<DatasetsStorage> {\n    if (this.#datasetsStore) return this.#datasetsStore;\n\n    const storage = this.#mastra.getStorage();\n    if (!storage) {\n      throw new MastraError({\n        id: 'DATASETS_STORAGE_NOT_CONFIGURED',\n        text: 'Storage not configured. Configure storage in Mastra instance.',\n        domain: 'STORAGE',\n        category: 'USER',\n      });\n    }\n\n    const store = await storage.getStore('datasets');\n    if (!store) {\n      throw new MastraError({\n        id: 'DATASETS_STORE_NOT_AVAILABLE',\n        text: 'Datasets store not available. Ensure your storage adapter provides a datasets domain.',\n        domain: 'STORAGE',\n        category: 'USER',\n      });\n    }\n\n    this.#datasetsStore = store;\n    return store;\n  }\n\n  async #getExperimentsStore(): Promise<ExperimentsStorage> {\n    if (this.#experimentsStore) return this.#experimentsStore;\n\n    const storage = this.#mastra.getStorage();\n    if (!storage) {\n      throw new MastraError({\n        id: 'DATASETS_STORAGE_NOT_CONFIGURED',\n        text: 'Storage not configured. Configure storage in Mastra instance.',\n        domain: 'STORAGE',\n        category: 'USER',\n      });\n    }\n\n    const store = await storage.getStore('experiments');\n    if (!store) {\n      throw new MastraError({\n        id: 'EXPERIMENTS_STORE_NOT_AVAILABLE',\n        text: 'Experiments store not available. Ensure your storage adapter provides an experiments domain.',\n        domain: 'STORAGE',\n        category: 'USER',\n      });\n    }\n\n    this.#experimentsStore = store;\n    return store;\n  }\n\n  // ---------------------------------------------------------------------------\n  // Dataset CRUD\n  // ---------------------------------------------------------------------------\n\n  /**\n   * Create a new dataset.\n   * Zod schemas are automatically converted to JSON Schema.\n   */\n  async create(input: {\n    name: string;\n    description?: string;\n    inputSchema?: unknown;\n    groundTruthSchema?: unknown;\n    metadata?: Record<string, unknown>;\n  }): Promise<Dataset> {\n    const store = await this.#getDatasetsStore();\n\n    let { inputSchema, groundTruthSchema, ...rest } = input;\n\n    if (inputSchema !== undefined && isZodType(inputSchema)) {\n      inputSchema = zodToJsonSchema(inputSchema);\n    }\n    if (groundTruthSchema !== undefined && isZodType(groundTruthSchema)) {\n      groundTruthSchema = zodToJsonSchema(groundTruthSchema);\n    }\n\n    const result = await store.createDataset({\n      ...rest,\n      inputSchema: inputSchema as Record<string, unknown> | undefined,\n      groundTruthSchema: groundTruthSchema as Record<string, unknown> | undefined,\n    });\n\n    return new Dataset(result.id, this.#mastra);\n  }\n\n  /**\n   * Get an existing dataset by ID.\n   * Throws if the dataset does not exist.\n   */\n  async get(args: { id: string }): Promise<Dataset> {\n    const store = await this.#getDatasetsStore();\n    const record = await store.getDatasetById({ id: args.id });\n    if (!record) {\n      throw new MastraError({\n        id: 'DATASET_NOT_FOUND',\n        text: 'Dataset not found',\n        domain: 'STORAGE',\n        category: 'USER',\n      });\n    }\n    return new Dataset(args.id, this.#mastra);\n  }\n\n  /**\n   * List all datasets with pagination.\n   */\n  async list(args?: { page?: number; perPage?: number }) {\n    const store = await this.#getDatasetsStore();\n    return store.listDatasets({\n      pagination: { page: args?.page ?? 0, perPage: args?.perPage ?? 20 },\n    });\n  }\n\n  /**\n   * Delete a dataset by ID.\n   */\n  async delete(args: { id: string }) {\n    const store = await this.#getDatasetsStore();\n    return store.deleteDataset({ id: args.id });\n  }\n\n  // ---------------------------------------------------------------------------\n  // Cross-dataset experiment operations\n  // ---------------------------------------------------------------------------\n\n  /**\n   * Get a specific experiment (run) by ID.\n   */\n  async getExperiment(args: { experimentId: string }) {\n    const experimentsStore = await this.#getExperimentsStore();\n    return experimentsStore.getExperimentById({ id: args.experimentId });\n  }\n\n  /**\n   * Compare two or more experiments.\n   *\n   * Uses the internal `compareExperiments` function for pairwise comparison,\n   * then enriches results with per-item input/groundTruth/output data.\n   */\n  async compareExperiments(args: { experimentIds: string[]; baselineId?: string }) {\n    const { experimentIds, baselineId } = args;\n\n    if (experimentIds.length < 2) {\n      throw new MastraError({\n        id: 'COMPARE_INVALID_INPUT',\n        text: 'compareExperiments requires at least 2 experiment IDs.',\n        domain: 'STORAGE',\n        category: 'USER',\n      });\n    }\n\n    const resolvedBaseline = baselineId ?? experimentIds[0]!;\n    const otherExperimentId = experimentIds.find(id => id !== resolvedBaseline) ?? experimentIds[1]!;\n\n    const internal = await compareExperimentsInternal(this.#mastra, {\n      experimentIdA: resolvedBaseline,\n      experimentIdB: otherExperimentId,\n    });\n\n    // Load results for both runs to get input/groundTruth/output\n    const experimentsStore = await this.#getExperimentsStore();\n    const [resultsA, resultsB] = await Promise.all([\n      experimentsStore.listExperimentResults({\n        experimentId: resolvedBaseline,\n        pagination: { page: 0, perPage: false },\n      }),\n      experimentsStore.listExperimentResults({\n        experimentId: otherExperimentId,\n        pagination: { page: 0, perPage: false },\n      }),\n    ]);\n\n    // Build results maps by itemId\n    const resultsMapA = new Map(resultsA.results.map(r => [r.itemId, r]));\n    const resultsMapB = new Map(resultsB.results.map(r => [r.itemId, r]));\n\n    // Transform internal items to MVP shape\n    const items = internal.items.map(item => {\n      const resultA = resultsMapA.get(item.itemId);\n      const resultB = resultsMapB.get(item.itemId);\n\n      return {\n        itemId: item.itemId,\n        input: resultA?.input ?? resultB?.input ?? null,\n        groundTruth: resultA?.groundTruth ?? resultB?.groundTruth ?? null,\n        results: {\n          [resolvedBaseline]: resultA ? { output: resultA.output, scores: item.scoresA } : null,\n          [otherExperimentId]: resultB ? { output: resultB.output, scores: item.scoresB } : null,\n        },\n      };\n    });\n\n    return {\n      baselineId: resolvedBaseline,\n      items,\n    };\n  }\n}\n"]}