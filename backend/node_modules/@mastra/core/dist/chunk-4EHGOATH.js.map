{"version":3,"sources":["../src/workspace/errors.ts","../src/workspace/lifecycle.ts","../src/workspace/filesystem/composite-filesystem.ts","../src/workspace/filesystem/mastra-filesystem.ts","../src/workspace/filesystem/fs-utils.ts","../src/workspace/filesystem/local-filesystem.ts","../src/workspace/filesystem/file-read-tracker.ts","../src/workspace/sandbox/errors.ts","../src/workspace/sandbox/mount-manager.ts","../src/workspace/sandbox/mastra-sandbox.ts","../src/workspace/line-utils.ts","../src/workspace/search/bm25.ts","../src/workspace/search/search-engine.ts","../src/workspace/skills/schemas.ts","../src/workspace/skills/local-skill-source.ts","../src/workspace/skills/workspace-skills.ts","../src/workspace/workspace.ts","../src/workspace/sandbox/native-sandbox/detect.ts","../src/workspace/sandbox/native-sandbox/seatbelt.ts","../src/workspace/sandbox/native-sandbox/bubblewrap.ts","../src/workspace/sandbox/native-sandbox/wrapper.ts","../src/workspace/sandbox/local-sandbox.ts","../src/workspace/constants/index.ts","../src/workspace/tools/tree-formatter.ts","../src/workspace/tools/tools.ts"],"names":["path","fs","stat","access","relative","fsConstants","nodePath2","path2","fs3","os","platform","nodePath","resolve","path3","fs4","os2"],"mappings":"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","file":"chunk-4EHGOATH.js","sourcesContent":["/**\n * Workspace Errors\n *\n * Error classes for workspace operations.\n */\n\nimport type { WorkspaceStatus } from './types';\n\n// =============================================================================\n// Base Error\n// =============================================================================\n\nexport class WorkspaceError extends Error {\n  constructor(\n    message: string,\n    public readonly code: string,\n    public readonly workspaceId?: string,\n  ) {\n    super(message);\n    this.name = 'WorkspaceError';\n  }\n}\n\n// =============================================================================\n// Availability Errors\n// =============================================================================\n\nexport class FilesystemNotAvailableError extends WorkspaceError {\n  constructor() {\n    super('Workspace does not have a filesystem configured', 'NO_FILESYSTEM');\n    this.name = 'FilesystemNotAvailableError';\n  }\n}\n\nexport class SandboxNotAvailableError extends WorkspaceError {\n  constructor(message?: string) {\n    super(message ?? 'Workspace does not have a sandbox configured', 'NO_SANDBOX');\n    this.name = 'SandboxNotAvailableError';\n  }\n}\n\nexport class SandboxFeatureNotSupportedError extends WorkspaceError {\n  constructor(feature: 'executeCommand' | 'installPackage') {\n    super(`Sandbox does not support ${feature}`, 'FEATURE_NOT_SUPPORTED');\n    this.name = 'SandboxFeatureNotSupportedError';\n  }\n}\n\nexport class SearchNotAvailableError extends WorkspaceError {\n  constructor() {\n    super('Workspace does not have search configured (enable bm25 or provide vectorStore + embedder)', 'NO_SEARCH');\n    this.name = 'SearchNotAvailableError';\n  }\n}\n\n// =============================================================================\n// State Errors\n// =============================================================================\n\nexport class WorkspaceNotReadyError extends WorkspaceError {\n  constructor(workspaceId: string, status: WorkspaceStatus) {\n    super(`Workspace is not ready (status: ${status})`, 'NOT_READY', workspaceId);\n    this.name = 'WorkspaceNotReadyError';\n  }\n}\n\nexport class WorkspaceReadOnlyError extends WorkspaceError {\n  constructor(operation: string) {\n    super(`Workspace is in read-only mode. Cannot perform: ${operation}`, 'READ_ONLY');\n    this.name = 'WorkspaceReadOnlyError';\n  }\n}\n\n// =============================================================================\n// Filesystem Errors\n// =============================================================================\n\nexport class FilesystemError extends Error {\n  constructor(\n    message: string,\n    public readonly code: string,\n    public readonly path: string,\n  ) {\n    super(message);\n    this.name = 'FilesystemError';\n  }\n}\n\nexport class FileNotFoundError extends FilesystemError {\n  constructor(path: string) {\n    super(`File not found: ${path}`, 'ENOENT', path);\n    this.name = 'FileNotFoundError';\n  }\n}\n\nexport class DirectoryNotFoundError extends FilesystemError {\n  constructor(path: string) {\n    super(`Directory not found: ${path}`, 'ENOENT', path);\n    this.name = 'DirectoryNotFoundError';\n  }\n}\n\nexport class FileExistsError extends FilesystemError {\n  constructor(path: string) {\n    super(`File already exists: ${path}`, 'EEXIST', path);\n    this.name = 'FileExistsError';\n  }\n}\n\nexport class IsDirectoryError extends FilesystemError {\n  constructor(path: string) {\n    super(`Path is a directory: ${path}`, 'EISDIR', path);\n    this.name = 'IsDirectoryError';\n  }\n}\n\nexport class NotDirectoryError extends FilesystemError {\n  constructor(path: string) {\n    super(`Path is not a directory: ${path}`, 'ENOTDIR', path);\n    this.name = 'NotDirectoryError';\n  }\n}\n\nexport class DirectoryNotEmptyError extends FilesystemError {\n  constructor(path: string) {\n    super(`Directory not empty: ${path}`, 'ENOTEMPTY', path);\n    this.name = 'DirectoryNotEmptyError';\n  }\n}\n\nexport class PermissionError extends FilesystemError {\n  constructor(\n    path: string,\n    public readonly operation: string,\n  ) {\n    super(`Permission denied: ${operation} on ${path}`, 'EACCES', path);\n    this.name = 'PermissionError';\n  }\n}\n\nexport class FileReadRequiredError extends FilesystemError {\n  constructor(path: string, reason: string) {\n    super(reason, 'EREAD_REQUIRED', path);\n    this.name = 'FileReadRequiredError';\n  }\n}\n\n/**\n * Error thrown when a filesystem operation is attempted before initialization.\n */\nexport class FilesystemNotReadyError extends FilesystemError {\n  constructor(id: string) {\n    super(`Filesystem \"${id}\" is not ready. Call init() first or use ensureReady().`, 'ENOTREADY', id);\n    this.name = 'FilesystemNotReadyError';\n  }\n}\n","/**\n * Workspace Lifecycle Interfaces\n *\n * Defines lifecycle contracts for workspace providers (filesystem, sandbox).\n * The base `Lifecycle` holds shared members while `FilesystemLifecycle` and\n * `SandboxLifecycle` add the methods each provider kind actually uses.\n */\n\n// =============================================================================\n// Base Lifecycle Interface\n// =============================================================================\n\n/**\n * Shared lifecycle base for workspace providers.\n *\n * Contains status tracking, destroy, readiness check, and info retrieval.\n * Provider-specific lifecycle methods live in the extended interfaces:\n * - {@link FilesystemLifecycle} adds `init()`\n * - {@link SandboxLifecycle} adds `start()` / `stop()`\n *\n * @typeParam TInfo - The type returned by getInfo() (e.g., FilesystemInfo, SandboxInfo)\n */\nexport interface Lifecycle<TInfo = unknown> {\n  /** Current status */\n  status: ProviderStatus;\n\n  /** Error message when status is 'error' */\n  error?: string;\n\n  /**\n   * Clean up all resources.\n   *\n   * Called when the workspace is being permanently shut down.\n   * Use for operations like:\n   * - Terminating cloud instances\n   * - Closing all connections\n   * - Cleaning up temporary files\n   */\n  destroy?(): void | Promise<void>;\n\n  /**\n   * Check if ready for operations.\n   *\n   * Returns true if the provider is ready to handle requests.\n   * Use for checking:\n   * - Connection health\n   * - Instance status\n   * - Resource availability\n   */\n  isReady?(): boolean | Promise<boolean>;\n\n  /**\n   * Get status and metadata.\n   *\n   * Returns information about the current state of the provider.\n   */\n  getInfo?(): TInfo | Promise<TInfo>;\n}\n\n// =============================================================================\n// Filesystem Lifecycle\n// =============================================================================\n\n/**\n * Lifecycle interface for filesystem providers (two-phase: init  destroy).\n *\n * @typeParam TInfo - The type returned by getInfo()\n */\nexport interface FilesystemLifecycle<TInfo = unknown> extends Lifecycle<TInfo> {\n  /**\n   * One-time setup operations.\n   *\n   * Called once when the workspace is first initialized.\n   * Use for operations like:\n   * - Creating base directories\n   * - Setting up database tables\n   * - Provisioning cloud resources\n   * - Installing dependencies\n   */\n  init?(): void | Promise<void>;\n}\n\n// =============================================================================\n// Sandbox Lifecycle\n// =============================================================================\n\n/**\n * Lifecycle interface for sandbox providers (three-phase: start  stop  destroy).\n *\n * @typeParam TInfo - The type returned by getInfo()\n */\nexport interface SandboxLifecycle<TInfo = unknown> extends Lifecycle<TInfo> {\n  /**\n   * Begin active operation.\n   *\n   * Called to transition from initialized to running state.\n   * Use for operations like:\n   * - Establishing connection pools\n   * - Spinning up cloud instances\n   * - Starting background processes\n   * - Warming up caches\n   */\n  start?(): void | Promise<void>;\n\n  /**\n   * Pause operation, keeping state for potential restart.\n   *\n   * Called to temporarily stop without full cleanup.\n   * Use for operations like:\n   * - Closing connections (but keeping config)\n   * - Pausing cloud instances\n   * - Flushing buffers\n   */\n  stop?(): void | Promise<void>;\n}\n\n// =============================================================================\n// Status Types\n// =============================================================================\n\n/**\n * Common status values for stateful providers.\n *\n * Not all providers need status tracking - local/stateless providers\n * may not use this. But providers with connection pools or cloud\n * instances can use these states.\n */\nexport type ProviderStatus =\n  | 'pending' // Created but not initialized\n  | 'initializing' // Running init()\n  | 'ready' // Initialized, waiting to start (or stateless and ready)\n  | 'starting' // Running start()\n  | 'running' // Active and accepting requests\n  | 'stopping' // Running stop()\n  | 'stopped' // Stopped but can restart\n  | 'destroying' // Running destroy()\n  | 'destroyed' // Fully cleaned up\n  | 'error'; // Something went wrong\n\n// =============================================================================\n// Lifecycle Helper\n// =============================================================================\n\n/**\n * Provider that may have lifecycle methods.\n * Used by `callLifecycle` to dispatch to the correct method.\n */\ninterface LifecycleProvider {\n  _init?(): void | Promise<void>;\n  _start?(): void | Promise<void>;\n  _stop?(): void | Promise<void>;\n  _destroy?(): void | Promise<void>;\n  init?(): void | Promise<void>;\n  start?(): void | Promise<void>;\n  stop?(): void | Promise<void>;\n  destroy?(): void | Promise<void>;\n}\n\n/**\n * Call a lifecycle method on a provider, preferring the `_`-prefixed wrapper\n * (which adds status tracking & race-condition safety) when available,\n * falling back to the plain method for interface-only implementations.\n *\n * @example\n * ```typescript\n * await callLifecycle(sandbox, 'start');   // calls sandbox._start() ?? sandbox.start()\n * await callLifecycle(filesystem, 'init'); // calls filesystem._init() ?? filesystem.init()\n * ```\n */\nexport async function callLifecycle(\n  provider: LifecycleProvider,\n  method: 'init' | 'start' | 'stop' | 'destroy',\n): Promise<void> {\n  const wrapped = `_${method}` as const;\n  const wrappedFn = provider[wrapped];\n  if (typeof wrappedFn === 'function') {\n    await wrappedFn.call(provider);\n  } else {\n    const plainFn = provider[method];\n    if (typeof plainFn === 'function') {\n      await plainFn.call(provider);\n    }\n  }\n}\n","/**\n * CompositeFilesystem - Routes operations to mounted filesystems based on path.\n *\n * Creates a unified filesystem view by combining multiple filesystems at different\n * mount points. Useful for composing local storage, S3, and other backends.\n *\n * @example\n * ```typescript\n * const cfs = new CompositeFilesystem({\n *   mounts: {\n *     '/local': new LocalFilesystem({ basePath: './data' }),\n *     '/s3': new S3Filesystem({ bucket: 'my-bucket', ... }),\n *   }\n * });\n *\n * // readdir('/') returns ['local', 's3']\n * // readFile('/local/file.txt') reads from LocalFilesystem\n * // readFile('/s3/data.json') reads from S3Filesystem\n * ```\n */\n\nimport { PermissionError } from '../errors';\nimport { callLifecycle } from '../lifecycle';\nimport type { ProviderStatus } from '../lifecycle';\nimport type {\n  WorkspaceFilesystem,\n  FileContent,\n  FileEntry,\n  FileStat,\n  ReadOptions,\n  WriteOptions,\n  ListOptions,\n  CopyOptions,\n  RemoveOptions,\n} from './filesystem';\n\n/**\n * Configuration for CompositeFilesystem.\n */\nexport interface CompositeFilesystemConfig {\n  /** Map of mount paths to filesystem instances */\n  mounts: Record<string, WorkspaceFilesystem>;\n}\n\ninterface ResolvedMount {\n  fs: WorkspaceFilesystem;\n  fsPath: string;\n  mountPath: string;\n}\n\n/**\n * CompositeFilesystem implementation.\n *\n * Routes file operations to the appropriate underlying filesystem based on path.\n * Supports cross-mount operations (copy/move between different filesystems).\n */\nexport class CompositeFilesystem implements WorkspaceFilesystem {\n  readonly id: string;\n  readonly name = 'CompositeFilesystem';\n  readonly provider = 'composite';\n\n  status: ProviderStatus = 'ready';\n\n  private readonly _mounts: Map<string, WorkspaceFilesystem>;\n\n  constructor(config: CompositeFilesystemConfig) {\n    this.id = `cfs-${Date.now().toString(36)}`;\n    this._mounts = new Map();\n\n    for (const [path, fs] of Object.entries(config.mounts)) {\n      const normalized = this.normalizePath(path);\n      this._mounts.set(normalized, fs);\n    }\n\n    if (this._mounts.size === 0) {\n      throw new Error('CompositeFilesystem requires at least one mount');\n    }\n\n    // Validate no nested mount paths (e.g., /data and /data/sub)\n    const mountPaths = [...this._mounts.keys()];\n    for (const a of mountPaths) {\n      for (const b of mountPaths) {\n        if (a !== b && b.startsWith(a + '/')) {\n          throw new Error(`Nested mount paths are not supported: \"${b}\" is nested under \"${a}\"`);\n        }\n      }\n    }\n  }\n\n  /**\n   * Get all mount paths.\n   */\n  get mountPaths(): string[] {\n    return Array.from(this._mounts.keys());\n  }\n\n  /**\n   * Get the mounts map.\n   */\n  get mounts(): ReadonlyMap<string, WorkspaceFilesystem> {\n    return this._mounts;\n  }\n\n  /**\n   * Get the underlying filesystem for a given path.\n   * Returns undefined if the path doesn't resolve to any mount.\n   */\n  getFilesystemForPath(path: string): WorkspaceFilesystem | undefined {\n    const resolved = this.resolveMount(path);\n    return resolved?.fs;\n  }\n\n  /**\n   * Get the mount path for a given path.\n   * Returns undefined if the path doesn't resolve to any mount.\n   */\n  getMountPathForPath(path: string): string | undefined {\n    const resolved = this.resolveMount(path);\n    return resolved?.mountPath;\n  }\n\n  private normalizePath(path: string): string {\n    if (!path || path === '/') return '/';\n    let n = path.startsWith('/') ? path : `/${path}`;\n    if (n.length > 1 && n.endsWith('/')) n = n.slice(0, -1);\n    return n;\n  }\n\n  private resolveMount(path: string): ResolvedMount | null {\n    const normalized = this.normalizePath(path);\n    let best: { mountPath: string; fs: WorkspaceFilesystem } | null = null;\n\n    for (const [mountPath, fs] of this._mounts) {\n      if (normalized === mountPath || normalized.startsWith(mountPath + '/')) {\n        if (!best || mountPath.length > best.mountPath.length) {\n          best = { mountPath, fs };\n        }\n      }\n    }\n\n    if (!best) return null;\n\n    let fsPath = normalized.slice(best.mountPath.length);\n    if (!fsPath) fsPath = '/';\n    if (!fsPath.startsWith('/')) fsPath = '/' + fsPath;\n\n    return { fs: best.fs, fsPath, mountPath: best.mountPath };\n  }\n\n  private getVirtualEntries(path: string): FileEntry[] | null {\n    const normalized = this.normalizePath(path);\n    if (this.resolveMount(normalized)) return null;\n\n    const entriesMap = new Map<string, FileEntry>();\n    for (const [mountPath, fs] of this._mounts.entries()) {\n      const isUnder = normalized === '/' ? mountPath.startsWith('/') : mountPath.startsWith(normalized + '/');\n\n      if (isUnder) {\n        const remaining = normalized === '/' ? mountPath.slice(1) : mountPath.slice(normalized.length + 1);\n        const next = remaining.split('/')[0];\n        if (next && !entriesMap.has(next)) {\n          // Check if this is a direct mount point (e.g., listing '/' and mount is '/s3')\n          const isDirectMount = remaining === next;\n          const entry: FileEntry = { name: next, type: 'directory' as const };\n\n          // If it's a direct mount point, include filesystem metadata\n          if (isDirectMount) {\n            entry.mount = {\n              provider: fs.provider,\n              icon: fs.icon,\n              displayName: fs.displayName,\n              description: fs.description,\n              status: fs.status,\n              error: fs.error,\n            };\n          }\n\n          entriesMap.set(next, entry);\n        }\n      }\n    }\n\n    return entriesMap.size > 0 ? Array.from(entriesMap.values()) : null;\n  }\n\n  private isVirtualPath(path: string): boolean {\n    const normalized = this.normalizePath(path);\n    if (normalized === '/' && !this._mounts.has('/')) return true;\n    for (const mountPath of this._mounts.keys()) {\n      if (mountPath.startsWith(normalized + '/')) return true;\n    }\n    return false;\n  }\n\n  /**\n   * Assert that a filesystem is writable (not read-only).\n   * @throws {PermissionError} if the filesystem is read-only\n   */\n  private assertWritable(fs: WorkspaceFilesystem, path: string, operation: string): void {\n    if (fs.readOnly) {\n      throw new PermissionError(path, `${operation} (filesystem is read-only)`);\n    }\n  }\n\n  // ===========================================================================\n  // WorkspaceFilesystem Implementation\n  // ===========================================================================\n\n  async init(): Promise<void> {\n    this.status = 'initializing';\n    for (const [mountPath, fs] of this._mounts.entries()) {\n      try {\n        await callLifecycle(fs, 'init');\n      } catch (e) {\n        // Individual mount failed - it will have status='error'\n        // Log but continue with other mounts\n        const message = e instanceof Error ? e.message : String(e);\n        console.warn(`[CompositeFilesystem] Mount \"${mountPath}\" failed to initialize: ${message}`);\n      }\n    }\n    // CompositeFilesystem is ready even if some mounts failed\n    // Operations on errored mounts will be handled by the underlying filesystem\n    this.status = 'ready';\n  }\n\n  async destroy(): Promise<void> {\n    this.status = 'destroying';\n    const errors: Error[] = [];\n    for (const fs of this._mounts.values()) {\n      try {\n        await callLifecycle(fs, 'destroy');\n      } catch (e) {\n        errors.push(e instanceof Error ? e : new Error(String(e)));\n      }\n    }\n    if (errors.length > 0) {\n      this.status = 'error';\n      throw new AggregateError(errors, 'Some filesystems failed to destroy');\n    }\n    this.status = 'destroyed';\n  }\n\n  async readFile(path: string, options?: ReadOptions): Promise<string | Buffer> {\n    const r = this.resolveMount(path);\n    if (!r) throw new Error(`No mount for path: ${path}`);\n    return r.fs.readFile(r.fsPath, options);\n  }\n\n  async writeFile(path: string, content: FileContent, options?: WriteOptions): Promise<void> {\n    const r = this.resolveMount(path);\n    if (!r) throw new Error(`No mount for path: ${path}`);\n    this.assertWritable(r.fs, path, 'writeFile');\n    return r.fs.writeFile(r.fsPath, content, options);\n  }\n\n  async appendFile(path: string, content: FileContent): Promise<void> {\n    const r = this.resolveMount(path);\n    if (!r) throw new Error(`No mount for path: ${path}`);\n    this.assertWritable(r.fs, path, 'appendFile');\n    return r.fs.appendFile(r.fsPath, content);\n  }\n\n  async deleteFile(path: string, options?: RemoveOptions): Promise<void> {\n    const r = this.resolveMount(path);\n    if (!r) throw new Error(`No mount for path: ${path}`);\n    this.assertWritable(r.fs, path, 'deleteFile');\n    return r.fs.deleteFile(r.fsPath, options);\n  }\n\n  async copyFile(src: string, dest: string, options?: CopyOptions): Promise<void> {\n    const srcR = this.resolveMount(src);\n    const destR = this.resolveMount(dest);\n    if (!srcR) throw new Error(`No mount for source: ${src}`);\n    if (!destR) throw new Error(`No mount for dest: ${dest}`);\n    this.assertWritable(destR.fs, dest, 'copyFile');\n\n    // Same mount - delegate\n    if (srcR.mountPath === destR.mountPath) {\n      return srcR.fs.copyFile(srcR.fsPath, destR.fsPath, options);\n    }\n\n    // Cross-mount copy - read then write\n    const content = await srcR.fs.readFile(srcR.fsPath);\n    await destR.fs.writeFile(destR.fsPath, content, { overwrite: options?.overwrite });\n  }\n\n  async moveFile(src: string, dest: string, options?: CopyOptions): Promise<void> {\n    const srcR = this.resolveMount(src);\n    const destR = this.resolveMount(dest);\n    if (!srcR) throw new Error(`No mount for source: ${src}`);\n    if (!destR) throw new Error(`No mount for dest: ${dest}`);\n    this.assertWritable(destR.fs, dest, 'moveFile');\n    this.assertWritable(srcR.fs, src, 'moveFile'); // Source must be writable for delete\n\n    // Same mount - delegate\n    if (srcR.mountPath === destR.mountPath) {\n      return srcR.fs.moveFile(srcR.fsPath, destR.fsPath, options);\n    }\n\n    // Cross-mount move - copy then delete\n    await this.copyFile(src, dest, options);\n    await srcR.fs.deleteFile(srcR.fsPath);\n  }\n\n  async readdir(path: string, options?: ListOptions): Promise<FileEntry[]> {\n    const virtual = this.getVirtualEntries(path);\n    if (virtual) return virtual;\n\n    const r = this.resolveMount(path);\n    if (!r) throw new Error(`No mount for path: ${path}`);\n    return r.fs.readdir(r.fsPath, options);\n  }\n\n  async mkdir(path: string, options?: { recursive?: boolean }): Promise<void> {\n    const r = this.resolveMount(path);\n    if (!r) throw new Error(`No mount for path: ${path}`);\n    this.assertWritable(r.fs, path, 'mkdir');\n    return r.fs.mkdir(r.fsPath, options);\n  }\n\n  async rmdir(path: string, options?: RemoveOptions): Promise<void> {\n    const r = this.resolveMount(path);\n    if (!r) throw new Error(`No mount for path: ${path}`);\n    this.assertWritable(r.fs, path, 'rmdir');\n    return r.fs.rmdir(r.fsPath, options);\n  }\n\n  async exists(path: string): Promise<boolean> {\n    if (this.isVirtualPath(path)) return true;\n    const r = this.resolveMount(path);\n    if (!r) return false;\n    // Mount point root always exists (even if errored)\n    if (r.fsPath === '/') return true;\n    return r.fs.exists(r.fsPath);\n  }\n\n  async stat(path: string): Promise<FileStat> {\n    const normalized = this.normalizePath(path);\n\n    if (this.isVirtualPath(path)) {\n      const parts = normalized.split('/').filter(Boolean);\n      const now = new Date();\n      return {\n        name: parts[parts.length - 1] || '',\n        path: normalized,\n        type: 'directory',\n        size: 0,\n        createdAt: now,\n        modifiedAt: now,\n      };\n    }\n\n    const r = this.resolveMount(path);\n    if (!r) throw new Error(`No mount for path: ${path}`);\n\n    // Mount point root always returns directory stat (even if errored)\n    if (r.fsPath === '/') {\n      const parts = normalized.split('/').filter(Boolean);\n      const now = new Date();\n      return {\n        name: parts[parts.length - 1] || '',\n        path: normalized,\n        type: 'directory',\n        size: 0,\n        createdAt: now,\n        modifiedAt: now,\n      };\n    }\n\n    return r.fs.stat(r.fsPath);\n  }\n\n  async isFile(path: string): Promise<boolean> {\n    if (this.isVirtualPath(path)) return false;\n    const r = this.resolveMount(path);\n    if (!r) return false;\n    try {\n      const stat = await r.fs.stat(r.fsPath);\n      return stat.type === 'file';\n    } catch {\n      return false;\n    }\n  }\n\n  async isDirectory(path: string): Promise<boolean> {\n    if (this.isVirtualPath(path)) return true;\n    const r = this.resolveMount(path);\n    if (!r) return false;\n    // Mount point root is always a directory (even if errored)\n    if (r.fsPath === '/') return true;\n    try {\n      const stat = await r.fs.stat(r.fsPath);\n      return stat.type === 'directory';\n    } catch {\n      return false;\n    }\n  }\n\n  /**\n   * Get instructions describing the mounted filesystems.\n   * Used by agents to understand available storage locations.\n   */\n  getInstructions(): string {\n    const mountDescriptions = Array.from(this._mounts.entries())\n      .map(([mountPath, fs]) => {\n        const name = fs.displayName || fs.provider;\n        const access = fs.readOnly ? '(read-only)' : '(read-write)';\n        return `- ${mountPath}: ${name} ${access}`;\n      })\n      .join('\\n');\n\n    return `Mounted filesystems:\\n${mountDescriptions}\\nFiles written via workspace tools are accessible at the same paths in sandbox commands.`;\n  }\n}\n","/**\n * MastraFilesystem Base Class\n *\n * Abstract base class for filesystem providers that want automatic logger integration\n * and lifecycle management.\n *\n * Extends MastraBase to receive the Mastra logger when registered with a Mastra instance.\n *\n * ## Lifecycle Management\n *\n * The base class provides race-condition-safe lifecycle wrappers:\n * - `_init()` - Handles concurrent calls, status management\n * - `_destroy()` - Handles concurrent calls and status management\n *\n * Subclasses override the plain `init()` and `destroy()` methods to provide\n * their implementation. Callers use the `_`-prefixed wrappers (or `callLifecycle()`)\n * which add status tracking and race-condition safety.\n *\n * External providers can extend this class to get logger support, or implement\n * the WorkspaceFilesystem interface directly if they don't need logging.\n */\n\nimport { MastraBase } from '../../base';\nimport { RegisteredLogger } from '../../logger/constants';\nimport { FilesystemNotReadyError } from '../errors';\nimport type { ProviderStatus } from '../lifecycle';\nimport type {\n  WorkspaceFilesystem,\n  FileContent,\n  FileStat,\n  FileEntry,\n  ReadOptions,\n  WriteOptions,\n  ListOptions,\n  RemoveOptions,\n  CopyOptions,\n} from './filesystem';\n\n/**\n * Lifecycle hook that fires during filesystem state transitions.\n * Receives the filesystem instance so users can inspect state, log, etc.\n */\nexport type FilesystemLifecycleHook = (args: { filesystem: WorkspaceFilesystem }) => void | Promise<void>;\n\n/**\n * Options for the MastraFilesystem base class constructor.\n * Providers extend this to add their own options while inheriting lifecycle hooks.\n */\nexport interface MastraFilesystemOptions {\n  /** Called after the filesystem reaches 'ready' status */\n  onInit?: FilesystemLifecycleHook;\n  /** Called before the filesystem is destroyed */\n  onDestroy?: FilesystemLifecycleHook;\n}\n\n/**\n * Abstract base class for filesystem providers with logger support and lifecycle management.\n *\n * Providers that extend this class automatically receive the Mastra logger\n * when the filesystem is used with a Mastra instance.\n *\n * @example\n * ```typescript\n * class MyCustomFilesystem extends MastraFilesystem {\n *   readonly id = 'my-fs';\n *   readonly name = 'MyCustomFilesystem';\n *   readonly provider = 'custom';\n *   status: ProviderStatus = 'pending';\n *\n *   constructor() {\n *     super({ name: 'MyCustomFilesystem' });\n *   }\n *\n *   // Override init() to provide initialization logic\n *   async init(): Promise<void> {\n *     // Your initialization logic here\n *   }\n *\n *   async readFile(path: string): Promise<string | Buffer> {\n *     await this.ensureReady();\n *     this.logger.debug('Reading file', { path });\n *     // Implementation...\n *   }\n *   // ... implement other WorkspaceFilesystem methods\n * }\n * ```\n */\nexport abstract class MastraFilesystem extends MastraBase implements WorkspaceFilesystem {\n  /** Unique identifier for this filesystem instance */\n  abstract readonly id: string;\n\n  /** Human-readable name (e.g., 'LocalFilesystem', 'AgentFS') */\n  abstract readonly name: string;\n\n  /** Provider type identifier */\n  abstract readonly provider: string;\n\n  /** Current status of the filesystem */\n  abstract status: ProviderStatus;\n\n  /** Error message when status is 'error' */\n  error?: string;\n\n  // ---------------------------------------------------------------------------\n  // Lifecycle Promise Tracking (prevents race conditions)\n  // ---------------------------------------------------------------------------\n\n  /** Promise for _init() to prevent race conditions from concurrent calls */\n  private _initPromise?: Promise<void>;\n\n  /** Promise for _destroy() to prevent race conditions from concurrent calls */\n  private _destroyPromise?: Promise<void>;\n\n  /** Lifecycle callbacks */\n  private readonly _onInit?: FilesystemLifecycleHook;\n  private readonly _onDestroy?: FilesystemLifecycleHook;\n\n  constructor(options: { name: string } & MastraFilesystemOptions) {\n    super({ name: options.name, component: RegisteredLogger.WORKSPACE });\n\n    this._onInit = options.onInit;\n    this._onDestroy = options.onDestroy;\n  }\n\n  // ---------------------------------------------------------------------------\n  // Lifecycle Wrappers (race-condition-safe)\n  // ---------------------------------------------------------------------------\n\n  /**\n   * Initialize the filesystem (wrapper with status management and race-condition safety).\n   *\n   * This method is race-condition-safe - concurrent calls will return the same promise.\n   * Handles status management automatically.\n   *\n   * Subclasses override `init()` to provide their initialization logic.\n   */\n  async _init(): Promise<void> {\n    // Already ready\n    // Note: intentionally allows re-init after destroy() for reconnect scenarios\n    if (this.status === 'ready') {\n      return;\n    }\n\n    // Wait for any in-progress destroy to complete before (re-)initializing\n    if (this._destroyPromise) {\n      try {\n        await this._destroyPromise;\n      } catch {\n        // Ignore destroy errors  we're re-initializing anyway\n      }\n    }\n\n    // Init already in progress - return existing promise\n    if (this._initPromise) {\n      return this._initPromise;\n    }\n\n    // Create and store the init promise\n    this._initPromise = this._executeInit();\n\n    try {\n      await this._initPromise;\n    } finally {\n      this._initPromise = undefined;\n    }\n  }\n\n  /**\n   * Internal init execution - handles status.\n   */\n  private async _executeInit(): Promise<void> {\n    this.status = 'initializing';\n    this.error = undefined;\n\n    try {\n      await this.init();\n      this.status = 'ready';\n\n      // Fire onInit callback after filesystem is ready  treat failure as non-fatal\n      // so that a bad callback doesn't kill an otherwise healthy filesystem\n      try {\n        await this._onInit?.({ filesystem: this });\n      } catch (error) {\n        this.logger.warn('onInit callback failed', { error });\n      }\n    } catch (error) {\n      this.status = 'error';\n      this.error = error instanceof Error ? error.message : String(error);\n      this.logger.error('Failed to initialize filesystem', { error, id: this.id });\n      throw error;\n    }\n  }\n\n  /**\n   * Override this method to implement filesystem initialization logic.\n   *\n   * Called by `_init()` after status is set to 'initializing'.\n   * Status will be set to 'ready' on success, 'error' on failure.\n   *\n   * @example\n   * ```typescript\n   * async init(): Promise<void> {\n   *   this._client = new StorageClient({ ... });\n   *   await this._client.connect();\n   * }\n   * ```\n   */\n  async init(): Promise<void> {\n    // Default no-op - subclasses override\n  }\n\n  /**\n   * Ensure the filesystem is ready.\n   *\n   * Calls `_init()` if status is not 'ready'. Useful for lazy initialization\n   * where operations should automatically initialize the filesystem if needed.\n   *\n   * @throws {FilesystemNotReadyError} if the filesystem fails to reach 'ready' status\n   *\n   * @example\n   * ```typescript\n   * async readFile(path: string): Promise<string | Buffer> {\n   *   await this.ensureReady();\n   *   // Now safe to use the filesystem\n   * }\n   * ```\n   */\n  protected async ensureReady(): Promise<void> {\n    if (this.status !== 'ready') {\n      await this._init();\n    }\n    if (this.status !== 'ready') {\n      throw new FilesystemNotReadyError(this.id);\n    }\n  }\n\n  /**\n   * Destroy the filesystem and clean up all resources (wrapper with status management).\n   *\n   * This method is race-condition-safe - concurrent calls will return the same promise.\n   * Handles status management.\n   *\n   * Subclasses override `destroy()` to provide their destroy logic.\n   */\n  async _destroy(): Promise<void> {\n    // Already destroyed\n    if (this.status === 'destroyed') {\n      return;\n    }\n\n    // Never initialized  nothing to tear down\n    if (this.status === 'pending') {\n      this.status = 'destroyed';\n      return;\n    }\n\n    // Destroy already in progress - return existing promise\n    if (this._destroyPromise) {\n      return this._destroyPromise;\n    }\n\n    // Create and store the destroy promise\n    this._destroyPromise = this._executeDestroy();\n\n    try {\n      await this._destroyPromise;\n    } finally {\n      this._destroyPromise = undefined;\n    }\n  }\n\n  /**\n   * Internal destroy execution - handles status.\n   */\n  private async _executeDestroy(): Promise<void> {\n    // Wait for any in-progress init to complete before destroying\n    if (this._initPromise) {\n      try {\n        await this._initPromise;\n      } catch {\n        // Ignore init errors  we're destroying anyway\n      }\n    }\n    this.status = 'destroying';\n\n    try {\n      // Fire onDestroy callback before destroying\n      await this._onDestroy?.({ filesystem: this });\n\n      await this.destroy();\n      this.status = 'destroyed';\n    } catch (error) {\n      this.status = 'error';\n      this.logger.error('Failed to destroy filesystem', { error, id: this.id });\n      throw error;\n    }\n  }\n\n  /**\n   * Override this method to implement filesystem destroy logic.\n   *\n   * Called by `_destroy()` after status is set to 'destroying'.\n   * Status will be set to 'destroyed' on success, 'error' on failure.\n   */\n  async destroy(): Promise<void> {\n    // Default no-op - subclasses override\n  }\n\n  // ---------------------------------------------------------------------------\n  // Abstract methods - implementations must provide these\n  // ---------------------------------------------------------------------------\n\n  abstract readFile(path: string, options?: ReadOptions): Promise<string | Buffer>;\n  abstract writeFile(path: string, content: FileContent, options?: WriteOptions): Promise<void>;\n  abstract appendFile(path: string, content: FileContent): Promise<void>;\n  abstract deleteFile(path: string, options?: RemoveOptions): Promise<void>;\n  abstract copyFile(src: string, dest: string, options?: CopyOptions): Promise<void>;\n  abstract moveFile(src: string, dest: string, options?: CopyOptions): Promise<void>;\n  abstract mkdir(path: string, options?: { recursive?: boolean }): Promise<void>;\n  abstract rmdir(path: string, options?: RemoveOptions): Promise<void>;\n  abstract readdir(path: string, options?: ListOptions): Promise<FileEntry[]>;\n  abstract exists(path: string): Promise<boolean>;\n  abstract stat(path: string): Promise<FileStat>;\n}\n","/**\n * Shared filesystem utilities for LocalFilesystem and LocalSkillSource.\n *\n * These utilities provide consistent implementations for common fs operations.\n */\n\nimport * as fs from 'node:fs/promises';\nimport * as path from 'node:path';\n\nimport { FileNotFoundError } from '../errors';\n\n// =============================================================================\n// Types\n// =============================================================================\n\n/**\n * Full file stat information.\n * Used by both WorkspaceFilesystem and SkillSource.\n */\nexport interface FsStatResult {\n  /** File or directory name */\n  name: string;\n  /** 'file' or 'directory' */\n  type: 'file' | 'directory';\n  /** Size in bytes (0 for directories) */\n  size: number;\n  /** Creation time */\n  createdAt: Date;\n  /** Last modification time */\n  modifiedAt: Date;\n  /** MIME type (for files) */\n  mimeType?: string;\n}\n\n// =============================================================================\n// Error Utilities\n// =============================================================================\n\n/**\n * Check if an error is an ENOENT (file not found) error.\n */\nexport function isEnoentError(error: unknown): error is NodeJS.ErrnoException & { code: 'ENOENT' } {\n  return (\n    error !== null && typeof error === 'object' && 'code' in error && (error as NodeJS.ErrnoException).code === 'ENOENT'\n  );\n}\n\n/**\n * Check if an error is an EEXIST (file exists) error.\n */\nexport function isEexistError(error: unknown): error is NodeJS.ErrnoException & { code: 'EEXIST' } {\n  return (\n    error !== null && typeof error === 'object' && 'code' in error && (error as NodeJS.ErrnoException).code === 'EEXIST'\n  );\n}\n\n// =============================================================================\n// MIME Type Detection\n// =============================================================================\n\nconst MIME_TYPES: Record<string, string> = {\n  // Text\n  txt: 'text/plain',\n  html: 'text/html',\n  htm: 'text/html',\n  css: 'text/css',\n  csv: 'text/csv',\n  md: 'text/markdown',\n  // Code\n  js: 'application/javascript',\n  mjs: 'application/javascript',\n  ts: 'application/typescript',\n  tsx: 'application/typescript',\n  jsx: 'application/javascript',\n  json: 'application/json',\n  xml: 'application/xml',\n  yaml: 'text/yaml',\n  yml: 'text/yaml',\n  // Programming languages\n  py: 'text/x-python',\n  rb: 'text/x-ruby',\n  go: 'text/x-go',\n  rs: 'text/x-rust',\n  java: 'text/x-java',\n  c: 'text/x-c',\n  cpp: 'text/x-c++',\n  h: 'text/x-c',\n  hpp: 'text/x-c++',\n  sh: 'text/x-sh',\n  bash: 'text/x-sh',\n  zsh: 'text/x-sh',\n  // Config\n  toml: 'text/toml',\n  ini: 'text/plain',\n  env: 'text/plain',\n  // Database/Query\n  sql: 'text/x-sql',\n  graphql: 'application/graphql',\n  gql: 'application/graphql',\n  // Frameworks\n  vue: 'text/x-vue',\n  // Images\n  png: 'image/png',\n  jpg: 'image/jpeg',\n  jpeg: 'image/jpeg',\n  gif: 'image/gif',\n  svg: 'image/svg+xml',\n  webp: 'image/webp',\n  ico: 'image/x-icon',\n  // Documents\n  pdf: 'application/pdf',\n};\n\n/**\n * Get MIME type for a filename based on extension.\n */\nexport function getMimeType(filename: string): string {\n  const ext = path.extname(filename).slice(1).toLowerCase();\n  return MIME_TYPES[ext] ?? 'application/octet-stream';\n}\n\n/**\n * Extensions that should be treated as text files.\n */\nconst TEXT_EXTENSIONS = new Set([\n  '.md',\n  '.txt',\n  '.json',\n  '.yaml',\n  '.yml',\n  '.js',\n  '.mjs',\n  '.ts',\n  '.tsx',\n  '.jsx',\n  '.py',\n  '.rb',\n  '.go',\n  '.rs',\n  '.java',\n  '.c',\n  '.cpp',\n  '.h',\n  '.hpp',\n  '.sh',\n  '.bash',\n  '.zsh',\n  '.html',\n  '.htm',\n  '.css',\n  '.xml',\n  '.toml',\n  '.ini',\n  '.env',\n  '.csv',\n  '.sql',\n  '.graphql',\n  '.gql',\n  '.vue',\n  '.svg',\n]);\n\n/**\n * Check if a file should be treated as text based on extension.\n */\nexport function isTextFile(filename: string): boolean {\n  const ext = path.extname(filename).toLowerCase();\n  return TEXT_EXTENSIONS.has(ext);\n}\n\n// =============================================================================\n// Filesystem Operations\n// =============================================================================\n\n/**\n * Check if a path exists.\n * Never throws - returns false on any error.\n *\n * @param absolutePath - The absolute path to check\n * @returns true if path exists and is accessible\n */\nexport async function fsExists(absolutePath: string): Promise<boolean> {\n  try {\n    await fs.access(absolutePath);\n    return true;\n  } catch {\n    return false;\n  }\n}\n\n/**\n * Get file/directory stats.\n * Throws FileNotFoundError if path doesn't exist.\n *\n * @param absolutePath - The absolute path to stat\n * @param userPath - The user-facing path for error messages\n * @returns File stat information\n * @throws {FileNotFoundError} if path doesn't exist\n */\nexport async function fsStat(absolutePath: string, userPath: string): Promise<FsStatResult> {\n  try {\n    const stats = await fs.stat(absolutePath);\n    return {\n      name: path.basename(absolutePath),\n      type: stats.isDirectory() ? 'directory' : 'file',\n      size: stats.size,\n      createdAt: stats.birthtime,\n      modifiedAt: stats.mtime,\n      mimeType: stats.isFile() ? getMimeType(absolutePath) : undefined,\n    };\n  } catch (error: unknown) {\n    if (isEnoentError(error)) {\n      throw new FileNotFoundError(userPath);\n    }\n    throw error;\n  }\n}\n","/**\n * Local Filesystem Provider\n *\n * A filesystem implementation backed by a folder on the local disk.\n * This is the default filesystem for development and local agents.\n */\n\nimport { constants as fsConstants } from 'node:fs';\nimport * as fs from 'node:fs/promises';\nimport * as nodePath from 'node:path';\nimport {\n  FileNotFoundError,\n  DirectoryNotFoundError,\n  FileExistsError,\n  IsDirectoryError,\n  NotDirectoryError,\n  DirectoryNotEmptyError,\n  PermissionError,\n  WorkspaceReadOnlyError,\n} from '../errors';\nimport type { ProviderStatus } from '../lifecycle';\nimport type {\n  FilesystemInfo,\n  FileContent,\n  FileStat,\n  FileEntry,\n  ReadOptions,\n  WriteOptions,\n  ListOptions,\n  RemoveOptions,\n  CopyOptions,\n} from './filesystem';\nimport { fsExists, fsStat, isEnoentError, isEexistError } from './fs-utils';\nimport { MastraFilesystem } from './mastra-filesystem';\nimport type { MastraFilesystemOptions } from './mastra-filesystem';\n\n/**\n * Local filesystem provider configuration.\n */\nexport interface LocalFilesystemOptions extends MastraFilesystemOptions {\n  /** Unique identifier for this filesystem instance */\n  id?: string;\n  /** Base directory path on disk */\n  basePath: string;\n  /**\n   * When true, all file operations are restricted to stay within basePath.\n   * Prevents path traversal attacks and symlink escapes.\n   *\n   * Path resolution depends on this setting:\n   * - `contained: true` (default)  Absolute paths that fall within basePath are\n   *   used as-is; all other absolute paths are treated as virtual (resolved\n   *   relative to basePath, e.g. `/file.txt`  `basePath/file.txt`). Any\n   *   resolved path that escapes basePath throws a PermissionError.\n   * - `contained: false`  Absolute paths are always treated as real filesystem\n   *   paths. No containment check is applied.\n   *\n   * Set to `false` when the filesystem needs to access paths outside basePath,\n   * such as global skills directories or user home directories.\n   *\n   * @default true\n   */\n  contained?: boolean;\n  /**\n   * When true, all write operations to this filesystem are blocked.\n   * Read operations are still allowed.\n   * @default false\n   */\n  readOnly?: boolean;\n}\n\n/**\n * Local filesystem implementation.\n *\n * Stores files in a folder on the user's machine.\n * This is the recommended filesystem for development and persistent local storage.\n *\n * @example\n * ```typescript\n * import { Workspace, LocalFilesystem } from '@mastra/core';\n *\n * const workspace = new Workspace({\n *   filesystem: new LocalFilesystem({ basePath: './my-workspace' }),\n * });\n *\n * await workspace.init();\n * await workspace.writeFile('/hello.txt', 'Hello World!');\n * ```\n */\nexport class LocalFilesystem extends MastraFilesystem {\n  readonly id: string;\n  readonly name = 'LocalFilesystem';\n  readonly provider = 'local';\n  readonly readOnly?: boolean;\n\n  status: ProviderStatus = 'pending';\n\n  private readonly _basePath: string;\n  private readonly _contained: boolean;\n\n  /**\n   * The absolute base path on disk where files are stored.\n   * Useful for understanding how workspace paths map to disk paths.\n   */\n  get basePath(): string {\n    return this._basePath;\n  }\n\n  constructor(options: LocalFilesystemOptions) {\n    super({ ...options, name: 'LocalFilesystem' });\n    this.id = options.id ?? this.generateId();\n    this._basePath = nodePath.resolve(options.basePath);\n    this._contained = options.contained ?? true;\n    this.readOnly = options.readOnly;\n  }\n\n  private generateId(): string {\n    return `local-fs-${Date.now().toString(36)}-${Math.random().toString(36).slice(2, 8)}`;\n  }\n\n  private toBuffer(content: FileContent): Buffer {\n    if (Buffer.isBuffer(content)) return content;\n    if (content instanceof Uint8Array) return Buffer.from(content);\n    return Buffer.from(content, 'utf-8');\n  }\n\n  private resolvePath(inputPath: string): string {\n    let absolutePath: string;\n\n    if (!this._contained && nodePath.isAbsolute(inputPath)) {\n      // Containment disabled  absolute paths are real filesystem paths\n      absolutePath = nodePath.normalize(inputPath);\n    } else if (this._contained && nodePath.isAbsolute(inputPath)) {\n      // Containment enabled  check if this is a real path within basePath\n      // (e.g. \"/Users/foo/project/.mastracode/skills\") vs the virtual-root\n      // convention (e.g. \"/file.txt\" meaning \"basePath/file.txt\")\n      const normalized = nodePath.normalize(inputPath);\n      const relative = nodePath.relative(this._basePath, normalized);\n      if (!relative.startsWith('..') && !nodePath.isAbsolute(relative)) {\n        absolutePath = normalized;\n      } else {\n        const cleanedPath = inputPath.replace(/^\\/+/, '');\n        absolutePath = nodePath.resolve(this._basePath, nodePath.normalize(cleanedPath));\n      }\n    } else {\n      // Relative path  resolve against basePath\n      const cleanedPath = inputPath.replace(/^\\/+/, '');\n      absolutePath = nodePath.resolve(this._basePath, nodePath.normalize(cleanedPath));\n    }\n\n    if (this._contained) {\n      const relative = nodePath.relative(this._basePath, absolutePath);\n      if (relative.startsWith('..') || nodePath.isAbsolute(relative)) {\n        throw new PermissionError(inputPath, 'access');\n      }\n    }\n\n    return absolutePath;\n  }\n\n  private toRelativePath(absolutePath: string): string {\n    return '/' + nodePath.relative(this._basePath, absolutePath).replace(/\\\\/g, '/');\n  }\n\n  private assertWritable(operation: string): void {\n    if (this.readOnly) {\n      throw new WorkspaceReadOnlyError(operation);\n    }\n  }\n\n  /**\n   * Verify that the resolved path doesn't escape basePath via symlinks.\n   * Uses realpath to resolve symlinks and check the actual target.\n   */\n  private async assertPathContained(absolutePath: string): Promise<void> {\n    if (!this._contained) return;\n\n    let baseReal: string;\n    try {\n      baseReal = await fs.realpath(this._basePath);\n    } catch (error: unknown) {\n      if (isEnoentError(error)) {\n        throw new DirectoryNotFoundError(this._basePath);\n      }\n      throw error;\n    }\n\n    let targetReal: string;\n    try {\n      targetReal = await fs.realpath(absolutePath);\n    } catch (error: unknown) {\n      // If path doesn't exist, walk up to find an existing parent\n      if (isEnoentError(error)) {\n        let parentPath = absolutePath;\n        while (true) {\n          const nextParent = nodePath.dirname(parentPath);\n          if (nextParent === parentPath) {\n            // Reached filesystem root without finding existing directory\n            throw new DirectoryNotFoundError(absolutePath);\n          }\n          parentPath = nextParent;\n          try {\n            targetReal = await fs.realpath(parentPath);\n            break;\n          } catch (parentError: unknown) {\n            if (!isEnoentError(parentError)) {\n              throw parentError;\n            }\n            // Continue walking up\n          }\n        }\n      } else {\n        throw error;\n      }\n    }\n\n    if (targetReal !== baseReal && !targetReal.startsWith(baseReal + nodePath.sep)) {\n      throw new PermissionError(absolutePath, 'access');\n    }\n  }\n\n  async readFile(inputPath: string, options?: ReadOptions): Promise<string | Buffer> {\n    this.logger.debug('Reading file', { path: inputPath, encoding: options?.encoding });\n    await this.ensureReady();\n    const absolutePath = this.resolvePath(inputPath);\n    await this.assertPathContained(absolutePath);\n\n    try {\n      const stats = await fs.stat(absolutePath);\n      if (stats.isDirectory()) {\n        throw new IsDirectoryError(inputPath);\n      }\n\n      if (options?.encoding) {\n        return await fs.readFile(absolutePath, { encoding: options.encoding });\n      }\n      return await fs.readFile(absolutePath);\n    } catch (error: unknown) {\n      if (error instanceof IsDirectoryError) throw error;\n      if (isEnoentError(error)) {\n        throw new FileNotFoundError(inputPath);\n      }\n      throw error;\n    }\n  }\n\n  async writeFile(inputPath: string, content: FileContent, options?: WriteOptions): Promise<void> {\n    const contentSize = Buffer.isBuffer(content) ? content.length : content.length;\n    this.logger.debug('Writing file', { path: inputPath, size: contentSize, recursive: options?.recursive });\n    await this.ensureReady();\n    this.assertWritable('writeFile');\n    const absolutePath = this.resolvePath(inputPath);\n    await this.assertPathContained(absolutePath);\n\n    // When recursive is explicitly false, verify parent directory exists\n    if (options?.recursive === false) {\n      const dir = nodePath.dirname(absolutePath);\n      const parentPath = nodePath.dirname(inputPath);\n      try {\n        const stat = await fs.stat(dir);\n        if (!stat.isDirectory()) {\n          throw new NotDirectoryError(parentPath);\n        }\n      } catch (error: unknown) {\n        if (error instanceof NotDirectoryError) throw error;\n        if (isEnoentError(error)) {\n          throw new DirectoryNotFoundError(parentPath);\n        }\n        throw error;\n      }\n    }\n\n    if (options?.recursive !== false) {\n      const dir = nodePath.dirname(absolutePath);\n      await fs.mkdir(dir, { recursive: true });\n    }\n\n    // Use 'wx' flag for atomic overwrite check (avoids TOCTOU race)\n    const writeFlag = options?.overwrite === false ? 'wx' : 'w';\n    try {\n      await fs.writeFile(absolutePath, this.toBuffer(content), { flag: writeFlag });\n    } catch (error: unknown) {\n      if (options?.overwrite === false && isEexistError(error)) {\n        throw new FileExistsError(inputPath);\n      }\n      throw error;\n    }\n  }\n\n  async appendFile(inputPath: string, content: FileContent): Promise<void> {\n    const contentSize = Buffer.isBuffer(content) ? content.length : content.length;\n    this.logger.debug('Appending to file', { path: inputPath, size: contentSize });\n    await this.ensureReady();\n    this.assertWritable('appendFile');\n    const absolutePath = this.resolvePath(inputPath);\n    await this.assertPathContained(absolutePath);\n    const dir = nodePath.dirname(absolutePath);\n    await fs.mkdir(dir, { recursive: true });\n    await fs.appendFile(absolutePath, this.toBuffer(content));\n  }\n\n  async deleteFile(inputPath: string, options?: RemoveOptions): Promise<void> {\n    this.logger.debug('Deleting file', { path: inputPath, force: options?.force });\n    await this.ensureReady();\n    this.assertWritable('deleteFile');\n    const absolutePath = this.resolvePath(inputPath);\n    await this.assertPathContained(absolutePath);\n\n    try {\n      const stats = await fs.stat(absolutePath);\n      if (stats.isDirectory()) {\n        throw new IsDirectoryError(inputPath);\n      }\n      await fs.unlink(absolutePath);\n    } catch (error: unknown) {\n      if (error instanceof IsDirectoryError) throw error;\n      if (isEnoentError(error)) {\n        if (!options?.force) {\n          throw new FileNotFoundError(inputPath);\n        }\n      } else {\n        throw error;\n      }\n    }\n  }\n\n  async copyFile(src: string, dest: string, options?: CopyOptions): Promise<void> {\n    this.logger.debug('Copying file', { src, dest, recursive: options?.recursive });\n    await this.ensureReady();\n    this.assertWritable('copyFile');\n    const srcPath = this.resolvePath(src);\n    const destPath = this.resolvePath(dest);\n    await this.assertPathContained(srcPath);\n    await this.assertPathContained(destPath);\n\n    try {\n      const stats = await fs.stat(srcPath);\n      if (stats.isDirectory()) {\n        if (!options?.recursive) {\n          throw new IsDirectoryError(src);\n        }\n        await this.copyDirectory(srcPath, destPath, options);\n      } else {\n        await fs.mkdir(nodePath.dirname(destPath), { recursive: true });\n        // Use COPYFILE_EXCL for atomic overwrite check (avoids TOCTOU race)\n        const copyFlags = options?.overwrite === false ? fsConstants.COPYFILE_EXCL : 0;\n        try {\n          await fs.copyFile(srcPath, destPath, copyFlags);\n        } catch (error: unknown) {\n          if (options?.overwrite === false && isEexistError(error)) {\n            throw new FileExistsError(dest);\n          }\n          throw error;\n        }\n      }\n    } catch (error: unknown) {\n      if (error instanceof IsDirectoryError || error instanceof FileExistsError) throw error;\n      if (isEnoentError(error)) {\n        throw new FileNotFoundError(src);\n      }\n      throw error;\n    }\n  }\n\n  private async copyDirectory(src: string, dest: string, options?: CopyOptions): Promise<void> {\n    await this.ensureReady();\n    await fs.mkdir(dest, { recursive: true });\n    const entries = await fs.readdir(src, { withFileTypes: true });\n\n    for (const entry of entries) {\n      const srcEntry = nodePath.join(src, entry.name);\n      const destEntry = nodePath.join(dest, entry.name);\n\n      // Verify entries don't escape sandbox via symlink\n      await this.assertPathContained(srcEntry);\n      await this.assertPathContained(destEntry);\n\n      if (entry.isDirectory()) {\n        await this.copyDirectory(srcEntry, destEntry, options);\n      } else {\n        // Use COPYFILE_EXCL for atomic overwrite check (avoids TOCTOU race)\n        const copyFlags = options?.overwrite === false ? fsConstants.COPYFILE_EXCL : 0;\n        try {\n          await fs.copyFile(srcEntry, destEntry, copyFlags);\n        } catch (error: unknown) {\n          if (options?.overwrite === false && isEexistError(error)) {\n            // Skip existing files when overwrite is false\n            continue;\n          }\n          throw error;\n        }\n      }\n    }\n  }\n\n  async moveFile(src: string, dest: string, options?: CopyOptions): Promise<void> {\n    this.logger.debug('Moving file', { src, dest, overwrite: options?.overwrite });\n    await this.ensureReady();\n    this.assertWritable('moveFile');\n    const srcPath = this.resolvePath(src);\n    const destPath = this.resolvePath(dest);\n    await this.assertPathContained(srcPath);\n    await this.assertPathContained(destPath);\n\n    try {\n      await fs.mkdir(nodePath.dirname(destPath), { recursive: true });\n\n      // When overwrite: false, use copy+delete to avoid TOCTOU race condition.\n      // copyFile uses COPYFILE_EXCL which atomically checks and writes.\n      if (options?.overwrite === false) {\n        await this.copyFile(src, dest, { ...options, overwrite: false });\n        await fs.rm(srcPath, { recursive: true, force: true });\n        return;\n      }\n\n      try {\n        await fs.rename(srcPath, destPath);\n      } catch (error: unknown) {\n        // Only fall back to copy+delete for cross-device moves (EXDEV)\n        const code = (error as NodeJS.ErrnoException).code;\n        if (code !== 'EXDEV') {\n          throw error;\n        }\n        await this.copyFile(src, dest, options);\n        await fs.rm(srcPath, { recursive: true, force: true });\n      }\n    } catch (error: unknown) {\n      if (error instanceof FileExistsError) throw error;\n      if (isEnoentError(error)) {\n        throw new FileNotFoundError(src);\n      }\n      throw error;\n    }\n  }\n\n  async mkdir(inputPath: string, options?: { recursive?: boolean }): Promise<void> {\n    this.logger.debug('Creating directory', { path: inputPath, recursive: options?.recursive });\n    await this.ensureReady();\n    this.assertWritable('mkdir');\n    const absolutePath = this.resolvePath(inputPath);\n    await this.assertPathContained(absolutePath);\n\n    try {\n      await fs.mkdir(absolutePath, { recursive: options?.recursive ?? true });\n    } catch (error: unknown) {\n      if (isEexistError(error)) {\n        const stats = await fs.stat(absolutePath);\n        if (!stats.isDirectory()) {\n          throw new FileExistsError(inputPath);\n        }\n      } else if (isEnoentError(error)) {\n        // Parent directory doesn't exist (only happens when recursive: false)\n        const parentPath = nodePath.dirname(inputPath);\n        throw new DirectoryNotFoundError(parentPath);\n      } else {\n        throw error;\n      }\n    }\n  }\n\n  async rmdir(inputPath: string, options?: RemoveOptions): Promise<void> {\n    this.logger.debug('Removing directory', { path: inputPath, recursive: options?.recursive, force: options?.force });\n    await this.ensureReady();\n    this.assertWritable('rmdir');\n    const absolutePath = this.resolvePath(inputPath);\n    await this.assertPathContained(absolutePath);\n\n    try {\n      const stats = await fs.stat(absolutePath);\n      if (!stats.isDirectory()) {\n        throw new NotDirectoryError(inputPath);\n      }\n\n      if (options?.recursive) {\n        await fs.rm(absolutePath, { recursive: true, force: options?.force ?? false });\n      } else {\n        const entries = await fs.readdir(absolutePath);\n        if (entries.length > 0) {\n          throw new DirectoryNotEmptyError(inputPath);\n        }\n        await fs.rmdir(absolutePath);\n      }\n    } catch (error: unknown) {\n      if (error instanceof NotDirectoryError || error instanceof DirectoryNotEmptyError) {\n        throw error;\n      }\n      if (isEnoentError(error)) {\n        if (!options?.force) {\n          throw new DirectoryNotFoundError(inputPath);\n        }\n      } else {\n        throw error;\n      }\n    }\n  }\n\n  async readdir(inputPath: string, options?: ListOptions): Promise<FileEntry[]> {\n    this.logger.debug('Reading directory', { path: inputPath, recursive: options?.recursive });\n    await this.ensureReady();\n    const absolutePath = this.resolvePath(inputPath);\n    await this.assertPathContained(absolutePath);\n\n    try {\n      const stats = await fs.stat(absolutePath);\n      if (!stats.isDirectory()) {\n        throw new NotDirectoryError(inputPath);\n      }\n\n      const entries = await fs.readdir(absolutePath, { withFileTypes: true });\n      const result: FileEntry[] = [];\n\n      for (const entry of entries) {\n        const entryPath = nodePath.join(absolutePath, entry.name);\n\n        if (options?.extension) {\n          const extensions = Array.isArray(options.extension) ? options.extension : [options.extension];\n          if (entry.isFile()) {\n            const ext = nodePath.extname(entry.name);\n            if (!extensions.some(e => e === ext || e === ext.slice(1))) {\n              continue;\n            }\n          }\n        }\n\n        // Check if entry is a symlink\n        const isSymlink = entry.isSymbolicLink();\n        let symlinkTarget: string | undefined;\n        let resolvedType: 'file' | 'directory' = 'file';\n\n        if (isSymlink) {\n          try {\n            // Get the symlink target path\n            symlinkTarget = await fs.readlink(entryPath);\n            // Determine the type of the target (follow the symlink)\n            const targetStat = await fs.stat(entryPath);\n            resolvedType = targetStat.isDirectory() ? 'directory' : 'file';\n          } catch {\n            // If we can't read the symlink target or it's broken, treat as file\n            resolvedType = 'file';\n          }\n        } else {\n          resolvedType = entry.isDirectory() ? 'directory' : 'file';\n        }\n\n        const fileEntry: FileEntry = {\n          name: entry.name,\n          type: resolvedType,\n          isSymlink: isSymlink || undefined,\n          symlinkTarget,\n        };\n\n        if (resolvedType === 'file' && !isSymlink) {\n          try {\n            const stat = await fs.stat(entryPath);\n            fileEntry.size = stat.size;\n          } catch {\n            // Ignore\n          }\n        }\n\n        result.push(fileEntry);\n\n        // Only recurse into directories (follow symlinks to directories)\n        if (options?.recursive && resolvedType === 'directory') {\n          // Default to 100 to prevent stack overflow on deeply nested structures\n          const depth = options.maxDepth ?? 100;\n          if (depth > 0) {\n            const subEntries = await this.readdir(this.toRelativePath(entryPath), { ...options, maxDepth: depth - 1 });\n            result.push(\n              ...subEntries.map(e => ({\n                ...e,\n                name: `${entry.name}/${e.name}`,\n              })),\n            );\n          }\n        }\n      }\n\n      return result;\n    } catch (error: unknown) {\n      if (error instanceof NotDirectoryError) throw error;\n      if (isEnoentError(error)) {\n        throw new DirectoryNotFoundError(inputPath);\n      }\n      throw error;\n    }\n  }\n\n  async exists(inputPath: string): Promise<boolean> {\n    await this.ensureReady();\n    const absolutePath = this.resolvePath(inputPath);\n    await this.assertPathContained(absolutePath);\n    return fsExists(absolutePath);\n  }\n\n  async stat(inputPath: string): Promise<FileStat> {\n    await this.ensureReady();\n    const absolutePath = this.resolvePath(inputPath);\n    await this.assertPathContained(absolutePath);\n    const result = await fsStat(absolutePath, inputPath);\n    return {\n      ...result,\n      path: this.toRelativePath(absolutePath),\n    };\n  }\n\n  /**\n   * Initialize the local filesystem by creating the base directory.\n   * Status management is handled by the base class.\n   */\n  async init(): Promise<void> {\n    this.logger.debug('Initializing filesystem', { basePath: this._basePath });\n    await fs.mkdir(this._basePath, { recursive: true });\n    this.logger.debug('Filesystem initialized', { basePath: this._basePath });\n  }\n\n  /**\n   * Clean up the local filesystem.\n   * LocalFilesystem doesn't delete files on destroy by default.\n   * Status management is handled by the base class.\n   */\n  async destroy(): Promise<void> {\n    // LocalFilesystem doesn't clean up files on destroy by default\n  }\n\n  getInfo(): FilesystemInfo<{ basePath: string; contained: boolean }> {\n    return {\n      id: this.id,\n      name: this.name,\n      provider: this.provider,\n      readOnly: this.readOnly,\n      status: this.status,\n      error: this.error,\n      metadata: {\n        basePath: this.basePath,\n        contained: this._contained,\n      },\n    };\n  }\n\n  getInstructions(): string {\n    if (this._contained) {\n      return `Local filesystem at \"${this.basePath}\". Files at workspace path \"/foo\" are stored at \"${this.basePath}/foo\" on disk.`;\n    }\n    return `Local filesystem rooted at \"${this.basePath}\". Containment is disabled so absolute paths access the real filesystem. Use paths relative to \"${this.basePath}\" (e.g. \"foo/bar.txt\") for workspace files. Avoid unnecessary listing \"/\" as it would traverse the entire host filesystem.`;\n  }\n}\n","import * as nodePath from 'node:path';\n\n/**\n * File Read Tracker\n *\n * Tracks when files were last read by the workspace.\n * Used to enforce \"read before write\" semantics.\n */\n\n/**\n * Record of when a file was read.\n */\nexport interface FileReadRecord {\n  /** The file path that was read */\n  path: string;\n  /** When the file was read */\n  readAt: Date;\n  /** The file's modification time when it was read */\n  modifiedAtRead: Date;\n}\n\n/**\n * Interface for tracking file reads.\n */\nexport interface FileReadTracker {\n  /** Record that a file was read */\n  recordRead(path: string, modifiedAt: Date): void;\n\n  /** Get the last read record for a path */\n  getReadRecord(path: string): FileReadRecord | undefined;\n\n  /**\n   * Check if file needs re-reading.\n   * Returns needsReRead: true if file was never read or was modified since last read.\n   */\n  needsReRead(path: string, currentModifiedAt: Date): { needsReRead: boolean; reason?: string };\n\n  /** Clear read record (typically after a successful write) */\n  clearReadRecord(path: string): void;\n\n  /** Clear all records */\n  clear(): void;\n}\n\n/**\n * In-memory implementation of FileReadTracker.\n */\nexport class InMemoryFileReadTracker implements FileReadTracker {\n  private records = new Map<string, FileReadRecord>();\n\n  recordRead(path: string, modifiedAt: Date): void {\n    const normalizedPath = this.normalizePath(path);\n    this.records.set(normalizedPath, {\n      path: normalizedPath,\n      readAt: new Date(),\n      modifiedAtRead: modifiedAt,\n    });\n  }\n\n  getReadRecord(path: string): FileReadRecord | undefined {\n    return this.records.get(this.normalizePath(path));\n  }\n\n  needsReRead(path: string, currentModifiedAt: Date): { needsReRead: boolean; reason?: string } {\n    const record = this.getReadRecord(path);\n\n    if (!record) {\n      return {\n        needsReRead: true,\n        reason: `File \"${path}\" has not been read. You must read a file before writing to it.`,\n      };\n    }\n\n    // Compare timestamps - if current modification time is newer than when we read it\n    if (currentModifiedAt.getTime() > record.modifiedAtRead.getTime()) {\n      return {\n        needsReRead: true,\n        reason: `File \"${path}\" was modified since last read (read at: ${record.modifiedAtRead.toISOString()}, current: ${currentModifiedAt.toISOString()}). Please re-read the file to get the latest contents.`,\n      };\n    }\n\n    return { needsReRead: false };\n  }\n\n  clearReadRecord(path: string): void {\n    this.records.delete(this.normalizePath(path));\n  }\n\n  clear(): void {\n    this.records.clear();\n  }\n\n  private normalizePath(pathStr: string): string {\n    // Normalize path: unify separators, resolve dot segments, remove trailing slash\n    const normalized = nodePath.posix.normalize(pathStr.replace(/\\\\/g, '/'));\n    return normalized.replace(/\\/$/, '') || '/';\n  }\n}\n","/**\n * Sandbox Errors\n *\n * Error classes for sandbox operations including execution and mounting.\n */\n\nimport type { SandboxOperation } from './types';\n\n// =============================================================================\n// Base Error\n// =============================================================================\n\nexport class SandboxError extends Error {\n  constructor(\n    message: string,\n    public readonly code: string,\n    public readonly details?: Record<string, unknown>,\n  ) {\n    super(message);\n    this.name = 'SandboxError';\n  }\n}\n\n// =============================================================================\n// Execution Errors\n// =============================================================================\n\nexport class SandboxExecutionError extends SandboxError {\n  constructor(\n    message: string,\n    public readonly exitCode: number,\n    public readonly stdout: string,\n    public readonly stderr: string,\n  ) {\n    super(message, 'EXECUTION_FAILED', { exitCode, stdout, stderr });\n    this.name = 'SandboxExecutionError';\n  }\n}\n\nexport class SandboxTimeoutError extends SandboxError {\n  constructor(\n    public readonly timeoutMs: number,\n    public readonly operation: SandboxOperation,\n  ) {\n    super(`Execution timed out after ${timeoutMs}ms`, 'TIMEOUT', { timeoutMs, operation });\n    this.name = 'SandboxTimeoutError';\n  }\n}\n\nexport class SandboxNotReadyError extends SandboxError {\n  constructor(idOrStatus: string) {\n    super(`Sandbox is not ready: ${idOrStatus}`, 'NOT_READY', { id: idOrStatus });\n    this.name = 'SandboxNotReadyError';\n  }\n}\n\nexport class IsolationUnavailableError extends SandboxError {\n  constructor(\n    public readonly backend: string,\n    public readonly reason: string,\n  ) {\n    super(`Isolation backend '${backend}' is not available: ${reason}`, 'ISOLATION_UNAVAILABLE', { backend, reason });\n    this.name = 'IsolationUnavailableError';\n  }\n}\n\n// =============================================================================\n// Mount Errors\n// =============================================================================\n\n/**\n * Base error for mount operations.\n */\nexport class MountError extends SandboxError {\n  constructor(\n    message: string,\n    public readonly mountPath: string,\n    details?: Record<string, unknown>,\n  ) {\n    super(message, 'MOUNT_ERROR', { ...details, mountPath });\n    this.name = 'MountError';\n  }\n}\n\n/**\n * Error thrown when sandbox doesn't support mounting.\n */\nexport class MountNotSupportedError extends SandboxError {\n  constructor(sandboxProvider: string) {\n    super(`Sandbox provider '${sandboxProvider}' does not support mounting`, 'MOUNT_NOT_SUPPORTED', {\n      sandboxProvider,\n    });\n    this.name = 'MountNotSupportedError';\n  }\n}\n\n/**\n * Error thrown when a filesystem cannot be mounted.\n */\nexport class FilesystemNotMountableError extends SandboxError {\n  constructor(filesystemProvider: string, reason?: string) {\n    const message = reason\n      ? `Filesystem '${filesystemProvider}' cannot be mounted: ${reason}`\n      : `Filesystem '${filesystemProvider}' does not support mounting`;\n    super(message, 'FILESYSTEM_NOT_MOUNTABLE', { filesystemProvider, reason });\n    this.name = 'FilesystemNotMountableError';\n  }\n}\n","/**\n * Mount Manager\n *\n * Encapsulates all mount-related state and operations for sandboxes.\n * Used by BaseSandbox to manage filesystem mounts.\n */\n\nimport { createHash } from 'node:crypto';\n\nimport type { IMastraLogger } from '../../logger';\nimport type { WorkspaceFilesystem } from '../filesystem/filesystem';\nimport type { FilesystemMountConfig, MountResult } from '../filesystem/mount';\n\nimport type { Workspace } from '../workspace';\nimport type { WorkspaceSandbox } from './sandbox';\nimport type { MountEntry, MountState } from './types';\n\n// Type-only import  erased at compile time, no circular dependency at runtime.\n\n/**\n * Mount function signature.\n */\nexport type MountFn = (filesystem: WorkspaceFilesystem, mountPath: string) => Promise<MountResult>;\n\n/**\n * onMount hook result.\n * - false: skip mount\n * - { success, error? }: hook handled it\n * - void: use default mount\n */\nexport type OnMountResult = false | { success: boolean; error?: string } | void;\n\n/**\n * Arguments passed to the onMount hook.\n */\nexport interface OnMountArgs {\n  /** The filesystem being mounted */\n  filesystem: WorkspaceFilesystem;\n  /** The mount path in the sandbox */\n  mountPath: string;\n  /** The mount configuration from filesystem.getMountConfig() (undefined if not supported) */\n  config: FilesystemMountConfig | undefined;\n  /** The sandbox instance for custom mount implementations */\n  sandbox: WorkspaceSandbox;\n  /** The workspace instance */\n  workspace: Workspace;\n}\n\n/**\n * onMount hook function.\n *\n * Called for each filesystem before mounting into sandbox.\n * Return value controls mounting behavior (see {@link OnMountResult}).\n *\n * @example Skip local filesystems\n * ```typescript\n * onMount: ({ filesystem }) => {\n *   if (filesystem.provider === 'local') return false;\n * }\n * ```\n *\n * @example Custom mount implementation\n * ```typescript\n * onMount: async ({ filesystem, mountPath, sandbox }) => {\n *   if (mountPath === '/custom') {\n *     await sandbox.executeCommand?.('my-mount-script', [mountPath]);\n *     return { success: true };\n *   }\n * }\n * ```\n */\nexport type OnMountHook = (args: OnMountArgs) => Promise<OnMountResult> | OnMountResult;\n\n/**\n * MountManager configuration.\n */\nexport interface MountManagerConfig {\n  /** The mount implementation from the sandbox */\n  mount: MountFn;\n  /** Logger instance */\n  logger: IMastraLogger;\n}\n\n/**\n * Manages filesystem mounts for a sandbox.\n *\n * Provides methods for tracking mount state, updating entries,\n * and processing pending mounts.\n */\nexport class MountManager {\n  private _entries: Map<string, MountEntry> = new Map();\n  private _mountFn: MountFn;\n  private _onMount?: OnMountHook;\n  private _sandbox?: WorkspaceSandbox;\n  private _workspace?: Workspace;\n  private logger: IMastraLogger;\n\n  constructor(config: MountManagerConfig) {\n    this._mountFn = config.mount;\n    this.logger = config.logger;\n  }\n\n  /**\n   * Set the sandbox and workspace references for onMount hook args.\n   * Called by Workspace during construction.\n   */\n  setContext(context: { sandbox: WorkspaceSandbox; workspace: Workspace }): void {\n    this._sandbox = context.sandbox;\n    this._workspace = context.workspace;\n  }\n\n  /**\n   * Set the onMount hook for custom mount handling.\n   * Called before each mount - can skip, handle, or defer to default.\n   */\n  setOnMount(hook: OnMountHook | undefined): void {\n    this._onMount = hook;\n  }\n\n  /**\n   * Update the logger instance.\n   * Called when the sandbox receives a logger from Mastra.\n   * @internal\n   */\n  __setLogger(logger: IMastraLogger): void {\n    this.logger = logger;\n  }\n\n  // ---------------------------------------------------------------------------\n  // Entry Access\n  // ---------------------------------------------------------------------------\n\n  /**\n   * Get all mount entries.\n   */\n  get entries(): ReadonlyMap<string, MountEntry> {\n    return this._entries;\n  }\n\n  /**\n   * Get a mount entry by path.\n   */\n  get(path: string): MountEntry | undefined {\n    return this._entries.get(path);\n  }\n\n  /**\n   * Check if a mount exists at the given path.\n   */\n  has(path: string): boolean {\n    return this._entries.has(path);\n  }\n\n  // ---------------------------------------------------------------------------\n  // Entry Modification\n  // ---------------------------------------------------------------------------\n\n  /**\n   * Add pending mounts from workspace config.\n   * These will be processed when `processPending()` is called.\n   */\n  add(mounts: Record<string, WorkspaceFilesystem>): void {\n    const paths = Object.keys(mounts);\n    this.logger.debug(`Adding ${paths.length} pending mount(s)`, { paths });\n\n    for (const [path, filesystem] of Object.entries(mounts)) {\n      this._entries.set(path, {\n        filesystem,\n        state: 'pending',\n      });\n    }\n  }\n\n  /**\n   * Update a mount entry's state.\n   * Creates the entry if it doesn't exist.\n   */\n  set(\n    path: string,\n    updates: {\n      filesystem?: WorkspaceFilesystem;\n      state: MountState;\n      config?: FilesystemMountConfig;\n      error?: string;\n    },\n  ): void {\n    const existing = this._entries.get(path);\n\n    if (existing) {\n      existing.state = updates.state;\n      if (updates.config) {\n        existing.config = updates.config;\n        existing.configHash = this.hashConfig(updates.config);\n      }\n      if ('error' in updates) {\n        existing.error = updates.error;\n      }\n    } else if (updates.filesystem) {\n      // Create new entry (for direct mount() calls without add())\n      this._entries.set(path, {\n        filesystem: updates.filesystem,\n        state: updates.state,\n        config: updates.config,\n        configHash: updates.config ? this.hashConfig(updates.config) : undefined,\n        error: updates.error,\n      });\n    } else {\n      this.logger.debug(`set() called for unknown path \"${path}\" without filesystem  no entry created`);\n    }\n  }\n\n  /**\n   * Delete a mount entry.\n   */\n  delete(path: string): boolean {\n    return this._entries.delete(path);\n  }\n\n  /**\n   * Clear all mount entries.\n   */\n  clear(): void {\n    this._entries.clear();\n  }\n\n  // ---------------------------------------------------------------------------\n  // Mount Processing\n  // ---------------------------------------------------------------------------\n\n  /**\n   * Process all pending mounts.\n   * Call this after sandbox is ready (in start()).\n   */\n  async processPending(): Promise<void> {\n    const pendingCount = [...this._entries.values()].filter(e => e.state === 'pending').length;\n    if (pendingCount === 0) {\n      return;\n    }\n\n    this.logger.debug(`Processing ${pendingCount} pending mount(s)`);\n\n    for (const [path, entry] of this._entries) {\n      if (entry.state !== 'pending') {\n        continue;\n      }\n\n      const fsProvider = entry.filesystem.provider;\n\n      // Get config if available\n      const config = entry.filesystem.getMountConfig?.();\n\n      // Call onMount hook if configured\n      if (this._onMount) {\n        try {\n          const hookResult = await this._onMount({\n            filesystem: entry.filesystem,\n            mountPath: path,\n            config,\n            sandbox: this._sandbox!,\n            workspace: this._workspace!,\n          });\n\n          // false = skip mount entirely\n          if (hookResult === false) {\n            entry.state = 'unsupported';\n            entry.error = 'Skipped by onMount hook';\n            this.logger.debug(`Mount skipped by onMount hook`, { path, provider: fsProvider });\n            continue;\n          }\n\n          // { success, error? } = hook handled it\n          if (hookResult && typeof hookResult === 'object') {\n            if (hookResult.success) {\n              entry.state = 'mounted';\n              entry.config = config;\n              entry.configHash = config ? this.hashConfig(config) : undefined;\n              this.logger.info(`Mount handled by onMount hook`, { path, provider: fsProvider });\n            } else {\n              entry.state = 'error';\n              entry.error = hookResult.error ?? 'Mount hook failed';\n              this.logger.error(`Mount hook failed`, { path, provider: fsProvider, error: entry.error });\n            }\n            continue;\n          }\n\n          // void = continue with default mount\n        } catch (err) {\n          entry.state = 'error';\n          entry.error = `Mount hook error: ${String(err)}`;\n          this.logger.error(`Mount hook threw error`, { path, provider: fsProvider, error: entry.error });\n          continue;\n        }\n      }\n\n      // Check if filesystem supports mounting (for default behavior)\n      if (!config) {\n        entry.state = 'unsupported';\n        entry.error = 'Filesystem does not support mounting';\n        this.logger.debug(`Filesystem does not support mounting`, { path, provider: fsProvider });\n        continue;\n      }\n\n      // Store config and mark as mounting\n      entry.config = config;\n      entry.configHash = this.hashConfig(config);\n      entry.state = 'mounting';\n\n      this.logger.debug(`Mounting filesystem`, { path, provider: fsProvider, type: config.type });\n\n      // Call the sandbox's mount implementation\n      try {\n        const result = await this._mountFn(entry.filesystem, path);\n        if (result.success) {\n          entry.state = 'mounted';\n          this.logger.info(`Mount successful`, { path, provider: fsProvider });\n        } else {\n          entry.state = 'error';\n          entry.error = result.error ?? 'Mount failed';\n          this.logger.error(`Mount failed`, { path, provider: fsProvider, error: entry.error });\n        }\n      } catch (err) {\n        entry.state = 'error';\n        entry.error = String(err);\n        this.logger.error(`Mount threw error`, { path, provider: fsProvider, error: entry.error });\n      }\n    }\n  }\n\n  // ---------------------------------------------------------------------------\n  // Marker File Helpers\n  // ---------------------------------------------------------------------------\n\n  /**\n   * Generate a marker filename for a mount path.\n   * Used by sandboxes to store mount metadata for reconnection detection.\n   *\n   * @param mountPath - The mount path to generate a filename for\n   * @returns A safe filename like \"mount-abc123\"\n   */\n  markerFilename(mountPath: string): string {\n    let hash = 0;\n    for (let i = 0; i < mountPath.length; i++) {\n      const char = mountPath.charCodeAt(i);\n      hash = (hash << 5) - hash + char;\n      hash |= 0; // Convert to 32-bit integer\n    }\n    return `mount-${Math.abs(hash).toString(36)}`;\n  }\n\n  /**\n   * Generate marker file content for a mount path.\n   * Format: \"path|configHash\" - used for detecting config changes on reconnect.\n   *\n   * @param mountPath - The mount path\n   * @returns Marker content string, or null if no config hash available\n   */\n  getMarkerContent(mountPath: string): string | null {\n    const entry = this._entries.get(mountPath);\n    if (!entry?.configHash) {\n      return null;\n    }\n    return `${mountPath}|${entry.configHash}`;\n  }\n\n  /**\n   * Parse marker file content.\n   *\n   * @param content - The marker file content (format: \"path|configHash\")\n   * @returns Parsed path and configHash, or null if invalid format\n   */\n  parseMarkerContent(content: string): { path: string; configHash: string } | null {\n    const separatorIndex = content.lastIndexOf('|');\n    if (separatorIndex <= 0) {\n      return null;\n    }\n    const path = content.slice(0, separatorIndex);\n    const configHash = content.slice(separatorIndex + 1);\n    if (!path || !configHash) return null;\n    return { path, configHash };\n  }\n\n  /**\n   * Check if a config hash matches the expected hash for a mount path.\n   *\n   * @param mountPath - The mount path to check\n   * @param storedHash - The hash from the marker file\n   * @returns true if the hashes match\n   */\n  isConfigMatching(mountPath: string, storedHash: string): boolean {\n    const entry = this._entries.get(mountPath);\n    return entry?.configHash === storedHash;\n  }\n\n  /**\n   * Compute a hash for a mount config. Used for comparing configs across mounts.\n   *\n   * @param config - The config to hash\n   * @returns A hash string suitable for comparison\n   */\n  computeConfigHash(config: FilesystemMountConfig): string {\n    return this.hashConfig(config);\n  }\n\n  // ---------------------------------------------------------------------------\n  // Internal\n  // ---------------------------------------------------------------------------\n\n  /**\n   * Hash a mount config for comparison.\n   */\n  private hashConfig(config: FilesystemMountConfig): string {\n    const normalized = JSON.stringify(this.sortKeysDeep(config));\n    return createHash('sha256').update(normalized).digest('hex').slice(0, 16);\n  }\n\n  private sortKeysDeep(obj: unknown): unknown {\n    if (obj === null || typeof obj !== 'object') return obj;\n    if (Array.isArray(obj)) return obj.map(item => this.sortKeysDeep(item));\n    return Object.keys(obj as Record<string, unknown>)\n      .sort()\n      .reduce(\n        (acc, key) => {\n          acc[key] = this.sortKeysDeep((obj as Record<string, unknown>)[key]);\n          return acc;\n        },\n        {} as Record<string, unknown>,\n      );\n  }\n}\n","/**\n * MastraSandbox Base Class\n *\n * Abstract base class for sandbox providers that want automatic logger integration.\n * Extends MastraBase to receive the Mastra logger when registered with a Mastra instance.\n *\n * MountManager is automatically created if the subclass implements `mount()`.\n * Use `declare readonly mounts: MountManager` to get non-optional typing.\n *\n * ## Lifecycle Management\n *\n * The base class provides race-condition-safe lifecycle wrappers:\n * - `_start()` - Handles concurrent calls, status management, and mount processing\n * - `_stop()` - Handles concurrent calls and status management\n * - `_destroy()` - Handles concurrent calls and status management\n *\n * Subclasses override the plain `start()`, `stop()`, and `destroy()` methods\n * to provide their implementation. Callers use the `_`-prefixed wrappers\n * (or `callLifecycle()`) which add status tracking and race-condition safety.\n *\n * External providers can extend this class to get logger support, or implement\n * the WorkspaceSandbox interface directly if they don't need logging.\n */\n\nimport { MastraBase } from '../../base';\nimport type { IMastraLogger } from '../../logger';\nimport { RegisteredLogger } from '../../logger/constants';\nimport type { WorkspaceFilesystem } from '../filesystem/filesystem';\nimport type { MountResult } from '../filesystem/mount';\nimport type { ProviderStatus } from '../lifecycle';\nimport { SandboxNotReadyError } from './errors';\nimport { MountManager } from './mount-manager';\nimport type { WorkspaceSandbox } from './sandbox';\n\n/**\n * Lifecycle hook that fires during sandbox state transitions.\n * Receives the sandbox instance so users can call `executeCommand`, read files, etc.\n */\nexport type SandboxLifecycleHook = (args: { sandbox: WorkspaceSandbox }) => void | Promise<void>;\n\n/**\n * Options for the MastraSandbox base class constructor.\n * Providers extend this to add their own options while inheriting lifecycle hooks.\n */\nexport interface MastraSandboxOptions {\n  /** Called after the sandbox reaches 'running' status */\n  onStart?: SandboxLifecycleHook;\n  /** Called before the sandbox stops */\n  onStop?: SandboxLifecycleHook;\n  /** Called before the sandbox is destroyed */\n  onDestroy?: SandboxLifecycleHook;\n}\n\n/**\n * Abstract base class for sandbox providers with logger support.\n *\n * Providers that extend this class automatically receive the Mastra logger\n * when the sandbox is used with a Mastra instance. MountManager is also\n * automatically created if the subclass implements `mount()`.\n *\n * @example\n * ```typescript\n * class MyCustomSandbox extends MastraSandbox {\n *   declare readonly mounts: MountManager;  // Non-optional type\n *   readonly id = 'my-sandbox';\n *   readonly name = 'MyCustomSandbox';\n *   readonly provider = 'custom';\n *   status: ProviderStatus = 'pending';\n *\n *   constructor() {\n *     super({ name: 'MyCustomSandbox' });\n *   }\n *\n *   // Override start() to provide startup logic\n *   async start(): Promise<void> {\n *     // Your startup logic here\n *   }\n *\n *   async mount(filesystem, mountPath) { ... }\n *   async unmount(mountPath) { ... }\n *   async executeCommand(command: string, args?: string[]): Promise<CommandResult> {\n *     this.logger.debug('Executing command', { command, args });\n *     // Implementation...\n *   }\n * }\n * ```\n */\nexport abstract class MastraSandbox extends MastraBase implements WorkspaceSandbox {\n  /** Unique identifier for this sandbox instance */\n  abstract readonly id: string;\n\n  /** Human-readable name (e.g., 'E2B Sandbox', 'Docker') */\n  abstract readonly name: string;\n\n  /** Provider type identifier */\n  abstract readonly provider: string;\n\n  /** Current status of the sandbox */\n  abstract status: ProviderStatus;\n\n  /** Mount manager - automatically created if subclass implements mount() */\n  readonly mounts?: MountManager;\n\n  /** Optional mount method - implement to enable mounting support */\n  mount?(filesystem: WorkspaceFilesystem, mountPath: string): Promise<MountResult>;\n\n  // ---------------------------------------------------------------------------\n  // Lifecycle Promise Tracking (prevents race conditions)\n  // ---------------------------------------------------------------------------\n\n  /** Promise for _start() to prevent race conditions from concurrent calls */\n  protected _startPromise?: Promise<void>;\n\n  /** Promise for _stop() to prevent race conditions from concurrent calls */\n  protected _stopPromise?: Promise<void>;\n\n  /** Promise for _destroy() to prevent race conditions from concurrent calls */\n  protected _destroyPromise?: Promise<void>;\n\n  /** Lifecycle callbacks */\n  private readonly _onStart?: SandboxLifecycleHook;\n  private readonly _onStop?: SandboxLifecycleHook;\n  private readonly _onDestroy?: SandboxLifecycleHook;\n\n  constructor(options: { name: string } & MastraSandboxOptions) {\n    super({ name: options.name, component: RegisteredLogger.WORKSPACE });\n\n    this._onStart = options.onStart;\n    this._onStop = options.onStop;\n    this._onDestroy = options.onDestroy;\n\n    // Automatically create MountManager if subclass implements mount()\n    if (this.mount) {\n      this.mounts = new MountManager({\n        mount: this.mount.bind(this),\n        logger: this.logger,\n      });\n    }\n  }\n\n  // ---------------------------------------------------------------------------\n  // Lifecycle Wrappers (race-condition-safe)\n  // ---------------------------------------------------------------------------\n\n  /**\n   * Start the sandbox (wrapper with status management and race-condition safety).\n   *\n   * This method is race-condition-safe - concurrent calls will return the same promise.\n   * Handles status management and automatically processes pending mounts after startup.\n   *\n   * Subclasses override `start()` to provide their startup logic.\n   */\n  async _start(): Promise<void> {\n    // Already running\n    if (this.status === 'running') {\n      return;\n    }\n\n    // Wait for in-flight stop/destroy before starting.\n    // Intentionally no .catch()  if teardown is failing, _start() should propagate\n    // that error rather than silently starting on top of a broken state.\n    if (this._stopPromise) await this._stopPromise;\n    if (this._destroyPromise) await this._destroyPromise;\n\n    // Cannot start a destroyed sandbox\n    if (this.status === 'destroyed') {\n      throw new Error('Cannot start a destroyed sandbox');\n    }\n\n    // Start already in progress - return existing promise\n    if (this._startPromise) {\n      return this._startPromise;\n    }\n\n    // Create and store the start promise\n    this._startPromise = this._executeStart();\n\n    try {\n      await this._startPromise;\n    } finally {\n      this._startPromise = undefined;\n    }\n  }\n\n  /**\n   * Internal start execution - handles status and mount processing.\n   */\n  private async _executeStart(): Promise<void> {\n    this.status = 'starting';\n\n    try {\n      await this.start();\n      this.status = 'running';\n\n      // Fire onStart callback after sandbox is running  treat failure as non-fatal\n      // so that a bad callback doesn't kill an otherwise healthy sandbox\n      try {\n        await this._onStart?.({ sandbox: this });\n      } catch (error) {\n        this.logger.warn('onStart callback failed', { error });\n      }\n    } catch (error) {\n      this.status = 'error';\n      throw error;\n    }\n\n    // Process any pending mounts after successful start\n    // Mount failures are tracked individually in MountManager and\n    // shouldn't mark the sandbox itself as errored\n    try {\n      await this.mounts?.processPending();\n    } catch (error) {\n      // Mount failures are tracked in MountManager  log but don't affect sandbox status\n      this.logger.warn('Unexpected error processing pending mounts', { error });\n    }\n  }\n\n  /**\n   * Override this method to implement sandbox startup logic.\n   *\n   * Called by `_start()` after status is set to 'starting'.\n   * Status will be set to 'running' on success, 'error' on failure.\n   *\n   * @example\n   * ```typescript\n   * async start(): Promise<void> {\n   *   this._sandbox = await Sandbox.create({ ... });\n   * }\n   * ```\n   */\n  async start(): Promise<void> {\n    // Default no-op - subclasses override\n  }\n\n  /**\n   * Ensure the sandbox is running.\n   *\n   * Calls `_start()` if status is not 'running'. Useful for lazy initialization\n   * where operations should automatically start the sandbox if needed.\n   *\n   * @throws {SandboxNotReadyError} if the sandbox fails to reach 'running' status\n   *\n   * @example\n   * ```typescript\n   * async executeCommand(command: string): Promise<CommandResult> {\n   *   await this.ensureRunning();\n   *   // Now safe to use the sandbox\n   * }\n   * ```\n   */\n  protected async ensureRunning(): Promise<void> {\n    if (this.status !== 'running') {\n      await this._start();\n    }\n    if (this.status !== 'running') {\n      throw new SandboxNotReadyError(this.id);\n    }\n  }\n\n  /**\n   * Stop the sandbox (wrapper with status management and race-condition safety).\n   *\n   * This method is race-condition-safe - concurrent calls will return the same promise.\n   * Handles status management.\n   *\n   * Subclasses override `stop()` to provide their stop logic.\n   */\n  async _stop(): Promise<void> {\n    // Already stopped\n    if (this.status === 'stopped') {\n      return;\n    }\n\n    // Wait for in-flight start before stopping\n    if (this._startPromise) await this._startPromise.catch(() => {});\n\n    // Stop already in progress - return existing promise\n    if (this._stopPromise) {\n      return this._stopPromise;\n    }\n\n    // Create and store the stop promise\n    this._stopPromise = this._executeStop();\n\n    try {\n      await this._stopPromise;\n    } finally {\n      this._stopPromise = undefined;\n    }\n  }\n\n  /**\n   * Internal stop execution - handles status.\n   */\n  private async _executeStop(): Promise<void> {\n    this.status = 'stopping';\n\n    try {\n      // Fire onStop callback before stopping\n      await this._onStop?.({ sandbox: this });\n\n      await this.stop();\n      this.status = 'stopped';\n    } catch (error) {\n      this.status = 'error';\n      throw error;\n    }\n  }\n\n  /**\n   * Override this method to implement sandbox stop logic.\n   *\n   * Called by `_stop()` after status is set to 'stopping'.\n   * Status will be set to 'stopped' on success, 'error' on failure.\n   */\n  async stop(): Promise<void> {\n    // Default no-op - subclasses override\n  }\n\n  /**\n   * Destroy the sandbox and clean up all resources (wrapper with status management).\n   *\n   * This method is race-condition-safe - concurrent calls will return the same promise.\n   * Handles status management.\n   *\n   * Subclasses override `destroy()` to provide their destroy logic.\n   */\n  async _destroy(): Promise<void> {\n    // Already destroyed\n    if (this.status === 'destroyed') {\n      return;\n    }\n\n    // Wait for in-flight start/stop before destroying\n    if (this._startPromise) await this._startPromise.catch(() => {});\n    if (this._stopPromise) await this._stopPromise.catch(() => {});\n\n    // Destroy already in progress - return existing promise\n    if (this._destroyPromise) {\n      return this._destroyPromise;\n    }\n\n    // Create and store the destroy promise\n    this._destroyPromise = this._executeDestroy();\n\n    try {\n      await this._destroyPromise;\n    } finally {\n      this._destroyPromise = undefined;\n    }\n  }\n\n  /**\n   * Internal destroy execution - handles status.\n   */\n  private async _executeDestroy(): Promise<void> {\n    this.status = 'destroying';\n\n    try {\n      // Fire onDestroy callback before destroying\n      await this._onDestroy?.({ sandbox: this });\n\n      await this.destroy();\n      this.status = 'destroyed';\n    } catch (error) {\n      this.status = 'error';\n      throw error;\n    }\n  }\n\n  /**\n   * Override this method to implement sandbox destroy logic.\n   *\n   * Called by `_destroy()` after status is set to 'destroying'.\n   * Status will be set to 'destroyed' on success, 'error' on failure.\n   */\n  async destroy(): Promise<void> {\n    // Default no-op - subclasses override\n  }\n\n  // ---------------------------------------------------------------------------\n  // Logger Propagation\n  // ---------------------------------------------------------------------------\n\n  /**\n   * Override to propagate logger to MountManager.\n   * @internal\n   */\n  override __setLogger(logger: IMastraLogger): void {\n    super.__setLogger(logger);\n    // Propagate to MountManager if it exists\n    this.mounts?.__setLogger(logger);\n  }\n}\n","/**\n * Line Utilities\n *\n * Utility functions for working with line-based content:\n * - Extract lines by range\n * - Convert character positions to line numbers\n * - Format content with line number prefixes\n */\n\n/**\n * Line range where content was found\n */\nexport interface LineRange {\n  /** Starting line number (1-indexed) */\n  start: number;\n  /** Ending line number (1-indexed, inclusive) */\n  end: number;\n}\n\n/**\n * Extract lines from content by line range.\n *\n * @param content - The document content\n * @param startLine - Starting line number (1-indexed)\n * @param endLine - Ending line number (1-indexed, inclusive)\n * @returns Object with extracted content and metadata\n */\nexport function extractLines(\n  content: string,\n  startLine?: number,\n  endLine?: number,\n): {\n  content: string;\n  lines: { start: number; end: number };\n  totalLines: number;\n} {\n  const allLines = content.split('\\n');\n  const totalLines = allLines.length;\n\n  // Default to full content\n  const start = Math.max(1, startLine ?? 1);\n  const end = Math.min(totalLines, endLine ?? totalLines);\n\n  // Extract the requested range (convert to 0-indexed)\n  const extractedLines = allLines.slice(start - 1, end);\n\n  return {\n    content: extractedLines.join('\\n'),\n    lines: { start, end },\n    totalLines,\n  };\n}\n\n/**\n * Extract lines using offset/limit style parameters (like Claude Code).\n *\n * @param content - The document content\n * @param offset - Line number to start from (1-indexed, default: 1)\n * @param limit - Maximum number of lines to read (default: all remaining)\n * @returns Object with extracted content and metadata\n */\nexport function extractLinesWithLimit(\n  content: string,\n  offset?: number,\n  limit?: number,\n): {\n  content: string;\n  lines: { start: number; end: number };\n  totalLines: number;\n} {\n  const startLine = offset ?? 1;\n  const endLine = limit ? startLine + limit - 1 : undefined;\n  return extractLines(content, startLine, endLine);\n}\n\n/**\n * Format content with line number prefixes.\n * Output format matches Claude Code: \"     1content here\"\n *\n * @param content - The content to format\n * @param startLineNumber - The line number of the first line (1-indexed)\n * @returns Formatted content with line numbers\n */\nexport function formatWithLineNumbers(content: string, startLineNumber: number = 1): string {\n  const lines = content.split('\\n');\n  const maxLineNum = startLineNumber + lines.length - 1;\n  const padWidth = Math.max(6, String(maxLineNum).length + 1);\n\n  return lines\n    .map((line, i) => {\n      const lineNum = startLineNumber + i;\n      return `${String(lineNum).padStart(padWidth)}${line}`;\n    })\n    .join('\\n');\n}\n\n/**\n * Convert a character index to a line number.\n * Useful for converting RAG chunk character offsets to line numbers.\n *\n * @param content - The full document content\n * @param charIndex - The character index (0-indexed)\n * @returns The line number (1-indexed), or undefined if charIndex is out of bounds\n */\nexport function charIndexToLineNumber(content: string, charIndex: number): number | undefined {\n  if (charIndex < 0 || charIndex > content.length) {\n    return undefined;\n  }\n\n  // Count newlines before the character index\n  let lineNumber = 1;\n  for (let i = 0; i < charIndex && i < content.length; i++) {\n    if (content[i] === '\\n') {\n      lineNumber++;\n    }\n  }\n\n  return lineNumber;\n}\n\n/**\n * Convert character range to line range.\n * Useful for converting RAG chunk character offsets to line ranges.\n *\n * @param content - The full document content\n * @param startCharIdx - Start character index (0-indexed)\n * @param endCharIdx - End character index (0-indexed, exclusive)\n * @returns LineRange (1-indexed) or undefined if indices are out of bounds\n */\nexport function charRangeToLineRange(content: string, startCharIdx: number, endCharIdx: number): LineRange | undefined {\n  const startLine = charIndexToLineNumber(content, startCharIdx);\n  // For end, we want the line containing the last character (endCharIdx - 1)\n  const endLine = charIndexToLineNumber(content, Math.max(0, endCharIdx - 1));\n\n  if (startLine === undefined || endLine === undefined) {\n    return undefined;\n  }\n\n  return { start: startLine, end: endLine };\n}\n\n/**\n * Count occurrences of a string in content.\n *\n * @param content - The content to search\n * @param searchString - The string to find\n * @returns Number of occurrences\n */\nexport function countOccurrences(content: string, searchString: string): number {\n  if (!searchString) return 0;\n\n  let count = 0;\n  let position = 0;\n\n  while ((position = content.indexOf(searchString, position)) !== -1) {\n    count++;\n    position += searchString.length;\n  }\n\n  return count;\n}\n\n/**\n * Replace a string in content, with validation for uniqueness.\n *\n * @param content - The content to modify\n * @param oldString - The string to find and replace\n * @param newString - The replacement string\n * @param replaceAll - If true, replace all occurrences; if false, require unique match\n * @returns Object with result content and metadata\n * @throws Error if oldString is not found or not unique (when replaceAll is false)\n */\nexport function replaceString(\n  content: string,\n  oldString: string,\n  newString: string,\n  replaceAll: boolean = false,\n): {\n  content: string;\n  replacements: number;\n} {\n  const count = countOccurrences(content, oldString);\n\n  if (count === 0) {\n    throw new StringNotFoundError(oldString);\n  }\n\n  if (!replaceAll && count > 1) {\n    throw new StringNotUniqueError(oldString, count);\n  }\n\n  if (replaceAll) {\n    // Replace all occurrences\n    const result = content.split(oldString).join(newString);\n    return { content: result, replacements: count };\n  } else {\n    // Replace first (and only) occurrence\n    const result = content.replace(oldString, newString);\n    return { content: result, replacements: 1 };\n  }\n}\n\n/**\n * Error thrown when string is not found during replacement.\n */\nexport class StringNotFoundError extends Error {\n  constructor(public readonly searchString: string) {\n    super(`The specified text was not found. Make sure you use the exact text from the file.`);\n    this.name = 'StringNotFoundError';\n  }\n}\n\n/**\n * Error thrown when string appears multiple times but unique match required.\n */\nexport class StringNotUniqueError extends Error {\n  constructor(\n    public readonly searchString: string,\n    public readonly occurrences: number,\n  ) {\n    super(\n      `The specified text appears ${occurrences} times. Provide more surrounding context to make the match unique, or use replace_all to replace all occurrences.`,\n    );\n    this.name = 'StringNotUniqueError';\n  }\n}\n","/**\n * BM25 (Best Matching 25) implementation for keyword-based search.\n *\n * BM25 is a probabilistic ranking function used for information retrieval.\n * It ranks documents based on the query terms appearing in each document,\n * taking into account term frequency and document length normalization.\n */\n\nimport type { LineRange } from '../line-utils';\n\n/**\n * BM25 configuration parameters\n */\nexport interface BM25Config {\n  /**\n   * Controls term frequency saturation.\n   * Higher values give more weight to term frequency.\n   * Typical range: 1.2 - 2.0\n   * @default 1.5\n   */\n  k1?: number;\n\n  /**\n   * Controls document length normalization.\n   * 0 = no length normalization, 1 = full normalization\n   * @default 0.75\n   */\n  b?: number;\n}\n\n/**\n * Represents a document in the BM25 index\n */\nexport interface BM25Document {\n  /** Document identifier */\n  id: string;\n  /** Document content */\n  content: string;\n  /** Pre-computed tokens for the document */\n  tokens: string[];\n  /** Token frequency map */\n  termFrequencies: Map<string, number>;\n  /** Total number of tokens */\n  length: number;\n  /** Optional metadata */\n  metadata?: Record<string, unknown>;\n}\n\n/**\n * Result from a BM25 search\n */\nexport interface BM25SearchResult {\n  /** Document identifier */\n  id: string;\n  /** Document content */\n  content: string;\n  /** BM25 score (higher is more relevant) */\n  score: number;\n  /** Optional metadata */\n  metadata?: Record<string, unknown>;\n  /** Line range where query terms were found (if computed) */\n  lineRange?: LineRange;\n}\n\n/**\n * Tokenization options\n */\nexport interface TokenizeOptions {\n  /** Convert to lowercase */\n  lowercase?: boolean;\n  /** Remove punctuation */\n  removePunctuation?: boolean;\n  /** Minimum token length */\n  minLength?: number;\n  /** Custom stopwords to remove */\n  stopwords?: Set<string>;\n  /** Custom split pattern (default: /\\s+/) */\n  splitPattern?: RegExp;\n}\n\n/**\n * Default English stopwords\n */\nexport const DEFAULT_STOPWORDS = new Set([\n  'a',\n  'an',\n  'and',\n  'are',\n  'as',\n  'at',\n  'be',\n  'by',\n  'for',\n  'from',\n  'has',\n  'he',\n  'in',\n  'is',\n  'it',\n  'its',\n  'of',\n  'on',\n  'or',\n  'that',\n  'the',\n  'to',\n  'was',\n  'were',\n  'will',\n  'with',\n]);\n\n/**\n * Default tokenization options\n */\nconst DEFAULT_TOKENIZE_OPTIONS: Required<TokenizeOptions> = {\n  lowercase: true,\n  removePunctuation: true,\n  minLength: 2,\n  stopwords: DEFAULT_STOPWORDS,\n  splitPattern: /\\s+/,\n};\n\n/**\n * Tokenize text into an array of terms\n */\nexport function tokenize(text: string, options: TokenizeOptions = {}): string[] {\n  const opts = { ...DEFAULT_TOKENIZE_OPTIONS, ...options };\n\n  let processed = text;\n\n  // Convert to lowercase if enabled\n  if (opts.lowercase) {\n    processed = processed.toLowerCase();\n  }\n\n  // Remove punctuation if enabled\n  if (opts.removePunctuation) {\n    processed = processed.replace(/[^\\w\\s]/g, ' ');\n  }\n\n  // Split into tokens\n  const tokens = processed.split(opts.splitPattern).filter(token => {\n    // Filter by minimum length\n    if (token.length < opts.minLength) {\n      return false;\n    }\n    // Filter stopwords\n    if (opts.stopwords?.has(token)) {\n      return false;\n    }\n    return true;\n  });\n\n  return tokens;\n}\n\n// Re-export line utilities from line-utils.ts (except findLineRange which is defined here)\nexport {\n  extractLines,\n  extractLinesWithLimit,\n  formatWithLineNumbers,\n  replaceString,\n  StringNotFoundError,\n  StringNotUniqueError,\n} from '../line-utils';\n\n/**\n * Find the line range where query terms appear in content.\n * Returns the range spanning from the first to the last line containing any query term.\n *\n * @param content - The document content\n * @param queryTerms - Tokenized query terms to find\n * @param options - Tokenization options (should match indexing options)\n * @returns LineRange if terms found, undefined otherwise\n */\nexport function findLineRange(\n  content: string,\n  queryTerms: string[],\n  options: TokenizeOptions = {},\n): LineRange | undefined {\n  if (queryTerms.length === 0) return undefined;\n\n  const lines = content.split('\\n');\n\n  // Default tokenize options for matching\n  const defaultOpts = { lowercase: true, removePunctuation: true, minLength: 2 };\n  const opts = { ...defaultOpts, ...options };\n\n  // Normalize query terms for matching\n  const normalizedTerms = new Set(queryTerms.map(t => (opts.lowercase ? t.toLowerCase() : t)));\n\n  let firstMatchLine: number | undefined;\n  let lastMatchLine: number | undefined;\n\n  for (let i = 0; i < lines.length; i++) {\n    const lineTokens = tokenize(lines[i]!, options);\n\n    // Check if any query term appears in this line\n    for (const token of lineTokens) {\n      if (normalizedTerms.has(token)) {\n        const lineNum = i + 1; // 1-indexed\n        if (firstMatchLine === undefined) {\n          firstMatchLine = lineNum;\n        }\n        lastMatchLine = lineNum;\n        break; // Found a match on this line, move to next line\n      }\n    }\n  }\n\n  if (firstMatchLine !== undefined && lastMatchLine !== undefined) {\n    return { start: firstMatchLine, end: lastMatchLine };\n  }\n\n  return undefined;\n}\n\n/**\n * Compute term frequencies for a list of tokens\n */\nfunction computeTermFrequencies(tokens: string[]): Map<string, number> {\n  const frequencies = new Map<string, number>();\n  for (const token of tokens) {\n    frequencies.set(token, (frequencies.get(token) || 0) + 1);\n  }\n  return frequencies;\n}\n\n/**\n * BM25 Index for keyword-based document retrieval\n */\nexport class BM25Index {\n  /** BM25 k1 parameter */\n  readonly k1: number;\n  /** BM25 b parameter */\n  readonly b: number;\n\n  /** Documents in the index */\n  #documents: Map<string, BM25Document> = new Map();\n  /** Inverted index: term -> document IDs containing the term */\n  #invertedIndex: Map<string, Set<string>> = new Map();\n  /** Document frequency: term -> number of documents containing the term */\n  #documentFrequency: Map<string, number> = new Map();\n  /** Average document length */\n  #avgDocLength: number = 0;\n  /** Total number of documents */\n  #docCount: number = 0;\n  /** Tokenization options */\n  #tokenizeOptions: TokenizeOptions;\n\n  constructor(config: BM25Config = {}, tokenizeOptions: TokenizeOptions = {}) {\n    this.k1 = config.k1 ?? 1.5;\n    this.b = config.b ?? 0.75;\n    this.#tokenizeOptions = tokenizeOptions;\n  }\n\n  /**\n   * Add a document to the index\n   */\n  add(id: string, content: string, metadata?: Record<string, unknown>): void {\n    // Remove existing document if it exists\n    if (this.#documents.has(id)) {\n      this.remove(id);\n    }\n\n    const tokens = tokenize(content, this.#tokenizeOptions);\n    const termFrequencies = computeTermFrequencies(tokens);\n\n    const doc: BM25Document = {\n      id,\n      content,\n      tokens,\n      termFrequencies,\n      length: tokens.length,\n      metadata,\n    };\n\n    this.#documents.set(id, doc);\n    this.#docCount++;\n\n    // Update inverted index and document frequency\n    for (const term of termFrequencies.keys()) {\n      if (!this.#invertedIndex.has(term)) {\n        this.#invertedIndex.set(term, new Set());\n      }\n      this.#invertedIndex.get(term)!.add(id);\n      this.#documentFrequency.set(term, (this.#documentFrequency.get(term) || 0) + 1);\n    }\n\n    // Update average document length\n    this.#updateAvgDocLength();\n  }\n\n  /**\n   * Remove a document from the index\n   */\n  remove(id: string): boolean {\n    const doc = this.#documents.get(id);\n    if (!doc) {\n      return false;\n    }\n\n    // Update inverted index and document frequency\n    for (const term of doc.termFrequencies.keys()) {\n      const docIds = this.#invertedIndex.get(term);\n      if (docIds) {\n        docIds.delete(id);\n        if (docIds.size === 0) {\n          this.#invertedIndex.delete(term);\n          this.#documentFrequency.delete(term);\n        } else {\n          this.#documentFrequency.set(term, (this.#documentFrequency.get(term) || 1) - 1);\n        }\n      }\n    }\n\n    this.#documents.delete(id);\n    this.#docCount--;\n\n    // Update average document length\n    this.#updateAvgDocLength();\n\n    return true;\n  }\n\n  /**\n   * Clear all documents from the index\n   */\n  clear(): void {\n    this.#documents.clear();\n    this.#invertedIndex.clear();\n    this.#documentFrequency.clear();\n    this.#docCount = 0;\n    this.#avgDocLength = 0;\n  }\n\n  /**\n   * Search for documents matching the query\n   */\n  search(query: string, topK: number = 10, minScore: number = 0): BM25SearchResult[] {\n    const queryTokens = tokenize(query, this.#tokenizeOptions);\n\n    if (queryTokens.length === 0 || this.#docCount === 0) {\n      return [];\n    }\n\n    const scores = new Map<string, number>();\n\n    // Calculate BM25 scores for each document\n    for (const queryTerm of queryTokens) {\n      const docIds = this.#invertedIndex.get(queryTerm);\n      if (!docIds) {\n        continue;\n      }\n\n      const df = this.#documentFrequency.get(queryTerm) || 0;\n      const idf = this.#computeIDF(df);\n\n      for (const docId of docIds) {\n        const doc = this.#documents.get(docId)!;\n        const tf = doc.termFrequencies.get(queryTerm) || 0;\n        const termScore = this.#computeTermScore(tf, doc.length, idf);\n\n        scores.set(docId, (scores.get(docId) || 0) + termScore);\n      }\n    }\n\n    // Sort by score and return top K results\n    const results: BM25SearchResult[] = [];\n\n    for (const [docId, score] of scores.entries()) {\n      if (score >= minScore) {\n        const doc = this.#documents.get(docId)!;\n        results.push({\n          id: docId,\n          content: doc.content,\n          score,\n          metadata: doc.metadata,\n        });\n      }\n    }\n\n    // Sort by score descending\n    results.sort((a, b) => b.score - a.score);\n\n    return results.slice(0, topK);\n  }\n\n  /**\n   * Get a document by ID\n   */\n  get(id: string): BM25Document | undefined {\n    return this.#documents.get(id);\n  }\n\n  /**\n   * Check if a document exists in the index\n   */\n  has(id: string): boolean {\n    return this.#documents.has(id);\n  }\n\n  /**\n   * Get the number of documents in the index\n   */\n  get size(): number {\n    return this.#docCount;\n  }\n\n  /**\n   * Get all document IDs\n   */\n  get documentIds(): string[] {\n    return Array.from(this.#documents.keys());\n  }\n\n  /**\n   * Serialize the index to a JSON-compatible object\n   */\n  serialize(): BM25IndexData {\n    const documents: SerializedBM25Document[] = [];\n    for (const [id, doc] of this.#documents.entries()) {\n      documents.push({\n        id,\n        content: doc.content,\n        tokens: doc.tokens,\n        termFrequencies: Object.fromEntries(doc.termFrequencies),\n        length: doc.length,\n        metadata: doc.metadata,\n      });\n    }\n\n    return {\n      k1: this.k1,\n      b: this.b,\n      documents,\n      avgDocLength: this.#avgDocLength,\n    };\n  }\n\n  /**\n   * Deserialize an index from a JSON object\n   */\n  static deserialize(data: BM25IndexData, tokenizeOptions: TokenizeOptions = {}): BM25Index {\n    const index = new BM25Index({ k1: data.k1, b: data.b }, tokenizeOptions);\n\n    for (const doc of data.documents) {\n      const termFrequencies = new Map(Object.entries(doc.termFrequencies));\n\n      const document: BM25Document = {\n        id: doc.id,\n        content: doc.content,\n        tokens: doc.tokens,\n        termFrequencies,\n        length: doc.length,\n        metadata: doc.metadata,\n      };\n\n      index.#documents.set(doc.id, document);\n      index.#docCount++;\n\n      // Rebuild inverted index and document frequency\n      for (const term of termFrequencies.keys()) {\n        if (!index.#invertedIndex.has(term)) {\n          index.#invertedIndex.set(term, new Set());\n        }\n        index.#invertedIndex.get(term)!.add(doc.id);\n        index.#documentFrequency.set(term, (index.#documentFrequency.get(term) || 0) + 1);\n      }\n    }\n\n    index.#avgDocLength = data.avgDocLength;\n\n    return index;\n  }\n\n  /**\n   * Update average document length after add/remove operations\n   */\n  #updateAvgDocLength(): void {\n    if (this.#docCount === 0) {\n      this.#avgDocLength = 0;\n      return;\n    }\n\n    let totalLength = 0;\n    for (const doc of this.#documents.values()) {\n      totalLength += doc.length;\n    }\n    this.#avgDocLength = totalLength / this.#docCount;\n  }\n\n  /**\n   * Compute IDF (Inverse Document Frequency) for a term\n   */\n  #computeIDF(df: number): number {\n    // Using Robertson-Sprck Jones IDF formula\n    return Math.log((this.#docCount - df + 0.5) / (df + 0.5) + 1);\n  }\n\n  /**\n   * Compute the BM25 score component for a single term\n   */\n  #computeTermScore(tf: number, docLength: number, idf: number): number {\n    const numerator = tf * (this.k1 + 1);\n    const denominator = tf + this.k1 * (1 - this.b + this.b * (docLength / this.#avgDocLength));\n    return idf * (numerator / denominator);\n  }\n}\n\n/**\n * Serialized document format for persistence\n */\ninterface SerializedBM25Document {\n  id: string;\n  content: string;\n  tokens: string[];\n  termFrequencies: Record<string, number>;\n  length: number;\n  metadata?: Record<string, unknown>;\n}\n\n/**\n * Serialized index data for persistence\n */\nexport interface BM25IndexData {\n  k1: number;\n  b: number;\n  documents: SerializedBM25Document[];\n  avgDocLength: number;\n}\n","/**\n * SearchEngine - Unified search engine supporting BM25, vector, and hybrid search.\n *\n * Provides search capabilities for Workspace, enabling keyword-based (BM25),\n * semantic (vector), and combined hybrid search across indexed content.\n */\n\nimport type { MastraVector, VectorFilter } from '../../vector';\nimport type { LineRange } from '../line-utils';\n\nimport { BM25Index, tokenize, findLineRange } from './bm25';\nimport type { BM25Config, TokenizeOptions } from './bm25';\n\n/**\n * Search mode options\n */\nexport type SearchMode = 'vector' | 'bm25' | 'hybrid';\n\n// =============================================================================\n// Types\n// =============================================================================\n\n/**\n * Embedder interface - any function that takes text and returns embeddings\n */\nexport interface Embedder {\n  (text: string): Promise<number[]>;\n}\n\n/**\n * Configuration for vector search\n */\nexport interface VectorConfig {\n  /** Vector store for semantic search */\n  vectorStore: MastraVector;\n  /** Embedder function for generating vectors */\n  embedder: Embedder;\n  /** Index name for the vector store */\n  indexName: string;\n}\n\n/**\n * Configuration for BM25 search\n */\nexport interface BM25SearchConfig {\n  /** BM25 algorithm parameters */\n  bm25?: BM25Config;\n  /** Tokenization options */\n  tokenize?: TokenizeOptions;\n}\n\n/**\n * A document to be indexed\n */\nexport interface IndexDocument {\n  /** Unique identifier for this document */\n  id: string;\n  /** Text content to index */\n  content: string;\n  /** Optional metadata to store with the document */\n  metadata?: Record<string, unknown>;\n  /**\n   * For chunked documents: the starting line number of this chunk in the original document.\n   * When provided, lineRange in search results will be adjusted to reflect original document lines.\n   * (1-indexed)\n   */\n  startLineOffset?: number;\n}\n\n/**\n * Base search result with common fields\n */\nexport interface SearchResult {\n  /** Document identifier */\n  id: string;\n  /** Document content */\n  content: string;\n  /** Search score (0-1 for normalized results) */\n  score: number;\n  /** Line range where query terms appear */\n  lineRange?: LineRange;\n  /** Optional metadata */\n  metadata?: Record<string, unknown>;\n  /** Score breakdown by search type */\n  scoreDetails?: {\n    vector?: number;\n    bm25?: number;\n  };\n}\n\n/**\n * Options for searching\n */\nexport interface SearchOptions {\n  /** Maximum number of results to return */\n  topK?: number;\n  /** Minimum score threshold */\n  minScore?: number;\n  /** Search mode: 'bm25', 'vector', or 'hybrid' */\n  mode?: SearchMode;\n  /** Weight for vector scores in hybrid search (0-1, default 0.5) */\n  vectorWeight?: number;\n  /** Filter for vector search */\n  filter?: Record<string, unknown>;\n}\n\n/**\n * Configuration for SearchEngine\n */\nexport interface SearchEngineConfig {\n  /** BM25 configuration (enables BM25 search) */\n  bm25?: BM25SearchConfig;\n  /** Vector configuration (enables vector search) */\n  vector?: VectorConfig;\n  /** Whether to use lazy vector indexing (default: false = eager) */\n  lazyVectorIndex?: boolean;\n}\n\n// =============================================================================\n// SearchEngine\n// =============================================================================\n\n/**\n * Unified search engine supporting BM25, vector, and hybrid search.\n *\n * Used internally by Workspace to provide consistent search functionality.\n *\n * @example\n * ```typescript\n * const engine = new SearchEngine({\n *   bm25: { tokenize: { lowercase: true } },\n *   vector: { vectorStore, embedder, indexName: 'my-index' },\n * });\n *\n * // Index documents\n * await engine.index({ id: 'doc1', content: 'Hello world' });\n *\n * // Search\n * const results = await engine.search('hello', { mode: 'hybrid', topK: 5 });\n * ```\n */\nexport class SearchEngine {\n  /** BM25 index for keyword search */\n  #bm25Index?: BM25Index;\n\n  /** Tokenization options (stored for lineRange computation) */\n  #tokenizeOptions?: TokenizeOptions;\n\n  /** Vector configuration */\n  #vectorConfig?: VectorConfig;\n\n  /** Whether to use lazy vector indexing */\n  #lazyVectorIndex: boolean;\n\n  /** Documents pending vector indexing (for lazy mode) */\n  #pendingVectorDocs: IndexDocument[] = [];\n\n  /** Whether vector index has been built (for lazy mode) */\n  #vectorIndexBuilt: boolean = false;\n\n  constructor(config: SearchEngineConfig = {}) {\n    // Initialize BM25 if configured\n    if (config.bm25 !== undefined) {\n      this.#tokenizeOptions = config.bm25.tokenize;\n      this.#bm25Index = new BM25Index(config.bm25.bm25, this.#tokenizeOptions);\n    }\n\n    // Store vector config if provided\n    if (config.vector) {\n      this.#vectorConfig = config.vector;\n    }\n\n    this.#lazyVectorIndex = config.lazyVectorIndex ?? false;\n  }\n\n  // ===========================================================================\n  // Public API\n  // ===========================================================================\n\n  /**\n   * Index a document for search\n   */\n  async index(doc: IndexDocument): Promise<void> {\n    // Merge startLineOffset into metadata for retrieval at search time\n    const metadata: Record<string, unknown> = {\n      ...doc.metadata,\n    };\n    if (doc.startLineOffset !== undefined) {\n      metadata._startLineOffset = doc.startLineOffset;\n    }\n\n    // BM25 indexing (always synchronous and immediate)\n    if (this.#bm25Index) {\n      this.#bm25Index.add(doc.id, doc.content, metadata);\n    }\n\n    // Vector indexing\n    if (this.#vectorConfig) {\n      const docWithMergedMetadata = { ...doc, metadata };\n      if (this.#lazyVectorIndex) {\n        // Store for later indexing\n        this.#pendingVectorDocs.push(docWithMergedMetadata);\n        this.#vectorIndexBuilt = false;\n      } else {\n        // Index immediately\n        await this.#indexVector(docWithMergedMetadata);\n      }\n    }\n  }\n\n  /**\n   * Index multiple documents\n   */\n  async indexMany(docs: IndexDocument[]): Promise<void> {\n    for (const doc of docs) {\n      await this.index(doc);\n    }\n  }\n\n  /**\n   * Remove a document from the index\n   */\n  async remove(id: string): Promise<void> {\n    // Remove from BM25\n    if (this.#bm25Index) {\n      this.#bm25Index.remove(id);\n    }\n\n    // Remove from vector store\n    if (this.#vectorConfig) {\n      try {\n        await this.#vectorConfig.vectorStore.deleteVector({\n          indexName: this.#vectorConfig.indexName,\n          id,\n        });\n      } catch {\n        // Vector may not exist, ignore\n      }\n\n      // Also remove from pending docs if in lazy mode\n      if (this.#lazyVectorIndex) {\n        this.#pendingVectorDocs = this.#pendingVectorDocs.filter(d => d.id !== id);\n      }\n    }\n  }\n\n  /**\n   * Clear all indexed documents\n   */\n  clear(): void {\n    if (this.#bm25Index) {\n      this.#bm25Index.clear();\n    }\n    this.#pendingVectorDocs = [];\n    this.#vectorIndexBuilt = false;\n    // Note: We don't clear the vector store here as it may be shared\n  }\n\n  /**\n   * Search for documents\n   */\n  async search(query: string, options: SearchOptions = {}): Promise<SearchResult[]> {\n    const { topK = 10, minScore, mode, vectorWeight = 0.5, filter } = options;\n\n    const effectiveMode = this.#determineSearchMode(mode);\n\n    if (effectiveMode === 'bm25') {\n      return this.#searchBM25(query, topK, minScore);\n    }\n\n    if (effectiveMode === 'vector') {\n      return this.#searchVector(query, topK, minScore, filter);\n    }\n\n    // Hybrid search\n    return this.#searchHybrid(query, topK, minScore, vectorWeight, filter);\n  }\n\n  /**\n   * Check if BM25 search is available\n   */\n  get canBM25(): boolean {\n    return !!this.#bm25Index;\n  }\n\n  /**\n   * Check if vector search is available\n   */\n  get canVector(): boolean {\n    return !!this.#vectorConfig;\n  }\n\n  /**\n   * Check if hybrid search is available\n   */\n  get canHybrid(): boolean {\n    return this.canBM25 && this.canVector;\n  }\n\n  /**\n   * Get the BM25 index (for serialization/debugging)\n   */\n  get bm25Index(): BM25Index | undefined {\n    return this.#bm25Index;\n  }\n\n  // ===========================================================================\n  // Private Methods\n  // ===========================================================================\n\n  /**\n   * Determine the effective search mode\n   */\n  #determineSearchMode(requestedMode?: SearchMode): SearchMode {\n    if (requestedMode) {\n      if (requestedMode === 'vector' && !this.canVector) {\n        throw new Error('Vector search requires vector configuration.');\n      }\n      if (requestedMode === 'bm25' && !this.canBM25) {\n        throw new Error('BM25 search requires BM25 configuration.');\n      }\n      if (requestedMode === 'hybrid' && !this.canHybrid) {\n        throw new Error('Hybrid search requires both vector and BM25 configuration.');\n      }\n      return requestedMode;\n    }\n\n    // Auto-determine based on available configuration\n    if (this.canHybrid) {\n      return 'hybrid';\n    }\n    if (this.canVector) {\n      return 'vector';\n    }\n    if (this.canBM25) {\n      return 'bm25';\n    }\n\n    throw new Error('No search configuration available. Provide bm25 or vector config.');\n  }\n\n  /**\n   * Index a single document in the vector store\n   */\n  async #indexVector(doc: IndexDocument): Promise<void> {\n    if (!this.#vectorConfig) return;\n\n    const { vectorStore, embedder, indexName } = this.#vectorConfig;\n\n    const embedding = await embedder(doc.content);\n\n    await vectorStore.upsert({\n      indexName,\n      vectors: [embedding],\n      metadata: [\n        {\n          id: doc.id,\n          text: doc.content,\n          ...doc.metadata,\n        },\n      ],\n      ids: [doc.id],\n    });\n  }\n\n  /**\n   * Ensure vector index is built (for lazy mode)\n   */\n  async #ensureVectorIndex(): Promise<void> {\n    if (!this.#lazyVectorIndex || this.#vectorIndexBuilt || this.#pendingVectorDocs.length === 0) {\n      return;\n    }\n\n    for (const doc of this.#pendingVectorDocs) {\n      await this.#indexVector(doc);\n    }\n\n    this.#pendingVectorDocs = [];\n    this.#vectorIndexBuilt = true;\n  }\n\n  /**\n   * BM25 keyword search\n   */\n  #searchBM25(query: string, topK: number, minScore?: number): SearchResult[] {\n    if (!this.#bm25Index) {\n      throw new Error('BM25 search requires BM25 configuration.');\n    }\n\n    const results = this.#bm25Index.search(query, topK, minScore);\n    const queryTokens = tokenize(query, this.#tokenizeOptions);\n\n    return results.map(result => {\n      const rawLineRange = findLineRange(result.content, queryTokens, this.#tokenizeOptions);\n      const lineRange = this.#adjustLineRange(rawLineRange, result.metadata);\n      const { _startLineOffset, ...cleanMetadata } = result.metadata ?? {};\n\n      return {\n        id: result.id,\n        content: result.content,\n        score: result.score,\n        lineRange,\n        metadata: Object.keys(cleanMetadata).length > 0 ? cleanMetadata : undefined,\n        scoreDetails: { bm25: result.score },\n      };\n    });\n  }\n\n  /**\n   * Vector semantic search\n   */\n  async #searchVector(\n    query: string,\n    topK: number,\n    minScore?: number,\n    filter?: Record<string, unknown>,\n  ): Promise<SearchResult[]> {\n    if (!this.#vectorConfig) {\n      throw new Error('Vector search requires vector configuration.');\n    }\n\n    // Ensure lazy index is built\n    await this.#ensureVectorIndex();\n\n    const { vectorStore, embedder, indexName } = this.#vectorConfig;\n\n    const queryEmbedding = await embedder(query);\n\n    const vectorResults = await vectorStore.query({\n      indexName,\n      queryVector: queryEmbedding,\n      topK,\n      filter: filter as VectorFilter,\n    });\n\n    const queryTokens = tokenize(query, this.#tokenizeOptions);\n    const results: SearchResult[] = [];\n\n    for (const result of vectorResults) {\n      if (minScore !== undefined && result.score < minScore) {\n        continue;\n      }\n\n      const id = (result.metadata?.id as string) ?? result.id;\n      const content = (result.metadata?.text as string) ?? '';\n\n      // Extract metadata, excluding internal fields\n      const { id: _id, text: _text, _startLineOffset, ...restMetadata } = result.metadata ?? {};\n\n      const rawLineRange = findLineRange(content, queryTokens, this.#tokenizeOptions);\n      const lineRange = this.#adjustLineRange(rawLineRange, result.metadata);\n\n      results.push({\n        id,\n        content,\n        score: result.score,\n        lineRange,\n        metadata: Object.keys(restMetadata).length > 0 ? restMetadata : undefined,\n        scoreDetails: { vector: result.score },\n      });\n    }\n\n    return results;\n  }\n\n  /**\n   * Hybrid search combining vector and BM25 scores\n   */\n  async #searchHybrid(\n    query: string,\n    topK: number,\n    minScore?: number,\n    vectorWeight: number = 0.5,\n    filter?: Record<string, unknown>,\n  ): Promise<SearchResult[]> {\n    // Get more results than requested to account for merging\n    const expandedTopK = Math.min(topK * 2, 50);\n\n    // Perform both searches in parallel\n    const [vectorResults, bm25Results] = await Promise.all([\n      this.#searchVector(query, expandedTopK, undefined, filter),\n      Promise.resolve(this.#searchBM25(query, expandedTopK, undefined)),\n    ]);\n\n    // Normalize BM25 scores to 0-1 range\n    const normalizedBM25 = this.#normalizeBM25Scores(bm25Results);\n\n    // Create score maps by document id\n    const bm25Map = new Map<string, SearchResult>();\n    for (const result of normalizedBM25) {\n      bm25Map.set(result.id, result);\n    }\n\n    const vectorMap = new Map<string, SearchResult>();\n    for (const result of vectorResults) {\n      vectorMap.set(result.id, result);\n    }\n\n    // Combine scores\n    const combinedResults = new Map<string, SearchResult>();\n    const allIds = new Set([...vectorMap.keys(), ...bm25Map.keys()]);\n    const bm25Weight = 1 - vectorWeight;\n\n    for (const id of allIds) {\n      const vectorResult = vectorMap.get(id);\n      const bm25Result = bm25Map.get(id);\n\n      const vectorScore = vectorResult?.scoreDetails?.vector ?? 0;\n      const bm25Score = bm25Result?.score ?? 0; // Already normalized\n\n      const combinedScore = vectorWeight * vectorScore + bm25Weight * bm25Score;\n\n      // Use data from whichever source has it\n      const baseResult = vectorResult ?? bm25Result!;\n\n      combinedResults.set(id, {\n        id,\n        content: baseResult.content,\n        score: combinedScore,\n        lineRange: bm25Result?.lineRange ?? vectorResult?.lineRange,\n        metadata: baseResult.metadata,\n        scoreDetails: {\n          vector: vectorResult?.scoreDetails?.vector,\n          bm25: bm25Result?.scoreDetails?.bm25,\n        },\n      });\n    }\n\n    // Sort by combined score and apply filters\n    let results = Array.from(combinedResults.values());\n    results.sort((a, b) => b.score - a.score);\n\n    if (minScore !== undefined) {\n      results = results.filter(r => r.score >= minScore);\n    }\n\n    return results.slice(0, topK);\n  }\n\n  /**\n   * Normalize BM25 scores to 0-1 range using min-max normalization\n   */\n  #normalizeBM25Scores(results: SearchResult[]): SearchResult[] {\n    if (results.length === 0) return results;\n\n    const scores = results.map(r => r.scoreDetails?.bm25 ?? r.score);\n    const maxScore = Math.max(...scores);\n    const minScore = Math.min(...scores);\n    const range = maxScore - minScore;\n\n    if (range === 0) {\n      return results.map(r => ({ ...r, score: 1 }));\n    }\n\n    return results.map(r => ({\n      ...r,\n      score: ((r.scoreDetails?.bm25 ?? r.score) - minScore) / range,\n    }));\n  }\n\n  /**\n   * Adjust line range for chunked documents.\n   * If the document has a _startLineOffset in metadata, adjust the line range\n   * to reflect the original document's line numbers.\n   */\n  #adjustLineRange(lineRange: LineRange | undefined, metadata?: Record<string, unknown>): LineRange | undefined {\n    if (!lineRange) return undefined;\n\n    const startLineOffset = metadata?._startLineOffset;\n    if (typeof startLineOffset !== 'number') {\n      return lineRange;\n    }\n\n    // Adjust line numbers: chunk lines are 1-indexed relative to chunk,\n    // offset is 1-indexed relative to original document\n    // So line 1 in chunk with offset 10 becomes line 10 in original\n    return {\n      start: lineRange.start + startLineOffset - 1,\n      end: lineRange.end + startLineOffset - 1,\n    };\n  }\n}\n","/**\n * Validation for Skills following the Agent Skills specification.\n * @see https://agentskills.io/specification\n *\n * This module uses plain validation functions instead of Zod to avoid\n * version compatibility issues between Zod 3 and Zod 4.\n */\n\n// =============================================================================\n// Constants\n// =============================================================================\n\n/**\n * Recommended limits from the Agent Skills spec\n */\nexport const SKILL_LIMITS = {\n  /** Recommended max tokens for instructions */\n  MAX_INSTRUCTION_TOKENS: 5000,\n  /** Recommended max lines for SKILL.md */\n  MAX_INSTRUCTION_LINES: 500,\n  /** Max characters for name field */\n  MAX_NAME_LENGTH: 64,\n  /** Max characters for description field */\n  MAX_DESCRIPTION_LENGTH: 1024,\n  /** Max characters for compatibility field */\n  MAX_COMPATIBILITY_LENGTH: 500,\n} as const;\n\n// =============================================================================\n// Types\n// =============================================================================\n\n/**\n * Skill metadata input type (what users provide)\n */\nexport interface SkillMetadataInput {\n  /** Skill name (1-64 chars, lowercase letters/numbers/hyphens only, must match directory name) */\n  name: string;\n  /** Description of what the skill does and when to use it (1-1024 characters) */\n  description: string;\n  /** License for the skill (e.g., \"Apache-2.0\", \"MIT\") */\n  license?: string;\n  /** Environment requirements or compatibility notes (string or object for flexibility) */\n  compatibility?: unknown;\n  /** Arbitrary key-value metadata - values can be strings, arrays, objects, etc. */\n  metadata?: Record<string, unknown>;\n}\n\n/**\n * Skill metadata output type (after validation)\n */\nexport type SkillMetadataOutput = SkillMetadataInput;\n\n/**\n * Validation result with warnings\n */\nexport interface SkillValidationResult {\n  valid: boolean;\n  errors: string[];\n  warnings: string[];\n}\n\n// =============================================================================\n// Field Validators\n// =============================================================================\n\n/**\n * Validate skill name according to spec:\n * - 1-64 characters\n * - Lowercase letters, numbers, hyphens only\n * - Must not start or end with hyphen\n * - Must not contain consecutive hyphens\n *\n * @param name - The name to validate\n * @returns Array of error messages (empty if valid)\n */\nfunction validateSkillName(name: unknown): string[] {\n  const errors: string[] = [];\n  const fieldPath = 'name';\n\n  // Check type\n  if (typeof name !== 'string') {\n    errors.push(`${fieldPath}: Expected string, received ${typeof name}`);\n    return errors;\n  }\n\n  // Check not empty\n  if (name.length === 0) {\n    errors.push(`${fieldPath}: Skill name cannot be empty`);\n    return errors;\n  }\n\n  // Check max length\n  if (name.length > SKILL_LIMITS.MAX_NAME_LENGTH) {\n    errors.push(`${fieldPath}: Skill name must be ${SKILL_LIMITS.MAX_NAME_LENGTH} characters or less`);\n  }\n\n  // Check allowed characters (lowercase letters, numbers, hyphens only)\n  if (!/^[a-z0-9-]+$/.test(name)) {\n    errors.push(`${fieldPath}: Skill name must contain only lowercase letters, numbers, and hyphens`);\n  }\n\n  // Check not starting or ending with hyphen\n  if (name.startsWith('-') || name.endsWith('-')) {\n    errors.push(`${fieldPath}: Skill name must not start or end with a hyphen`);\n  }\n\n  // Check no consecutive hyphens\n  if (name.includes('--')) {\n    errors.push(`${fieldPath}: Skill name must not contain consecutive hyphens`);\n  }\n\n  return errors;\n}\n\n/**\n * Validate skill description according to spec:\n * - 1-1024 characters\n * - Cannot be empty or only whitespace\n *\n * @param description - The description to validate\n * @returns Array of error messages (empty if valid)\n */\nfunction validateSkillDescription(description: unknown): string[] {\n  const errors: string[] = [];\n  const fieldPath = 'description';\n\n  // Check type\n  if (typeof description !== 'string') {\n    errors.push(`${fieldPath}: Expected string, received ${typeof description}`);\n    return errors;\n  }\n\n  // Check not empty\n  if (description.length === 0) {\n    errors.push(`${fieldPath}: Skill description cannot be empty`);\n    return errors;\n  }\n\n  // Check max length\n  if (description.length > SKILL_LIMITS.MAX_DESCRIPTION_LENGTH) {\n    errors.push(`${fieldPath}: Skill description must be ${SKILL_LIMITS.MAX_DESCRIPTION_LENGTH} characters or less`);\n  }\n\n  // Check not only whitespace\n  if (description.trim().length === 0) {\n    errors.push(`${fieldPath}: Skill description cannot be only whitespace`);\n  }\n\n  return errors;\n}\n\n/**\n * Validate skill license (optional string).\n *\n * @param license - The license to validate\n * @returns Array of error messages (empty if valid)\n */\nfunction validateSkillLicense(license: unknown): string[] {\n  const errors: string[] = [];\n  const fieldPath = 'license';\n\n  // Optional field - undefined/null is valid\n  if (license === undefined || license === null) {\n    return errors;\n  }\n\n  // If provided, must be string\n  if (typeof license !== 'string') {\n    errors.push(`${fieldPath}: Expected string, received ${typeof license}`);\n  }\n\n  return errors;\n}\n\n/**\n * Validate skill compatibility notes (optional).\n * Accepts string or any JSON-serializable value for flexibility with external skills.\n *\n * @param compatibility - The compatibility value to validate\n * @returns Array of error messages (empty if valid)\n */\nfunction validateSkillCompatibility(_compatibility: unknown): string[] {\n  // Optional field - any value is allowed (string, object, array, etc.)\n  // External skills don't always follow the spec strictly\n  return [];\n}\n\n/**\n * Validate skill metadata field (optional Record<string, unknown>).\n * Accepts any values (not just strings) for flexibility with external skills.\n *\n * @param metadata - The metadata object to validate\n * @returns Array of error messages (empty if valid)\n */\nfunction validateSkillMetadataField(metadata: unknown): string[] {\n  const errors: string[] = [];\n  const fieldPath = 'metadata';\n\n  // Optional field - undefined/null is valid\n  if (metadata === undefined || metadata === null) {\n    return errors;\n  }\n\n  // If provided, must be object (but values can be anything)\n  if (typeof metadata !== 'object' || Array.isArray(metadata)) {\n    errors.push(`${fieldPath}: Expected object, received ${Array.isArray(metadata) ? 'array' : typeof metadata}`);\n    return errors;\n  }\n\n  // Allow any values - external skills use arrays, objects, etc.\n  return errors;\n}\n\n// =============================================================================\n// Validation Helpers\n// =============================================================================\n\n/**\n * Rough token estimate (words * 1.3)\n * This is a simple heuristic; actual token counts vary by model\n */\nfunction estimateTokens(text: string): number {\n  const words = text.split(/\\s+/).filter(Boolean).length;\n  return Math.ceil(words * 1.3);\n}\n\n/**\n * Count lines in text\n */\nfunction countLines(text: string): number {\n  return text.split('\\n').length;\n}\n\n// =============================================================================\n// Main Validation Function\n// =============================================================================\n\n/**\n * Validate skill metadata with optional content warnings.\n *\n * @param metadata - The skill metadata to validate\n * @param dirName - The directory name (must match skill name)\n * @param instructions - Optional instructions content for token/line warnings\n * @returns Validation result with errors and warnings\n *\n * @example\n * ```typescript\n * const result = validateSkillMetadata(\n *   { name: 'my-skill', description: 'A helpful skill' },\n *   'my-skill',\n *   '# Instructions\\n...'\n * );\n *\n * if (!result.valid) {\n *   console.error('Validation errors:', result.errors);\n * }\n * if (result.warnings.length > 0) {\n *   console.warn('Warnings:', result.warnings);\n * }\n * ```\n */\nexport function validateSkillMetadata(\n  metadata: unknown,\n  dirName?: string,\n  instructions?: string,\n): SkillValidationResult {\n  const errors: string[] = [];\n  const warnings: string[] = [];\n\n  // Check that metadata is an object\n  if (typeof metadata !== 'object' || metadata === null || Array.isArray(metadata)) {\n    errors.push(\n      `Expected object, received ${metadata === null ? 'null' : Array.isArray(metadata) ? 'array' : typeof metadata}`,\n    );\n    return { valid: false, errors, warnings };\n  }\n\n  const data = metadata as Record<string, unknown>;\n\n  // Validate each field\n  errors.push(...validateSkillName(data.name));\n  errors.push(...validateSkillDescription(data.description));\n  errors.push(...validateSkillLicense(data.license));\n  errors.push(...validateSkillCompatibility(data.compatibility));\n  errors.push(...validateSkillMetadataField(data.metadata));\n\n  // Check directory name match (only if no name errors and name is valid)\n  if (dirName && typeof data.name === 'string' && data.name !== dirName) {\n    errors.push(`Skill name \"${data.name}\" must match directory name \"${dirName}\"`);\n  }\n\n  // Check instruction limits (warnings only)\n  if (instructions) {\n    const lineCount = countLines(instructions);\n    const tokenEstimate = estimateTokens(instructions);\n\n    if (lineCount > SKILL_LIMITS.MAX_INSTRUCTION_LINES) {\n      warnings.push(\n        `Instructions have ${lineCount} lines (recommended: <${SKILL_LIMITS.MAX_INSTRUCTION_LINES}). Consider moving content to references/.`,\n      );\n    }\n\n    if (tokenEstimate > SKILL_LIMITS.MAX_INSTRUCTION_TOKENS) {\n      warnings.push(\n        `Instructions have ~${tokenEstimate} estimated tokens (recommended: <${SKILL_LIMITS.MAX_INSTRUCTION_TOKENS}). Consider moving content to references/.`,\n      );\n    }\n  }\n\n  return {\n    valid: errors.length === 0,\n    errors,\n    warnings,\n  };\n}\n","/**\n * LocalSkillSource - Read-only skill source backed by local filesystem.\n *\n * Uses Node.js fs/promises to read skills directly from disk.\n * This allows skills to be loaded without requiring a full WorkspaceFilesystem.\n *\n * @example\n * ```typescript\n * const source = new LocalSkillSource({\n *   basePath: process.cwd(),\n * });\n *\n * // skills paths are relative to basePath\n * const skillsImpl = new WorkspaceSkillsImpl({\n *   source,\n *   skills: ['./skills', './node_modules/@company/skills'],\n * });\n * ```\n */\n\nimport * as fs from 'node:fs/promises';\nimport * as path from 'node:path';\n\nimport { fsExists, fsStat, isTextFile } from '../filesystem';\nimport type { SkillSource, SkillSourceEntry, SkillSourceStat } from './skill-source';\n\n/**\n * Configuration for LocalSkillSource.\n */\nexport interface LocalSkillSourceOptions {\n  /**\n   * Base path for resolving relative skill paths.\n   * Defaults to process.cwd().\n   */\n  basePath?: string;\n}\n\n/**\n * Read-only skill source that loads skills from the local filesystem.\n *\n * Unlike WorkspaceFilesystem, this doesn't provide write operations.\n * Skills loaded from this source are read-only.\n */\nexport class LocalSkillSource implements SkillSource {\n  readonly #basePath: string;\n\n  constructor(options: LocalSkillSourceOptions = {}) {\n    this.#basePath = options.basePath ?? process.cwd();\n  }\n\n  /**\n   * Resolve a path relative to the base path.\n   * Handles both absolute and relative paths.\n   */\n  #resolvePath(skillPath: string): string {\n    if (path.isAbsolute(skillPath)) {\n      return skillPath;\n    }\n    return path.resolve(this.#basePath, skillPath);\n  }\n\n  async exists(skillPath: string): Promise<boolean> {\n    return fsExists(this.#resolvePath(skillPath));\n  }\n\n  async stat(skillPath: string): Promise<SkillSourceStat> {\n    return fsStat(this.#resolvePath(skillPath), skillPath);\n  }\n\n  async readFile(skillPath: string): Promise<string | Buffer> {\n    const resolved = this.#resolvePath(skillPath);\n    const content = await fs.readFile(resolved);\n    // Convert to string for text files\n    if (isTextFile(skillPath)) {\n      return content.toString('utf-8');\n    }\n    return content;\n  }\n\n  async readdir(skillPath: string): Promise<SkillSourceEntry[]> {\n    const resolved = this.#resolvePath(skillPath);\n    const entries = await fs.readdir(resolved, { withFileTypes: true });\n    return entries.map(entry => ({\n      name: entry.name,\n      type: entry.isDirectory() ? 'directory' : 'file',\n    }));\n  }\n}\n","/**\n * WorkspaceSkills - Skills implementation.\n *\n * Provides discovery and search operations for skills stored\n * in skills paths. All operations are async.\n */\n\nimport matter from 'gray-matter';\n\nimport type { IndexDocument, SearchResult } from '../search';\nimport { validateSkillMetadata } from './schemas';\nimport type { SkillSource as SkillSourceInterface } from './skill-source';\nimport type {\n  ContentSource,\n  Skill,\n  SkillMetadata,\n  SkillSearchResult,\n  SkillSearchOptions,\n  WorkspaceSkills,\n  SkillsResolver,\n  SkillsContext,\n} from './types';\n\n// =============================================================================\n// Internal Types\n// =============================================================================\n\n/**\n * Minimal search engine interface - only the methods we actually use.\n * This allows both the real SearchEngine and test mocks to be used.\n */\ninterface SkillSearchEngine {\n  index(doc: IndexDocument): Promise<void>;\n  search(\n    query: string,\n    options?: { topK?: number; minScore?: number; mode?: 'bm25' | 'vector' | 'hybrid' },\n  ): Promise<SearchResult[]>;\n  clear(): void;\n}\n\ninterface InternalSkill extends Skill {\n  /** Content for BM25 indexing (instructions + all references) */\n  indexableContent: string;\n}\n\n// =============================================================================\n// WorkspaceSkillsImpl\n// =============================================================================\n\n/**\n * Configuration for WorkspaceSkillsImpl\n */\nexport interface WorkspaceSkillsImplConfig {\n  /**\n   * Source for loading skills.\n   */\n  source: SkillSourceInterface;\n  /**\n   * Paths to scan for skills.\n   * Can be a static array or a function that returns paths based on context.\n   */\n  skills: SkillsResolver;\n  /** Search engine for skill search (optional) */\n  searchEngine?: SkillSearchEngine;\n  /** Validate skills on load (default: true) */\n  validateOnLoad?: boolean;\n}\n\n/**\n * Implementation of WorkspaceSkills interface.\n */\nexport class WorkspaceSkillsImpl implements WorkspaceSkills {\n  readonly #source: SkillSourceInterface;\n  readonly #skillsResolver: SkillsResolver;\n  readonly #searchEngine?: SkillSearchEngine;\n  readonly #validateOnLoad: boolean;\n\n  /** Map of skill name -> full skill data */\n  #skills: Map<string, InternalSkill> = new Map();\n\n  /** Whether skills have been discovered */\n  #initialized = false;\n\n  /** Promise for ongoing initialization (prevents concurrent discovery) */\n  #initPromise: Promise<void> | null = null;\n\n  /** Timestamp of last skills discovery (for staleness check) */\n  #lastDiscoveryTime = 0;\n\n  /** Currently resolved skills paths (used to detect changes) */\n  #resolvedPaths: string[] = [];\n\n  constructor(config: WorkspaceSkillsImplConfig) {\n    this.#source = config.source;\n    this.#skillsResolver = config.skills;\n    this.#searchEngine = config.searchEngine;\n    this.#validateOnLoad = config.validateOnLoad ?? true;\n  }\n\n  // ===========================================================================\n  // Discovery\n  // ===========================================================================\n\n  async list(): Promise<SkillMetadata[]> {\n    await this.#ensureInitialized();\n    return Array.from(this.#skills.values()).map(skill => ({\n      name: skill.name,\n      description: skill.description,\n      license: skill.license,\n      compatibility: skill.compatibility,\n      metadata: skill.metadata,\n    }));\n  }\n\n  async get(name: string): Promise<Skill | null> {\n    await this.#ensureInitialized();\n    const skill = this.#skills.get(name);\n    if (!skill) return null;\n\n    // Return without internal indexableContent field\n    const { indexableContent: _, ...skillData } = skill;\n    return skillData;\n  }\n\n  async has(name: string): Promise<boolean> {\n    await this.#ensureInitialized();\n    return this.#skills.has(name);\n  }\n\n  async refresh(): Promise<void> {\n    this.#skills.clear();\n    this.#searchEngine?.clear();\n    this.#initialized = false;\n    this.#initPromise = null;\n    await this.#discoverSkills();\n    this.#initialized = true;\n  }\n\n  async maybeRefresh(context?: SkillsContext): Promise<void> {\n    // Ensure initial discovery is complete\n    await this.#ensureInitialized();\n\n    // Resolve current paths (may be dynamic based on context)\n    const currentPaths = await this.#resolvePaths(context);\n\n    // Check if paths have changed (for dynamic resolvers)\n    const pathsChanged = !this.#arePathsEqual(this.#resolvedPaths, currentPaths);\n    if (pathsChanged) {\n      // Paths changed - need full refresh with new paths\n      this.#resolvedPaths = currentPaths;\n      await this.refresh();\n      return;\n    }\n\n    // Check if any skills path has been modified since last discovery\n    const isStale = await this.#isSkillsPathStale();\n    if (isStale) {\n      await this.refresh();\n    }\n  }\n\n  /**\n   * Resolve skills paths from the resolver (static array or function).\n   */\n  async #resolvePaths(context?: SkillsContext): Promise<string[]> {\n    if (Array.isArray(this.#skillsResolver)) {\n      return this.#skillsResolver;\n    }\n    return this.#skillsResolver(context ?? {});\n  }\n\n  /**\n   * Compare two path arrays for equality (order-independent).\n   */\n  #arePathsEqual(a: string[], b: string[]): boolean {\n    if (a.length !== b.length) return false;\n    const sortedA = [...a].sort();\n    const sortedB = [...b].sort();\n    return sortedA.every((path, i) => path === sortedB[i]);\n  }\n\n  // ===========================================================================\n  // Search\n  // ===========================================================================\n\n  async search(query: string, options: SkillSearchOptions = {}): Promise<SkillSearchResult[]> {\n    await this.#ensureInitialized();\n\n    if (!this.#searchEngine) {\n      // Fall back to simple text matching if no search engine\n      return this.#simpleSearch(query, options);\n    }\n\n    const { topK = 5, minScore, skillNames, includeReferences = true, mode } = options;\n\n    // Get more results than needed to filter by skillNames/includeReferences\n    const expandedTopK = skillNames ? topK * 3 : topK;\n\n    // Delegate to SearchEngine\n    const searchResults = await this.#searchEngine.search(query, {\n      topK: expandedTopK,\n      minScore,\n      mode,\n    });\n\n    const results: SkillSearchResult[] = [];\n\n    for (const result of searchResults) {\n      const skillName = result.metadata?.skillName as string;\n      const source = result.metadata?.source as string;\n\n      if (!skillName || !source) continue;\n\n      // Filter by skill names if specified\n      if (skillNames && !skillNames.includes(skillName)) {\n        continue;\n      }\n\n      // Filter out references if not included\n      if (!includeReferences && source !== 'SKILL.md') {\n        continue;\n      }\n\n      results.push({\n        skillName,\n        source,\n        content: result.content,\n        score: result.score,\n        lineRange: result.lineRange,\n        scoreDetails: result.scoreDetails,\n      });\n\n      if (results.length >= topK) break;\n    }\n\n    return results;\n  }\n\n  // ===========================================================================\n  // Single-item Accessors\n  // ===========================================================================\n\n  async getReference(skillName: string, referencePath: string): Promise<string | null> {\n    await this.#ensureInitialized();\n\n    const skill = this.#skills.get(skillName);\n    if (!skill) return null;\n\n    const safeRefPath = this.#assertRelativePath(referencePath, 'reference');\n    const refFilePath = this.#joinPath(skill.path, 'references', safeRefPath);\n\n    if (!(await this.#source.exists(refFilePath))) {\n      return null;\n    }\n\n    try {\n      const content = await this.#source.readFile(refFilePath);\n      return typeof content === 'string' ? content : content.toString('utf-8');\n    } catch {\n      return null;\n    }\n  }\n\n  async getScript(skillName: string, scriptPath: string): Promise<string | null> {\n    await this.#ensureInitialized();\n\n    const skill = this.#skills.get(skillName);\n    if (!skill) return null;\n\n    const safeScriptPath = this.#assertRelativePath(scriptPath, 'script');\n    const scriptFilePath = this.#joinPath(skill.path, 'scripts', safeScriptPath);\n\n    if (!(await this.#source.exists(scriptFilePath))) {\n      return null;\n    }\n\n    try {\n      const content = await this.#source.readFile(scriptFilePath);\n      return typeof content === 'string' ? content : content.toString('utf-8');\n    } catch {\n      return null;\n    }\n  }\n\n  async getAsset(skillName: string, assetPath: string): Promise<Buffer | null> {\n    await this.#ensureInitialized();\n\n    const skill = this.#skills.get(skillName);\n    if (!skill) return null;\n\n    const safeAssetPath = this.#assertRelativePath(assetPath, 'asset');\n    const assetFilePath = this.#joinPath(skill.path, 'assets', safeAssetPath);\n\n    if (!(await this.#source.exists(assetFilePath))) {\n      return null;\n    }\n\n    try {\n      const content = await this.#source.readFile(assetFilePath);\n      return typeof content === 'string' ? Buffer.from(content, 'utf-8') : content;\n    } catch {\n      return null;\n    }\n  }\n\n  // ===========================================================================\n  // Listing Accessors\n  // ===========================================================================\n\n  async listReferences(skillName: string): Promise<string[]> {\n    await this.#ensureInitialized();\n    const skill = this.#skills.get(skillName);\n    return skill?.references ?? [];\n  }\n\n  async listScripts(skillName: string): Promise<string[]> {\n    await this.#ensureInitialized();\n    const skill = this.#skills.get(skillName);\n    return skill?.scripts ?? [];\n  }\n\n  async listAssets(skillName: string): Promise<string[]> {\n    await this.#ensureInitialized();\n    const skill = this.#skills.get(skillName);\n    return skill?.assets ?? [];\n  }\n\n  // ===========================================================================\n  // Private Methods\n  // ===========================================================================\n\n  /**\n   * Ensure skills have been discovered.\n   * Uses a promise to prevent concurrent discovery.\n   */\n  async #ensureInitialized(): Promise<void> {\n    if (this.#initialized) {\n      return;\n    }\n\n    // If initialization is already in progress, wait for it\n    if (this.#initPromise) {\n      await this.#initPromise;\n      return;\n    }\n\n    // Start initialization and store the promise\n    this.#initPromise = (async () => {\n      try {\n        // Resolve paths on first initialization (uses empty context)\n        if (this.#resolvedPaths.length === 0) {\n          this.#resolvedPaths = await this.#resolvePaths();\n        }\n        await this.#discoverSkills();\n        this.#initialized = true;\n      } finally {\n        this.#initPromise = null;\n      }\n    })();\n\n    await this.#initPromise;\n  }\n\n  /**\n   * Discover skills from all skills paths.\n   * Uses currently resolved paths (must be set before calling).\n   */\n  async #discoverSkills(): Promise<void> {\n    for (const skillsPath of this.#resolvedPaths) {\n      const source = this.#determineSource(skillsPath);\n      await this.#discoverSkillsInPath(skillsPath, source);\n    }\n    // Track when discovery completed for staleness check\n    this.#lastDiscoveryTime = Date.now();\n  }\n\n  /**\n   * Discover skills in a single path\n   */\n  async #discoverSkillsInPath(skillsPath: string, source: ContentSource): Promise<void> {\n    if (!(await this.#source.exists(skillsPath))) {\n      return;\n    }\n\n    try {\n      const entries = await this.#source.readdir(skillsPath);\n\n      for (const entry of entries) {\n        if (entry.type !== 'directory') continue;\n\n        const entryPath = this.#joinPath(skillsPath, entry.name);\n        const skillFilePath = this.#joinPath(entryPath, 'SKILL.md');\n\n        if (await this.#source.exists(skillFilePath)) {\n          try {\n            const skill = await this.#parseSkillFile(skillFilePath, entry.name, source);\n\n            // Set skill (later discoveries overwrite earlier ones)\n            this.#skills.set(skill.name, skill);\n\n            // Index the skill content for search\n            await this.#indexSkill(skill);\n          } catch (error) {\n            if (error instanceof Error) {\n              console.error(`[WorkspaceSkills] Failed to load skill from ${skillFilePath}:`, error.message);\n            }\n          }\n        }\n      }\n    } catch (error) {\n      if (error instanceof Error) {\n        console.error(`[WorkspaceSkills] Failed to scan skills directory ${skillsPath}:`, error.message);\n      }\n    }\n  }\n\n  /**\n   * Check if any skills path directory has been modified since last discovery.\n   * Compares directory mtime to lastDiscoveryTime.\n   */\n  async #isSkillsPathStale(): Promise<boolean> {\n    if (this.#lastDiscoveryTime === 0) {\n      // Never discovered, consider stale\n      return true;\n    }\n\n    for (const skillsPath of this.#resolvedPaths) {\n      try {\n        const stat = await this.#source.stat(skillsPath);\n        const mtime = stat.modifiedAt.getTime();\n\n        if (mtime > this.#lastDiscoveryTime) {\n          return true;\n        }\n\n        // Also check subdirectories (skill directories) for changes\n        const entries = await this.#source.readdir(skillsPath);\n        for (const entry of entries) {\n          if (entry.type !== 'directory') continue;\n\n          const entryPath = this.#joinPath(skillsPath, entry.name);\n          try {\n            const entryStat = await this.#source.stat(entryPath);\n            if (entryStat.modifiedAt.getTime() > this.#lastDiscoveryTime) {\n              return true;\n            }\n          } catch {\n            // Couldn't stat entry, skip it\n          }\n        }\n      } catch {\n        // Couldn't stat skillsPath (doesn't exist or error), skip to next path\n        continue;\n      }\n    }\n\n    return false;\n  }\n\n  /**\n   * Parse a SKILL.md file\n   */\n  async #parseSkillFile(filePath: string, dirName: string, source: ContentSource): Promise<InternalSkill> {\n    const rawContent = await this.#source.readFile(filePath);\n    const content = typeof rawContent === 'string' ? rawContent : rawContent.toString('utf-8');\n\n    const parsed = matter(content);\n    const frontmatter = parsed.data;\n    const body = parsed.content.trim();\n\n    // Extract required fields\n    const metadata: SkillMetadata = {\n      name: frontmatter.name,\n      description: frontmatter.description,\n      license: frontmatter.license,\n      compatibility: frontmatter.compatibility,\n      metadata: frontmatter.metadata,\n    };\n\n    // Validate if enabled (includes token/line count warnings)\n    if (this.#validateOnLoad) {\n      const validation = this.#validateSkillMetadata(metadata, dirName, body);\n      if (!validation.valid) {\n        throw new Error(`Invalid skill metadata in ${filePath}:\\n${validation.errors.join('\\n')}`);\n      }\n    }\n\n    // Get skill directory path (parent of SKILL.md)\n    const skillPath = this.#getParentPath(filePath);\n\n    // Discover reference, script, and asset files\n    const references = await this.#discoverFilesInSubdir(skillPath, 'references');\n    const scripts = await this.#discoverFilesInSubdir(skillPath, 'scripts');\n    const assets = await this.#discoverFilesInSubdir(skillPath, 'assets');\n\n    // Build indexable content (instructions + references)\n    const indexableContent = await this.#buildIndexableContent(body, skillPath, references);\n\n    return {\n      ...metadata,\n      path: skillPath,\n      instructions: body,\n      source,\n      references,\n      scripts,\n      assets,\n      indexableContent,\n    };\n  }\n\n  /**\n   * Validate skill metadata (delegates to shared validation function)\n   */\n  #validateSkillMetadata(\n    metadata: SkillMetadata,\n    dirName: string,\n    instructions?: string,\n  ): { valid: boolean; errors: string[]; warnings: string[] } {\n    const result = validateSkillMetadata(metadata, dirName, instructions);\n\n    // Log warnings if any\n    if (result.warnings.length > 0) {\n      for (const warning of result.warnings) {\n        console.warn(`[WorkspaceSkills] ${metadata.name}: ${warning}`);\n      }\n    }\n\n    return result;\n  }\n\n  /**\n   * Discover files in a subdirectory of a skill (references/, scripts/, assets/)\n   */\n  async #discoverFilesInSubdir(skillPath: string, subdir: 'references' | 'scripts' | 'assets'): Promise<string[]> {\n    const subdirPath = this.#joinPath(skillPath, subdir);\n    const files: string[] = [];\n\n    if (!(await this.#source.exists(subdirPath))) {\n      return files;\n    }\n\n    try {\n      await this.#walkDirectory(subdirPath, subdirPath, (relativePath: string) => {\n        files.push(relativePath);\n      });\n    } catch {\n      // Failed to read subdirectory\n    }\n\n    return files;\n  }\n\n  /**\n   * Walk a directory recursively and call callback for each file.\n   * Limited to maxDepth (default 20) to prevent stack overflow on deep hierarchies.\n   */\n  async #walkDirectory(\n    basePath: string,\n    dirPath: string,\n    callback: (relativePath: string) => void,\n    depth: number = 0,\n    maxDepth: number = 20,\n  ): Promise<void> {\n    if (depth >= maxDepth) {\n      return;\n    }\n\n    const entries = await this.#source.readdir(dirPath);\n\n    for (const entry of entries) {\n      const entryPath = this.#joinPath(dirPath, entry.name);\n\n      if (entry.type === 'directory') {\n        await this.#walkDirectory(basePath, entryPath, callback, depth + 1, maxDepth);\n      } else {\n        // Get relative path from base\n        const relativePath = entryPath.substring(basePath.length + 1);\n        callback(relativePath);\n      }\n    }\n  }\n\n  /**\n   * Build indexable content from instructions and references\n   */\n  async #buildIndexableContent(instructions: string, skillPath: string, references: string[]): Promise<string> {\n    const parts = [instructions];\n\n    for (const refPath of references) {\n      const fullPath = this.#joinPath(skillPath, 'references', refPath);\n      try {\n        const rawContent = await this.#source.readFile(fullPath);\n        const content = typeof rawContent === 'string' ? rawContent : rawContent.toString('utf-8');\n        parts.push(content);\n      } catch {\n        // Skip files that can't be read\n      }\n    }\n\n    return parts.join('\\n\\n');\n  }\n\n  /**\n   * Index a skill for search\n   */\n  async #indexSkill(skill: InternalSkill): Promise<void> {\n    if (!this.#searchEngine) return;\n\n    // Index the main skill instructions\n    await this.#searchEngine.index({\n      id: `skill:${skill.name}:SKILL.md`,\n      content: skill.instructions,\n      metadata: {\n        skillName: skill.name,\n        source: 'SKILL.md',\n      },\n    });\n\n    // Index each reference file separately\n    for (const refPath of skill.references) {\n      const fullPath = this.#joinPath(skill.path, 'references', refPath);\n      try {\n        const rawContent = await this.#source.readFile(fullPath);\n        const content = typeof rawContent === 'string' ? rawContent : rawContent.toString('utf-8');\n        await this.#searchEngine.index({\n          id: `skill:${skill.name}:${refPath}`,\n          content,\n          metadata: {\n            skillName: skill.name,\n            source: `references/${refPath}`,\n          },\n        });\n      } catch {\n        // Skip files that can't be read\n      }\n    }\n  }\n\n  /**\n   * Simple text search fallback when no search engine is configured\n   */\n  async #simpleSearch(query: string, options: SkillSearchOptions): Promise<SkillSearchResult[]> {\n    const { topK = 5, skillNames, includeReferences = true } = options;\n    const queryLower = query.toLowerCase();\n    const results: SkillSearchResult[] = [];\n\n    for (const skill of this.#skills.values()) {\n      // Filter by skill names if specified\n      if (skillNames && !skillNames.includes(skill.name)) {\n        continue;\n      }\n\n      // Search in instructions\n      if (skill.instructions.toLowerCase().includes(queryLower)) {\n        results.push({\n          skillName: skill.name,\n          source: 'SKILL.md',\n          content: skill.instructions.substring(0, 200),\n          score: 1,\n        });\n      }\n\n      // Search in references if included\n      if (includeReferences) {\n        for (const refPath of skill.references) {\n          if (results.length >= topK) break;\n          const content = await this.getReference(skill.name, refPath);\n          if (content && content.toLowerCase().includes(queryLower)) {\n            results.push({\n              skillName: skill.name,\n              source: `references/${refPath}`,\n              content: content.substring(0, 200),\n              score: 0.8,\n            });\n          }\n        }\n      }\n\n      if (results.length >= topK) break;\n    }\n\n    return results.slice(0, topK);\n  }\n\n  /**\n   * Determine the source type based on the path\n   */\n  #determineSource(skillsPath: string): ContentSource {\n    // Use path segment matching to avoid false positives (e.g., my-node_modules)\n    const segments = skillsPath.split('/');\n    if (segments.includes('node_modules')) {\n      return { type: 'external', packagePath: skillsPath };\n    }\n    if (skillsPath.includes('/.mastra/skills') || skillsPath.startsWith('.mastra/skills')) {\n      return { type: 'managed', mastraPath: skillsPath };\n    }\n    return { type: 'local', projectPath: skillsPath };\n  }\n\n  /**\n   * Join path segments (workspace paths use forward slashes)\n   */\n  #joinPath(...segments: string[]): string {\n    return segments\n      .map((seg, i) => {\n        if (i === 0) return seg.replace(/\\/+$/, '');\n        return seg.replace(/^\\/+|\\/+$/g, '');\n      })\n      .filter(Boolean)\n      .join('/');\n  }\n\n  /**\n   * Validate and normalize a relative path to prevent directory traversal.\n   * Throws if the path contains traversal segments (..) or is absolute.\n   */\n  #assertRelativePath(input: string, label: string): string {\n    const normalized = input.replace(/\\\\/g, '/');\n    const segments = normalized.split('/').filter(Boolean);\n    if (normalized.startsWith('/') || segments.some(seg => seg === '.' || seg === '..')) {\n      throw new Error(`Invalid ${label} path: ${input}`);\n    }\n    return segments.join('/');\n  }\n\n  /**\n   * Get parent path\n   */\n  #getParentPath(path: string): string {\n    const lastSlash = path.lastIndexOf('/');\n    return lastSlash > 0 ? path.substring(0, lastSlash) : '/';\n  }\n}\n","/**\n * Workspace Class\n *\n * A Workspace combines a Filesystem and a Sandbox to provide agents\n * with a complete environment for storing files and executing code.\n *\n * Users pass provider instances directly to the Workspace constructor.\n *\n * @example\n * ```typescript\n * import { Workspace } from '@mastra/core';\n * import { LocalFilesystem } from '@mastra/workspace-fs-local';\n * import { AgentFS } from '@mastra/workspace-fs-agentfs';\n * import { ComputeSDKSandbox } from '@mastra/workspace-sandbox-computesdk';\n *\n * // Simple workspace with local filesystem\n * const workspace = new Workspace({\n *   filesystem: new LocalFilesystem({ basePath: './workspace' }),\n * });\n *\n * // Full workspace with AgentFS and cloud sandbox\n * const fullWorkspace = new Workspace({\n *   filesystem: new AgentFS({ path: './agent.db' }),\n *   sandbox: new ComputeSDKSandbox({ provider: 'e2b' }),\n * });\n *\n * await fullWorkspace.init();\n * await fullWorkspace.filesystem?.writeFile('/code/app.py', 'print(\"Hello!\")');\n * const result = await fullWorkspace.sandbox?.executeCommand?.('python3', ['app.py'], { cwd: '/code' });\n * ```\n */\n\nimport type { IMastraLogger } from '../logger';\nimport type { MastraVector } from '../vector';\n\nimport { WorkspaceError, SearchNotAvailableError } from './errors';\nimport { CompositeFilesystem } from './filesystem';\nimport type { WorkspaceFilesystem, FilesystemInfo } from './filesystem';\nimport { MastraFilesystem } from './filesystem/mastra-filesystem';\nimport { callLifecycle } from './lifecycle';\nimport type { WorkspaceSandbox, OnMountHook } from './sandbox';\nimport { MastraSandbox } from './sandbox/mastra-sandbox';\nimport { SearchEngine } from './search';\nimport type { BM25Config, Embedder, SearchOptions, SearchResult, IndexDocument } from './search';\nimport type { WorkspaceSkills, SkillsResolver } from './skills';\nimport { WorkspaceSkillsImpl, LocalSkillSource } from './skills';\nimport type { WorkspaceToolsConfig } from './tools';\nimport type { WorkspaceStatus } from './types';\n\n// =============================================================================\n// Workspace Configuration\n// =============================================================================\n\n/**\n * Configuration for creating a Workspace.\n * Users pass provider instances directly.\n */\nexport interface WorkspaceConfig {\n  /** Unique identifier (auto-generated if not provided) */\n  id?: string;\n\n  /** Human-readable name */\n  name?: string;\n\n  /**\n   * Filesystem provider instance.\n   * Use LocalFilesystem for a folder on disk, or AgentFS for Turso-backed storage.\n   * Extend MastraFilesystem for automatic logger integration.\n   */\n  filesystem?: WorkspaceFilesystem;\n\n  /**\n   * Sandbox provider instance.\n   * Use ComputeSDKSandbox to access E2B, Modal, Docker, etc.\n   * Extend MastraSandbox for automatic logger integration.\n   */\n  sandbox?: WorkspaceSandbox;\n\n  /**\n   * Mount multiple filesystems at different paths.\n   * Creates a CompositeFilesystem that routes operations based on path.\n   *\n   * When a sandbox is configured, filesystems are automatically mounted\n   * into the sandbox at their respective paths during init().\n   *\n   * Use the `onMount` hook to skip or customize mounting for specific filesystems.\n   *\n   * @example\n   * ```typescript\n   * const workspace = new Workspace({\n   *   sandbox: new E2BSandbox({ timeout: 60000 }),\n   *   mounts: {\n   *     '/data': new S3Filesystem({ bucket: 'my-data', ... }),\n   *     '/skills': new S3Filesystem({ bucket: 'skills', readOnly: true, ... }),\n   *   },\n   * });\n   *\n   * await workspace.init();\n   * // Both filesystems mounted in sandbox at /data and /skills\n   * ```\n   */\n  mounts?: Record<string, WorkspaceFilesystem>;\n\n  /**\n   * Hook called before mounting each filesystem into the sandbox.\n   *\n   * Return values:\n   * - `false` - Skip mount entirely (don't mount this filesystem)\n   * - `{ success: true }` - Hook handled the mount successfully\n   * - `{ success: false, error?: string }` - Hook attempted mount but failed\n   * - `undefined` / no return - Use provider's default mount behavior\n   *\n   * This is useful for:\n   * - Skipping specific filesystems (e.g., local filesystems in remote sandbox)\n   * - Custom mount implementations\n   * - Syncing files instead of FUSE mounting\n   *\n   * Note: If your hook handles the mount, you're responsible for the entire\n   * implementation. The sandbox provider won't do any additional tracking.\n   *\n   * @example Skip local filesystems\n   * ```typescript\n   * const workspace = new Workspace({\n   *   sandbox: new E2BSandbox(),\n   *   mounts: {\n   *     '/data': new S3Filesystem({ bucket: 'data', ... }),\n   *     '/local': new LocalFilesystem({ basePath: './data' }),\n   *   },\n   *   onMount: ({ filesystem }) => {\n   *     if (filesystem.provider === 'local') return false;\n   *   },\n   * });\n   * ```\n   *\n   * @example Custom mount implementation\n   * ```typescript\n   * onMount: async ({ filesystem, mountPath, config, sandbox }) => {\n   *   if (config?.type === 's3') {\n   *     await sandbox.executeCommand?.('my-s3-mount', [mountPath]);\n   *     return { success: true };\n   *   }\n   * }\n   * ```\n   */\n  onMount?: OnMountHook;\n\n  // ---------------------------------------------------------------------------\n  // Search Configuration\n  // ---------------------------------------------------------------------------\n\n  /**\n   * Vector store for semantic search.\n   * When provided along with embedder, enables vector and hybrid search.\n   */\n  vectorStore?: MastraVector;\n\n  /**\n   * Embedder function for generating vectors.\n   * Required when vectorStore is provided.\n   */\n  embedder?: Embedder;\n\n  /**\n   * Enable BM25 keyword search.\n   * Pass true for defaults, or a BM25Config object for custom parameters.\n   */\n  bm25?: boolean | BM25Config;\n\n  /**\n   * Custom index name for the vector store.\n   * If not provided, defaults to a sanitized version of `${id}_search`.\n   *\n   * Must be a valid SQL identifier for SQL-based stores (PgVector, LibSQL):\n   * - Start with a letter or underscore\n   * - Contain only letters, numbers, or underscores\n   * - Maximum 63 characters\n   *\n   * @example 'my_workspace_vectors'\n   */\n  searchIndexName?: string;\n\n  /**\n   * Paths to auto-index on init().\n   * Files in these directories will be indexed for search.\n   * @example ['/docs', '/support']\n   */\n  autoIndexPaths?: string[];\n\n  /**\n   * Paths where skills are located.\n   * Workspace will discover SKILL.md files in these directories.\n   *\n   * Can be a static array of paths or a function that returns paths\n   * dynamically based on request context (e.g., user tier, tenant).\n   *\n   * @example Static paths\n   * ```typescript\n   * skills: ['/skills', '/node_modules/@myorg/skills']\n   * ```\n   *\n   * @example Dynamic paths\n   * ```typescript\n   * skills: (ctx) => {\n   *   const tier = ctx.requestContext?.get('userTier');\n   *   return tier === 'premium'\n   *     ? ['/skills/basic', '/skills/premium']\n   *     : ['/skills/basic'];\n   * }\n   * ```\n   */\n  skills?: SkillsResolver;\n\n  // ---------------------------------------------------------------------------\n  // Tool Configuration\n  // ---------------------------------------------------------------------------\n\n  /**\n   * Per-tool configuration for workspace tools.\n   * Controls which tools are enabled and their safety settings.\n   *\n   * This replaces the provider-level `requireApproval` and `requireReadBeforeWrite`\n   * settings, allowing more granular control per tool.\n   *\n   * @example\n   * ```typescript\n   * tools: {\n   *   mastra_workspace_read_file: {\n   *     enabled: true,\n   *     requireApproval: false,\n   *   },\n   *   mastra_workspace_write_file: {\n   *     enabled: true,\n   *     requireApproval: true,\n   *     requireReadBeforeWrite: true,\n   *   },\n   *   mastra_workspace_execute_command: {\n   *     enabled: true,\n   *     requireApproval: true,\n   *   },\n   * }\n   * ```\n   */\n  tools?: WorkspaceToolsConfig;\n\n  // ---------------------------------------------------------------------------\n  // Lifecycle Options\n  // ---------------------------------------------------------------------------\n\n  /** Auto-sync between fs and sandbox (default: false) */\n  autoSync?: boolean;\n\n  /** Timeout for individual operations in milliseconds */\n  operationTimeout?: number;\n}\n\n// Re-export WorkspaceStatus from types\nexport type { WorkspaceStatus } from './types';\n\n// =============================================================================\n// Path Context Types\n// =============================================================================\n\n/**\n * Information about how filesystem and sandbox paths relate.\n * Used by agents to understand how to access workspace files from sandbox code.\n */\nexport interface PathContext {\n  /** Filesystem details (if available) */\n  filesystem?: {\n    provider: string;\n    /** Absolute base path on disk (for local filesystems) */\n    basePath?: string;\n  };\n\n  /** Sandbox details (if available) */\n  sandbox?: {\n    provider: string;\n    /** Working directory for command execution */\n    workingDirectory?: string;\n  };\n\n  /**\n   * Human-readable instructions for how to access filesystem files from sandbox code.\n   * Combined from filesystem and sandbox provider instructions.\n   */\n  instructions: string;\n}\n\nexport interface WorkspaceInfo {\n  id: string;\n  name: string;\n  status: WorkspaceStatus;\n  createdAt: Date;\n  lastAccessedAt: Date;\n\n  /** Filesystem info (if available) */\n  filesystem?: FilesystemInfo & {\n    totalFiles?: number;\n    totalSize?: number;\n  };\n\n  /** Sandbox info (if available) */\n  sandbox?: {\n    provider: string;\n    status: string;\n    resources?: {\n      memoryMB?: number;\n      memoryUsedMB?: number;\n      cpuCores?: number;\n      cpuPercent?: number;\n      diskMB?: number;\n      diskUsedMB?: number;\n    };\n  };\n}\n\n// =============================================================================\n// Workspace Class\n// =============================================================================\n\n/**\n * Workspace provides agents with filesystem and execution capabilities.\n *\n * At minimum, a workspace has either a filesystem or a sandbox (or both).\n * Users pass instantiated provider objects to the constructor.\n */\nexport class Workspace {\n  readonly id: string;\n  readonly name: string;\n  readonly createdAt: Date;\n  lastAccessedAt: Date;\n\n  private _status: WorkspaceStatus = 'pending';\n  private readonly _fs?: WorkspaceFilesystem;\n  private readonly _sandbox?: WorkspaceSandbox;\n  private readonly _config: WorkspaceConfig;\n  private readonly _searchEngine?: SearchEngine;\n  private _skills?: WorkspaceSkills;\n\n  constructor(config: WorkspaceConfig) {\n    this.id = config.id ?? this.generateId();\n    this.name = config.name ?? `workspace-${this.id.slice(0, 8)}`;\n    this.createdAt = new Date();\n    this.lastAccessedAt = new Date();\n\n    this._config = config;\n    this._sandbox = config.sandbox;\n\n    // Setup mounts - creates CompositeFilesystem and informs sandbox\n    if (config.mounts && Object.keys(config.mounts).length > 0) {\n      // Validate: can't use both filesystem and mounts\n      if (config.filesystem) {\n        throw new WorkspaceError('Cannot use both \"filesystem\" and \"mounts\"', 'INVALID_CONFIG');\n      }\n\n      this._fs = new CompositeFilesystem({ mounts: config.mounts });\n      if (this._sandbox?.mounts) {\n        // Inform sandbox about mounts so it can process them on start()\n        this._sandbox.mounts.setContext({ sandbox: this._sandbox, workspace: this });\n        this._sandbox.mounts.add(config.mounts);\n        if (config.onMount) {\n          this._sandbox.mounts.setOnMount(config.onMount);\n        }\n      }\n    } else {\n      this._fs = config.filesystem;\n    }\n\n    // Validate vector search config - embedder is required with vectorStore\n    if (config.vectorStore && !config.embedder) {\n      throw new WorkspaceError('vectorStore requires an embedder', 'INVALID_SEARCH_CONFIG');\n    }\n\n    // Create search engine if search is configured\n    if (config.bm25 || (config.vectorStore && config.embedder)) {\n      const buildIndexName = (): string => {\n        // Sanitize default name: replace all non-alphanumeric chars with underscores\n        const defaultName = `${this.id}_search`.replace(/[^a-zA-Z0-9_]/g, '_');\n        const indexName = config.searchIndexName ?? defaultName;\n\n        // Validate SQL identifier format\n        if (!/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(indexName)) {\n          throw new WorkspaceError(\n            `Invalid searchIndexName: \"${indexName}\". Must start with a letter or underscore, and contain only letters, numbers, or underscores.`,\n            'INVALID_SEARCH_CONFIG',\n            this.id,\n          );\n        }\n        if (indexName.length > 63) {\n          throw new WorkspaceError(\n            `searchIndexName exceeds 63 characters (got ${indexName.length})`,\n            'INVALID_SEARCH_CONFIG',\n            this.id,\n          );\n        }\n        return indexName;\n      };\n\n      this._searchEngine = new SearchEngine({\n        bm25: config.bm25\n          ? {\n              bm25: typeof config.bm25 === 'object' ? config.bm25 : undefined,\n            }\n          : undefined,\n        vector:\n          config.vectorStore && config.embedder\n            ? {\n                vectorStore: config.vectorStore,\n                embedder: config.embedder,\n                indexName: buildIndexName(),\n              }\n            : undefined,\n      });\n    }\n\n    // Validate at least one provider is given\n    // Note: skills alone is also valid - uses LocalSkillSource for read-only skills\n    if (!this._fs && !this._sandbox && !this.hasSkillsConfig()) {\n      throw new WorkspaceError('Workspace requires at least a filesystem, sandbox, or skills', 'NO_PROVIDERS');\n    }\n  }\n\n  private generateId(): string {\n    return `ws-${Date.now().toString(36)}-${Math.random().toString(36).slice(2, 8)}`;\n  }\n\n  private hasSkillsConfig(): boolean {\n    return (\n      this._config.skills !== undefined && (typeof this._config.skills === 'function' || this._config.skills.length > 0)\n    );\n  }\n\n  get status(): WorkspaceStatus {\n    return this._status;\n  }\n\n  /**\n   * The filesystem provider (if configured).\n   */\n  get filesystem(): WorkspaceFilesystem | undefined {\n    return this._fs;\n  }\n\n  /**\n   * The sandbox provider (if configured).\n   */\n  get sandbox(): WorkspaceSandbox | undefined {\n    return this._sandbox;\n  }\n\n  /**\n   * Get the per-tool configuration for this workspace.\n   * Returns undefined if no tools config was provided.\n   */\n  getToolsConfig(): WorkspaceToolsConfig | undefined {\n    return this._config.tools;\n  }\n\n  /**\n   * Access skills stored in this workspace.\n   * Skills are SKILL.md files discovered from the configured skillPaths.\n   *\n   * Returns undefined if no skillPaths are configured.\n   *\n   * @example\n   * ```typescript\n   * const skills = await workspace.skills?.list();\n   * const skill = await workspace.skills?.get('brand-guidelines');\n   * const results = await workspace.skills?.search('brand colors');\n   * ```\n   */\n  get skills(): WorkspaceSkills | undefined {\n    // Skills require skills config\n    if (!this.hasSkillsConfig()) {\n      return undefined;\n    }\n\n    // Lazy initialization\n    if (!this._skills) {\n      // Use filesystem if available, otherwise use LocalSkillSource (read-only from local disk)\n      const source = this._fs ?? new LocalSkillSource();\n\n      this._skills = new WorkspaceSkillsImpl({\n        source,\n        skills: this._config.skills!,\n        searchEngine: this._searchEngine,\n        validateOnLoad: true,\n      });\n    }\n\n    return this._skills;\n  }\n\n  // ---------------------------------------------------------------------------\n  // Search Capabilities\n  // ---------------------------------------------------------------------------\n\n  /**\n   * Check if BM25 keyword search is available.\n   */\n  get canBM25(): boolean {\n    return this._searchEngine?.canBM25 ?? false;\n  }\n\n  /**\n   * Check if vector semantic search is available.\n   */\n  get canVector(): boolean {\n    return this._searchEngine?.canVector ?? false;\n  }\n\n  /**\n   * Check if hybrid search is available.\n   */\n  get canHybrid(): boolean {\n    return this._searchEngine?.canHybrid ?? false;\n  }\n\n  // ---------------------------------------------------------------------------\n  // Search Operations\n  // ---------------------------------------------------------------------------\n\n  /**\n   * Index content for search.\n   * The path becomes the document ID in search results.\n   *\n   * @param path - File path (used as document ID)\n   * @param content - Text content to index\n   * @param options - Index options (metadata, type hints)\n   * @throws {SearchNotAvailableError} if search is not configured\n   */\n  async index(\n    path: string,\n    content: string,\n    options?: {\n      type?: 'text' | 'image' | 'file';\n      mimeType?: string;\n      metadata?: Record<string, unknown>;\n      startLineOffset?: number;\n    },\n  ): Promise<void> {\n    if (!this._searchEngine) {\n      throw new SearchNotAvailableError();\n    }\n    this.lastAccessedAt = new Date();\n\n    const doc: IndexDocument = {\n      id: path,\n      content,\n      metadata: {\n        type: options?.type,\n        mimeType: options?.mimeType,\n        ...options?.metadata,\n      },\n      startLineOffset: options?.startLineOffset,\n    };\n\n    await this._searchEngine.index(doc);\n  }\n\n  /**\n   * Search indexed content.\n   *\n   * @param query - Search query string\n   * @param options - Search options (topK, mode, filters)\n   * @returns Array of search results\n   * @throws {SearchNotAvailableError} if search is not configured\n   */\n  async search(query: string, options?: SearchOptions): Promise<SearchResult[]> {\n    if (!this._searchEngine) {\n      throw new SearchNotAvailableError();\n    }\n    this.lastAccessedAt = new Date();\n    return this._searchEngine.search(query, options);\n  }\n\n  /**\n   * Rebuild the search index from filesystem paths.\n   * Used internally for auto-indexing on init.\n   */\n  private async rebuildSearchIndex(paths: string[]): Promise<void> {\n    if (!this._searchEngine || !this._fs || paths.length === 0) {\n      return;\n    }\n\n    // Clear existing BM25 index\n    this._searchEngine.clear();\n\n    // Index all files from specified paths\n    for (const basePath of paths) {\n      try {\n        const files = await this.getAllFiles(basePath);\n        for (const filePath of files) {\n          try {\n            const content = await this._fs.readFile(filePath, { encoding: 'utf-8' });\n            await this._searchEngine.index({\n              id: filePath,\n              content: content as string,\n            });\n          } catch {\n            // Skip files that can't be read as text\n          }\n        }\n      } catch {\n        // Skip paths that don't exist\n      }\n    }\n  }\n\n  private async getAllFiles(dir: string): Promise<string[]> {\n    if (!this._fs) return [];\n\n    const files: string[] = [];\n    const entries = await this._fs.readdir(dir);\n\n    for (const entry of entries) {\n      const fullPath = dir === '/' ? `/${entry.name}` : `${dir}/${entry.name}`;\n      if (entry.type === 'file') {\n        files.push(fullPath);\n      } else if (entry.type === 'directory' && !entry.isSymlink) {\n        // Skip symlink directories to prevent infinite recursion from cycles\n        files.push(...(await this.getAllFiles(fullPath)));\n      }\n    }\n\n    return files;\n  }\n\n  // ---------------------------------------------------------------------------\n  // Lifecycle\n  // ---------------------------------------------------------------------------\n\n  /**\n   * Initialize the workspace.\n   * Starts the sandbox, initializes the filesystem, and auto-mounts filesystems.\n   */\n  async init(): Promise<void> {\n    this._status = 'initializing';\n\n    try {\n      if (this._fs) {\n        await callLifecycle(this._fs, 'init');\n      }\n\n      if (this._sandbox) {\n        await callLifecycle(this._sandbox, 'start');\n      }\n\n      // Auto-index files if autoIndexPaths is configured\n      if (this._searchEngine && this._config.autoIndexPaths && this._config.autoIndexPaths.length > 0) {\n        await this.rebuildSearchIndex(this._config.autoIndexPaths ?? []);\n      }\n\n      this._status = 'ready';\n    } catch (error) {\n      this._status = 'error';\n      throw error;\n    }\n  }\n\n  /**\n   * Destroy the workspace and clean up all resources.\n   */\n  async destroy(): Promise<void> {\n    this._status = 'destroying';\n\n    try {\n      if (this._sandbox) {\n        await callLifecycle(this._sandbox, 'destroy');\n      }\n\n      if (this._fs) {\n        await callLifecycle(this._fs, 'destroy');\n      }\n\n      this._status = 'destroyed';\n    } catch (error) {\n      this._status = 'error';\n      throw error;\n    }\n  }\n\n  /**\n   * Get workspace information.\n   * @param options.includeFileCount - Whether to count total files (can be slow for large workspaces)\n   */\n  async getInfo(options?: { includeFileCount?: boolean }): Promise<WorkspaceInfo> {\n    const info: WorkspaceInfo = {\n      id: this.id,\n      name: this.name,\n      status: this._status,\n      createdAt: this.createdAt,\n      lastAccessedAt: this.lastAccessedAt,\n    };\n\n    if (this._fs) {\n      const fsInfo = await this._fs.getInfo?.();\n      info.filesystem = {\n        id: fsInfo?.id ?? this._fs.id,\n        name: fsInfo?.name ?? this._fs.name,\n        provider: fsInfo?.provider ?? this._fs.provider,\n        readOnly: fsInfo?.readOnly ?? this._fs.readOnly,\n        status: fsInfo?.status,\n        error: fsInfo?.error,\n        icon: fsInfo?.icon,\n        metadata: fsInfo?.metadata,\n      };\n\n      if (options?.includeFileCount) {\n        try {\n          const files = await this.getAllFiles('/');\n          info.filesystem.totalFiles = files.length;\n        } catch {\n          // Ignore errors - filesystem may not support listing\n        }\n      }\n    }\n\n    if (this._sandbox) {\n      const sandboxInfo = await this._sandbox.getInfo?.();\n      info.sandbox = {\n        provider: this._sandbox.provider,\n        status: sandboxInfo?.status ?? this._sandbox.status,\n        resources: sandboxInfo?.resources,\n      };\n    }\n\n    return info;\n  }\n\n  /**\n   * Get information about how filesystem and sandbox paths relate.\n   * Useful for understanding how to access workspace files from sandbox code.\n   *\n   * @returns PathContext with paths and instructions from providers\n   */\n  getPathContext(): PathContext {\n    // Get instructions from providers\n    const fsInstructions = this._fs?.getInstructions?.();\n    const sandboxInstructions = this._sandbox?.getInstructions?.();\n\n    // Combine instructions from both providers\n    const instructions = [fsInstructions, sandboxInstructions].filter(Boolean).join(' ');\n\n    return {\n      filesystem: this._fs\n        ? {\n            provider: this._fs.provider,\n            basePath: this._fs.basePath,\n          }\n        : undefined,\n      sandbox: this._sandbox\n        ? {\n            provider: this._sandbox.provider,\n            workingDirectory: this._sandbox.workingDirectory,\n          }\n        : undefined,\n      instructions,\n    };\n  }\n\n  // ---------------------------------------------------------------------------\n  // Logger Integration\n  // ---------------------------------------------------------------------------\n\n  /**\n   * Set the logger for this workspace and propagate to providers.\n   * Called by Mastra when the logger is set.\n   * @internal\n   */\n  __setLogger(logger: IMastraLogger): void {\n    // Propagate logger to filesystem provider if it extends MastraFilesystem\n    if (this._fs instanceof MastraFilesystem) {\n      this._fs.__setLogger(logger);\n    }\n\n    // Propagate logger to sandbox provider if it extends MastraSandbox\n    if (this._sandbox instanceof MastraSandbox) {\n      this._sandbox.__setLogger(logger);\n    }\n  }\n}\n","/**\n * Platform Detection\n *\n * Detects available sandboxing backends for the current platform.\n */\n\nimport { execFileSync } from 'node:child_process';\nimport os from 'node:os';\n\nimport type { IsolationBackend, SandboxDetectionResult } from './types';\n\n/**\n * Check if a command exists on the system.\n */\nfunction commandExists(command: string): boolean {\n  try {\n    // Use 'which' on Unix-like systems\n    execFileSync('which', [command], { stdio: 'ignore' });\n    return true;\n  } catch {\n    return false;\n  }\n}\n\n/**\n * Check if seatbelt (sandbox-exec) is available.\n * This is built-in on macOS.\n */\nexport function isSeatbeltAvailable(): boolean {\n  if (os.platform() !== 'darwin') {\n    return false;\n  }\n  return commandExists('sandbox-exec');\n}\n\n/**\n * Check if bubblewrap (bwrap) is available.\n * This must be installed on Linux systems.\n */\nexport function isBwrapAvailable(): boolean {\n  if (os.platform() !== 'linux') {\n    return false;\n  }\n  return commandExists('bwrap');\n}\n\n/**\n * Detect the best available isolation backend for the current platform.\n *\n * @returns The recommended isolation backend and availability info\n *\n * @example\n * ```typescript\n * const result = detectIsolation();\n * if (result.available) {\n *   console.log(`Using ${result.backend} for sandboxing`);\n * } else {\n *   console.warn(result.message);\n * }\n * ```\n */\nexport function detectIsolation(): SandboxDetectionResult {\n  const platform = os.platform();\n\n  if (platform === 'darwin') {\n    const available = isSeatbeltAvailable();\n    return {\n      backend: 'seatbelt',\n      available,\n      message: available\n        ? 'macOS seatbelt (sandbox-exec) is available'\n        : 'macOS seatbelt (sandbox-exec) not found - this is unexpected on macOS',\n    };\n  }\n\n  if (platform === 'linux') {\n    const available = isBwrapAvailable();\n    return {\n      backend: 'bwrap',\n      available,\n      message: available\n        ? 'Linux bubblewrap (bwrap) is available'\n        : 'Linux bubblewrap (bwrap) not found. Install with: apt install bubblewrap (Debian/Ubuntu) or dnf install bubblewrap (Fedora)',\n    };\n  }\n\n  // Windows or other platforms\n  return {\n    backend: 'none',\n    available: false,\n    message: `Native sandboxing is not supported on ${platform}. Commands will run without isolation.`,\n  };\n}\n\n/**\n * Check if a specific isolation backend is available.\n *\n * @param backend - The isolation backend to check\n * @returns Whether the backend is available on this system\n */\nexport function isIsolationAvailable(backend: IsolationBackend): boolean {\n  switch (backend) {\n    case 'seatbelt':\n      return isSeatbeltAvailable();\n    case 'bwrap':\n      return isBwrapAvailable();\n    case 'none':\n      return true;\n    default:\n      return false;\n  }\n}\n\n/**\n * Get the recommended isolation backend for this platform.\n * Returns 'none' if no sandboxing is available.\n */\nexport function getRecommendedIsolation(): IsolationBackend {\n  const result = detectIsolation();\n  return result.available ? result.backend : 'none';\n}\n","/**\n * Seatbelt (macOS sandbox-exec)\n *\n * macOS built-in sandboxing using sandbox-exec with SBPL profiles.\n *\n * Important: Uses `-p` (inline profile) instead of `-f` (file) because\n * `-f` doesn't work reliably with path filters on modern macOS.\n *\n * Note on macOS sandbox limitations:\n * - `(allow file-read* (subpath ...))` only works WITH a preceding `(allow file-read*)`\n * - So for reads: allow all, then deny specific paths\n * - For writes: allow specific paths with subpath filters\n *\n * Based on the approach used by Claude Code's sandbox-runtime:\n * https://github.com/anthropic-experimental/sandbox-runtime\n */\n\nimport type { NativeSandboxConfig } from './types';\n\n/**\n * Mach services needed for basic operation\n */\nconst MACH_SERVICES = [\n  'com.apple.distributed_notifications@Uv3',\n  'com.apple.logd',\n  'com.apple.system.logger',\n  'com.apple.system.notification_center',\n  'com.apple.system.opendirectoryd.libinfo',\n  'com.apple.system.opendirectoryd.membership',\n  'com.apple.bsd.dirhelper',\n  'com.apple.securityd.xpc',\n  'com.apple.SecurityServer',\n  'com.apple.trustd.agent',\n];\n\n/**\n * Escape a path for use in SBPL profile.\n * Uses JSON.stringify for proper escaping.\n */\nfunction escapePath(pathStr: string): string {\n  return JSON.stringify(pathStr);\n}\n\n/**\n * Generate a seatbelt profile for the given configuration.\n *\n * The profile:\n * - Allows all file reads (can't restrict with subpath on macOS)\n * - Restricts file writes to workspace and temp directories\n * - Blocks network unless explicitly allowed\n *\n * @param workspacePath - The workspace directory to allow write access to\n * @param config - Additional sandbox configuration\n * @returns The generated SBPL profile content\n */\nexport function generateSeatbeltProfile(workspacePath: string, config: NativeSandboxConfig): string {\n  // Fail-closed: seatbelt cannot restrict process-exec, so reject unsupported config\n  if (config.allowSystemBinaries === false) {\n    throw new Error(\n      'allowSystemBinaries: false is not supported by seatbelt (macOS). ' +\n        'Use bubblewrap on Linux or remove this restriction.',\n    );\n  }\n\n  const lines: string[] = [];\n\n  // Version and default deny\n  lines.push('(version 1)');\n  lines.push('(deny default (with message \"mastra-sandbox\"))');\n  lines.push('');\n\n  // Process permissions\n  lines.push('; Process permissions');\n  lines.push('(allow process-exec)');\n  lines.push('(allow process-fork)');\n  lines.push('(allow process-info* (target same-sandbox))');\n  lines.push('(allow signal (target same-sandbox))');\n  lines.push('');\n\n  // Mach IPC\n  lines.push('; Mach IPC');\n  lines.push('(allow mach-lookup');\n  for (const service of MACH_SERVICES) {\n    lines.push(`  (global-name \"${service}\")`);\n  }\n  lines.push(')');\n  lines.push('');\n\n  // IPC\n  lines.push('; IPC');\n  lines.push('(allow ipc-posix-shm)');\n  lines.push('(allow ipc-posix-sem)');\n  lines.push('');\n\n  // User preferences\n  lines.push('; User preferences');\n  lines.push('(allow user-preference-read)');\n  lines.push('');\n\n  // sysctl\n  lines.push('; sysctl');\n  lines.push('(allow sysctl-read)');\n  lines.push('');\n\n  // Device files\n  lines.push('; Device files');\n  lines.push('(allow file-ioctl (literal \"/dev/null\"))');\n  lines.push('(allow file-ioctl (literal \"/dev/zero\"))');\n  lines.push('(allow file-ioctl (literal \"/dev/random\"))');\n  lines.push('(allow file-ioctl (literal \"/dev/urandom\"))');\n  lines.push('(allow file-ioctl (literal \"/dev/tty\"))');\n  lines.push('');\n\n  // File read access - allow all reads (macOS limitation: can't use subpath without this)\n  lines.push('; File read access (allow all - macOS sandbox limitation)');\n  lines.push('(allow file-read*)');\n\n  // Add custom read-only paths as additional allows (technically redundant but explicit)\n  for (const p of config.readOnlyPaths ?? []) {\n    lines.push(`(allow file-read* (subpath ${escapePath(p)}))`);\n  }\n  lines.push('');\n\n  // File write access - restrict to workspace and temp\n  lines.push('; File write access (restricted to workspace and temp)');\n\n  // Workspace\n  lines.push(`(allow file-write* (subpath ${escapePath(workspacePath)}))`);\n\n  // Temp directories (needed for many operations)\n  lines.push('(allow file-write* (subpath \"/private/tmp\"))');\n  lines.push('(allow file-write* (subpath \"/var/folders\"))');\n  lines.push('(allow file-write* (subpath \"/private/var/folders\"))');\n\n  // Custom read-write paths\n  for (const p of config.readWritePaths ?? []) {\n    lines.push(`(allow file-write* (subpath ${escapePath(p)}))`);\n  }\n  lines.push('');\n\n  // Network\n  lines.push('; Network');\n  if (config.allowNetwork) {\n    lines.push('(allow network*)');\n  } else {\n    lines.push('(deny network* (with message \"mastra-sandbox-network\"))');\n  }\n\n  return lines.join('\\n');\n}\n\n/**\n * Build the command arguments for sandbox-exec.\n *\n * Uses `-p` (inline profile) instead of `-f` (file) because\n * `-f` doesn't work reliably with path filters on modern macOS.\n *\n * @param command - The command to run\n * @param args - Arguments for the command\n * @param profile - The SBPL profile content (not a file path)\n * @returns Wrapped command and arguments for sandbox-exec\n */\nexport function buildSeatbeltCommand(\n  command: string,\n  args: string[],\n  profile: string,\n): { command: string; args: string[] } {\n  return {\n    command: 'sandbox-exec',\n    args: ['-p', profile, command, ...args],\n  };\n}\n","/**\n * Bubblewrap (Linux bwrap)\n *\n * Linux sandboxing using user namespaces and bind mounts.\n * https://github.com/containers/bubblewrap\n */\n\nimport type { NativeSandboxConfig } from './types';\n\n/**\n * System paths to mount read-only by default.\n * These are needed for basic command execution.\n */\nconst DEFAULT_READONLY_BINDS = [\n  '/usr',\n  '/lib',\n  '/lib64',\n  '/bin',\n  '/sbin',\n  '/etc/alternatives',\n  '/etc/ssl',\n  '/etc/ca-certificates',\n  '/etc/resolv.conf',\n  '/etc/hosts',\n  '/etc/passwd',\n  '/etc/group',\n  '/etc/nsswitch.conf',\n  '/etc/ld.so.cache',\n  '/etc/localtime',\n];\n\n/**\n * Build the bwrap command arguments for the given configuration.\n *\n * @param command - The command to run inside the sandbox\n * @param args - Arguments for the command\n * @param workspacePath - The workspace directory (mounted read-write)\n * @param config - Additional sandbox configuration\n * @returns Wrapped command and arguments for bwrap\n */\nexport function buildBwrapCommand(\n  command: string,\n  args: string[],\n  workspacePath: string,\n  config: NativeSandboxConfig,\n): { command: string; args: string[] } {\n  // If custom bwrap args are provided, use them directly\n  if (config.bwrapArgs && config.bwrapArgs.length > 0) {\n    return {\n      command: 'bwrap',\n      args: [...config.bwrapArgs, '--', command, ...args],\n    };\n  }\n\n  const bwrapArgs: string[] = [];\n\n  // Create new namespaces for isolation\n  bwrapArgs.push('--unshare-pid'); // PID namespace (can't see host processes)\n  bwrapArgs.push('--unshare-ipc'); // IPC namespace\n  bwrapArgs.push('--unshare-uts'); // UTS namespace (separate hostname)\n\n  // Network isolation (unless explicitly allowed)\n  if (!config.allowNetwork) {\n    bwrapArgs.push('--unshare-net');\n  }\n\n  // Mount a new /proc for the PID namespace\n  bwrapArgs.push('--proc', '/proc');\n\n  // Mount a tmpfs at /tmp\n  bwrapArgs.push('--tmpfs', '/tmp');\n\n  // Mount system paths read-only\n  for (const path of DEFAULT_READONLY_BINDS) {\n    // Use --ro-bind-try to skip paths that don't exist on this system\n    bwrapArgs.push('--ro-bind-try', path, path);\n  }\n\n  // Mount custom read-only paths\n  for (const path of config.readOnlyPaths ?? []) {\n    bwrapArgs.push('--ro-bind', path, path);\n  }\n\n  // Allow system binaries by default (node, python, etc.)\n  if (config.allowSystemBinaries !== false) {\n    // Include the Node.js binary location\n    const nodePath = process.execPath;\n    const nodeDir = nodePath.substring(0, nodePath.lastIndexOf('/'));\n\n    // Mount the node directory if it's not already covered\n    if (!DEFAULT_READONLY_BINDS.some(p => nodeDir.startsWith(p))) {\n      bwrapArgs.push('--ro-bind', nodeDir, nodeDir);\n    }\n\n    // Also mount common runtime locations\n    bwrapArgs.push('--ro-bind-try', '/opt', '/opt');\n    bwrapArgs.push('--ro-bind-try', '/snap', '/snap');\n  }\n\n  // Mount workspace read-write\n  bwrapArgs.push('--bind', workspacePath, workspacePath);\n\n  // Mount custom read-write paths\n  for (const path of config.readWritePaths ?? []) {\n    bwrapArgs.push('--bind', path, path);\n  }\n\n  // Set the working directory\n  bwrapArgs.push('--chdir', workspacePath);\n\n  // Die with parent (clean up if the parent process dies)\n  bwrapArgs.push('--die-with-parent');\n\n  // Add the command separator and actual command\n  bwrapArgs.push('--', command, ...args);\n\n  return {\n    command: 'bwrap',\n    args: bwrapArgs,\n  };\n}\n","/**\n * Command Wrapper\n *\n * Wraps commands with the appropriate sandbox backend.\n */\n\nimport { buildBwrapCommand } from './bubblewrap';\nimport { buildSeatbeltCommand, generateSeatbeltProfile } from './seatbelt';\nimport type { IsolationBackend, NativeSandboxConfig } from './types';\n\nexport interface WrappedCommand {\n  command: string;\n  args: string[];\n}\n\nexport interface WrapCommandOptions {\n  /** The isolation backend to use */\n  backend: IsolationBackend;\n  /** The workspace directory path */\n  workspacePath: string;\n  /** Pre-generated seatbelt profile content (optional, will be generated if not provided) */\n  seatbeltProfile?: string;\n  /** Native sandbox configuration */\n  config: NativeSandboxConfig;\n}\n\n/**\n * Wrap a command with the appropriate sandbox backend.\n *\n * @param command - The command to run\n * @param args - Arguments for the command\n * @param options - Wrapping options\n * @returns The wrapped command and arguments\n *\n * @example\n * ```typescript\n * const wrapped = wrapCommand('node', ['script.js'], {\n *   backend: 'seatbelt',\n *   workspacePath: '/workspace',\n *   config: { allowNetwork: false },\n * });\n * // wrapped.command = 'sandbox-exec'\n * // wrapped.args = ['-p', '<profile>', 'node', 'script.js']\n * ```\n */\nexport function wrapCommand(command: string, args: string[], options: WrapCommandOptions): WrappedCommand {\n  switch (options.backend) {\n    case 'seatbelt': {\n      const profile = options.seatbeltProfile ?? generateSeatbeltProfile(options.workspacePath, options.config);\n      return buildSeatbeltCommand(command, args, profile);\n    }\n\n    case 'bwrap': {\n      return buildBwrapCommand(command, args, options.workspacePath, options.config);\n    }\n\n    case 'none':\n    default:\n      return { command, args };\n  }\n}\n","/**\n * Local Sandbox Provider\n *\n * A sandbox implementation that executes commands on the local machine.\n * This is the default sandbox for development and local agents.\n *\n * Supports optional native OS sandboxing:\n * - macOS: Uses seatbelt (sandbox-exec) for filesystem and network isolation\n * - Linux: Uses bubblewrap (bwrap) for namespace isolation\n */\n\nimport * as childProcess from 'node:child_process';\nimport type { SpawnOptions } from 'node:child_process';\nimport * as crypto from 'node:crypto';\nimport * as fs from 'node:fs/promises';\nimport * as os from 'node:os';\nimport * as path from 'node:path';\nimport type { ProviderStatus } from '../lifecycle';\nimport { IsolationUnavailableError } from './errors';\nimport { MastraSandbox } from './mastra-sandbox';\nimport type { MastraSandboxOptions } from './mastra-sandbox';\nimport type { IsolationBackend, NativeSandboxConfig } from './native-sandbox';\nimport { detectIsolation, isIsolationAvailable, generateSeatbeltProfile, wrapCommand } from './native-sandbox';\nimport type { SandboxInfo, ExecuteCommandOptions, CommandResult } from './types';\n\ninterface ExecStreamingOptions extends Omit<SpawnOptions, 'timeout' | 'stdio'> {\n  /** Timeout in ms - handled manually for custom exit code 124 */\n  timeout?: number;\n  onStdout?: (data: string) => void;\n  onStderr?: (data: string) => void;\n}\n\n/**\n * Execute a command with optional streaming callbacks.\n * Uses spawn when callbacks are provided for real-time output.\n */\nfunction execWithStreaming(\n  command: string,\n  args: string[],\n  options: ExecStreamingOptions,\n): Promise<{ stdout: string; stderr: string; exitCode: number }> {\n  const { timeout, onStdout, onStderr, cwd, env, ...spawnOptions } = options;\n  return new Promise((resolve, reject) => {\n    const proc = childProcess.spawn(command, args, { cwd, env, ...spawnOptions });\n\n    let stdout = '';\n    let stderr = '';\n    let killed = false;\n\n    // Set up timeout\n    const timeoutId = timeout\n      ? setTimeout(() => {\n          killed = true;\n          proc.kill('SIGTERM');\n        }, timeout)\n      : undefined;\n\n    proc.stdout.on('data', (data: Buffer) => {\n      const str = data.toString();\n      stdout += str;\n      onStdout?.(str);\n    });\n\n    proc.stderr.on('data', (data: Buffer) => {\n      const str = data.toString();\n      stderr += str;\n      onStderr?.(str);\n    });\n\n    proc.on('error', err => {\n      if (timeoutId) clearTimeout(timeoutId);\n      const errorMsg = err.message;\n      stderr += errorMsg;\n      onStderr?.(errorMsg);\n      reject(err);\n    });\n\n    proc.on('close', (code, signal) => {\n      if (timeoutId) clearTimeout(timeoutId);\n      if (killed) {\n        const timeoutMsg = `\\nProcess timed out after ${timeout}ms`;\n        onStderr?.(timeoutMsg);\n        resolve({ stdout, stderr: stderr + timeoutMsg, exitCode: 124 });\n      } else if (signal) {\n        // When terminated by signal, code is null but signal contains the signal name\n        const signalMsg = `\\nProcess terminated by ${signal}`;\n        onStderr?.(signalMsg);\n        resolve({ stdout, stderr: stderr + signalMsg, exitCode: 128 });\n      } else {\n        resolve({ stdout, stderr, exitCode: code ?? 0 });\n      }\n    });\n  });\n}\n\n/**\n * Local sandbox provider configuration.\n */\nexport interface LocalSandboxOptions extends MastraSandboxOptions {\n  /** Unique identifier for this sandbox instance */\n  id?: string;\n  /** Working directory for command execution */\n  workingDirectory?: string;\n  /**\n   * Environment variables to set for command execution.\n   * PATH is included by default unless overridden (needed for finding executables).\n   * Other host environment variables are not inherited unless explicitly passed.\n   *\n   * @example\n   * ```typescript\n   * // Default - only PATH is available\n   * env: undefined\n   *\n   * // Add specific variables\n   * env: { NODE_ENV: 'production', HOME: process.env.HOME }\n   *\n   * // Full host environment (less secure)\n   * env: process.env\n   * ```\n   */\n  env?: NodeJS.ProcessEnv;\n  /** Default timeout for operations in ms (default: 30000) */\n  timeout?: number;\n  /**\n   * Isolation backend for sandboxed execution.\n   * - 'none': No sandboxing (direct execution on host) - default\n   * - 'seatbelt': macOS sandbox-exec (built-in on macOS)\n   * - 'bwrap': Linux bubblewrap (requires installation)\n   *\n   * Use `LocalSandbox.detectIsolation()` to get the recommended backend.\n   * @default 'none'\n   */\n  isolation?: IsolationBackend;\n  /**\n   * Configuration for native sandboxing.\n   * Only used when isolation is 'seatbelt' or 'bwrap'.\n   */\n  nativeSandbox?: NativeSandboxConfig;\n}\n\n/**\n * Local sandbox implementation.\n *\n * Executes commands directly on the host machine.\n * This is the recommended sandbox for development and trusted local execution.\n *\n * @example\n * ```typescript\n * import { Workspace, LocalFilesystem, LocalSandbox } from '@mastra/core';\n *\n * const workspace = new Workspace({\n *   filesystem: new LocalFilesystem({ basePath: './my-workspace' }),\n *   sandbox: new LocalSandbox({ workingDirectory: './my-workspace' }),\n * });\n *\n * await workspace.init();\n * const result = await workspace.executeCommand('node', ['script.js']);\n * ```\n */\nexport class LocalSandbox extends MastraSandbox {\n  readonly id: string;\n  readonly name = 'LocalSandbox';\n  readonly provider = 'local';\n\n  status: ProviderStatus = 'pending';\n\n  private readonly _workingDirectory: string;\n  private readonly env: NodeJS.ProcessEnv;\n  private readonly timeout?: number;\n  private readonly _isolation: IsolationBackend;\n  private readonly _nativeSandboxConfig: NativeSandboxConfig;\n  private _seatbeltProfile?: string;\n  private _seatbeltProfilePath?: string;\n  private _sandboxFolderPath?: string;\n  private _userProvidedProfilePath = false;\n  private readonly _createdAt: Date;\n\n  /**\n   * The working directory where commands are executed.\n   */\n  get workingDirectory(): string {\n    return this._workingDirectory;\n  }\n\n  /**\n   * The isolation backend being used.\n   */\n  get isolation(): IsolationBackend {\n    return this._isolation;\n  }\n\n  /**\n   * Detect the best available isolation backend for this platform.\n   * Returns detection result with backend recommendation and availability.\n   *\n   * @example\n   * ```typescript\n   * const result = LocalSandbox.detectIsolation();\n   * const sandbox = new LocalSandbox({\n   *   isolation: result.available ? result.backend : 'none',\n   * });\n   * ```\n   */\n  static detectIsolation() {\n    return detectIsolation();\n  }\n\n  constructor(options: LocalSandboxOptions = {}) {\n    super({ ...options, name: 'LocalSandbox' });\n    this.id = options.id ?? this.generateId();\n    this._createdAt = new Date();\n    // Default working directory is .sandbox/ in cwd - isolated from seatbelt profiles\n    this._workingDirectory = options.workingDirectory ?? path.join(process.cwd(), '.sandbox');\n    this.env = options.env ?? {};\n    this.timeout = options.timeout;\n    this._nativeSandboxConfig = options.nativeSandbox ?? {};\n\n    // Validate and set isolation backend\n    const requestedIsolation = options.isolation ?? 'none';\n    if (requestedIsolation !== 'none' && !isIsolationAvailable(requestedIsolation)) {\n      const detection = detectIsolation();\n      throw new IsolationUnavailableError(requestedIsolation, detection.message);\n    }\n    this._isolation = requestedIsolation;\n  }\n\n  private generateId(): string {\n    return `local-sandbox-${Date.now().toString(36)}-${Math.random().toString(36).slice(2, 8)}`;\n  }\n\n  /**\n   * Build the environment object for execution.\n   * Always includes PATH by default (needed for finding executables).\n   * Merges the sandbox's configured env with any additional env from the command.\n   */\n  private buildEnv(additionalEnv?: NodeJS.ProcessEnv): NodeJS.ProcessEnv {\n    return {\n      PATH: process.env.PATH, // Always include PATH for finding executables\n      ...this.env,\n      ...additionalEnv,\n    };\n  }\n\n  /**\n   * Start the local sandbox.\n   * Creates working directory and sets up seatbelt profile if using macOS isolation.\n   * Status management is handled by the base class.\n   */\n  async start(): Promise<void> {\n    this.logger.debug('Starting sandbox', { workingDirectory: this._workingDirectory, isolation: this._isolation });\n\n    await fs.mkdir(this.workingDirectory, { recursive: true });\n\n    // Set up seatbelt profile for macOS sandboxing\n    if (this._isolation === 'seatbelt') {\n      const userProvidedPath = this._nativeSandboxConfig.seatbeltProfilePath;\n\n      if (userProvidedPath) {\n        // User provided a custom path\n        this._seatbeltProfilePath = userProvidedPath;\n        this._userProvidedProfilePath = true;\n\n        // Check if file exists at user's path\n        try {\n          this._seatbeltProfile = await fs.readFile(userProvidedPath, 'utf-8');\n        } catch (err: unknown) {\n          if (err instanceof Error && 'code' in err && (err as NodeJS.ErrnoException).code !== 'ENOENT') {\n            throw err;\n          }\n          // File doesn't exist, generate default and write to user's path\n          this._seatbeltProfile = generateSeatbeltProfile(this.workingDirectory, this._nativeSandboxConfig);\n          // Ensure parent directory exists\n          await fs.mkdir(path.dirname(userProvidedPath), { recursive: true });\n          await fs.writeFile(userProvidedPath, this._seatbeltProfile, 'utf-8');\n        }\n      } else {\n        // No custom path, use default location\n        this._seatbeltProfile = generateSeatbeltProfile(this.workingDirectory, this._nativeSandboxConfig);\n\n        // Generate a deterministic hash from workspace path and config\n        // This allows identical sandboxes to share profiles while preventing collisions\n        const configHash = crypto\n          .createHash('sha256')\n          .update(this.workingDirectory)\n          .update(JSON.stringify(this._nativeSandboxConfig))\n          .digest('hex')\n          .slice(0, 8);\n\n        // Write profile to .sandbox-profiles/ in cwd (outside working directory)\n        // This prevents sandboxed processes from reading/modifying their own security profile\n        this._sandboxFolderPath = path.join(process.cwd(), '.sandbox-profiles');\n        await fs.mkdir(this._sandboxFolderPath, { recursive: true });\n        this._seatbeltProfilePath = path.join(this._sandboxFolderPath, `seatbelt-${configHash}.sb`);\n        await fs.writeFile(this._seatbeltProfilePath, this._seatbeltProfile, 'utf-8');\n      }\n    }\n\n    this.logger.debug('Sandbox started', { workingDirectory: this._workingDirectory });\n  }\n\n  /**\n   * Stop the local sandbox.\n   * Status management is handled by the base class.\n   */\n  async stop(): Promise<void> {\n    this.logger.debug('Stopping sandbox', { workingDirectory: this._workingDirectory });\n  }\n\n  /**\n   * Destroy the local sandbox and clean up resources.\n   * Cleans up seatbelt profile if auto-generated.\n   * Status management is handled by the base class.\n   */\n  async destroy(): Promise<void> {\n    this.logger.debug('Destroying sandbox', { workingDirectory: this._workingDirectory });\n    // Clean up seatbelt profile only if it was auto-generated (not user-provided)\n    if (this._seatbeltProfilePath && !this._userProvidedProfilePath) {\n      try {\n        await fs.unlink(this._seatbeltProfilePath);\n      } catch {\n        // Ignore errors if file doesn't exist\n      }\n    }\n    this._seatbeltProfilePath = undefined;\n    this._seatbeltProfile = undefined;\n    this._userProvidedProfilePath = false;\n\n    // Try to remove .sandbox folder if empty\n    if (this._sandboxFolderPath) {\n      try {\n        await fs.rmdir(this._sandboxFolderPath);\n      } catch {\n        // Ignore errors - folder may not be empty or may not exist\n      }\n      this._sandboxFolderPath = undefined;\n    }\n  }\n\n  async isReady(): Promise<boolean> {\n    return this.status === 'running';\n  }\n\n  async getInfo(): Promise<SandboxInfo> {\n    return {\n      id: this.id,\n      name: this.name,\n      provider: this.provider,\n      status: this.status,\n      createdAt: this._createdAt,\n      resources: {\n        memoryMB: Math.round(os.totalmem() / 1024 / 1024),\n        cpuCores: os.cpus().length,\n      },\n      metadata: {\n        workingDirectory: this.workingDirectory,\n        platform: os.platform(),\n        nodeVersion: process.version,\n        isolation: this._isolation,\n        isolationConfig:\n          this._isolation !== 'none'\n            ? {\n                allowNetwork: this._nativeSandboxConfig.allowNetwork ?? false,\n                readOnlyPaths: this._nativeSandboxConfig.readOnlyPaths,\n                readWritePaths: this._nativeSandboxConfig.readWritePaths,\n              }\n            : undefined,\n      },\n    };\n  }\n\n  getInstructions(): string {\n    if (this.workingDirectory) {\n      return `Local command execution. Working directory: \"${this.workingDirectory}\".`;\n    }\n    return 'Local command execution on the host machine.';\n  }\n\n  /**\n   * Wrap a command with the configured isolation backend.\n   */\n  private wrapCommandForIsolation(command: string, args: string[]): { command: string; args: string[] } {\n    if (this._isolation === 'none') {\n      return { command, args };\n    }\n\n    return wrapCommand(command, args, {\n      backend: this._isolation,\n      workspacePath: this.workingDirectory,\n      seatbeltProfile: this._seatbeltProfile,\n      config: this._nativeSandboxConfig,\n    });\n  }\n\n  async executeCommand(\n    command: string,\n    args: string[] = [],\n    options: ExecuteCommandOptions = {},\n  ): Promise<CommandResult> {\n    this.logger.debug('Executing command', { command, args, cwd: options.cwd ?? this.workingDirectory });\n\n    // Auto-start if not running (lazy initialization)\n    await this.ensureRunning();\n\n    const startTime = Date.now();\n\n    // Wrap command with isolation backend if configured\n    const wrapped = this.wrapCommandForIsolation(command, args);\n\n    // Use streaming execution when callbacks are provided\n\n    try {\n      const result = await execWithStreaming(wrapped.command, wrapped.args, {\n        cwd: options.cwd ?? this.workingDirectory,\n        timeout: options.timeout ?? this.timeout ?? 30000,\n        env: this.buildEnv(options.env),\n        onStdout: options.onStdout,\n        onStderr: options.onStderr,\n      });\n\n      const commandResult: CommandResult = {\n        success: result.exitCode === 0,\n        stdout: result.stdout,\n        stderr: result.stderr,\n        exitCode: result.exitCode,\n        executionTimeMs: Date.now() - startTime,\n      };\n\n      this.logger.info('Command completed', {\n        command,\n        exitCode: commandResult.exitCode,\n        executionTimeMs: commandResult.executionTimeMs,\n      });\n\n      return commandResult;\n    } catch (error: unknown) {\n      const executionTimeMs = Date.now() - startTime;\n      this.logger.error('Command failed', { command, error, executionTimeMs });\n      return {\n        success: false,\n        stdout: '',\n        stderr: error instanceof Error ? error.message : String(error),\n        exitCode: 1,\n        executionTimeMs,\n      };\n    }\n  }\n}\n","export const WORKSPACE_TOOLS_PREFIX = 'mastra_workspace' as const;\n\n/**\n * Workspace tool name constants.\n * Use these to reference workspace tools by name.\n *\n * @example\n * ```typescript\n * import { WORKSPACE_TOOLS } from '@mastra/core/workspace';\n *\n * if (toolName === WORKSPACE_TOOLS.SANDBOX.EXECUTE_COMMAND) {\n *   // Handle sandbox execution\n * }\n * ```\n */\nexport const WORKSPACE_TOOLS = {\n  FILESYSTEM: {\n    READ_FILE: `${WORKSPACE_TOOLS_PREFIX}_read_file` as const,\n    WRITE_FILE: `${WORKSPACE_TOOLS_PREFIX}_write_file` as const,\n    EDIT_FILE: `${WORKSPACE_TOOLS_PREFIX}_edit_file` as const,\n    LIST_FILES: `${WORKSPACE_TOOLS_PREFIX}_list_files` as const,\n    DELETE: `${WORKSPACE_TOOLS_PREFIX}_delete` as const,\n    FILE_STAT: `${WORKSPACE_TOOLS_PREFIX}_file_stat` as const,\n    MKDIR: `${WORKSPACE_TOOLS_PREFIX}_mkdir` as const,\n  },\n  SANDBOX: {\n    EXECUTE_COMMAND: `${WORKSPACE_TOOLS_PREFIX}_execute_command` as const,\n  },\n  SEARCH: {\n    SEARCH: `${WORKSPACE_TOOLS_PREFIX}_search` as const,\n    INDEX: `${WORKSPACE_TOOLS_PREFIX}_index` as const,\n  },\n} as const;\n\n/**\n * Type representing any workspace tool name.\n */\nexport type WorkspaceToolName =\n  | (typeof WORKSPACE_TOOLS.FILESYSTEM)[keyof typeof WORKSPACE_TOOLS.FILESYSTEM]\n  | (typeof WORKSPACE_TOOLS.SEARCH)[keyof typeof WORKSPACE_TOOLS.SEARCH]\n  | (typeof WORKSPACE_TOOLS.SANDBOX)[keyof typeof WORKSPACE_TOOLS.SANDBOX];\n","/**\n * Tree Formatter\n *\n * Formats directory structures as ASCII tree output.\n * Works with any WorkspaceFilesystem implementation.\n *\n * @example\n * ```typescript\n * import { formatAsTree } from './tree-formatter';\n *\n * const result = await formatAsTree(filesystem, '/', { maxDepth: 3 });\n * console.log(result.tree);\n * // .\n * //  src\n * //     index.ts\n * //     utils\n * //         helpers.ts\n * //  package.json\n * console.log(result.summary);\n * // \"2 directories, 3 files\"\n * ```\n */\n\nimport type { WorkspaceFilesystem, FileEntry } from '../filesystem';\n\n// =============================================================================\n// Types\n// =============================================================================\n\nexport interface TreeOptions {\n  /** Maximum recursion depth (default: Infinity). Similar to tree's -L flag. */\n  maxDepth?: number;\n  /** Show hidden files/directories starting with '.' (default: false). Similar to tree's -a flag. */\n  showHidden?: boolean;\n  /** List directories only, no files (default: false). Similar to tree's -d flag. */\n  dirsOnly?: boolean;\n  /** Pattern to exclude from listing (e.g., 'node_modules'). Similar to tree's -I flag. */\n  exclude?: string | string[];\n  /** Filter by file extension (e.g., '.ts'). Similar to tree's -P flag. */\n  extension?: string | string[];\n}\n\nexport interface TreeResult {\n  /** ASCII tree representation */\n  tree: string;\n  /** Human-readable summary (e.g., \"3 directories, 12 files\") */\n  summary: string;\n  /** Number of directories found */\n  dirCount: number;\n  /** Number of files found */\n  fileCount: number;\n  /** Whether output was truncated due to maxDepth */\n  truncated: boolean;\n}\n\n// =============================================================================\n// Constants\n// =============================================================================\n\nconst BRANCH = ' ';\nconst LAST_BRANCH = ' ';\nconst VERTICAL = '   ';\nconst SPACE = '    ';\n\n// =============================================================================\n// Tree Formatting\n// =============================================================================\n\n/**\n * Format a directory as an ASCII tree.\n *\n * @param fs - WorkspaceFilesystem implementation\n * @param path - Root path to format\n * @param options - Formatting options\n * @returns Tree result with formatted string and counts\n */\nexport async function formatAsTree(fs: WorkspaceFilesystem, path: string, options?: TreeOptions): Promise<TreeResult> {\n  const maxDepth = options?.maxDepth ?? Infinity;\n  const showHidden = options?.showHidden ?? false;\n  const dirsOnly = options?.dirsOnly ?? false;\n  const exclude = options?.exclude;\n  const extension = options?.extension;\n\n  const lines: string[] = ['.'];\n  let dirCount = 0;\n  let fileCount = 0;\n  let truncated = false;\n\n  /**\n   * Build tree recursively\n   */\n  async function buildTree(currentPath: string, prefix: string, depth: number): Promise<void> {\n    if (depth >= maxDepth) {\n      truncated = true;\n      return;\n    }\n\n    let entries: FileEntry[];\n    try {\n      entries = await fs.readdir(currentPath);\n    } catch (error) {\n      // At root level (depth 0), propagate errors so users see auth/access issues\n      // For subdirectories, silently skip (permission issues on nested dirs are common)\n      if (depth === 0) {\n        throw error;\n      }\n      return;\n    }\n\n    // Filter entries\n    let filtered = entries;\n\n    // Filter hidden files unless showHidden\n    if (!showHidden) {\n      filtered = filtered.filter(e => !e.name.startsWith('.'));\n    }\n\n    // Filter by exclude pattern (like tree's -I flag)\n    if (exclude) {\n      const patterns = Array.isArray(exclude) ? exclude : [exclude];\n      filtered = filtered.filter(e => {\n        return !patterns.some(pattern => e.name.includes(pattern));\n      });\n    }\n\n    // Filter to directories only (like tree's -d flag)\n    if (dirsOnly) {\n      filtered = filtered.filter(e => e.type === 'directory');\n    }\n\n    // Filter by extension (only affects files, directories always pass)\n    if (extension && !dirsOnly) {\n      const extensions = Array.isArray(extension) ? extension : [extension];\n      filtered = filtered.filter(e => {\n        if (e.type === 'directory') return true;\n        return extensions.some(ext => {\n          // Support both '.ts' and 'ts' formats\n          const normalizedExt = ext.startsWith('.') ? ext : `.${ext}`;\n          return e.name.endsWith(normalizedExt);\n        });\n      });\n    }\n\n    // Sort: directories first, then alphabetically (ASCII order to match native tree's strcmp)\n    filtered.sort((a, b) => {\n      if (a.type === 'directory' && b.type !== 'directory') return -1;\n      if (a.type !== 'directory' && b.type === 'directory') return 1;\n      return a.name < b.name ? -1 : a.name > b.name ? 1 : 0;\n    });\n\n    for (let i = 0; i < filtered.length; i++) {\n      const entry = filtered[i]!;\n      const isLast = i === filtered.length - 1;\n      const connector = isLast ? LAST_BRANCH : BRANCH;\n      const childPrefix = prefix + (isLast ? SPACE : VERTICAL);\n\n      // Format entry name, including symlink target if present\n      const displayName =\n        entry.isSymlink && entry.symlinkTarget ? `${entry.name} -> ${entry.symlinkTarget}` : entry.name;\n\n      lines.push(prefix + connector + displayName);\n\n      if (entry.type === 'directory') {\n        dirCount++;\n        // Don't recurse into symlinks (matches native tree behavior)\n        // This also prevents infinite loops from circular symlinks\n        if (!entry.isSymlink) {\n          const childPath = joinPath(currentPath, entry.name);\n          await buildTree(childPath, childPrefix, depth + 1);\n        }\n      } else {\n        fileCount++;\n      }\n    }\n  }\n\n  await buildTree(path, '', 0);\n\n  // Build summary\n  const dirPart = dirCount === 1 ? '1 directory' : `${dirCount} directories`;\n  const filePart = fileCount === 1 ? '1 file' : `${fileCount} files`;\n  let summary = `${dirPart}, ${filePart}`;\n  if (truncated) {\n    summary += ` (truncated at depth ${maxDepth})`;\n  }\n\n  return {\n    tree: lines.join('\\n'),\n    summary,\n    dirCount,\n    fileCount,\n    truncated,\n  };\n}\n\n/**\n * Format entries directly (without filesystem access).\n * Useful when you already have the entries and want tree output.\n *\n * @param entries - Flat list of entries with path-like names (e.g., \"dir/subdir/file.txt\")\n * @returns Formatted tree string\n */\nexport function formatEntriesAsTree(entries: Array<{ name: string; type: 'file' | 'directory' }>): string {\n  // Build a nested structure from flat paths\n  interface TreeNode {\n    name: string;\n    type: 'file' | 'directory';\n    children: Map<string, TreeNode>;\n  }\n\n  const root: TreeNode = { name: '.', type: 'directory', children: new Map() };\n\n  for (const entry of entries) {\n    const parts = entry.name.split('/');\n    let current = root;\n\n    for (let i = 0; i < parts.length; i++) {\n      const part = parts[i]!;\n      const isLastPart = i === parts.length - 1;\n\n      if (!current.children.has(part)) {\n        current.children.set(part, {\n          name: part,\n          type: isLastPart ? entry.type : 'directory',\n          children: new Map(),\n        });\n      }\n      current = current.children.get(part)!;\n    }\n  }\n\n  // Render tree\n  const lines: string[] = ['.'];\n\n  function renderNode(node: TreeNode, prefix: string): void {\n    const children = Array.from(node.children.values());\n    // Sort: directories first, then alphabetically (ASCII order to match native tree's strcmp)\n    children.sort((a, b) => {\n      if (a.type === 'directory' && b.type !== 'directory') return -1;\n      if (a.type !== 'directory' && b.type === 'directory') return 1;\n      return a.name < b.name ? -1 : a.name > b.name ? 1 : 0;\n    });\n\n    for (let i = 0; i < children.length; i++) {\n      const child = children[i]!;\n      const isLast = i === children.length - 1;\n      const connector = isLast ? LAST_BRANCH : BRANCH;\n      const childPrefix = prefix + (isLast ? SPACE : VERTICAL);\n\n      lines.push(prefix + connector + child.name);\n\n      if (child.children.size > 0) {\n        renderNode(child, childPrefix);\n      }\n    }\n  }\n\n  renderNode(root, '');\n  return lines.join('\\n');\n}\n\n// =============================================================================\n// Helpers\n// =============================================================================\n\n/**\n * Join path segments, handling root paths correctly\n */\nfunction joinPath(base: string, name: string): string {\n  if (base === '/' || base === '') {\n    return `/${name}`;\n  }\n  return `${base}/${name}`;\n}\n","/**\n * Workspace Tools\n *\n * Auto-injected tools for agents with workspace configured.\n * These tools provide filesystem and sandbox capabilities.\n */\n\nimport { z } from 'zod';\nimport { createTool } from '../../tools';\nimport type { WorkspaceToolName } from '../constants';\nimport { WORKSPACE_TOOLS } from '../constants';\nimport { FileNotFoundError, FileReadRequiredError } from '../errors';\nimport { InMemoryFileReadTracker } from '../filesystem';\nimport type { FileReadTracker } from '../filesystem';\nimport {\n  extractLinesWithLimit,\n  formatWithLineNumbers,\n  replaceString,\n  StringNotFoundError,\n  StringNotUniqueError,\n} from '../line-utils';\nimport type { Workspace } from '../workspace';\nimport { formatAsTree } from './tree-formatter';\nimport type { WorkspaceToolsConfig } from './types';\n\n/**\n * Resolves the effective configuration for a specific tool.\n *\n * Resolution order (later overrides earlier):\n * 1. Built-in defaults (enabled: true, requireApproval: false)\n * 2. Top-level config (tools.enabled, tools.requireApproval)\n * 3. Per-tool config (tools[toolName].enabled, tools[toolName].requireApproval)\n *\n * @param toolsConfig - The workspace tools configuration\n * @param toolName - The tool name to resolve config for\n * @returns Resolved enabled and requireApproval values\n */\nexport function resolveToolConfig(\n  toolsConfig: WorkspaceToolsConfig | undefined,\n  toolName: WorkspaceToolName,\n): { enabled: boolean; requireApproval: boolean; requireReadBeforeWrite?: boolean } {\n  // Built-in defaults\n  let enabled = true;\n  let requireApproval = false;\n  let requireReadBeforeWrite: boolean | undefined;\n\n  if (toolsConfig) {\n    // Apply top-level defaults\n    if (toolsConfig.enabled !== undefined) {\n      enabled = toolsConfig.enabled;\n    }\n    if (toolsConfig.requireApproval !== undefined) {\n      requireApproval = toolsConfig.requireApproval;\n    }\n\n    // Apply per-tool overrides\n    const perToolConfig = toolsConfig[toolName];\n    if (perToolConfig) {\n      if (perToolConfig.enabled !== undefined) {\n        enabled = perToolConfig.enabled;\n      }\n      if (perToolConfig.requireApproval !== undefined) {\n        requireApproval = perToolConfig.requireApproval;\n      }\n      if (perToolConfig.requireReadBeforeWrite !== undefined) {\n        requireReadBeforeWrite = perToolConfig.requireReadBeforeWrite;\n      }\n    }\n  }\n\n  return { enabled, requireApproval, requireReadBeforeWrite };\n}\n\n/**\n * Creates workspace tools that will be auto-injected into agents.\n *\n * @param workspace - The workspace instance to bind tools to\n * @returns Record of workspace tools\n */\nexport function createWorkspaceTools(workspace: Workspace) {\n  const tools: Record<string, any> = {};\n  const toolsConfig = workspace.getToolsConfig();\n  const isReadOnly = workspace.filesystem?.readOnly ?? false;\n\n  // Create a shared file read tracker for requireReadBeforeWrite enforcement\n  // This is only used by tools, not by direct workspace method calls\n  let readTracker: FileReadTracker | undefined;\n\n  // Check if any write tool has requireReadBeforeWrite enabled\n  const writeFileConfig = resolveToolConfig(toolsConfig, WORKSPACE_TOOLS.FILESYSTEM.WRITE_FILE);\n  const editFileConfig = resolveToolConfig(toolsConfig, WORKSPACE_TOOLS.FILESYSTEM.EDIT_FILE);\n  if (writeFileConfig.requireReadBeforeWrite || editFileConfig.requireReadBeforeWrite) {\n    readTracker = new InMemoryFileReadTracker();\n  }\n\n  // Only add filesystem tools if filesystem is available\n  if (workspace.filesystem) {\n    // Read file tool\n    const readFileConfig = resolveToolConfig(toolsConfig, WORKSPACE_TOOLS.FILESYSTEM.READ_FILE);\n    if (readFileConfig.enabled) {\n      tools[WORKSPACE_TOOLS.FILESYSTEM.READ_FILE] = createTool({\n        id: WORKSPACE_TOOLS.FILESYSTEM.READ_FILE,\n        description:\n          'Read the contents of a file from the workspace filesystem. Use offset/limit parameters to read specific line ranges for large files.',\n        requireApproval: readFileConfig.requireApproval,\n        inputSchema: z.object({\n          path: z.string().describe('The path to the file to read (e.g., \"/data/config.json\")'),\n          encoding: z\n            .enum(['utf-8', 'utf8', 'base64', 'hex', 'binary'])\n            .optional()\n            .describe('The encoding to use when reading the file. Defaults to utf-8 for text files.'),\n          offset: z\n            .number()\n            .optional()\n            .describe('Line number to start reading from (1-indexed). If omitted, starts from line 1.'),\n          limit: z\n            .number()\n            .optional()\n            .describe('Maximum number of lines to read. If omitted, reads to the end of the file.'),\n          showLineNumbers: z\n            .boolean()\n            .optional()\n            .default(true)\n            .describe('Whether to prefix each line with its line number (default: true)'),\n        }),\n        outputSchema: z.object({\n          content: z.string().describe('The file contents (with optional line number prefixes)'),\n          size: z.number().describe('The file size in bytes'),\n          path: z.string().describe('The full path to the file'),\n          lines: z\n            .object({\n              start: z.number().describe('First line number returned'),\n              end: z.number().describe('Last line number returned'),\n            })\n            .optional()\n            .describe('Line range information (when offset/limit used)'),\n          totalLines: z.number().optional().describe('Total number of lines in the file'),\n        }),\n        execute: async ({ path, encoding, offset, limit, showLineNumbers }) => {\n          // Default to utf-8 for text files\n          const effectiveEncoding = (encoding as BufferEncoding) ?? 'utf-8';\n          const fullContent = await workspace.filesystem!.readFile(path, {\n            encoding: effectiveEncoding,\n          });\n          const stat = await workspace.filesystem!.stat(path);\n\n          // Track the read for requireReadBeforeWrite enforcement\n          if (readTracker) {\n            readTracker.recordRead(path, stat.modifiedAt);\n          }\n\n          // Determine if this is a text encoding that should be line-processed\n          // Non-text encodings (base64, hex, binary, etc.) should not be line-processed\n          const isTextEncoding = !encoding || encoding === 'utf-8' || encoding === 'utf8';\n\n          // If non-text encoding, return without line processing to avoid corrupting data\n          if (!isTextEncoding) {\n            return {\n              content: fullContent,\n              size: stat.size,\n              path: stat.path,\n            };\n          }\n\n          // If content is somehow a Buffer (shouldn't happen with encoding), return as base64\n          if (typeof fullContent !== 'string') {\n            return {\n              content: fullContent.toString('base64'),\n              size: stat.size,\n              path: stat.path,\n            };\n          }\n\n          // Extract lines if offset or limit specified\n          const hasLineRange = offset !== undefined || limit !== undefined;\n          const result = extractLinesWithLimit(fullContent, offset, limit);\n\n          // Format with line numbers if requested (default: true)\n          const shouldShowLineNumbers = showLineNumbers !== false;\n          const formattedContent = shouldShowLineNumbers\n            ? formatWithLineNumbers(result.content, result.lines.start)\n            : result.content;\n\n          return {\n            content: formattedContent,\n            size: stat.size,\n            path: stat.path,\n            ...(hasLineRange && {\n              lines: result.lines,\n              totalLines: result.totalLines,\n            }),\n          };\n        },\n      });\n    }\n\n    // Write file tool (only if not in readonly mode)\n    // Note: writeFileConfig was already resolved above for tracker creation\n    if (!isReadOnly && writeFileConfig.enabled) {\n      tools[WORKSPACE_TOOLS.FILESYSTEM.WRITE_FILE] = createTool({\n        id: WORKSPACE_TOOLS.FILESYSTEM.WRITE_FILE,\n        description: 'Write content to a file in the workspace filesystem. Creates parent directories if needed.',\n        requireApproval: writeFileConfig.requireApproval,\n        inputSchema: z.object({\n          path: z.string().describe('The path where to write the file (e.g., \"/data/output.txt\")'),\n          content: z.string().describe('The content to write to the file'),\n          overwrite: z\n            .boolean()\n            .optional()\n            .default(true)\n            .describe('Whether to overwrite the file if it already exists'),\n        }),\n        outputSchema: z.object({\n          success: z.boolean(),\n          path: z.string().describe('The path where the file was written'),\n          size: z.number().describe('The size of the written content in bytes'),\n        }),\n        execute: async ({ path, content, overwrite }) => {\n          // Check read-before-write requirement (only for existing files)\n          if (readTracker && writeFileConfig.requireReadBeforeWrite) {\n            try {\n              const stat = await workspace.filesystem!.stat(path);\n              const check = readTracker.needsReRead(path, stat.modifiedAt);\n              if (check.needsReRead) {\n                throw new FileReadRequiredError(path, check.reason!);\n              }\n            } catch (error) {\n              // File doesn't exist - that's fine, no read-before-write check needed for new files\n              if (!(error instanceof FileNotFoundError)) {\n                throw error;\n              }\n            }\n          }\n\n          await workspace.filesystem!.writeFile(path, content, { overwrite });\n\n          // Clear the read record after successful write (requires a new read to write again)\n          if (readTracker) {\n            readTracker.clearReadRecord(path);\n          }\n\n          return {\n            success: true,\n            path,\n            size: Buffer.byteLength(content, 'utf-8'),\n          };\n        },\n      });\n    }\n\n    // Edit file tool (only if not in readonly mode)\n    // Note: editFileConfig was already resolved above for tracker creation\n    if (!isReadOnly && editFileConfig.enabled) {\n      tools[WORKSPACE_TOOLS.FILESYSTEM.EDIT_FILE] = createTool({\n        id: WORKSPACE_TOOLS.FILESYSTEM.EDIT_FILE,\n        description: `Edit a file by replacing specific text. The old_string must match exactly and be unique in the file.\n\nUsage:\n- Read the file first to get the exact text to replace.\n- By default, ${WORKSPACE_TOOLS.FILESYSTEM.READ_FILE} output includes line number prefixes (e.g., \"     1\"). Ensure you preserve the exact indentation as it appears AFTER the arrow. Never include any part of the line number prefix in old_string or new_string.\n- Include enough surrounding context (multiple lines) to make old_string unique. If it still isn't unique, include more lines.\n- Use replace_all only when intentionally replacing all occurrences.`,\n        requireApproval: editFileConfig.requireApproval,\n        inputSchema: z.object({\n          path: z.string().describe('The path to the file to edit'),\n          old_string: z.string().describe('The exact text to find and replace. Must be unique in the file.'),\n          new_string: z.string().describe('The text to replace old_string with'),\n          replace_all: z\n            .boolean()\n            .optional()\n            .default(false)\n            .describe('If true, replace all occurrences. If false (default), old_string must be unique.'),\n        }),\n        outputSchema: z.object({\n          success: z.boolean(),\n          path: z.string().describe('The path to the edited file'),\n          replacements: z.number().describe('Number of replacements made'),\n          error: z.string().optional().describe('Error message if the edit failed'),\n        }),\n        execute: async ({ path, old_string, new_string, replace_all }) => {\n          try {\n            // Check read-before-write requirement before reading\n            // Edit file needs the file to have been read by the read_file tool first\n            if (readTracker && editFileConfig.requireReadBeforeWrite) {\n              const stat = await workspace.filesystem!.stat(path);\n              const check = readTracker.needsReRead(path, stat.modifiedAt);\n              if (check.needsReRead) {\n                throw new FileReadRequiredError(path, check.reason!);\n              }\n            }\n\n            // Read the current file content\n            const content = await workspace.filesystem!.readFile(path, { encoding: 'utf-8' });\n\n            if (typeof content !== 'string') {\n              return {\n                success: false,\n                path,\n                replacements: 0,\n                error: 'Cannot edit binary files. Use workspace_write_file instead.',\n              };\n            }\n\n            // Perform the replacement with validation\n            const result = replaceString(content, old_string, new_string, replace_all);\n\n            // Write the modified content back\n            await workspace.filesystem!.writeFile(path, result.content, { overwrite: true });\n\n            // Clear the read record after successful write (requires a new read to write again)\n            if (readTracker) {\n              readTracker.clearReadRecord(path);\n            }\n\n            return {\n              success: true,\n              path,\n              replacements: result.replacements,\n            };\n          } catch (error) {\n            if (error instanceof FileReadRequiredError) {\n              throw error; // Re-throw to be handled by caller\n            }\n            if (error instanceof StringNotFoundError) {\n              return {\n                success: false,\n                path,\n                replacements: 0,\n                error: error.message,\n              };\n            }\n            if (error instanceof StringNotUniqueError) {\n              return {\n                success: false,\n                path,\n                replacements: 0,\n                error: error.message,\n              };\n            }\n            throw error;\n          }\n        },\n      });\n    }\n\n    // List files tool\n    const listFilesConfig = resolveToolConfig(toolsConfig, WORKSPACE_TOOLS.FILESYSTEM.LIST_FILES);\n    if (listFilesConfig.enabled) {\n      tools[WORKSPACE_TOOLS.FILESYSTEM.LIST_FILES] = createTool({\n        id: WORKSPACE_TOOLS.FILESYSTEM.LIST_FILES,\n        description: `List files and directories in the workspace filesystem.\nReturns a tree-style view (like the Unix \"tree\" command) for easy visualization.\nThe output is displayed to the user as a tree-like structure in the tool result.\nOptions mirror common tree command flags for familiarity.\n\nExamples:\n- List root: { path: \"/\" }\n- Deep listing: { path: \"/src\", maxDepth: 5 }\n- Directories only: { path: \"/\", dirsOnly: true }\n- Exclude node_modules: { path: \"/\", exclude: \"node_modules\" }`,\n        requireApproval: listFilesConfig.requireApproval,\n        inputSchema: z.object({\n          path: z.string().default('/').describe('Directory path to list'),\n          maxDepth: z\n            .number()\n            .optional()\n            .default(3)\n            .describe('Maximum depth to descend (default: 3). Similar to tree -L flag.'),\n          showHidden: z\n            .boolean()\n            .optional()\n            .default(false)\n            .describe('Show hidden files starting with \".\" (default: false). Similar to tree -a flag.'),\n          dirsOnly: z\n            .boolean()\n            .optional()\n            .default(false)\n            .describe('List directories only, no files (default: false). Similar to tree -d flag.'),\n          exclude: z\n            .string()\n            .optional()\n            .describe('Pattern to exclude (e.g., \"node_modules\"). Similar to tree -I flag.'),\n          extension: z.string().optional().describe('Filter by file extension (e.g., \".ts\"). Similar to tree -P flag.'),\n        }),\n        outputSchema: z.object({\n          tree: z.string().describe('Tree-style directory listing'),\n          summary: z.string().describe('Summary of directories and files (e.g., \"3 directories, 12 files\")'),\n          metadata: z\n            .object({\n              workspace: z\n                .object({\n                  id: z.string().optional(),\n                  name: z.string().optional(),\n                })\n                .optional(),\n              filesystem: z\n                .object({\n                  id: z.string().optional(),\n                  name: z.string().optional(),\n                  provider: z.string().optional(),\n                })\n                .optional(),\n            })\n            .optional()\n            .describe('Metadata about the workspace and filesystem'),\n        }),\n        execute: async ({ path = '/', maxDepth = 3, showHidden, dirsOnly, exclude, extension }) => {\n          const result = await formatAsTree(workspace.filesystem!, path, {\n            maxDepth,\n            showHidden,\n            dirsOnly,\n            exclude: exclude || undefined,\n            extension: extension || undefined,\n          });\n\n          // Include workspace/filesystem metadata for UI display\n          const fs = workspace.filesystem!;\n          const metadata = {\n            workspace: {\n              id: workspace.id,\n              name: workspace.name,\n            },\n            filesystem: {\n              id: fs.id,\n              name: fs.name,\n              provider: fs.provider,\n            },\n          };\n\n          return {\n            tree: result.tree,\n            summary: result.summary,\n            metadata,\n          };\n        },\n      });\n    }\n\n    // Delete tool (only if not in readonly mode)\n    const deleteConfig = resolveToolConfig(toolsConfig, WORKSPACE_TOOLS.FILESYSTEM.DELETE);\n    if (!isReadOnly && deleteConfig.enabled) {\n      tools[WORKSPACE_TOOLS.FILESYSTEM.DELETE] = createTool({\n        id: WORKSPACE_TOOLS.FILESYSTEM.DELETE,\n        description: 'Delete a file or directory from the workspace filesystem',\n        requireApproval: deleteConfig.requireApproval,\n        inputSchema: z.object({\n          path: z.string().describe('The path to the file or directory to delete'),\n          recursive: z\n            .boolean()\n            .optional()\n            .default(false)\n            .describe(\n              'If true, delete directories and their contents recursively. Required for non-empty directories.',\n            ),\n        }),\n        outputSchema: z.object({\n          success: z.boolean(),\n          path: z.string(),\n        }),\n        execute: async ({ path, recursive }) => {\n          const stat = await workspace.filesystem!.stat(path);\n          if (stat.type === 'directory') {\n            await workspace.filesystem!.rmdir(path, { recursive, force: recursive });\n          } else {\n            await workspace.filesystem!.deleteFile(path);\n          }\n          return { success: true, path };\n        },\n      });\n    }\n\n    // File stat tool\n    const fileStatConfig = resolveToolConfig(toolsConfig, WORKSPACE_TOOLS.FILESYSTEM.FILE_STAT);\n    if (fileStatConfig.enabled) {\n      tools[WORKSPACE_TOOLS.FILESYSTEM.FILE_STAT] = createTool({\n        id: WORKSPACE_TOOLS.FILESYSTEM.FILE_STAT,\n        description:\n          'Get file or directory metadata from the workspace. Returns existence, type, size, and modification time.',\n        requireApproval: fileStatConfig.requireApproval,\n        inputSchema: z.object({\n          path: z.string().describe('The path to check'),\n        }),\n        outputSchema: z.object({\n          exists: z.boolean().describe('Whether the path exists'),\n          type: z.enum(['file', 'directory', 'none']).describe('The type of the path if it exists'),\n          size: z.number().optional().describe('Size in bytes (for files)'),\n          modifiedAt: z.string().optional().describe('Last modification time (ISO string)'),\n        }),\n        execute: async ({ path }) => {\n          try {\n            const stat = await workspace.filesystem!.stat(path);\n            return {\n              exists: true,\n              type: stat.type,\n              size: stat.size,\n              modifiedAt: stat.modifiedAt.toISOString(),\n            };\n          } catch (error) {\n            // FileNotFoundError indicates the path doesn't exist\n            // Other errors (permissions, I/O) are propagated\n            if (error instanceof FileNotFoundError) {\n              return { exists: false, type: 'none' as const };\n            }\n            throw error;\n          }\n        },\n      });\n    }\n\n    // Mkdir tool (only if not in readonly mode)\n    const mkdirConfig = resolveToolConfig(toolsConfig, WORKSPACE_TOOLS.FILESYSTEM.MKDIR);\n    if (!isReadOnly && mkdirConfig.enabled) {\n      tools[WORKSPACE_TOOLS.FILESYSTEM.MKDIR] = createTool({\n        id: WORKSPACE_TOOLS.FILESYSTEM.MKDIR,\n        description: 'Create a directory in the workspace filesystem',\n        requireApproval: mkdirConfig.requireApproval,\n        inputSchema: z.object({\n          path: z.string().describe('The path of the directory to create'),\n          recursive: z\n            .boolean()\n            .optional()\n            .default(true)\n            .describe('Whether to create parent directories if they do not exist'),\n        }),\n        outputSchema: z.object({\n          success: z.boolean(),\n          path: z.string(),\n        }),\n        execute: async ({ path, recursive }) => {\n          await workspace.filesystem!.mkdir(path, { recursive });\n          return { success: true, path };\n        },\n      });\n    }\n  }\n\n  // Only add search tools if search is available\n  if (workspace.canBM25 || workspace.canVector) {\n    // Search tool\n    const searchConfig = resolveToolConfig(toolsConfig, WORKSPACE_TOOLS.SEARCH.SEARCH);\n    if (searchConfig.enabled) {\n      tools[WORKSPACE_TOOLS.SEARCH.SEARCH] = createTool({\n        id: WORKSPACE_TOOLS.SEARCH.SEARCH,\n        description:\n          'Search indexed content in the workspace. Supports keyword (BM25), semantic (vector), and hybrid search modes.',\n        requireApproval: searchConfig.requireApproval,\n        inputSchema: z.object({\n          query: z.string().describe('The search query string'),\n          topK: z.number().optional().default(5).describe('Maximum number of results to return'),\n          mode: z\n            .enum(['bm25', 'vector', 'hybrid'])\n            .optional()\n            .describe('Search mode: bm25 for keyword search, vector for semantic search, hybrid for both combined'),\n          minScore: z.number().optional().describe('Minimum score threshold (0-1 for normalized scores)'),\n        }),\n        outputSchema: z.object({\n          results: z.array(\n            z.object({\n              id: z.string().describe('Document/file path'),\n              content: z.string().describe('The matching content'),\n              score: z.number().describe('Relevance score'),\n              lineRange: z\n                .object({\n                  start: z.number(),\n                  end: z.number(),\n                })\n                .optional()\n                .describe('Line range where query terms were found'),\n            }),\n          ),\n          count: z.number().describe('Number of results returned'),\n          mode: z.string().describe('The search mode that was used'),\n        }),\n        execute: async ({ query, topK, mode, minScore }) => {\n          const results = await workspace.search(query, {\n            topK,\n            mode: mode as 'bm25' | 'vector' | 'hybrid' | undefined,\n            minScore,\n          });\n          return {\n            results: results.map(r => ({\n              id: r.id,\n              content: r.content,\n              score: r.score,\n              lineRange: r.lineRange,\n            })),\n            count: results.length,\n            mode: mode ?? (workspace.canHybrid ? 'hybrid' : workspace.canVector ? 'vector' : 'bm25'),\n          };\n        },\n      });\n    }\n\n    // Index tool (only if not in readonly mode)\n    const indexConfig = resolveToolConfig(toolsConfig, WORKSPACE_TOOLS.SEARCH.INDEX);\n    if (!isReadOnly && indexConfig.enabled) {\n      tools[WORKSPACE_TOOLS.SEARCH.INDEX] = createTool({\n        id: WORKSPACE_TOOLS.SEARCH.INDEX,\n        description: 'Index content for search. The path becomes the document ID in search results.',\n        requireApproval: indexConfig.requireApproval,\n        inputSchema: z.object({\n          path: z.string().describe('The document ID/path for search results'),\n          content: z.string().describe('The text content to index'),\n          metadata: z.record(z.unknown()).optional().describe('Optional metadata to store with the document'),\n        }),\n        outputSchema: z.object({\n          success: z.boolean(),\n          path: z.string().describe('The indexed document ID'),\n        }),\n        execute: async ({ path, content, metadata }) => {\n          await workspace.index(path, content, { metadata });\n          return { success: true, path };\n        },\n      });\n    }\n  }\n\n  // Only add sandbox tools if sandbox is available\n  if (workspace.sandbox) {\n    // Get path context for dynamic descriptions\n    const pathContext = workspace.getPathContext();\n\n    // Use provider-supplied instructions\n    const pathInfo = pathContext.instructions ? ` ${pathContext.instructions}` : '';\n\n    // Execute command tool (only if sandbox implements it)\n    const executeCommandConfig = resolveToolConfig(toolsConfig, WORKSPACE_TOOLS.SANDBOX.EXECUTE_COMMAND);\n    if (workspace.sandbox.executeCommand && executeCommandConfig.enabled) {\n      tools[WORKSPACE_TOOLS.SANDBOX.EXECUTE_COMMAND] = createTool({\n        id: WORKSPACE_TOOLS.SANDBOX.EXECUTE_COMMAND,\n        description: `Execute a shell command in the workspace sandbox.${pathInfo}\n\nUsage:\n- Verify parent directories exist before running commands that create files or directories.\n- Always quote file paths that contain spaces (e.g., cd \"/path/with spaces\").\n- Use the timeout parameter to limit execution time. Behavior when omitted depends on the sandbox provider.\n- Use cwd to set the working directory, or commands run from the sandbox default.`,\n        requireApproval: executeCommandConfig.requireApproval,\n        inputSchema: z.object({\n          command: z.string().describe('The command to execute (e.g., \"ls\", \"npm\", \"python\")'),\n          args: z.array(z.string()).nullish().default([]).describe('Arguments to pass to the command'),\n          timeout: z\n            .number()\n            .nullish()\n            .describe('Maximum execution time in milliseconds. Example: 60000 for 1 minute.'),\n          cwd: z.string().nullish().describe('Working directory for the command'),\n        }),\n        outputSchema: z.object({\n          success: z.boolean().describe('Whether the command executed successfully (exit code 0)'),\n          stdout: z.string().describe('Standard output from the command'),\n          stderr: z.string().describe('Standard error output'),\n          exitCode: z.number().describe('Exit code (0 = success)'),\n          executionTimeMs: z.number().describe('How long the execution took in milliseconds'),\n        }),\n        execute: async ({ command, args, timeout, cwd }, context) => {\n          const getExecutionMetadata = () => ({\n            workspace: {\n              id: workspace.id,\n              name: workspace.name,\n            },\n            sandbox: {\n              id: workspace.sandbox?.id,\n              name: workspace.sandbox?.name,\n              provider: workspace.sandbox?.provider,\n              status: workspace.sandbox?.status,\n            },\n          });\n\n          const startedAt = Date.now();\n          try {\n            const result = await workspace.sandbox!.executeCommand!(command, args ?? [], {\n              timeout: timeout ?? undefined,\n              cwd: cwd ?? undefined,\n              // Stream stdout/stderr as tool-output chunks for proper UI integration\n              onStdout: async (data: string) => {\n                await context?.writer?.write({\n                  type: 'sandbox-stdout',\n                  data,\n                  timestamp: Date.now(),\n                  metadata: getExecutionMetadata(),\n                });\n              },\n              onStderr: async (data: string) => {\n                await context?.writer?.write({\n                  type: 'sandbox-stderr',\n                  data,\n                  timestamp: Date.now(),\n                  metadata: getExecutionMetadata(),\n                });\n              },\n            });\n            // Emit exit chunk so UI knows streaming is complete\n            await context?.writer?.write({\n              type: 'sandbox-exit',\n              exitCode: result.exitCode,\n              success: result.success,\n              executionTimeMs: result.executionTimeMs,\n              metadata: getExecutionMetadata(),\n            });\n            return {\n              success: result.success,\n              stdout: result.stdout,\n              stderr: result.stderr,\n              exitCode: result.exitCode,\n              executionTimeMs: result.executionTimeMs,\n            };\n          } catch (error) {\n            // Always emit exit chunk on error so UI knows streaming is complete\n            await context?.writer?.write({\n              type: 'sandbox-exit',\n              exitCode: -1,\n              success: false,\n              executionTimeMs: Date.now() - startedAt,\n              metadata: getExecutionMetadata(),\n            });\n            throw error;\n          }\n        },\n      });\n    }\n  }\n\n  return tools;\n}\n"]}