'use strict';

var chunk6XCINXZ7_cjs = require('../chunk-6XCINXZ7.cjs');
var chunkVTE2OBKS_cjs = require('../chunk-VTE2OBKS.cjs');
var chunkBP7VYTOP_cjs = require('../chunk-BP7VYTOP.cjs');
var chunkZIEQA3YP_cjs = require('../chunk-ZIEQA3YP.cjs');
var chunkCC3OOESY_cjs = require('../chunk-CC3OOESY.cjs');
var chunk4U7ZLI36_cjs = require('../chunk-4U7ZLI36.cjs');
var chunkRO47SMI7_cjs = require('../chunk-RO47SMI7.cjs');

// src/vector/vector.ts
var supportedEmbeddingModelSpecifications = ["v2", "v3"];
var isSupportedEmbeddingModel = (model) => {
  return supportedEmbeddingModelSpecifications.includes(
    model.specificationVersion
  );
};
var MastraVector = class extends chunkRO47SMI7_cjs.MastraBase {
  id;
  constructor({ id }) {
    if (!id || typeof id !== "string" || id.trim() === "") {
      throw new chunk4U7ZLI36_cjs.MastraError({
        id: "VECTOR_INVALID_ID",
        text: "Vector id must be provided and cannot be empty",
        domain: "MASTRA_VECTOR" /* MASTRA_VECTOR */,
        category: "USER" /* USER */
      });
    }
    super({ name: "MastraVector", component: "VECTOR" });
    this.id = id;
  }
  get indexSeparator() {
    return "_";
  }
  async validateExistingIndex(indexName, dimension, metric) {
    let info;
    try {
      info = await this.describeIndex({ indexName });
    } catch (infoError) {
      const mastraError = new chunk4U7ZLI36_cjs.MastraError(
        {
          id: "VECTOR_VALIDATE_INDEX_FETCH_FAILED",
          text: `Index "${indexName}" already exists, but failed to fetch index info for dimension check.`,
          domain: "MASTRA_VECTOR" /* MASTRA_VECTOR */,
          category: "SYSTEM" /* SYSTEM */,
          details: { indexName }
        },
        infoError
      );
      this.logger?.trackException(mastraError);
      this.logger?.error(mastraError.toString());
      throw mastraError;
    }
    const existingDim = info?.dimension;
    const existingMetric = info?.metric;
    if (existingDim === dimension) {
      this.logger?.info(
        `Index "${indexName}" already exists with ${existingDim} dimensions and metric ${existingMetric}, skipping creation.`
      );
      if (existingMetric !== metric) {
        this.logger?.warn(
          `Attempted to create index with metric "${metric}", but index already exists with metric "${existingMetric}". To use a different metric, delete and recreate the index.`
        );
      }
    } else if (info) {
      const mastraError = new chunk4U7ZLI36_cjs.MastraError({
        id: "VECTOR_VALIDATE_INDEX_DIMENSION_MISMATCH",
        text: `Index "${indexName}" already exists with ${existingDim} dimensions, but ${dimension} dimensions were requested`,
        domain: "MASTRA_VECTOR" /* MASTRA_VECTOR */,
        category: "USER" /* USER */,
        details: { indexName, existingDim, requestedDim: dimension }
      });
      this.logger?.trackException(mastraError);
      this.logger?.error(mastraError.toString());
      throw mastraError;
    } else {
      const mastraError = new chunk4U7ZLI36_cjs.MastraError({
        id: "VECTOR_VALIDATE_INDEX_NO_DIMENSION",
        text: `Index "${indexName}" already exists, but could not retrieve its dimensions for validation.`,
        domain: "MASTRA_VECTOR" /* MASTRA_VECTOR */,
        category: "SYSTEM" /* SYSTEM */,
        details: { indexName }
      });
      this.logger?.trackException(mastraError);
      this.logger?.error(mastraError.toString());
      throw mastraError;
    }
  }
};

// src/vector/validation.ts
function validateUpsertInput(storeName, vectors, metadata, ids) {
  if (!vectors || vectors.length === 0) {
    throw new chunk4U7ZLI36_cjs.MastraError({
      id: chunkBP7VYTOP_cjs.createVectorErrorId(storeName, "UPSERT", "EMPTY_VECTORS"),
      domain: "MASTRA_VECTOR" /* MASTRA_VECTOR */,
      category: "USER" /* USER */,
      details: {
        message: "Vectors array cannot be empty"
      }
    });
  }
  if (metadata && metadata.length > 0 && metadata.length !== vectors.length) {
    throw new chunk4U7ZLI36_cjs.MastraError({
      id: chunkBP7VYTOP_cjs.createVectorErrorId(storeName, "UPSERT", "METADATA_LENGTH_MISMATCH"),
      domain: "MASTRA_VECTOR" /* MASTRA_VECTOR */,
      category: "USER" /* USER */,
      details: {
        message: "Metadata array length must match vectors array length",
        vectorsLength: vectors.length,
        metadataLength: metadata.length
      }
    });
  }
  if (ids && ids.length !== vectors.length) {
    throw new chunk4U7ZLI36_cjs.MastraError({
      id: chunkBP7VYTOP_cjs.createVectorErrorId(storeName, "UPSERT", "IDS_LENGTH_MISMATCH"),
      domain: "MASTRA_VECTOR" /* MASTRA_VECTOR */,
      category: "USER" /* USER */,
      details: {
        message: "IDs array length must match vectors array length",
        vectorsLength: vectors.length,
        idsLength: ids.length
      }
    });
  }
}
function validateTopK(storeName, topK) {
  if (!Number.isInteger(topK) || topK <= 0) {
    throw new chunk4U7ZLI36_cjs.MastraError({
      id: chunkBP7VYTOP_cjs.createVectorErrorId(storeName, "QUERY", "INVALID_TOP_K"),
      domain: "MASTRA_VECTOR" /* MASTRA_VECTOR */,
      category: "USER" /* USER */,
      details: {
        message: "topK must be a positive integer",
        topK
      }
    });
  }
}
function validateVectorValues(storeName, vectors) {
  for (let i = 0; i < vectors.length; i++) {
    const vector = vectors[i];
    if (!vector) {
      throw new chunk4U7ZLI36_cjs.MastraError({
        id: chunkBP7VYTOP_cjs.createVectorErrorId(storeName, "UPSERT", "INVALID_VECTOR"),
        domain: "MASTRA_VECTOR" /* MASTRA_VECTOR */,
        category: "USER" /* USER */,
        details: {
          message: `Vector at index ${i} is null or undefined`,
          vectorIndex: i
        }
      });
    }
    for (let j = 0; j < vector.length; j++) {
      const value = vector[j];
      if (value === null || value === void 0 || !Number.isFinite(value)) {
        throw new chunk4U7ZLI36_cjs.MastraError({
          id: chunkBP7VYTOP_cjs.createVectorErrorId(storeName, "UPSERT", "INVALID_VECTOR_VALUE"),
          domain: "MASTRA_VECTOR" /* MASTRA_VECTOR */,
          category: "USER" /* USER */,
          details: {
            message: `Vector contains invalid value (null, undefined, NaN, or Infinity) at position [${i}][${j}]`,
            vectorIndex: i,
            componentIndex: j,
            value: String(value)
          }
        });
      }
    }
  }
}
function validateUpsert(storeName, vectors, metadata, ids, validateValues = false) {
  validateUpsertInput(storeName, vectors, metadata, ids);
  if (validateValues && vectors) {
    validateVectorValues(storeName, vectors);
  }
}

Object.defineProperty(exports, "BaseFilterTranslator", {
  enumerable: true,
  get: function () { return chunk6XCINXZ7_cjs.BaseFilterTranslator; }
});
Object.defineProperty(exports, "embedV3", {
  enumerable: true,
  get: function () { return chunkVTE2OBKS_cjs.embed; }
});
Object.defineProperty(exports, "embedV2", {
  enumerable: true,
  get: function () { return chunkZIEQA3YP_cjs.embed; }
});
Object.defineProperty(exports, "embedV1", {
  enumerable: true,
  get: function () { return chunkCC3OOESY_cjs.embed; }
});
exports.MastraVector = MastraVector;
exports.isSupportedEmbeddingModel = isSupportedEmbeddingModel;
exports.supportedEmbeddingModelSpecifications = supportedEmbeddingModelSpecifications;
exports.validateTopK = validateTopK;
exports.validateUpsert = validateUpsert;
exports.validateUpsertInput = validateUpsertInput;
exports.validateVectorValues = validateVectorValues;
//# sourceMappingURL=index.cjs.map
//# sourceMappingURL=index.cjs.map