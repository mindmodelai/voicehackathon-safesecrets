{"version":3,"sources":["../src/workflows/evented/step-executor.ts","../src/workflows/evented/helpers.ts","../src/events/processor.ts","../src/workflows/evented/workflow-event-processor/loop.ts","../src/workflows/evented/workflow-event-processor/parallel.ts","../src/workflows/evented/workflow-event-processor/sleep.ts","../src/workflows/evented/workflow-event-processor/index.ts","../src/workflows/evented/workflow.ts","../src/workflows/evented/workflow-event-processor/utils.ts","../src/workflows/evented/execution-engine.ts"],"names":["MastraBase","RegisteredLogger","validateStepInput","randomUUID","createDeprecationProxy","getStepResult","validationError","validateStepSuspendData","ToolStream","PUBSUB_SYMBOL","STREAM_FORMAT_SYMBOL","runCountDeprecationMessage","getErrorFromUnknown","MastraError","TripWire","RequestContext","isNestedWorkflow","targetArray","iterationPrevResult","workflowsStore","createPendingMarker","step","createTimeTravelExecutionParams","EventEmitter","validateStepResumeData","Workflow","Agent","Tool","z","isSupportedLanguageModel","ProcessorStepSchema","ProcessorStepOutputSchema","MessageList","ProcessorRunner","processorSpan","processorTracingContext","Run","ReadableStream","WorkflowRunOutput","ExecutionEngine","hydrateSerializedStepErrors","cleanStepResult"],"mappings":"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","file":"chunk-64WGYTQK.cjs","sourcesContent":["import { randomUUID } from 'node:crypto';\nimport { TripWire } from '../../agent/trip-wire';\nimport { MastraBase } from '../../base';\nimport type { RequestContext } from '../../di';\nimport { MastraError, ErrorDomain, ErrorCategory } from '../../error';\nimport { getErrorFromUnknown } from '../../error/utils.js';\nimport { RegisteredLogger } from '../../logger';\nimport type { Mastra } from '../../mastra';\nimport { ToolStream } from '../../tools/stream';\nimport { PUBSUB_SYMBOL, STREAM_FORMAT_SYMBOL } from '../constants';\nimport { getStepResult } from '../step';\nimport type { InnerOutput, LoopConditionFunction, Step, SuspendOptions } from '../step';\nimport type { StepFlowEntry, StepResult } from '../types';\nimport {\n  validateStepInput,\n  createDeprecationProxy,\n  runCountDeprecationMessage,\n  validateStepSuspendData,\n} from '../utils';\n\nexport class StepExecutor extends MastraBase {\n  protected mastra?: Mastra;\n  constructor({ mastra }: { mastra?: Mastra }) {\n    super({ name: 'StepExecutor', component: RegisteredLogger.WORKFLOW });\n    this.mastra = mastra;\n  }\n\n  __registerMastra(mastra: Mastra) {\n    this.mastra = mastra;\n    const logger = mastra?.getLogger();\n    if (logger) {\n      this.__setLogger(logger);\n    }\n  }\n\n  /**\n   * Creates an output writer function that publishes chunks to the workflow event stream.\n   * @param runId - The workflow run ID\n   * @returns An async function that writes chunks to the pubsub\n   */\n  private createOutputWriter(runId: string): (chunk: unknown) => Promise<void> {\n    return async (chunk: unknown) => {\n      try {\n        if (this.mastra?.pubsub) {\n          await this.mastra.pubsub.publish(`workflow.events.v2.${runId}`, {\n            type: 'watch',\n            runId,\n            data: chunk,\n          });\n        }\n      } catch (err) {\n        // Non-critical: streaming events are observational\n        // Errors here should not fail step execution\n        this.logger.debug('Failed to publish workflow watch event', { runId, error: err });\n      }\n    };\n  }\n\n  async execute(params: {\n    workflowId: string;\n    step: Step<any, any, any, any>;\n    runId: string;\n    input?: any;\n    resumeData?: any;\n    stepResults: Record<string, StepResult<any, any, any, any>>;\n    state: Record<string, any>;\n    requestContext: RequestContext;\n    retryCount?: number;\n    foreachIdx?: number;\n    validateInputs?: boolean;\n    abortController?: AbortController;\n    perStep?: boolean;\n  }): Promise<StepResult<any, any, any, any>> {\n    const { step, stepResults, runId, requestContext, retryCount = 0, perStep } = params;\n\n    // Use provided abortController or create a new one for backwards compatibility\n    const abortController = params.abortController ?? new AbortController();\n\n    let suspended: { payload: any } | undefined;\n    let bailed: { payload: any } | undefined;\n    const startedAt = Date.now();\n    const { inputData, validationError } = await validateStepInput({\n      prevOutput: typeof params.foreachIdx === 'number' ? params.input?.[params.foreachIdx] : params.input,\n      step,\n      validateInputs: params.validateInputs ?? true,\n    });\n\n    let stepInfo: {\n      startedAt: number;\n      payload: any;\n      resumePayload?: any;\n      resumedAt?: number;\n      [key: string]: any;\n    } = {\n      ...stepResults[step.id],\n      startedAt,\n      payload: (typeof params.foreachIdx === 'number' ? params.input : inputData) ?? {},\n    };\n\n    if (params.resumeData) {\n      stepInfo.resumePayload = params.resumeData;\n      stepInfo.resumedAt = Date.now();\n      // Strip __workflow_meta from suspendPayload when step is resumed\n      // This metadata is only needed during suspend, not in the final completed result\n      if (stepInfo.suspendPayload && '__workflow_meta' in stepInfo.suspendPayload) {\n        const { __workflow_meta, ...userSuspendPayload } = stepInfo.suspendPayload;\n        stepInfo.suspendPayload = userSuspendPayload;\n      }\n    }\n\n    // Extract suspend data if this step was previously suspended\n    let suspendDataToUse =\n      params.stepResults[step.id]?.status === 'suspended' ? params.stepResults[step.id]?.suspendPayload : undefined;\n\n    // Filter out internal workflow metadata before exposing to step code\n    if (suspendDataToUse && '__workflow_meta' in suspendDataToUse) {\n      const { __workflow_meta, ...userSuspendData } = suspendDataToUse;\n      suspendDataToUse = userSuspendData;\n    }\n\n    try {\n      if (validationError) {\n        throw validationError;\n      }\n\n      const callId = randomUUID();\n      const outputWriter = this.createOutputWriter(runId);\n\n      const stepOutput = await step.execute(\n        createDeprecationProxy(\n          {\n            workflowId: params.workflowId,\n            runId,\n            mastra: this.mastra!,\n            requestContext,\n            inputData,\n            state: params.state,\n            setState: async (newState: Record<string, any>) => {\n              // Merge new state with existing state (preserves other keys)\n              Object.assign(params.state, newState);\n            },\n            retryCount,\n            resumeData: params.resumeData,\n            suspendData: suspendDataToUse,\n            getInitData: () => stepResults?.input as any,\n            getStepResult: getStepResult.bind(this, stepResults),\n            suspend: async (suspendPayload: unknown, suspendOptions?: SuspendOptions): Promise<InnerOutput> => {\n              const { suspendData, validationError } = await validateStepSuspendData({\n                suspendData: suspendPayload,\n                step,\n                validateInputs: params.validateInputs ?? true,\n              });\n              if (validationError) {\n                throw validationError;\n              }\n              // Build resume labels if provided\n              const resumeLabels: Record<string, { stepId: string; foreachIndex?: number }> = {};\n              if (suspendOptions?.resumeLabel) {\n                const labels = Array.isArray(suspendOptions.resumeLabel)\n                  ? suspendOptions.resumeLabel\n                  : [suspendOptions.resumeLabel];\n                for (const label of labels) {\n                  resumeLabels[label] = {\n                    stepId: step.id,\n                    foreachIndex: params.foreachIdx,\n                  };\n                }\n              }\n              suspended = {\n                payload: {\n                  ...suspendData,\n                  __workflow_meta: {\n                    runId,\n                    path: [step.id],\n                    foreachIndex: params.foreachIdx,\n                    resumeLabels: Object.keys(resumeLabels).length > 0 ? resumeLabels : undefined,\n                  },\n                },\n              };\n            },\n            bail: (result: any): InnerOutput => {\n              bailed = { payload: result };\n            },\n            writer: new ToolStream(\n              {\n                prefix: 'workflow-step',\n                callId,\n                name: step.id,\n                runId,\n              },\n              outputWriter,\n            ),\n            abort: () => {\n              abortController?.abort();\n            },\n            [PUBSUB_SYMBOL]: this.mastra!.pubsub,\n            [STREAM_FORMAT_SYMBOL]: undefined, // TODO\n            engine: {},\n            abortSignal: abortController?.signal,\n            // TODO\n            tracingContext: {},\n          },\n          {\n            paramName: 'runCount',\n            deprecationMessage: runCountDeprecationMessage,\n            logger: this.logger,\n          },\n        ),\n      );\n\n      const isNestedWorkflowStep = step.component === 'WORKFLOW';\n\n      const nestedWflowStepPaused = isNestedWorkflowStep && perStep;\n\n      const endedAt = Date.now();\n\n      let finalResult: StepResult<any, any, any, any> & { __state?: Record<string, any> };\n      if (suspended) {\n        finalResult = {\n          ...stepInfo,\n          status: 'suspended',\n          suspendedAt: endedAt,\n          ...(stepOutput ? { suspendOutput: stepOutput } : {}),\n          __state: params.state,\n        };\n\n        if (suspended.payload) {\n          finalResult.suspendPayload = suspended.payload;\n        }\n      } else if (bailed) {\n        finalResult = {\n          ...stepInfo,\n          // @ts-expect-error - bailed status not in type\n          status: 'bailed',\n          endedAt,\n          output: bailed.payload,\n          __state: params.state,\n        };\n      } else if (nestedWflowStepPaused) {\n        finalResult = {\n          ...stepInfo,\n          status: 'paused',\n          __state: params.state,\n        };\n      } else {\n        finalResult = {\n          ...stepInfo,\n          status: 'success',\n          endedAt,\n          output: stepOutput,\n          __state: params.state,\n        };\n      }\n\n      return finalResult;\n    } catch (error: any) {\n      const endedAt = Date.now();\n\n      const errorInstance = getErrorFromUnknown(error, {\n        serializeStack: false,\n        fallbackMessage: 'Unknown step execution error',\n      });\n\n      // Log the error for observability (matching default engine behavior)\n      const stepId = params.step.id;\n      const mastraError = new MastraError(\n        {\n          id: 'WORKFLOW_STEP_INVOKE_FAILED',\n          domain: ErrorDomain.MASTRA_WORKFLOW,\n          category: ErrorCategory.USER,\n          details: { workflowId: params.workflowId, runId: params.runId, stepId },\n        },\n        errorInstance,\n      );\n      this.logger?.trackException(mastraError);\n      this.logger?.error(`Error executing step ${stepId}: ` + errorInstance?.stack);\n\n      return {\n        ...stepInfo,\n        status: 'failed',\n        endedAt,\n        error: errorInstance,\n        // Preserve TripWire data as plain object for proper serialization\n        // Important: Check `error` not `errorInstance` because getErrorFromUnknown\n        // converts the error and loses the prototype chain\n        tripwire:\n          error instanceof TripWire\n            ? {\n                reason: error.message,\n                retry: error.options?.retry,\n                metadata: error.options?.metadata,\n                processorId: error.processorId,\n              }\n            : undefined,\n      };\n    }\n  }\n\n  async evaluateConditions(params: {\n    workflowId: string;\n    step: Extract<StepFlowEntry, { type: 'conditional' }>;\n    runId: string;\n    input?: any;\n    resumeData?: any;\n    stepResults: Record<string, StepResult<any, any, any, any>>;\n    state: Record<string, any>;\n    requestContext: RequestContext;\n    retryCount?: number;\n    abortController?: AbortController;\n  }): Promise<number[]> {\n    const { step, stepResults, runId, requestContext, retryCount = 0 } = params;\n\n    const abortController = params.abortController ?? new AbortController();\n\n    const results = await Promise.all(\n      step.conditions.map(condition => {\n        try {\n          return this.evaluateCondition({\n            workflowId: params.workflowId,\n            condition,\n            runId,\n            requestContext,\n            inputData: params.input,\n            state: params.state,\n            retryCount,\n            resumeData: params.resumeData,\n            abortController,\n            stepResults,\n            iterationCount: 0,\n          });\n        } catch (e) {\n          this.mastra?.getLogger()?.error('error evaluating condition', e);\n          return false;\n        }\n      }),\n    );\n\n    const idxs = results.reduce((acc, result, idx) => {\n      if (result) {\n        acc.push(idx);\n      }\n\n      return acc;\n    }, [] as number[]);\n\n    return idxs;\n  }\n\n  async evaluateCondition({\n    workflowId,\n    condition,\n    runId,\n    inputData,\n    resumeData,\n    stepResults,\n    state,\n    requestContext,\n    abortController,\n    retryCount = 0,\n    iterationCount,\n  }: {\n    workflowId: string;\n    condition: LoopConditionFunction<any, any, any, any, any, any>;\n    runId: string;\n    inputData?: any;\n    resumeData?: any;\n    stepResults: Record<string, StepResult<any, any, any, any>>;\n    state: Record<string, any>;\n    requestContext: RequestContext;\n    abortController: AbortController;\n    retryCount?: number;\n    iterationCount: number;\n  }): Promise<boolean> {\n    const callId = randomUUID();\n    const outputWriter = this.createOutputWriter(runId);\n\n    return condition(\n      createDeprecationProxy(\n        {\n          workflowId,\n          runId,\n          mastra: this.mastra!,\n          requestContext,\n          inputData,\n          state,\n          retryCount,\n          resumeData: resumeData,\n          getInitData: () => stepResults?.input as any,\n          getStepResult: getStepResult.bind(this, stepResults),\n          bail: (_result: any) => {\n            throw new Error('Not implemented');\n          },\n          writer: new ToolStream(\n            {\n              prefix: 'workflow-step',\n              callId,\n              name: 'condition',\n              runId,\n            },\n            outputWriter,\n          ),\n          abort: () => {\n            abortController?.abort();\n          },\n          [PUBSUB_SYMBOL]: this.mastra!.pubsub,\n          [STREAM_FORMAT_SYMBOL]: undefined, // TODO\n          engine: {},\n          abortSignal: abortController?.signal,\n          // TODO\n          tracingContext: {},\n          iterationCount,\n        },\n        {\n          paramName: 'runCount',\n          deprecationMessage: runCountDeprecationMessage,\n          logger: this.logger,\n        },\n      ),\n    );\n  }\n\n  async resolveSleep(params: {\n    workflowId: string;\n    step: Extract<StepFlowEntry, { type: 'sleep' }>;\n    runId: string;\n    input?: any;\n    resumeData?: any;\n    stepResults: Record<string, StepResult<any, any, any, any>>;\n    state?: Record<string, any>;\n    requestContext: RequestContext;\n    retryCount?: number;\n    abortController?: AbortController;\n  }): Promise<number> {\n    const { step, stepResults, runId, requestContext, retryCount = 0 } = params;\n    const currentState = params.state ?? stepResults?.__state ?? {};\n\n    const abortController = params.abortController ?? new AbortController();\n\n    if (step.duration) {\n      return step.duration;\n    }\n\n    if (!step.fn) {\n      return 0;\n    }\n\n    try {\n      const callId = randomUUID();\n      const outputWriter = this.createOutputWriter(runId);\n\n      return await step.fn(\n        createDeprecationProxy(\n          {\n            workflowId: params.workflowId,\n            runId,\n            mastra: this.mastra!,\n            requestContext,\n            inputData: params.input,\n            state: currentState,\n            setState: async (newState: Record<string, any>) => {\n              Object.assign(currentState, newState);\n            },\n            retryCount,\n            resumeData: params.resumeData,\n            getInitData: () => stepResults?.input as any,\n            getStepResult: getStepResult.bind(this, stepResults),\n            suspend: async (_suspendPayload: any): Promise<any> => {\n              throw new Error('Not implemented');\n            },\n            bail: (_result: any) => {\n              throw new Error('Not implemented');\n            },\n            abort: () => {\n              abortController?.abort();\n            },\n            writer: new ToolStream(\n              {\n                prefix: 'workflow-step',\n                callId,\n                name: step.id,\n                runId,\n              },\n              outputWriter,\n            ),\n            [PUBSUB_SYMBOL]: this.mastra!.pubsub,\n            [STREAM_FORMAT_SYMBOL]: undefined, // TODO\n            engine: {},\n            abortSignal: abortController?.signal,\n            // TODO\n            tracingContext: {},\n          },\n          {\n            paramName: 'runCount',\n            deprecationMessage: runCountDeprecationMessage,\n            logger: this.logger,\n          },\n        ),\n      );\n    } catch (e) {\n      this.mastra?.getLogger()?.error('error evaluating condition', e);\n      return 0;\n    }\n  }\n\n  async resolveSleepUntil(params: {\n    workflowId: string;\n    step: Extract<StepFlowEntry, { type: 'sleepUntil' }>;\n    runId: string;\n    input?: any;\n    resumeData?: any;\n    stepResults: Record<string, StepResult<any, any, any, any>>;\n    state?: Record<string, any>;\n    requestContext: RequestContext;\n    retryCount?: number;\n    abortController?: AbortController;\n  }): Promise<number> {\n    const { step, stepResults, runId, requestContext, retryCount = 0 } = params;\n    const currentState = params.state ?? stepResults?.__state ?? {};\n\n    const abortController = params.abortController ?? new AbortController();\n\n    if (step.date) {\n      return step.date.getTime() - Date.now();\n    }\n\n    if (!step.fn) {\n      return 0;\n    }\n\n    try {\n      const callId = randomUUID();\n      const outputWriter = this.createOutputWriter(runId);\n\n      const result = await step.fn(\n        createDeprecationProxy(\n          {\n            workflowId: params.workflowId,\n            runId,\n            mastra: this.mastra!,\n            requestContext,\n            inputData: params.input,\n            state: currentState,\n            setState: async (newState: Record<string, any>) => {\n              Object.assign(currentState, newState);\n            },\n            retryCount,\n            resumeData: params.resumeData,\n            getInitData: () => stepResults?.input as any,\n            getStepResult: getStepResult.bind(this, stepResults),\n            suspend: async (_suspendPayload: any): Promise<any> => {\n              throw new Error('Not implemented');\n            },\n            bail: (_result: any) => {\n              throw new Error('Not implemented');\n            },\n            abort: () => {\n              abortController?.abort();\n            },\n            writer: new ToolStream(\n              {\n                prefix: 'workflow-step',\n                callId,\n                name: step.id,\n                runId,\n              },\n              outputWriter,\n            ),\n            [PUBSUB_SYMBOL]: this.mastra!.pubsub,\n            [STREAM_FORMAT_SYMBOL]: undefined, // TODO\n            engine: {},\n            abortSignal: abortController?.signal,\n            // TODO\n            tracingContext: {},\n          },\n          {\n            paramName: 'runCount',\n            deprecationMessage: runCountDeprecationMessage,\n            logger: this.logger,\n          },\n        ),\n      );\n\n      return result.getTime() - Date.now();\n    } catch (e) {\n      this.mastra?.getLogger()?.error('error evaluating condition', e);\n      return 0;\n    }\n  }\n}\n","/**\n * Helper functions for evented workflow execution.\n */\n\nimport { TripWire } from '../../agent/trip-wire';\n\n/**\n * Interface for tripwire chunks in the stream.\n * These chunks are emitted when a processor triggers a tripwire.\n */\nexport interface TripwireChunk {\n  type: 'tripwire';\n  payload: {\n    reason: string;\n    retry?: boolean;\n    metadata?: unknown;\n    processorId?: string;\n  };\n}\n\n/**\n * Type guard to check if a chunk is a tripwire chunk.\n * @param chunk - The chunk to check\n * @returns True if the chunk is a TripwireChunk\n */\nexport function isTripwireChunk(chunk: unknown): chunk is TripwireChunk {\n  return (\n    chunk !== null && typeof chunk === 'object' && 'type' in chunk && chunk.type === 'tripwire' && 'payload' in chunk\n  );\n}\n\n/**\n * Creates a TripWire error from a tripwire chunk.\n * @param chunk - The tripwire chunk from the stream\n * @returns A TripWire error instance\n */\nexport function createTripWireFromChunk(chunk: TripwireChunk): TripWire {\n  const { payload } = chunk;\n  return new TripWire(\n    payload.reason || 'Agent tripwire triggered',\n    {\n      retry: payload.retry,\n      metadata: payload.metadata,\n    },\n    payload.processorId,\n  );\n}\n\n/**\n * Extracts text delta from a stream chunk, handling V1 vs V2 differences.\n *\n * V1 (AI SDK v4): Uses `chunk.textDelta` for raw text\n * V2 (AI SDK v5): Uses `chunk.payload.text` for normalized text\n *\n * @param chunk - The stream chunk\n * @param isV2Model - Whether this is a V2 model (uses normalized payload)\n * @returns The text delta string, or undefined if not a text-delta chunk\n */\nexport function getTextDeltaFromChunk(\n  chunk: { type: string; textDelta?: string; payload?: { text?: string } },\n  isV2Model: boolean,\n): string | undefined {\n  if (chunk.type !== 'text-delta') {\n    return undefined;\n  }\n  return isV2Model ? chunk.payload?.text : chunk.textDelta;\n}\n\n/**\n * Parameters for resolving the current workflow state.\n */\nexport interface ResolveStateParams {\n  /** State from a step result (highest priority). Uses `any` to accommodate various StepResult types. */\n  stepResult?: unknown;\n  /** State from all step results */\n  stepResults?: { __state?: Record<string, unknown> };\n  /** State passed directly */\n  state?: Record<string, unknown>;\n}\n\n/**\n * Resolves the current workflow state from multiple potential sources.\n * Priority order: stepResult.__state > stepResults.__state > state > empty object\n *\n * @param params - The state sources to check\n * @returns The resolved state object\n */\nexport function resolveCurrentState(params: ResolveStateParams): Record<string, unknown> {\n  const { stepResult, stepResults, state } = params;\n  return (stepResult as any)?.__state ?? stepResults?.__state ?? state ?? {};\n}\n","import type { Mastra } from '../mastra';\nimport type { Event } from './types';\n\nexport abstract class EventProcessor {\n  protected mastra: Mastra;\n\n  __registerMastra(mastra: Mastra) {\n    this.mastra = mastra;\n  }\n\n  constructor({ mastra }: { mastra: Mastra }) {\n    this.mastra = mastra;\n  }\n\n  protected abstract process(event: Event): Promise<void>;\n}\n","import type { StepFlowEntry, StepResult } from '../..';\nimport { RequestContext } from '../../../di';\nimport type { PubSub } from '../../../events';\nimport type { Mastra } from '../../../mastra';\nimport { resolveCurrentState } from '../helpers';\nimport type { StepExecutor } from '../step-executor';\nimport { createPendingMarker } from '../types';\nimport type { ProcessorArgs } from '.';\n\nexport async function processWorkflowLoop(\n  {\n    workflowId,\n    prevResult,\n    runId,\n    executionPath,\n    stepResults,\n    activeSteps,\n    resumeSteps,\n    resumeData,\n    parentWorkflow,\n    requestContext,\n    retryCount = 0,\n    perStep,\n    state,\n    outputOptions,\n  }: ProcessorArgs,\n  {\n    pubsub,\n    stepExecutor,\n    step,\n    stepResult,\n  }: {\n    pubsub: PubSub;\n    stepExecutor: StepExecutor;\n    step: Extract<StepFlowEntry, { type: 'loop' }>;\n    stepResult: StepResult<any, any, any, any>;\n  },\n) {\n  // Get current state from stepResult, stepResults or passed state\n  const currentState = resolveCurrentState({ stepResult, stepResults, state });\n\n  // Create a proper RequestContext from the plain object passed in ProcessorArgs\n  const reqContext = new RequestContext(Object.entries(requestContext ?? {}) as any);\n\n  // Get iteration count from step results metadata (same pattern as control-flow.ts)\n  const prevIterationCount = stepResults[step.step?.id]?.metadata?.iterationCount ?? 0;\n  const iterationCount = prevIterationCount + 1;\n\n  const loopCondition = await stepExecutor.evaluateCondition({\n    workflowId,\n    condition: step.condition,\n    runId,\n    stepResults,\n    state: currentState,\n    requestContext: reqContext,\n    inputData: prevResult?.status === 'success' ? prevResult.output : undefined,\n    resumeData,\n    abortController: new AbortController(),\n    retryCount,\n    iterationCount,\n  });\n\n  if (step.loopType === 'dountil') {\n    if (loopCondition) {\n      await pubsub.publish('workflows', {\n        type: 'workflow.step.end',\n        runId,\n        data: {\n          parentWorkflow,\n          workflowId,\n          runId,\n          executionPath,\n          resumeSteps,\n          stepResults,\n          prevResult: stepResult,\n          resumeData,\n          activeSteps,\n          requestContext,\n          perStep,\n          state: currentState,\n          outputOptions,\n        },\n      });\n    } else {\n      await pubsub.publish('workflows', {\n        type: 'workflow.step.run',\n        runId,\n        data: {\n          parentWorkflow,\n          workflowId,\n          runId,\n          executionPath,\n          resumeSteps,\n          stepResults,\n          state: currentState,\n          outputOptions,\n          prevResult: stepResult,\n          resumeData,\n          activeSteps,\n          requestContext,\n          retryCount,\n          perStep,\n        },\n      });\n    }\n  } else {\n    if (loopCondition) {\n      await pubsub.publish('workflows', {\n        type: 'workflow.step.run',\n        runId,\n        data: {\n          parentWorkflow,\n          workflowId,\n          runId,\n          executionPath,\n          resumeSteps,\n          stepResults,\n          prevResult: stepResult,\n          resumeData,\n          activeSteps,\n          requestContext,\n          retryCount,\n          perStep,\n          state: currentState,\n          outputOptions,\n        },\n      });\n    } else {\n      await pubsub.publish('workflows', {\n        type: 'workflow.step.end',\n        runId,\n        data: {\n          parentWorkflow,\n          workflowId,\n          runId,\n          executionPath,\n          resumeSteps,\n          stepResults,\n          prevResult: stepResult,\n          resumeData,\n          activeSteps,\n          requestContext,\n          perStep,\n          state: currentState,\n          outputOptions,\n        },\n      });\n    }\n  }\n}\n\nexport async function processWorkflowForEach(\n  {\n    workflowId,\n    prevResult,\n    runId,\n    executionPath,\n    stepResults,\n    activeSteps,\n    resumeSteps,\n    timeTravel,\n    resumeData,\n    parentWorkflow,\n    requestContext,\n    perStep,\n    state,\n    outputOptions,\n    forEachIndex,\n  }: ProcessorArgs,\n  {\n    pubsub,\n    mastra,\n    step,\n  }: {\n    pubsub: PubSub;\n    mastra: Mastra;\n    step: Extract<StepFlowEntry, { type: 'foreach' }>;\n  },\n) {\n  // Get current state from stepResults or passed state\n  const currentState = resolveCurrentState({ stepResults, state });\n  const currentResult: Extract<StepResult<any, any, any, any>, { status: 'success' }> = stepResults[\n    step.step.id\n  ] as any;\n\n  const idx = currentResult?.output?.length ?? 0;\n  const targetLen = (prevResult as any)?.output?.length ?? 0;\n\n  // Handle resume with forEachIndex: kick off the targeted iteration resume\n  if (forEachIndex !== undefined && resumeSteps?.length > 0 && idx > 0) {\n    // Validate forEachIndex is within bounds to fail loudly instead of silently no-op\n    const outputArray = currentResult?.output;\n    const outputLength = Array.isArray(outputArray) ? outputArray.length : 0;\n    if (!Array.isArray(outputArray) || forEachIndex < 0 || forEachIndex >= outputLength) {\n      const error = new Error(\n        `Invalid forEachIndex ${forEachIndex} for forEach resume: ` +\n          `expected index in range [0, ${outputLength - 1}] but output array has length ${outputLength}`,\n      );\n      await pubsub.publish('workflows', {\n        type: 'workflow.fail',\n        runId,\n        data: {\n          parentWorkflow,\n          workflowId,\n          runId,\n          executionPath,\n          resumeSteps,\n          stepResults,\n          prevResult: { status: 'failed', error },\n          activeSteps,\n          requestContext,\n          state: currentState,\n          outputOptions,\n        },\n      });\n      return;\n    }\n\n    // Check if the target iteration is suspended\n    const iterationResult = currentResult?.output?.[forEachIndex];\n    if (iterationResult?.status === 'suspended' || iterationResult === null) {\n      // Only pass resumeData to the targeted iteration\n      const isNestedWorkflow = (step.step as any).component === 'WORKFLOW';\n      const targetArray = (prevResult as any)?.output;\n      const iterationPrevResult =\n        isNestedWorkflow && prevResult.status === 'success' && Array.isArray(targetArray)\n          ? { status: 'success' as const, output: targetArray[forEachIndex] }\n          : prevResult;\n\n      await pubsub.publish('workflows', {\n        type: 'workflow.step.run',\n        runId,\n        data: {\n          parentWorkflow,\n          workflowId,\n          runId,\n          executionPath: [executionPath[0]!, forEachIndex],\n          resumeSteps,\n          timeTravel,\n          stepResults,\n          prevResult: iterationPrevResult,\n          resumeData,\n          activeSteps,\n          requestContext,\n          perStep,\n          state: currentState,\n          outputOptions,\n        },\n      });\n      return;\n    }\n\n    // If forEachIndex was provided but the iteration is already complete,\n    // check if there are still pending (null or suspended) iterations.\n    // If so, re-suspend the workflow to wait for those to be resumed.\n    const pendingIterations = currentResult.output.filter((r: any) => r === null || r?.status === 'suspended');\n    if (pendingIterations.length > 0) {\n      // Collect resumeLabels from all suspended iterations\n      const collectedResumeLabels: Record<string, { stepId: string; foreachIndex?: number }> = {};\n      for (let i = 0; i < currentResult.output.length; i++) {\n        const iterResult = currentResult.output[i];\n        if (iterResult?.status === 'suspended' && iterResult.suspendPayload?.__workflow_meta?.resumeLabels) {\n          Object.assign(collectedResumeLabels, iterResult.suspendPayload.__workflow_meta.resumeLabels);\n        }\n      }\n\n      // Build the suspend metadata with all collected resumeLabels\n      const suspendMeta: {\n        foreachIndex?: number;\n        resumeLabels?: Record<string, { stepId: string; foreachIndex?: number }>;\n      } = {\n        foreachIndex: forEachIndex,\n      };\n      if (Object.keys(collectedResumeLabels).length > 0) {\n        suspendMeta.resumeLabels = collectedResumeLabels;\n      }\n\n      // Re-suspend the workflow - there are still pending iterations\n      // Use workflow.step.end with suspended status to update storage\n      await pubsub.publish('workflows', {\n        type: 'workflow.step.end',\n        runId,\n        data: {\n          parentWorkflow,\n          workflowId,\n          runId,\n          executionPath,\n          resumeSteps,\n          stepResults: {\n            ...stepResults,\n            [step.step.id]: {\n              ...currentResult,\n              status: 'suspended',\n              suspendedAt: Date.now(),\n              suspendPayload: { __workflow_meta: suspendMeta },\n            },\n          },\n          prevResult: {\n            status: 'suspended',\n            output: currentResult.output,\n            suspendPayload: { __workflow_meta: suspendMeta },\n            payload: currentResult.payload,\n            startedAt: currentResult.startedAt,\n            suspendedAt: Date.now(),\n          },\n          activeSteps,\n          requestContext,\n          state: currentState,\n          outputOptions,\n        },\n      });\n      return;\n    }\n\n    // forEachIndex was provided but the target iteration is already complete,\n    // and there are no pending iterations. The workflow step.end handler will\n    // advance the workflow. This is expected behavior for completed forEach loops.\n    return;\n  }\n\n  // Handle bulk resume: when resumeData is provided but no forEachIndex,\n  // resume suspended iterations up to the concurrency limit\n  if (resumeData !== undefined && forEachIndex === undefined && currentResult?.output?.length > 0) {\n    const suspendedIndices: number[] = [];\n    for (let i = 0; i < currentResult.output.length; i++) {\n      const iterResult = currentResult.output[i];\n      if (iterResult && typeof iterResult === 'object' && iterResult.status === 'suspended') {\n        suspendedIndices.push(i);\n      }\n    }\n\n    if (suspendedIndices.length > 0) {\n      // Limit resumption to concurrency value (like initial execution)\n      const concurrency = step.opts.concurrency ?? 1;\n      const indicesToResume = suspendedIndices.slice(0, concurrency);\n\n      // Reset suspended iterations to \"pending\" state before re-running them.\n      //\n      // Why PendingMarker instead of null?\n      // The storage merge logic treats null as \"keep existing value\" to prevent\n      // completed results from being overwritten by concurrent iterations that\n      // haven't finished yet. But when resuming, we need to force-reset the\n      // suspended result to null so the iteration can run fresh.\n      //\n      // PendingMarker ({ __mastra_pending__: true }) tells the storage layer\n      // \"force this to null, don't preserve the existing suspended result.\"\n      // See inmemory.ts updateWorkflowResults for the merge logic.\n      const workflowsStore = await mastra.getStorage()?.getStore('workflows');\n      const updatedOutput = [...currentResult.output];\n      for (const suspIdx of indicesToResume) {\n        updatedOutput[suspIdx] = createPendingMarker() as any;\n      }\n\n      await workflowsStore?.updateWorkflowResults({\n        workflowName: workflowId,\n        runId,\n        stepId: step.step.id,\n        result: {\n          ...currentResult,\n          output: updatedOutput,\n        } as any,\n        requestContext,\n      });\n\n      // Check if inner step is a nested workflow\n      const isNestedWorkflow = (step.step as any).component === 'WORKFLOW';\n\n      // Resume iterations up to concurrency limit\n      // Wrap in try-catch to prevent partial state issues if some publishes fail\n      for (const suspIdx of indicesToResume) {\n        const targetArray = (prevResult as any)?.output;\n        const iterationPrevResult =\n          isNestedWorkflow && prevResult.status === 'success' && Array.isArray(targetArray)\n            ? { status: 'success' as const, output: targetArray[suspIdx] }\n            : prevResult;\n\n        try {\n          await pubsub.publish('workflows', {\n            type: 'workflow.step.run',\n            runId,\n            data: {\n              parentWorkflow,\n              workflowId,\n              runId,\n              executionPath: [executionPath[0]!, suspIdx],\n              resumeSteps,\n              timeTravel,\n              stepResults,\n              prevResult: iterationPrevResult,\n              resumeData,\n              activeSteps,\n              requestContext,\n              perStep,\n              state: currentState,\n              outputOptions,\n            },\n          });\n        } catch {\n          // Log error but continue - the iteration will be picked up on next resume\n          // State was already updated, so no data loss\n        }\n      }\n      return;\n    }\n  }\n\n  if (idx >= targetLen && currentResult.output.filter((r: any) => r !== null).length >= targetLen) {\n    // Foreach completed all iterations - advance to next step\n    await pubsub.publish('workflows', {\n      type: 'workflow.step.run',\n      runId,\n      data: {\n        parentWorkflow,\n        workflowId,\n        runId,\n        executionPath: executionPath.slice(0, -1).concat([executionPath[executionPath.length - 1]! + 1]),\n        resumeSteps,\n        stepResults,\n        timeTravel,\n        prevResult: currentResult,\n        resumeData: undefined, // No resumeData when advancing past foreach\n        activeSteps,\n        requestContext,\n        perStep,\n        state: currentState,\n        outputOptions,\n      },\n    });\n\n    return;\n  } else if (idx >= targetLen) {\n    // wait for the 'null' values to be filled from the concurrent run\n    return;\n  }\n\n  const workflowsStore = await mastra.getStorage()?.getStore('workflows');\n\n  if (executionPath.length === 1 && idx === 0) {\n    // on first iteratation we need to kick off up to the set concurrency\n    const concurrency = Math.min(step.opts.concurrency ?? 1, targetLen);\n    const dummyResult = Array.from({ length: concurrency }, () => null);\n\n    await workflowsStore?.updateWorkflowResults({\n      workflowName: workflowId,\n      runId,\n      stepId: step.step.id,\n      result: {\n        status: 'success',\n        output: dummyResult as any,\n        startedAt: Date.now(),\n        payload: (prevResult as any)?.output,\n      } as any,\n      requestContext,\n    });\n\n    // Check if inner step is a nested workflow - only then extract individual items\n    // Regular steps use foreachIdx in step executor for item extraction\n    const isNestedWorkflow = (step.step as any).component === 'WORKFLOW';\n\n    for (let i = 0; i < concurrency; i++) {\n      // For nested workflows, extract individual item since they receive prevResult directly\n      // For regular steps, step executor handles extraction via foreachIdx\n      const targetArray = (prevResult as any)?.output;\n      const iterationPrevResult =\n        isNestedWorkflow && prevResult.status === 'success' && Array.isArray(targetArray)\n          ? { status: 'success' as const, output: targetArray[i] }\n          : prevResult;\n      await pubsub.publish('workflows', {\n        type: 'workflow.step.run',\n        runId,\n        data: {\n          parentWorkflow,\n          workflowId,\n          runId,\n          executionPath: [executionPath[0]!, i],\n          resumeSteps,\n          stepResults,\n          timeTravel,\n          prevResult: iterationPrevResult,\n          resumeData,\n          activeSteps,\n          requestContext,\n          perStep,\n          state: currentState,\n          outputOptions,\n        },\n      });\n    }\n\n    return;\n  }\n\n  (currentResult as any).output.push(null);\n  await workflowsStore?.updateWorkflowResults({\n    workflowName: workflowId,\n    runId,\n    stepId: step.step.id,\n    result: {\n      status: 'success',\n      output: (currentResult as any).output,\n      startedAt: Date.now(),\n      payload: (prevResult as any)?.output,\n    } as any,\n    requestContext,\n  });\n\n  // For nested workflows, extract individual item since they receive prevResult directly\n  // For regular steps, step executor handles extraction via foreachIdx\n  const isNestedWorkflow = (step.step as any).component === 'WORKFLOW';\n  const targetArray = (prevResult as any)?.output;\n  const iterationPrevResult =\n    isNestedWorkflow && prevResult.status === 'success' && Array.isArray(targetArray)\n      ? { status: 'success' as const, output: targetArray[idx] }\n      : prevResult;\n\n  await pubsub.publish('workflows', {\n    type: 'workflow.step.run',\n    runId,\n    data: {\n      parentWorkflow,\n      workflowId,\n      runId,\n      executionPath: [executionPath[0]!, idx],\n      resumeSteps,\n      timeTravel,\n      stepResults,\n      prevResult: iterationPrevResult,\n      resumeData,\n      activeSteps,\n      requestContext,\n      perStep,\n      state: currentState,\n      outputOptions,\n    },\n  });\n}\n","import type { StepFlowEntry } from '../..';\nimport { RequestContext } from '../../../di';\nimport type { PubSub } from '../../../events';\nimport { resolveCurrentState } from '../helpers';\nimport type { StepExecutor } from '../step-executor';\nimport type { ProcessorArgs } from '.';\n\nexport async function processWorkflowParallel(\n  {\n    workflowId,\n    runId,\n    executionPath,\n    stepResults,\n    activeSteps,\n    resumeSteps,\n    timeTravel,\n    prevResult,\n    resumeData,\n    parentWorkflow,\n    requestContext,\n    perStep,\n    state,\n    outputOptions,\n  }: ProcessorArgs,\n  {\n    pubsub,\n    step,\n  }: {\n    pubsub: PubSub;\n    step: Extract<StepFlowEntry, { type: 'parallel' }>;\n  },\n) {\n  // Get current state from stepResults or passed state\n  const currentState = resolveCurrentState({ stepResults, state });\n  for (let i = 0; i < step.steps.length; i++) {\n    const nestedStep = step.steps[i];\n    if (nestedStep?.type === 'step') {\n      activeSteps[nestedStep.step.id] = true;\n      if (perStep) {\n        break;\n      }\n    }\n  }\n\n  await Promise.all(\n    step.steps\n      ?.filter(step => activeSteps[step.step.id])\n      .map(async (_step, idx) => {\n        return pubsub.publish('workflows', {\n          type: 'workflow.step.run',\n          runId,\n          data: {\n            workflowId,\n            runId,\n            executionPath: executionPath.concat([idx]),\n            resumeSteps,\n            stepResults,\n            prevResult,\n            resumeData,\n            timeTravel,\n            parentWorkflow,\n            activeSteps,\n            requestContext,\n            perStep,\n            state: currentState,\n            outputOptions,\n          },\n        });\n      }),\n  );\n}\n\nexport async function processWorkflowConditional(\n  {\n    workflowId,\n    runId,\n    executionPath,\n    stepResults,\n    activeSteps,\n    resumeSteps,\n    timeTravel,\n    prevResult,\n    resumeData,\n    parentWorkflow,\n    requestContext,\n    perStep,\n    state,\n    outputOptions,\n  }: ProcessorArgs,\n  {\n    pubsub,\n    stepExecutor,\n    step,\n  }: {\n    pubsub: PubSub;\n    stepExecutor: StepExecutor;\n    step: Extract<StepFlowEntry, { type: 'conditional' }>;\n  },\n) {\n  // Get current state from stepResults or passed state\n  const currentState = resolveCurrentState({ stepResults, state });\n\n  // Create a proper RequestContext from the plain object passed in ProcessorArgs\n  const reqContext = new RequestContext(Object.entries(requestContext ?? {}) as any);\n\n  const idxs = await stepExecutor.evaluateConditions({\n    workflowId,\n    step,\n    runId,\n    stepResults,\n    state: currentState,\n    requestContext: reqContext,\n    input: prevResult?.status === 'success' ? prevResult.output : undefined,\n    resumeData,\n  });\n\n  const truthyIdxs: Record<number, boolean> = {};\n  for (let i = 0; i < idxs.length; i++) {\n    truthyIdxs[idxs[i]!] = true;\n  }\n\n  let onlyStepToRun: Extract<StepFlowEntry, { type: 'step' }> | undefined;\n\n  if (perStep) {\n    const stepsToRun = step.steps.filter((_, idx) => truthyIdxs[idx]);\n    onlyStepToRun = stepsToRun[0];\n  }\n\n  if (onlyStepToRun) {\n    activeSteps[onlyStepToRun.step.id] = true;\n    const stepIndex = step.steps.findIndex(step => step.step.id === onlyStepToRun.step.id);\n    await pubsub.publish('workflows', {\n      type: 'workflow.step.run',\n      runId,\n      data: {\n        workflowId,\n        runId,\n        executionPath: executionPath.concat([stepIndex]),\n        resumeSteps,\n        stepResults,\n        timeTravel,\n        prevResult,\n        resumeData,\n        parentWorkflow,\n        activeSteps,\n        requestContext,\n        perStep,\n        state: currentState,\n        outputOptions,\n      },\n    });\n  } else {\n    await Promise.all(\n      step.steps.map(async (step, idx) => {\n        if (truthyIdxs[idx]) {\n          if (step?.type === 'step') {\n            activeSteps[step.step.id] = true;\n          }\n          return pubsub.publish('workflows', {\n            type: 'workflow.step.run',\n            runId,\n            data: {\n              workflowId,\n              runId,\n              executionPath: executionPath.concat([idx]),\n              resumeSteps,\n              stepResults,\n              timeTravel,\n              prevResult,\n              resumeData,\n              parentWorkflow,\n              activeSteps,\n              requestContext,\n              perStep,\n              state: currentState,\n              outputOptions,\n            },\n          });\n        } else {\n          return pubsub.publish('workflows', {\n            type: 'workflow.step.end',\n            runId,\n            data: {\n              workflowId,\n              runId,\n              executionPath: executionPath.concat([idx]),\n              resumeSteps,\n              stepResults,\n              prevResult: { status: 'skipped' },\n              resumeData,\n              parentWorkflow,\n              activeSteps,\n              requestContext,\n              perStep,\n              state: currentState,\n              outputOptions,\n            },\n          });\n        }\n      }),\n    );\n  }\n}\n","import type { StepFlowEntry, WorkflowRunState } from '../..';\nimport { RequestContext } from '../../../di';\nimport type { PubSub } from '../../../events';\nimport type { StepExecutor } from '../step-executor';\nimport { getStep } from './utils';\nimport type { ProcessorArgs } from '.';\n\nexport async function processWorkflowWaitForEvent(\n  workflowData: ProcessorArgs,\n  {\n    pubsub,\n    eventName,\n    currentState,\n  }: {\n    pubsub: PubSub;\n    eventName: string;\n    currentState: WorkflowRunState;\n  },\n) {\n  const executionPath = currentState?.waitingPaths[eventName];\n  if (!executionPath) {\n    return;\n  }\n\n  const currentStep = getStep(workflowData.workflow, executionPath);\n  const prevResult = {\n    status: 'success',\n    output: currentState?.context[currentStep?.id ?? 'input']?.payload,\n  };\n\n  await pubsub.publish('workflows', {\n    type: 'workflow.step.run',\n    runId: workflowData.runId,\n    data: {\n      workflowId: workflowData.workflowId,\n      runId: workflowData.runId,\n      executionPath,\n      resumeSteps: [],\n      resumeData: workflowData.resumeData,\n      parentWorkflow: workflowData.parentWorkflow,\n      stepResults: currentState?.context,\n      prevResult,\n      activeSteps: [],\n      requestContext: currentState?.requestContext,\n      perStep: workflowData.perStep,\n    },\n  });\n}\n\nexport async function processWorkflowSleep(\n  {\n    workflowId,\n    runId,\n    executionPath,\n    stepResults,\n    activeSteps,\n    resumeSteps,\n    timeTravel,\n    prevResult,\n    resumeData,\n    parentWorkflow,\n    requestContext,\n    perStep,\n  }: ProcessorArgs,\n  {\n    pubsub,\n    stepExecutor,\n    step,\n  }: {\n    pubsub: PubSub;\n    stepExecutor: StepExecutor;\n    step: Extract<StepFlowEntry, { type: 'sleep' }>;\n  },\n) {\n  const startedAt = Date.now();\n  await pubsub.publish(`workflow.events.v2.${runId}`, {\n    type: 'watch',\n    runId,\n    data: {\n      type: 'workflow-step-waiting',\n      payload: {\n        id: step.id,\n        status: 'waiting',\n        payload: prevResult.status === 'success' ? prevResult.output : undefined,\n        startedAt,\n      },\n    },\n  });\n\n  // Create a proper RequestContext from the plain object passed in ProcessorArgs\n  const reqContext = new RequestContext(Object.entries(requestContext ?? {}) as any);\n\n  const duration = await stepExecutor.resolveSleep({\n    workflowId,\n    step,\n    runId,\n    stepResults,\n    requestContext: reqContext,\n    input: prevResult?.status === 'success' ? prevResult.output : undefined,\n    resumeData,\n  });\n\n  setTimeout(\n    async () => {\n      await pubsub.publish(`workflow.events.v2.${runId}`, {\n        type: 'watch',\n        runId,\n        data: {\n          type: 'workflow-step-result',\n          payload: {\n            id: step.id,\n            status: 'success',\n            payload: prevResult.status === 'success' ? prevResult.output : undefined,\n            output: prevResult.status === 'success' ? prevResult.output : undefined,\n            startedAt,\n            endedAt: Date.now(),\n          },\n        },\n      });\n\n      await pubsub.publish(`workflow.events.v2.${runId}`, {\n        type: 'watch',\n        runId,\n        data: {\n          type: 'workflow-step-finish',\n          payload: {\n            id: step.id,\n            metadata: {},\n          },\n        },\n      });\n\n      await pubsub.publish('workflows', {\n        type: 'workflow.step.run',\n        runId,\n        data: {\n          workflowId,\n          runId,\n          executionPath: executionPath.slice(0, -1).concat([executionPath[executionPath.length - 1]! + 1]),\n          resumeSteps,\n          timeTravel,\n          stepResults,\n          prevResult,\n          resumeData,\n          parentWorkflow,\n          activeSteps,\n          requestContext,\n          perStep,\n        },\n      });\n    },\n    duration < 0 ? 0 : duration,\n  );\n}\n\nexport async function processWorkflowSleepUntil(\n  {\n    workflowId,\n    runId,\n    executionPath,\n    stepResults,\n    activeSteps,\n    resumeSteps,\n    timeTravel,\n    prevResult,\n    resumeData,\n    parentWorkflow,\n    requestContext,\n    perStep,\n  }: ProcessorArgs,\n  {\n    pubsub,\n    stepExecutor,\n    step,\n  }: {\n    pubsub: PubSub;\n    stepExecutor: StepExecutor;\n    step: Extract<StepFlowEntry, { type: 'sleepUntil' }>;\n  },\n) {\n  const startedAt = Date.now();\n\n  // Create a proper RequestContext from the plain object passed in ProcessorArgs\n  const reqContext = new RequestContext(Object.entries(requestContext ?? {}) as any);\n\n  const duration = await stepExecutor.resolveSleepUntil({\n    workflowId,\n    step,\n    runId,\n    stepResults,\n    requestContext: reqContext,\n    input: prevResult?.status === 'success' ? prevResult.output : undefined,\n    resumeData,\n  });\n\n  await pubsub.publish(`workflow.events.v2.${runId}`, {\n    type: 'watch',\n    runId,\n    data: {\n      type: 'workflow-step-waiting',\n      payload: {\n        id: step.id,\n        status: 'waiting',\n        payload: prevResult.status === 'success' ? prevResult.output : undefined,\n        startedAt,\n      },\n    },\n  });\n\n  setTimeout(\n    async () => {\n      await pubsub.publish(`workflow.events.v2.${runId}`, {\n        type: 'watch',\n        runId,\n        data: {\n          type: 'workflow-step-result',\n          payload: {\n            id: step.id,\n            status: 'success',\n            payload: prevResult.status === 'success' ? prevResult.output : undefined,\n            output: prevResult.status === 'success' ? prevResult.output : undefined,\n            startedAt,\n            endedAt: Date.now(),\n          },\n        },\n      });\n\n      await pubsub.publish(`workflow.events.v2.${runId}`, {\n        type: 'watch',\n        runId,\n        data: {\n          type: 'workflow-step-finish',\n          payload: {\n            id: step.id,\n            metadata: {},\n          },\n        },\n      });\n\n      await pubsub.publish('workflows', {\n        type: 'workflow.step.run',\n        runId,\n        data: {\n          workflowId,\n          runId,\n          executionPath: executionPath.slice(0, -1).concat([executionPath[executionPath.length - 1]! + 1]),\n          resumeSteps,\n          timeTravel,\n          stepResults,\n          prevResult,\n          resumeData,\n          parentWorkflow,\n          activeSteps,\n          requestContext,\n          perStep,\n        },\n      });\n    },\n    duration < 0 ? 0 : duration,\n  );\n}\n","import { randomUUID } from 'node:crypto';\nimport EventEmitter from 'node:events';\nimport { ErrorCategory, ErrorDomain, MastraError, getErrorFromUnknown } from '../../../error';\nimport { EventProcessor } from '../../../events/processor';\nimport type { Event } from '../../../events/types';\nimport type { Mastra } from '../../../mastra';\nimport { RequestContext } from '../../../request-context/';\nimport type {\n  StepFlowEntry,\n  StepResult,\n  StepSuccess,\n  TimeTravelExecutionParams,\n  WorkflowRunState,\n} from '../../../workflows/types';\nimport type { Workflow } from '../../../workflows/workflow';\nimport { createTimeTravelExecutionParams, validateStepResumeData } from '../../utils';\nimport { resolveCurrentState } from '../helpers';\nimport { StepExecutor } from '../step-executor';\nimport { EventedWorkflow } from '../workflow';\nimport { processWorkflowForEach, processWorkflowLoop } from './loop';\nimport { processWorkflowConditional, processWorkflowParallel } from './parallel';\nimport { processWorkflowSleep, processWorkflowSleepUntil, processWorkflowWaitForEvent } from './sleep';\nimport { getNestedWorkflow, getStep, isExecutableStep } from './utils';\n\nexport type ProcessorArgs = {\n  activeSteps: Record<string, boolean>;\n  workflow: Workflow;\n  workflowId: string;\n  runId: string;\n  executionPath: number[];\n  stepResults: Record<string, StepResult<any, any, any, any>>;\n  resumeSteps: string[];\n  prevResult: StepResult<any, any, any, any>;\n  requestContext: Record<string, any>;\n  timeTravel?: TimeTravelExecutionParams;\n  resumeData?: any;\n  parentWorkflow?: ParentWorkflow;\n  parentContext?: {\n    workflowId: string;\n    input: any;\n  };\n  retryCount?: number;\n  perStep?: boolean;\n  state?: Record<string, any>;\n  outputOptions?: {\n    includeState?: boolean;\n    includeResumeLabels?: boolean;\n  };\n  forEachIndex?: number;\n  nestedRunId?: string; // runId of nested workflow when reporting back to parent\n};\n\nexport type ParentWorkflow = {\n  workflowId: string;\n  runId: string;\n  executionPath: number[];\n  resume: boolean;\n  stepResults: Record<string, StepResult<any, any, any, any>>;\n  parentWorkflow?: ParentWorkflow;\n  stepId: string;\n};\n\nexport class WorkflowEventProcessor extends EventProcessor {\n  private stepExecutor: StepExecutor;\n  // Map of runId -> AbortController for active workflow runs\n  private abortControllers: Map<string, AbortController> = new Map();\n  // Map of child runId -> parent runId for tracking nested workflows\n  private parentChildRelationships: Map<string, string> = new Map();\n\n  constructor({ mastra }: { mastra: Mastra }) {\n    super({ mastra });\n    this.stepExecutor = new StepExecutor({ mastra });\n  }\n\n  /**\n   * Get or create an AbortController for a workflow run\n   */\n  private getOrCreateAbortController(runId: string): AbortController {\n    let controller = this.abortControllers.get(runId);\n    if (!controller) {\n      controller = new AbortController();\n      this.abortControllers.set(runId, controller);\n    }\n    return controller;\n  }\n\n  /**\n   * Cancel a workflow run and all its nested child workflows\n   */\n  private cancelRunAndChildren(runId: string): void {\n    // Abort the controller for this run\n    const controller = this.abortControllers.get(runId);\n    if (controller) {\n      controller.abort();\n    }\n\n    // Find and cancel all child workflows\n    for (const [childRunId, parentRunId] of this.parentChildRelationships.entries()) {\n      if (parentRunId === runId) {\n        this.cancelRunAndChildren(childRunId);\n      }\n    }\n  }\n\n  /**\n   * Clean up abort controller and relationships when a workflow completes.\n   * Also cleans up any orphaned child entries that reference this run as parent.\n   */\n  private cleanupRun(runId: string): void {\n    this.abortControllers.delete(runId);\n    this.parentChildRelationships.delete(runId);\n\n    // Clean up any orphaned child entries pointing to this run as their parent\n    for (const [childRunId, parentRunId] of this.parentChildRelationships.entries()) {\n      if (parentRunId === runId) {\n        this.parentChildRelationships.delete(childRunId);\n      }\n    }\n  }\n\n  __registerMastra(mastra: Mastra) {\n    super.__registerMastra(mastra);\n    this.stepExecutor.__registerMastra(mastra);\n  }\n\n  private async errorWorkflow(\n    {\n      parentWorkflow,\n      workflowId,\n      runId,\n      resumeSteps,\n      stepResults,\n      resumeData,\n      requestContext,\n    }: Omit<ProcessorArgs, 'workflow'>,\n    e: Error,\n  ) {\n    await this.mastra.pubsub.publish('workflows', {\n      type: 'workflow.fail',\n      runId,\n      data: {\n        workflowId,\n        runId,\n        executionPath: [],\n        resumeSteps,\n        stepResults,\n        prevResult: { status: 'failed', error: getErrorFromUnknown(e).toJSON() },\n        requestContext,\n        resumeData,\n        activeSteps: {},\n        parentWorkflow: parentWorkflow,\n      },\n    });\n  }\n\n  protected async processWorkflowCancel({ workflowId, runId }: ProcessorArgs) {\n    // Cancel this workflow and all nested child workflows\n    this.cancelRunAndChildren(runId);\n\n    const workflowsStore = await this.mastra.getStorage()?.getStore('workflows');\n    const currentState = await workflowsStore?.loadWorkflowSnapshot({\n      workflowName: workflowId,\n      runId,\n    });\n\n    if (!currentState) {\n      this.mastra.getLogger()?.warn('Canceling workflow without loaded state', { workflowId, runId });\n    }\n\n    await this.endWorkflow(\n      {\n        workflow: undefined as any,\n        workflowId,\n        runId,\n        stepResults: (currentState?.context ?? {}) as any,\n        prevResult: { status: 'canceled' } as any,\n        requestContext: (currentState?.requestContext ?? {}) as any,\n        executionPath: [],\n        activeSteps: {},\n        resumeSteps: [],\n        resumeData: undefined,\n        parentWorkflow: undefined,\n      },\n      'canceled',\n    );\n  }\n\n  protected async processWorkflowStart({\n    workflow,\n    parentWorkflow,\n    workflowId,\n    runId,\n    resumeSteps,\n    prevResult,\n    resumeData,\n    timeTravel,\n    executionPath,\n    stepResults,\n    requestContext,\n    perStep,\n    state,\n    outputOptions,\n    forEachIndex,\n  }: ProcessorArgs & { initialState?: Record<string, any> }) {\n    // Use initialState from event data if provided, otherwise use state from ProcessorArgs\n    const initialState = (arguments[0] as any).initialState ?? state ?? {};\n    // Create abort controller for this workflow run\n    this.getOrCreateAbortController(runId);\n\n    // Track parent-child relationship if this is a nested workflow\n    if (parentWorkflow?.runId) {\n      this.parentChildRelationships.set(runId, parentWorkflow.runId);\n    }\n    // Preserve resourceId from existing snapshot if present\n    const workflowsStore = await this.mastra.getStorage()?.getStore('workflows');\n    const existingRun = await workflowsStore?.getWorkflowRunById({ runId, workflowName: workflow.id });\n    const resourceId = existingRun?.resourceId;\n\n    // Check shouldPersistSnapshot option - default to true if not specified\n    // This is particularly important for resume: if shouldPersist returns false for 'running',\n    // we shouldn't overwrite the existing 'suspended' status with 'running'\n    const shouldPersist =\n      workflow?.options?.shouldPersistSnapshot?.({\n        stepResults: stepResults ?? {},\n        workflowStatus: 'running',\n      }) ?? true;\n\n    if (shouldPersist) {\n      await workflowsStore?.persistWorkflowSnapshot({\n        workflowName: workflow.id,\n        runId,\n        resourceId,\n        snapshot: {\n          activePaths: [],\n          suspendedPaths: {},\n          resumeLabels: {},\n          waitingPaths: {},\n          activeStepsPath: {},\n          serializedStepGraph: workflow.serializedStepGraph,\n          timestamp: Date.now(),\n          runId,\n          context: {\n            ...(stepResults ?? {\n              input: prevResult?.status === 'success' ? prevResult.output : undefined,\n            }),\n            __state: initialState,\n          },\n          status: 'running',\n          value: initialState,\n        },\n      });\n    }\n\n    await this.mastra.pubsub.publish('workflows', {\n      type: 'workflow.step.run',\n      runId,\n      data: {\n        parentWorkflow,\n        workflowId,\n        runId,\n        executionPath: executionPath ?? [0],\n        resumeSteps,\n        stepResults: {\n          ...(stepResults ?? {\n            input: prevResult?.status === 'success' ? prevResult.output : undefined,\n          }),\n          __state: initialState,\n        },\n        prevResult,\n        timeTravel,\n        requestContext,\n        resumeData,\n        activeSteps: {},\n        perStep,\n        state: initialState,\n        outputOptions,\n        forEachIndex,\n      },\n    });\n  }\n\n  protected async endWorkflow(args: ProcessorArgs, status: 'success' | 'failed' | 'canceled' | 'paused' = 'success') {\n    const { workflowId, runId, prevResult, perStep, workflow, stepResults } = args;\n    const workflowsStore = await this.mastra.getStorage()?.getStore('workflows');\n\n    // Check shouldPersistSnapshot option - default to true if not specified\n    const finalStatus = perStep && status === 'success' ? 'paused' : status;\n    const shouldPersist =\n      workflow?.options?.shouldPersistSnapshot?.({\n        stepResults: stepResults ?? {},\n        workflowStatus: finalStatus,\n      }) ?? true;\n\n    if (shouldPersist) {\n      await workflowsStore?.updateWorkflowState({\n        workflowName: workflowId,\n        runId,\n        opts: {\n          status: finalStatus,\n          result: prevResult,\n        },\n      });\n    }\n\n    if (perStep) {\n      await this.mastra.pubsub.publish(`workflow.events.v2.${runId}`, {\n        type: 'watch',\n        runId,\n        data: {\n          type: 'workflow-paused',\n          payload: {},\n        },\n      });\n    }\n\n    await this.mastra.pubsub.publish(`workflow.events.v2.${runId}`, {\n      type: 'watch',\n      runId,\n      data: {\n        type: 'workflow-finish',\n        payload: {\n          runId,\n        },\n      },\n    });\n\n    await this.mastra.pubsub.publish('workflows', {\n      type: 'workflow.end',\n      runId,\n      data: { ...args, workflow: undefined },\n    });\n  }\n\n  protected async processWorkflowEnd(args: ProcessorArgs) {\n    const {\n      resumeSteps,\n      prevResult,\n      resumeData,\n      parentWorkflow,\n      activeSteps,\n      requestContext,\n      runId,\n      timeTravel,\n      perStep,\n      stepResults,\n      state,\n      workflowId: _workflowId,\n    } = args;\n\n    // Extract final state from stepResults or args\n    const finalState = resolveCurrentState({ stepResults, state });\n\n    // Clean up abort controller and parent-child tracking\n    this.cleanupRun(runId);\n\n    // handle nested workflow\n    if (parentWorkflow) {\n      await this.mastra.pubsub.publish('workflows', {\n        type: 'workflow.step.end',\n        runId: parentWorkflow.runId, // Use parent's runId for event routing\n        data: {\n          workflowId: parentWorkflow.workflowId,\n          runId: parentWorkflow.runId,\n          executionPath: parentWorkflow.executionPath,\n          resumeSteps,\n          stepResults: parentWorkflow.stepResults,\n          prevResult,\n          resumeData,\n          activeSteps,\n          parentWorkflow: parentWorkflow.parentWorkflow,\n          parentContext: parentWorkflow,\n          requestContext,\n          timeTravel,\n          perStep,\n          state: finalState,\n          nestedRunId: runId, // Pass nested workflow's runId for step retrieval\n        },\n      });\n    }\n\n    await this.mastra.pubsub.publish('workflows-finish', {\n      type: 'workflow.end',\n      runId,\n      data: { ...args, workflow: undefined, state: finalState },\n    });\n  }\n\n  protected async processWorkflowSuspend(args: ProcessorArgs) {\n    const {\n      resumeSteps,\n      prevResult,\n      resumeData,\n      parentWorkflow,\n      activeSteps,\n      runId,\n      requestContext,\n      timeTravel,\n      stepResults,\n      state,\n      outputOptions,\n    } = args;\n\n    // Extract final state from stepResults or args\n    const finalState = resolveCurrentState({ stepResults, state });\n\n    // TODO: if there are still active paths don't end the workflow yet\n    // handle nested workflow\n    if (parentWorkflow) {\n      await this.mastra.pubsub.publish('workflows', {\n        type: 'workflow.step.end',\n        runId: parentWorkflow.runId, // Use parent's runId for event routing\n        data: {\n          workflowId: parentWorkflow.workflowId,\n          runId: parentWorkflow.runId,\n          executionPath: parentWorkflow.executionPath,\n          resumeSteps,\n          stepResults: parentWorkflow.stepResults,\n          prevResult: {\n            ...prevResult,\n            suspendPayload: {\n              ...prevResult.suspendPayload,\n              __workflow_meta: {\n                runId: runId,\n                path: parentWorkflow?.stepId\n                  ? [parentWorkflow.stepId].concat(prevResult.suspendPayload?.__workflow_meta?.path ?? [])\n                  : (prevResult.suspendPayload?.__workflow_meta?.path ?? []),\n              },\n            },\n          },\n          timeTravel,\n          resumeData,\n          activeSteps,\n          requestContext,\n          parentWorkflow: parentWorkflow.parentWorkflow,\n          parentContext: parentWorkflow,\n          state: finalState,\n          outputOptions,\n          nestedRunId: runId, // Pass nested workflow's runId for step retrieval\n        },\n      });\n    }\n\n    await this.mastra.pubsub.publish('workflows-finish', {\n      type: 'workflow.suspend',\n      runId,\n      data: { ...args, workflow: undefined, state: finalState },\n    });\n  }\n\n  protected async processWorkflowFail(args: ProcessorArgs) {\n    const {\n      workflowId,\n      runId,\n      resumeSteps,\n      prevResult,\n      resumeData,\n      parentWorkflow,\n      activeSteps,\n      requestContext,\n      timeTravel,\n      stepResults,\n      state,\n      outputOptions,\n      workflow,\n    } = args;\n\n    // Extract final state from stepResults or args\n    const finalState = resolveCurrentState({ stepResults, state });\n\n    // Clean up abort controller and parent-child tracking\n    this.cleanupRun(runId);\n\n    const workflowsStore = await this.mastra.getStorage()?.getStore('workflows');\n\n    // Check shouldPersistSnapshot option - default to true if not specified\n    const shouldPersist =\n      workflow?.options?.shouldPersistSnapshot?.({\n        stepResults: stepResults ?? {},\n        workflowStatus: 'failed',\n      }) ?? true;\n\n    if (shouldPersist) {\n      await workflowsStore?.updateWorkflowState({\n        workflowName: workflowId,\n        runId,\n        opts: {\n          status: 'failed',\n          error: (prevResult as any).error,\n        },\n      });\n    }\n\n    // handle nested workflow\n    if (parentWorkflow) {\n      await this.mastra.pubsub.publish('workflows', {\n        type: 'workflow.step.end',\n        runId: parentWorkflow.runId, // Use parent's runId for event routing\n        data: {\n          workflowId: parentWorkflow.workflowId,\n          runId: parentWorkflow.runId,\n          executionPath: parentWorkflow.executionPath,\n          resumeSteps,\n          stepResults: parentWorkflow.stepResults,\n          prevResult,\n          timeTravel,\n          resumeData,\n          activeSteps,\n          requestContext,\n          parentWorkflow: parentWorkflow.parentWorkflow,\n          parentContext: parentWorkflow,\n          state: finalState,\n          outputOptions,\n          nestedRunId: runId, // Pass nested workflow's runId for step retrieval\n        },\n      });\n    }\n\n    await this.mastra.pubsub.publish('workflows-finish', {\n      type: 'workflow.fail',\n      runId,\n      data: { ...args, workflow: undefined, state: finalState },\n    });\n  }\n\n  protected async processWorkflowStepRun({\n    workflow,\n    workflowId,\n    runId,\n    executionPath,\n    stepResults,\n    activeSteps,\n    resumeSteps,\n    timeTravel,\n    prevResult,\n    resumeData,\n    parentWorkflow,\n    requestContext,\n    retryCount = 0,\n    perStep,\n    state,\n    outputOptions,\n    forEachIndex,\n  }: ProcessorArgs) {\n    // Get current state from stepResults.__state or from passed state\n    const currentState = resolveCurrentState({ stepResults, state });\n    let stepGraph: StepFlowEntry[] = workflow.stepGraph;\n\n    if (!executionPath?.length) {\n      return this.errorWorkflow(\n        {\n          workflowId,\n          runId,\n          executionPath,\n          stepResults,\n          activeSteps,\n          resumeSteps,\n          prevResult,\n          resumeData,\n          parentWorkflow,\n          requestContext,\n        },\n        new MastraError({\n          id: 'MASTRA_WORKFLOW',\n          text: `Execution path is empty: ${JSON.stringify(executionPath)}`,\n          domain: ErrorDomain.MASTRA_WORKFLOW,\n          category: ErrorCategory.SYSTEM,\n        }),\n      );\n    }\n\n    let step: StepFlowEntry | undefined = stepGraph[executionPath[0]!];\n\n    if (!step) {\n      // If we're past the last step, end the workflow successfully\n      if (executionPath[0]! >= stepGraph.length) {\n        return this.endWorkflow({\n          workflow,\n          parentWorkflow,\n          workflowId,\n          runId,\n          executionPath,\n          resumeSteps,\n          stepResults,\n          prevResult,\n          activeSteps,\n          requestContext,\n          // Use currentState (resolved from stepResults.__state and state) instead of\n          // the possibly-undefined state parameter, to ensure final state is preserved\n          state: currentState,\n          outputOptions,\n        });\n      }\n      return this.errorWorkflow(\n        {\n          workflowId,\n          runId,\n          executionPath,\n          stepResults,\n          activeSteps,\n          resumeSteps,\n          prevResult,\n          resumeData,\n          parentWorkflow,\n          requestContext,\n        },\n        new MastraError({\n          id: 'MASTRA_WORKFLOW',\n          text: `Step not found in step graph: ${JSON.stringify(executionPath)}`,\n          domain: ErrorDomain.MASTRA_WORKFLOW,\n          category: ErrorCategory.SYSTEM,\n        }),\n      );\n    }\n\n    if ((step.type === 'parallel' || step.type === 'conditional') && executionPath.length > 1) {\n      step = step.steps[executionPath[1]!] as StepFlowEntry;\n    } else if (step.type === 'parallel') {\n      return processWorkflowParallel(\n        {\n          workflow,\n          workflowId,\n          runId,\n          executionPath,\n          stepResults,\n          activeSteps,\n          resumeSteps,\n          timeTravel,\n          prevResult,\n          resumeData,\n          parentWorkflow,\n          requestContext,\n          perStep,\n          state: currentState,\n          outputOptions,\n        },\n        {\n          pubsub: this.mastra.pubsub,\n          step,\n        },\n      );\n    } else if (step?.type === 'conditional') {\n      return processWorkflowConditional(\n        {\n          workflow,\n          workflowId,\n          runId,\n          executionPath,\n          stepResults,\n          activeSteps,\n          resumeSteps,\n          timeTravel,\n          prevResult,\n          resumeData,\n          parentWorkflow,\n          requestContext,\n          perStep,\n          state: currentState,\n          outputOptions,\n        },\n        {\n          pubsub: this.mastra.pubsub,\n          stepExecutor: this.stepExecutor,\n          step,\n        },\n      );\n    } else if (step?.type === 'sleep') {\n      return processWorkflowSleep(\n        {\n          workflow,\n          workflowId,\n          runId,\n          executionPath,\n          stepResults,\n          activeSteps,\n          resumeSteps,\n          timeTravel,\n          prevResult,\n          resumeData,\n          parentWorkflow,\n          requestContext,\n          perStep,\n          state: currentState,\n          outputOptions,\n        },\n        {\n          pubsub: this.mastra.pubsub,\n          stepExecutor: this.stepExecutor,\n          step,\n        },\n      );\n    } else if (step?.type === 'sleepUntil') {\n      return processWorkflowSleepUntil(\n        {\n          workflow,\n          workflowId,\n          runId,\n          executionPath,\n          stepResults,\n          activeSteps,\n          resumeSteps,\n          timeTravel,\n          prevResult,\n          resumeData,\n          parentWorkflow,\n          requestContext,\n          perStep,\n          state: currentState,\n          outputOptions,\n        },\n        {\n          pubsub: this.mastra.pubsub,\n          stepExecutor: this.stepExecutor,\n          step,\n        },\n      );\n    } else if (step?.type === 'foreach' && executionPath.length === 1) {\n      return processWorkflowForEach(\n        {\n          workflow,\n          workflowId,\n          runId,\n          executionPath,\n          stepResults,\n          activeSteps,\n          resumeSteps,\n          timeTravel,\n          prevResult,\n          resumeData,\n          parentWorkflow,\n          requestContext,\n          perStep,\n          state: currentState,\n          outputOptions,\n          forEachIndex,\n        },\n        {\n          pubsub: this.mastra.pubsub,\n          mastra: this.mastra,\n          step,\n        },\n      );\n    }\n\n    if (!isExecutableStep(step)) {\n      return this.errorWorkflow(\n        {\n          workflowId,\n          runId,\n          executionPath,\n          stepResults,\n          activeSteps,\n          resumeSteps,\n          prevResult,\n          resumeData,\n          parentWorkflow,\n          requestContext,\n        },\n        new MastraError({\n          id: 'MASTRA_WORKFLOW',\n          text: `Step is not executable: ${step?.type} -- ${JSON.stringify(executionPath)}`,\n          domain: ErrorDomain.MASTRA_WORKFLOW,\n          category: ErrorCategory.SYSTEM,\n        }),\n      );\n    }\n\n    activeSteps[step.step.id] = true;\n\n    const workflowsStore = await this.mastra?.getStorage()?.getStore('workflows');\n\n    // Run nested workflow - check for both EventedWorkflow and regular Workflow\n    if (step.step instanceof EventedWorkflow || (step.step as any).component === 'WORKFLOW') {\n      if (resumeSteps?.length > 1) {\n        const stepData = stepResults[step.step.id];\n        const nestedRunId = stepData?.suspendPayload?.__workflow_meta?.runId;\n        if (!nestedRunId) {\n          return this.errorWorkflow(\n            {\n              workflowId,\n              runId,\n              executionPath,\n              stepResults,\n              activeSteps,\n              resumeSteps,\n              prevResult,\n              resumeData,\n              parentWorkflow,\n              requestContext,\n            },\n            new MastraError({\n              id: 'MASTRA_WORKFLOW',\n              text: `Nested workflow run id not found: ${JSON.stringify(stepResults)}`,\n              domain: ErrorDomain.MASTRA_WORKFLOW,\n              category: ErrorCategory.SYSTEM,\n            }),\n          );\n        }\n\n        const snapshot = await workflowsStore?.loadWorkflowSnapshot({\n          workflowName: step.step.id,\n          runId: nestedRunId,\n        });\n\n        const nestedStepResults = snapshot?.context;\n        const nestedSteps = resumeSteps.slice(1);\n\n        await this.mastra.pubsub.publish('workflows', {\n          type: 'workflow.resume',\n          runId,\n          data: {\n            workflowId: step.step.id,\n            parentWorkflow: {\n              stepId: step.step.id,\n              workflowId,\n              runId,\n              executionPath,\n              resumeSteps,\n              stepResults,\n              input: prevResult,\n              parentWorkflow,\n            },\n            executionPath: snapshot?.suspendedPaths?.[nestedSteps[0]!] as any,\n            runId: nestedRunId,\n            resumeSteps: nestedSteps,\n            stepResults: nestedStepResults,\n            prevResult,\n            resumeData,\n            activeSteps,\n            requestContext,\n            perStep,\n            initialState: currentState,\n            state: currentState,\n            outputOptions,\n          },\n        });\n      } else if (timeTravel && timeTravel.steps?.length > 1 && timeTravel.steps[0] === step.step.id) {\n        const snapshot =\n          (await workflowsStore?.loadWorkflowSnapshot({\n            workflowName: step.step.id,\n            runId,\n          })) ?? ({ context: {} } as WorkflowRunState);\n\n        // Cast to Workflow since we know this is a nested workflow at this point\n        const nestedWorkflow = step.step as any;\n        const timeTravelParams = createTimeTravelExecutionParams({\n          steps: timeTravel.steps.slice(1),\n          inputData: timeTravel.inputData,\n          resumeData: timeTravel.resumeData,\n          context: (timeTravel.nestedStepResults?.[step.step.id] ?? {}) as any,\n          nestedStepsContext: (timeTravel.nestedStepResults ?? {}) as any,\n          snapshot,\n          graph: nestedWorkflow.buildExecutionGraph(),\n          perStep,\n        });\n\n        const nestedPrevStep = getStep(nestedWorkflow, timeTravelParams.executionPath);\n        const nestedPrevResult = timeTravelParams.stepResults[nestedPrevStep?.id ?? 'input'];\n\n        await this.mastra.pubsub.publish('workflows', {\n          type: 'workflow.start',\n          runId,\n          data: {\n            workflowId: step.step.id,\n            parentWorkflow: {\n              stepId: step.step.id,\n              workflowId,\n              runId,\n              executionPath,\n              resumeSteps,\n              stepResults,\n              timeTravel,\n              input: prevResult,\n              parentWorkflow,\n            },\n            executionPath: timeTravelParams.executionPath,\n            runId: randomUUID(),\n            stepResults: timeTravelParams.stepResults,\n            prevResult: { status: 'success', output: nestedPrevResult?.payload },\n            timeTravel: timeTravelParams,\n            activeSteps,\n            requestContext,\n            perStep,\n            initialState: currentState,\n            state: currentState,\n            outputOptions,\n          },\n        });\n      } else {\n        await this.mastra.pubsub.publish('workflows', {\n          type: 'workflow.start',\n          runId,\n          data: {\n            workflowId: step.step.id,\n            parentWorkflow: {\n              stepId: step.step.id,\n              workflowId,\n              runId,\n              executionPath,\n              resumeSteps,\n              stepResults,\n              input: prevResult,\n              parentWorkflow,\n            },\n            executionPath: [0],\n            runId: randomUUID(),\n            resumeSteps,\n            prevResult,\n            resumeData,\n            activeSteps,\n            requestContext,\n            perStep,\n            initialState: currentState,\n            state: currentState,\n            outputOptions,\n          },\n        });\n      }\n\n      return;\n    }\n\n    if (step.type === 'step') {\n      await this.mastra.pubsub.publish(`workflow.events.v2.${runId}`, {\n        type: 'watch',\n        runId,\n        data: {\n          type: 'workflow-step-start',\n          payload: {\n            id: step.step.id,\n            startedAt: Date.now(),\n            payload: prevResult.status === 'success' ? prevResult.output : undefined,\n            status: 'running',\n          },\n        },\n      });\n    }\n\n    const ee = new EventEmitter();\n    ee.on('watch', async (event: any) => {\n      await this.mastra.pubsub.publish(`workflow.events.v2.${runId}`, {\n        type: 'watch',\n        runId,\n        data: event,\n      });\n    });\n    const rc = new RequestContext();\n    for (const [key, value] of Object.entries(requestContext)) {\n      rc.set(key, value);\n    }\n    const { resumeData: timeTravelResumeData, validationError: timeTravelResumeValidationError } =\n      await validateStepResumeData({\n        resumeData: timeTravel?.stepResults[step.step.id]?.status === 'suspended' ? timeTravel?.resumeData : undefined,\n        step: step.step,\n      });\n\n    let resumeDataToUse;\n    if (timeTravelResumeData && !timeTravelResumeValidationError) {\n      resumeDataToUse = timeTravelResumeData;\n    } else if (timeTravelResumeData && timeTravelResumeValidationError) {\n      this.mastra.getLogger()?.warn('Time travel resume data validation failed', {\n        stepId: step.step.id,\n        error: timeTravelResumeValidationError.message,\n      });\n    } else if (resumeSteps?.length > 0 && resumeSteps?.[0] === step.step.id) {\n      resumeDataToUse = resumeData;\n    }\n\n    // Get the abort controller for this workflow run\n    const abortController = this.getOrCreateAbortController(runId);\n\n    const stepResult = await this.stepExecutor.execute({\n      workflowId,\n      step: step.step,\n      runId,\n      stepResults,\n      state: currentState,\n      requestContext: rc,\n      input: (prevResult as any)?.output,\n      resumeData: resumeDataToUse,\n      retryCount,\n      foreachIdx: step.type === 'foreach' ? executionPath[1] : undefined,\n      validateInputs: workflow.options.validateInputs,\n      abortController,\n      perStep,\n    });\n    requestContext = Object.fromEntries(rc.entries());\n\n    // @ts-expect-error - bailed status not in type\n    if (stepResult.status === 'bailed') {\n      // @ts-expect-error - bailed status not in type\n      stepResult.status = 'success';\n\n      await this.endWorkflow({\n        workflow,\n        resumeData,\n        parentWorkflow,\n        workflowId,\n        runId,\n        executionPath,\n        resumeSteps,\n        stepResults: {\n          ...stepResults,\n          [step.step.id]: stepResult,\n        },\n        prevResult: stepResult,\n        activeSteps,\n        requestContext,\n        perStep,\n        state: currentState,\n        outputOptions,\n      });\n      return;\n    }\n\n    if (stepResult.status === 'failed') {\n      const retries = step.step.retries ?? workflow.retryConfig.attempts ?? 0;\n      if (retryCount >= retries) {\n        await this.mastra.pubsub.publish('workflows', {\n          type: 'workflow.step.end',\n          runId,\n          data: {\n            parentWorkflow,\n            workflowId,\n            runId,\n            executionPath,\n            resumeSteps,\n            stepResults,\n            prevResult: stepResult,\n            activeSteps,\n            requestContext,\n            state: currentState,\n            outputOptions,\n          },\n        });\n      } else {\n        return this.mastra.pubsub.publish('workflows', {\n          type: 'workflow.step.run',\n          runId,\n          data: {\n            parentWorkflow,\n            workflowId,\n            runId,\n            executionPath,\n            resumeSteps,\n            stepResults,\n            timeTravel,\n            prevResult,\n            activeSteps,\n            requestContext,\n            retryCount: retryCount + 1,\n            state: currentState,\n            outputOptions,\n          },\n        });\n      }\n    }\n\n    if (step.type === 'loop') {\n      //timeTravel is not passed to the processWorkflowLoop function becuase the step already ran the first time\n      // with whatever information it needs from timeTravel, subsequent loop runs use the previous loop run result as it's input.\n      await processWorkflowLoop(\n        {\n          workflow,\n          workflowId,\n          prevResult: stepResult,\n          runId,\n          executionPath,\n          stepResults,\n          activeSteps,\n          resumeSteps,\n          resumeData,\n          parentWorkflow,\n          requestContext,\n          retryCount: retryCount + 1,\n        },\n        {\n          pubsub: this.mastra.pubsub,\n          stepExecutor: this.stepExecutor,\n          step,\n          stepResult,\n        },\n      );\n    } else {\n      // Extract updated state from step result\n      const updatedState = (stepResult as any).__state ?? currentState;\n\n      await this.mastra.pubsub.publish('workflows', {\n        type: 'workflow.step.end',\n        runId,\n        data: {\n          parentWorkflow,\n          workflowId,\n          runId,\n          executionPath,\n          resumeSteps,\n          timeTravel, //timeTravel is passed in as workflow.step.end ends the step, not the workflow, the timeTravel info is passed to the next step to run.\n          stepResults: {\n            ...stepResults,\n            __state: updatedState,\n          },\n          prevResult: stepResult,\n          activeSteps,\n          requestContext,\n          perStep,\n          state: updatedState,\n          outputOptions,\n          forEachIndex,\n        },\n      });\n    }\n  }\n\n  protected async processWorkflowStepEnd({\n    workflow,\n    workflowId,\n    runId,\n    executionPath,\n    resumeSteps,\n    timeTravel,\n    prevResult,\n    parentWorkflow,\n    stepResults,\n    activeSteps,\n    parentContext,\n    requestContext,\n    perStep,\n    state,\n    outputOptions,\n    forEachIndex,\n    nestedRunId,\n  }: ProcessorArgs) {\n    // Extract state from prevResult if it was updated by the step\n    // For nested workflow completion (parentContext present), prefer the passed state\n    // as it contains the nested workflow's updated state\n    const currentState = parentContext\n      ? (state ?? (prevResult as any)?.__state ?? stepResults?.__state ?? {})\n      : ((prevResult as any)?.__state ?? stepResults?.__state ?? state ?? {});\n\n    // Create a clean version of prevResult without __state for storing\n    const { __state: _removedState, ...cleanPrevResult } = prevResult as any;\n    prevResult = cleanPrevResult as typeof prevResult;\n\n    let step = workflow.stepGraph[executionPath[0]!];\n\n    if ((step?.type === 'parallel' || step?.type === 'conditional') && executionPath.length > 1) {\n      step = step.steps[executionPath[1]!];\n    }\n\n    if (!step) {\n      return this.errorWorkflow(\n        {\n          workflowId,\n          runId,\n          executionPath,\n          resumeSteps,\n          prevResult,\n          stepResults,\n          activeSteps,\n          requestContext,\n        },\n        new MastraError({\n          id: 'MASTRA_WORKFLOW',\n          text: `Step not found: ${JSON.stringify(executionPath)}`,\n          domain: ErrorDomain.MASTRA_WORKFLOW,\n          category: ErrorCategory.SYSTEM,\n        }),\n      );\n    }\n\n    // Cache workflows store to avoid redundant async calls\n    const workflowsStore = await this.mastra.getStorage()?.getStore('workflows');\n\n    if (step.type === 'foreach') {\n      const snapshot = await workflowsStore?.loadWorkflowSnapshot({\n        workflowName: workflowId,\n        runId,\n      });\n\n      const currentIdx = executionPath[1];\n      const existingStepResult = snapshot?.context?.[step.step.id] as any;\n      const currentResult = existingStepResult?.output;\n      // Preserve the original payload (the input array) from the existing step result\n      const originalPayload = existingStepResult?.payload;\n\n      let newResult = prevResult;\n      if (currentIdx !== undefined) {\n        // Check for bail - short circuit foreach execution\n        // @ts-expect-error - bailed status not in type\n        if (prevResult.status === 'bailed') {\n          const bailedResult = {\n            status: 'success' as const,\n            output: (prevResult as any).output,\n            startedAt: existingStepResult?.startedAt ?? Date.now(),\n            endedAt: Date.now(),\n            payload: originalPayload,\n          };\n\n          // Store final result\n          await workflowsStore?.updateWorkflowResults({\n            workflowName: workflow.id,\n            runId,\n            stepId: step.step.id,\n            result: bailedResult as any,\n            requestContext,\n          });\n\n          // End workflow with bail result\n          return this.endWorkflow({\n            workflow,\n            parentWorkflow,\n            workflowId,\n            runId,\n            executionPath: [executionPath[0]!],\n            resumeSteps,\n            stepResults: { ...stepResults, [step.step.id]: bailedResult },\n            prevResult: bailedResult,\n            activeSteps,\n            requestContext,\n            perStep,\n            state: currentState,\n            outputOptions,\n          });\n        }\n\n        // For foreach, store the full iteration result (including status, suspendPayload, etc.)\n        // not just the output, so suspend state is preserved\n        const iterationResult =\n          prevResult.status === 'suspended'\n            ? prevResult // Keep full result for suspended iterations\n            : (prevResult as any).output; // Just output for completed iterations\n\n        if (currentResult) {\n          currentResult[currentIdx] = iterationResult;\n          // Merge foreach step-level properties (suspendPayload, resumePayload, suspendedAt, resumedAt)\n          // New iteration's resume properties take precedence for resumePayload/resumedAt (most recent resume)\n          // Existing step's suspend properties are preserved (first suspend)\n          newResult = {\n            ...existingStepResult, // Preserve step-level properties\n            ...prevResult, // Get iteration timing info\n            output: currentResult,\n            payload: originalPayload,\n            // Preserve suspend metadata from first suspension\n            suspendPayload: existingStepResult?.suspendPayload ?? prevResult.suspendPayload,\n            suspendedAt: existingStepResult?.suspendedAt ?? (prevResult as any).suspendedAt,\n            // Update resume metadata to most recent resume (new iteration takes precedence)\n            resumePayload: (prevResult as any).resumePayload ?? existingStepResult?.resumePayload,\n            resumedAt: (prevResult as any).resumedAt ?? existingStepResult?.resumedAt,\n          } as any;\n        } else {\n          newResult = { ...prevResult, output: [iterationResult], payload: originalPayload } as any;\n        }\n      }\n      const newStepResults = await workflowsStore?.updateWorkflowResults({\n        workflowName: workflow.id,\n        runId,\n        stepId: step.step.id,\n        result: newResult,\n        requestContext,\n      });\n\n      if (!newStepResults) {\n        return;\n      }\n\n      stepResults = newStepResults;\n\n      // For foreach iterations, check if all iterations are complete before emitting events\n      // This prevents emitting workflow.suspend when only some concurrent iterations have finished\n      if (currentIdx !== undefined) {\n        const foreachResult = stepResults[step.step.id] as any;\n        const iterationResults = foreachResult?.output ?? [];\n        const targetLen = foreachResult?.payload?.length ?? 0;\n\n        // Count iterations by status - pending iterations appear as null in stepResults after\n        // storage merge (pending markers are converted to null by the storage layer).\n        const pendingCount = iterationResults.filter((r: any) => r === null).length;\n        const suspendedCount = iterationResults.filter(\n          (r: any) => r && typeof r === 'object' && r.status === 'suspended',\n        ).length;\n        const iterationsStarted = iterationResults.length;\n\n        // Emit per-iteration progress event\n        const completedCount = iterationResults.filter(\n          (r: any) => r !== null && !(typeof r === 'object' && r.status === 'suspended'),\n        ).length;\n        const iterationStatus =\n          prevResult.status === 'suspended'\n            ? ('suspended' as const)\n            : prevResult.status === 'success'\n              ? ('success' as const)\n              : ('failed' as const);\n\n        await this.mastra.pubsub.publish(`workflow.events.v2.${runId}`, {\n          type: 'watch',\n          runId,\n          data: {\n            type: 'workflow-step-progress',\n            payload: {\n              id: step.step.id,\n              completedCount,\n              totalCount: targetLen,\n              currentIndex: currentIdx,\n              iterationStatus,\n              ...(prevResult.status === 'success' ? { iterationOutput: (prevResult as any).output } : {}),\n            },\n          },\n        });\n\n        if (pendingCount > 0) {\n          // There are still pending (null) iterations - concurrent execution in progress\n          // Wait for them to complete\n          return;\n        }\n\n        // Check if there are more iterations to start before deciding to suspend\n        // This handles partial concurrency: don't suspend until all iterations have been started\n        if (iterationsStarted < targetLen) {\n          // More iterations need to be started - call processWorkflowForEach to continue\n          await processWorkflowForEach(\n            {\n              workflow,\n              workflowId,\n              prevResult: { status: 'success', output: foreachResult.payload } as any,\n              runId,\n              executionPath: [executionPath[0]!],\n              stepResults,\n              activeSteps,\n              resumeSteps,\n              timeTravel,\n              resumeData: undefined, // Don't pass resumeData when starting new iterations\n              parentWorkflow,\n              requestContext,\n              perStep,\n              state: currentState,\n              outputOptions,\n            },\n            {\n              pubsub: this.mastra.pubsub,\n              mastra: this.mastra,\n              step,\n            },\n          );\n          return;\n        }\n\n        if (suspendedCount > 0) {\n          // Some iterations are suspended - emit workflow suspend\n          // Build aggregated suspend metadata from all suspended iterations\n          const collectedResumeLabels: Record<string, { stepId: string; foreachIndex?: number }> = {};\n          // suspendedPaths maps stepId -> executionPath, using the step ID (not stepId[index])\n          const suspendedPaths: Record<string, number[]> = {\n            [step.step.id]: [executionPath[0]!],\n          };\n\n          for (let i = 0; i < iterationResults.length; i++) {\n            const iterResult = iterationResults[i];\n            if (iterResult && typeof iterResult === 'object' && iterResult.status === 'suspended') {\n              // Collect resume labels\n              if (iterResult.suspendPayload?.__workflow_meta?.resumeLabels) {\n                Object.assign(collectedResumeLabels, iterResult.suspendPayload.__workflow_meta.resumeLabels);\n              }\n            }\n          }\n\n          // Create the aggregated foreach step suspend result\n          const foreachSuspendResult = {\n            status: 'suspended' as const,\n            output: iterationResults,\n            payload: foreachResult.payload,\n            suspendedAt: Date.now(),\n            startedAt: foreachResult.startedAt,\n            suspendPayload: {\n              __workflow_meta: {\n                path: executionPath,\n                resumeLabels: collectedResumeLabels,\n              },\n            },\n          };\n\n          // Update the step result with aggregated suspend status\n          await workflowsStore?.updateWorkflowResults({\n            workflowName: workflow.id,\n            runId,\n            stepId: step.step.id,\n            result: foreachSuspendResult as any,\n            requestContext,\n          });\n\n          // Check shouldPersistSnapshot option - default to true if not specified\n          const shouldPersist =\n            workflow?.options?.shouldPersistSnapshot?.({\n              stepResults: stepResults ?? {},\n              workflowStatus: 'suspended',\n            }) ?? true;\n\n          if (shouldPersist) {\n            // Persist state to snapshot context before suspending\n            await workflowsStore?.updateWorkflowResults({\n              workflowName: workflow.id,\n              runId,\n              stepId: '__state',\n              result: currentState as any,\n              requestContext,\n            });\n\n            await workflowsStore?.updateWorkflowState({\n              workflowName: workflowId,\n              runId,\n              opts: {\n                status: 'suspended',\n                result: foreachSuspendResult,\n                suspendedPaths,\n                resumeLabels: collectedResumeLabels,\n              },\n            });\n          }\n\n          await this.mastra.pubsub.publish('workflows', {\n            type: 'workflow.suspend',\n            runId,\n            data: {\n              workflowId,\n              runId,\n              executionPath: [executionPath[0]!],\n              resumeSteps,\n              parentWorkflow,\n              stepResults: { ...stepResults, [step.step.id]: foreachSuspendResult },\n              prevResult: foreachSuspendResult,\n              activeSteps,\n              requestContext,\n              timeTravel,\n              state: currentState,\n              outputOptions,\n            },\n          });\n\n          return;\n        }\n\n        // All iterations succeeded - call processWorkflowForEach to advance to next step\n        await processWorkflowForEach(\n          {\n            workflow,\n            workflowId,\n            prevResult: { status: 'success', output: foreachResult.payload } as any,\n            runId,\n            executionPath: [executionPath[0]!],\n            stepResults,\n            activeSteps,\n            resumeSteps,\n            timeTravel,\n            resumeData: undefined,\n            parentWorkflow,\n            requestContext,\n            perStep,\n            state: currentState,\n            outputOptions,\n          },\n          {\n            pubsub: this.mastra.pubsub,\n            mastra: this.mastra,\n            step,\n          },\n        );\n        return;\n      }\n    } else if (isExecutableStep(step)) {\n      // clear from activeSteps\n      delete activeSteps[step.step.id];\n\n      // handle nested workflow\n      if (parentContext) {\n        prevResult = stepResults[step.step.id] = {\n          ...prevResult,\n          payload: parentContext.input?.output ?? {},\n          // Store nestedRunId in metadata for getWorkflowRunById retrieval\n          ...(nestedRunId && {\n            metadata: {\n              ...(prevResult as any).metadata,\n              nestedRunId,\n            },\n          }),\n        };\n      }\n\n      const newStepResults = await workflowsStore?.updateWorkflowResults({\n        workflowName: workflow.id,\n        runId,\n        stepId: step.step.id,\n        result: prevResult,\n        requestContext,\n      });\n\n      if (!newStepResults) {\n        return;\n      }\n\n      stepResults = newStepResults;\n    }\n\n    // Update stepResults with current state\n    stepResults = { ...stepResults, __state: currentState };\n\n    if (!prevResult?.status || prevResult.status === 'failed') {\n      await this.mastra.pubsub.publish('workflows', {\n        type: 'workflow.fail',\n        runId,\n        data: {\n          workflowId,\n          runId,\n          executionPath,\n          resumeSteps,\n          parentWorkflow,\n          stepResults,\n          timeTravel,\n          prevResult,\n          activeSteps,\n          requestContext,\n          state: currentState,\n          outputOptions,\n        },\n      });\n\n      return;\n    } else if (prevResult.status === 'suspended') {\n      const suspendedPaths: Record<string, number[]> = {};\n      const suspendedStep = getStep(workflow, executionPath);\n      if (suspendedStep) {\n        suspendedPaths[suspendedStep.id] = executionPath;\n      }\n\n      // Extract resume labels from suspend payload metadata\n      const resumeLabels: Record<string, { stepId: string; foreachIndex?: number }> =\n        prevResult.suspendPayload?.__workflow_meta?.resumeLabels ?? {};\n\n      // Check shouldPersistSnapshot option - default to true if not specified\n      const shouldPersist =\n        workflow?.options?.shouldPersistSnapshot?.({\n          stepResults: stepResults ?? {},\n          workflowStatus: 'suspended',\n        }) ?? true;\n\n      if (shouldPersist) {\n        // Persist state to snapshot context before suspending\n        // We use a special '__state' key to store state at the context level\n        await workflowsStore?.updateWorkflowResults({\n          workflowName: workflow.id,\n          runId,\n          stepId: '__state',\n          result: currentState as any,\n          requestContext,\n        });\n\n        await workflowsStore?.updateWorkflowState({\n          workflowName: workflowId,\n          runId,\n          opts: {\n            status: 'suspended',\n            result: prevResult,\n            suspendedPaths,\n            resumeLabels,\n          },\n        });\n      }\n\n      await this.mastra.pubsub.publish('workflows', {\n        type: 'workflow.suspend',\n        runId,\n        data: {\n          workflowId,\n          runId,\n          executionPath,\n          resumeSteps,\n          parentWorkflow,\n          stepResults,\n          prevResult,\n          activeSteps,\n          requestContext,\n          timeTravel,\n          state: currentState,\n          outputOptions,\n        },\n      });\n\n      await this.mastra.pubsub.publish(`workflow.events.v2.${runId}`, {\n        type: 'watch',\n        runId,\n        data: {\n          type: 'workflow-step-suspended',\n          payload: {\n            id: (step as any)?.step?.id,\n            ...prevResult,\n            suspendedAt: Date.now(),\n            suspendPayload: prevResult.suspendPayload,\n          },\n        },\n      });\n\n      return;\n    }\n\n    if (step?.type === 'step') {\n      await this.mastra.pubsub.publish(`workflow.events.v2.${runId}`, {\n        type: 'watch',\n        runId,\n        data: {\n          type: 'workflow-step-result',\n          payload: {\n            id: step.step.id,\n            ...prevResult,\n          },\n        },\n      });\n\n      if (prevResult.status === 'success') {\n        await this.mastra.pubsub.publish(`workflow.events.v2.${runId}`, {\n          type: 'watch',\n          runId,\n          data: {\n            type: 'workflow-step-finish',\n            payload: {\n              id: step.step.id,\n              metadata: {},\n            },\n          },\n        });\n      }\n    }\n\n    step = workflow.stepGraph[executionPath[0]!];\n    if (perStep) {\n      if (parentWorkflow && executionPath[0]! < workflow.stepGraph.length - 1) {\n        const { endedAt, output, status, ...nestedPrevResult } = prevResult as StepSuccess<any, any, any, any>;\n        await this.endWorkflow({\n          workflow,\n          parentWorkflow,\n          workflowId,\n          runId,\n          executionPath,\n          resumeSteps,\n          stepResults,\n          prevResult: { ...nestedPrevResult, status: 'paused' },\n          activeSteps,\n          requestContext,\n          perStep,\n        });\n      } else {\n        await this.endWorkflow({\n          workflow,\n          parentWorkflow,\n          workflowId,\n          runId,\n          executionPath,\n          resumeSteps,\n          stepResults,\n          prevResult,\n          activeSteps,\n          requestContext,\n          perStep,\n        });\n      }\n    } else if ((step?.type === 'parallel' || step?.type === 'conditional') && executionPath.length > 1) {\n      let skippedCount = 0;\n      const allResults: Record<string, any> = step.steps.reduce(\n        (acc, step) => {\n          if (isExecutableStep(step)) {\n            const res = stepResults?.[step.step.id];\n            if (res && res.status === 'success') {\n              acc[step.step.id] = res?.output;\n              // @ts-expect-error - skipped status not in type\n            } else if (res?.status === 'skipped') {\n              skippedCount++;\n            }\n          }\n\n          return acc;\n        },\n        {} as Record<string, StepResult<any, any, any, any>>,\n      );\n\n      const keys = Object.keys(allResults);\n      if (keys.length + skippedCount < step.steps.length) {\n        return;\n      }\n\n      await this.mastra.pubsub.publish('workflows', {\n        type: 'workflow.step.end',\n        runId,\n        data: {\n          parentWorkflow,\n          workflowId,\n          runId,\n          executionPath: executionPath.slice(0, -1),\n          resumeSteps,\n          stepResults,\n          prevResult: { status: 'success', output: allResults },\n          activeSteps,\n          requestContext,\n          timeTravel,\n          state: currentState,\n          outputOptions,\n        },\n      });\n    } else if (step?.type === 'foreach') {\n      // Get the original array from the foreach step's stored payload\n      const foreachStepResult = stepResults[step.step.id] as any;\n      const originalArray = foreachStepResult?.payload;\n      await this.mastra.pubsub.publish('workflows', {\n        type: 'workflow.step.run',\n        runId,\n        data: {\n          workflowId,\n          runId,\n          executionPath: executionPath.slice(0, -1),\n          resumeSteps,\n          parentWorkflow,\n          stepResults,\n          prevResult: { ...prevResult, output: originalArray },\n          activeSteps,\n          requestContext,\n          timeTravel,\n          state: currentState,\n          outputOptions,\n          forEachIndex,\n        },\n      });\n    } else if (executionPath[0]! >= workflow.stepGraph.length - 1) {\n      await this.endWorkflow({\n        workflow,\n        parentWorkflow,\n        workflowId,\n        runId,\n        executionPath,\n        resumeSteps,\n        stepResults,\n        prevResult,\n        activeSteps,\n        requestContext,\n        state: currentState,\n        outputOptions,\n      });\n    } else {\n      await this.mastra.pubsub.publish('workflows', {\n        type: 'workflow.step.run',\n        runId,\n        data: {\n          workflowId,\n          runId,\n          executionPath: executionPath.slice(0, -1).concat([executionPath[executionPath.length - 1]! + 1]),\n          resumeSteps,\n          parentWorkflow,\n          stepResults,\n          prevResult,\n          activeSteps,\n          requestContext,\n          timeTravel,\n          state: currentState,\n          outputOptions,\n        },\n      });\n    }\n  }\n\n  async loadData({\n    workflowId,\n    runId,\n  }: {\n    workflowId: string;\n    runId: string;\n  }): Promise<WorkflowRunState | null | undefined> {\n    const workflowsStore = await this.mastra.getStorage()?.getStore('workflows');\n    const snapshot = await workflowsStore?.loadWorkflowSnapshot({\n      workflowName: workflowId,\n      runId,\n    });\n\n    return snapshot;\n  }\n\n  async process(event: Event, ack?: () => Promise<void>) {\n    const { type, data } = event;\n\n    const workflowData = data as Omit<ProcessorArgs, 'workflow'>;\n\n    const currentState = await this.loadData({\n      workflowId: workflowData.workflowId,\n      runId: workflowData.runId,\n    });\n\n    if (currentState?.status === 'canceled' && type !== 'workflow.end' && type !== 'workflow.cancel') {\n      return;\n    }\n\n    if (type.startsWith('workflow.user-event.')) {\n      await processWorkflowWaitForEvent(\n        {\n          ...workflowData,\n          workflow: this.mastra.getWorkflow(workflowData.workflowId),\n        },\n        {\n          pubsub: this.mastra.pubsub,\n          eventName: type.split('.').slice(2).join('.'),\n          currentState: currentState!,\n        },\n      );\n      return;\n    }\n\n    let workflow;\n    if (this.mastra.__hasInternalWorkflow(workflowData.workflowId)) {\n      workflow = this.mastra.__getInternalWorkflow(workflowData.workflowId);\n    } else if (workflowData.parentWorkflow) {\n      workflow = getNestedWorkflow(this.mastra, workflowData.parentWorkflow);\n    } else {\n      workflow = this.mastra.getWorkflow(workflowData.workflowId);\n    }\n\n    if (!workflow) {\n      return this.errorWorkflow(\n        workflowData,\n        new MastraError({\n          id: 'MASTRA_WORKFLOW',\n          text: `Workflow not found: ${workflowData.workflowId}`,\n          domain: ErrorDomain.MASTRA_WORKFLOW,\n          category: ErrorCategory.SYSTEM,\n        }),\n      );\n    }\n\n    if (type === 'workflow.start' || type === 'workflow.resume') {\n      const { runId } = workflowData;\n      await this.mastra.pubsub.publish(`workflow.events.v2.${runId}`, {\n        type: 'watch',\n        runId,\n        data: {\n          type: 'workflow-start',\n          payload: {\n            runId,\n          },\n        },\n      });\n    }\n\n    switch (type) {\n      case 'workflow.cancel':\n        await this.processWorkflowCancel({\n          workflow,\n          ...workflowData,\n        });\n        break;\n      case 'workflow.start':\n        await this.processWorkflowStart({\n          workflow,\n          ...workflowData,\n        });\n        break;\n      case 'workflow.resume':\n        await this.processWorkflowStart({\n          workflow,\n          ...workflowData,\n        });\n        break;\n      case 'workflow.end':\n        await this.processWorkflowEnd({\n          workflow,\n          ...workflowData,\n        });\n        break;\n      case 'workflow.step.end':\n        await this.processWorkflowStepEnd({\n          workflow,\n          ...workflowData,\n        });\n        break;\n      case 'workflow.step.run':\n        await this.processWorkflowStepRun({\n          workflow,\n          ...workflowData,\n        });\n        break;\n      case 'workflow.suspend':\n        await this.processWorkflowSuspend({\n          workflow,\n          ...workflowData,\n        });\n        break;\n      case 'workflow.fail':\n        await this.processWorkflowFail({\n          workflow,\n          ...workflowData,\n        });\n        break;\n      default:\n        break;\n    }\n\n    try {\n      await ack?.();\n    } catch (e) {\n      this.mastra.getLogger()?.error('Error acking event', e);\n    }\n  }\n}\n","import { randomUUID } from 'node:crypto';\nimport { ReadableStream } from 'node:stream/web';\nimport type { CoreMessage } from '@internal/ai-sdk-v4';\nimport { z } from 'zod';\nimport { Agent } from '../../agent';\nimport type { MastraDBMessage } from '../../agent';\nimport { MessageList } from '../../agent/message-list';\nimport { TripWire } from '../../agent/trip-wire';\nimport { isSupportedLanguageModel } from '../../agent/utils';\nimport { RequestContext } from '../../di';\nimport { ErrorCategory, ErrorDomain, MastraError } from '../../error';\nimport type { MastraScorers } from '../../evals';\nimport type { Event } from '../../events';\nimport type { Mastra } from '../../mastra';\nimport type { TracingContext } from '../../observability';\nimport { EntityType, SpanType } from '../../observability';\nimport type { Processor } from '../../processors';\nimport { ProcessorRunner, ProcessorStepOutputSchema, ProcessorStepSchema } from '../../processors';\nimport type { ProcessorStepOutput } from '../../processors/step-schema';\nimport type { InferSchemaOutput, SchemaWithValidation } from '../../stream/base/schema';\nimport { WorkflowRunOutput } from '../../stream/RunOutput';\nimport type { ChunkType } from '../../stream/types';\nimport { ChunkFrom } from '../../stream/types';\nimport { Tool } from '../../tools';\nimport type { ToolExecutionContext } from '../../tools/types';\nimport type { DynamicArgument } from '../../types';\nimport { Workflow, Run } from '../../workflows';\nimport type { AgentStepOptions } from '../../workflows';\nimport type { ExecutionEngine, ExecutionGraph } from '../../workflows/execution-engine';\nimport type { Step } from '../../workflows/step';\nimport type {\n  SerializedStepFlowEntry,\n  WorkflowConfig,\n  WorkflowResult,\n  StepWithComponent,\n  WorkflowStreamEvent,\n  WorkflowEngineType,\n  WorkflowRunStatus,\n  StepParams,\n  ToolStep,\n  DefaultEngineType,\n  StepMetadata,\n} from '../../workflows/types';\nimport { PUBSUB_SYMBOL } from '../constants';\nimport { EventedExecutionEngine } from './execution-engine';\nimport { isTripwireChunk, createTripWireFromChunk, getTextDeltaFromChunk } from './helpers';\nimport type { TripwireChunk } from './helpers';\nimport { WorkflowEventProcessor } from './workflow-event-processor';\n\nexport type EventedEngineType = {};\n\nexport function cloneWorkflow<\n  TWorkflowId extends string = string,\n  TState = unknown,\n  TInput = unknown,\n  TOutput = unknown,\n  TSteps extends Step<string, any, any, any, any, any, EventedEngineType>[] = Step<\n    string,\n    any,\n    any,\n    any,\n    any,\n    any,\n    EventedEngineType\n  >[],\n  TPrevSchema = TInput,\n>(\n  workflow: Workflow<EventedEngineType, TSteps, string, TState, TInput, TOutput, TPrevSchema>,\n  opts: { id: TWorkflowId },\n): Workflow<EventedEngineType, TSteps, TWorkflowId, TState, TInput, TOutput, TPrevSchema> {\n  const wf: Workflow<EventedEngineType, TSteps, TWorkflowId, TState, TInput, TOutput, TPrevSchema> = new Workflow({\n    id: opts.id,\n    inputSchema: workflow.inputSchema,\n    outputSchema: workflow.outputSchema,\n    steps: workflow.stepDefs,\n    mastra: workflow.mastra,\n    options: workflow.options,\n  });\n\n  wf.setStepFlow(workflow.stepGraph);\n  wf.commit();\n  return wf;\n}\n\nexport function cloneStep<TStepId extends string>(\n  step: Step<string, any, any, any, any, any, EventedEngineType>,\n  opts: { id: TStepId },\n): Step<TStepId, any, any, any, any, any, EventedEngineType> {\n  return {\n    id: opts.id,\n    description: step.description,\n    inputSchema: step.inputSchema,\n    outputSchema: step.outputSchema,\n    suspendSchema: step.suspendSchema,\n    resumeSchema: step.resumeSchema,\n    stateSchema: step.stateSchema,\n    execute: step.execute,\n    retries: step.retries,\n    scorers: step.scorers,\n    metadata: step.metadata,\n    component: step.component,\n  };\n}\n\n// ============================================\n// Type Guards\n// ============================================\n\nfunction isAgent<TStepId extends string>(input: unknown): input is Agent<TStepId, any> {\n  return input instanceof Agent;\n}\n\nfunction isToolStep(input: unknown): input is ToolStep<any, any, any, any, any> {\n  return input instanceof Tool;\n}\n\nfunction isStepParams(input: unknown): input is StepParams<any, any, any, any, any, any> {\n  return (\n    input !== null &&\n    typeof input === 'object' &&\n    'id' in input &&\n    'execute' in input &&\n    !(input instanceof Agent) &&\n    !(input instanceof Tool)\n  );\n}\n\n/**\n * Type guard to check if an object is a Processor.\n * A Processor must have an 'id' property and at least one processor method.\n */\nfunction isProcessor(obj: unknown): obj is Processor {\n  return (\n    obj !== null &&\n    typeof obj === 'object' &&\n    'id' in obj &&\n    typeof (obj as any).id === 'string' &&\n    !(obj instanceof Agent) &&\n    !(obj instanceof Tool) &&\n    (typeof (obj as any).processInput === 'function' ||\n      typeof (obj as any).processInputStep === 'function' ||\n      typeof (obj as any).processOutputStream === 'function' ||\n      typeof (obj as any).processOutputResult === 'function' ||\n      typeof (obj as any).processOutputStep === 'function')\n  );\n}\n\n// ============================================\n// Overloads (Public API - clean types for consumers)\n// ============================================\n\n/**\n * Creates a step from explicit params (FIRST overload for best error messages)\n * @param params Configuration parameters for the step\n * @param params.id Unique identifier for the step\n * @param params.description Optional description of what the step does\n * @param params.inputSchema Zod schema defining the input structure\n * @param params.outputSchema Zod schema defining the output structure\n * @param params.execute Function that performs the step's operations\n * @returns A Step object that can be added to the workflow\n */\nexport function createStep<\n  TStepId extends string,\n  TStateSchema extends z.ZodTypeAny | undefined,\n  TInputSchema extends z.ZodTypeAny,\n  TOutputSchema extends z.ZodTypeAny,\n  TResumeSchema extends z.ZodTypeAny | undefined = undefined,\n  TSuspendSchema extends z.ZodTypeAny | undefined = undefined,\n>(\n  params: StepParams<TStepId, TStateSchema, TInputSchema, TOutputSchema, TResumeSchema, TSuspendSchema>,\n): Step<\n  TStepId,\n  TStateSchema extends z.ZodTypeAny ? z.infer<TStateSchema> : unknown,\n  z.infer<TInputSchema>,\n  z.infer<TOutputSchema>,\n  TResumeSchema extends z.ZodTypeAny ? z.infer<TResumeSchema> : unknown,\n  TSuspendSchema extends z.ZodTypeAny ? z.infer<TSuspendSchema> : unknown,\n  DefaultEngineType\n>;\n\n/**\n * Creates a step from an agent with structured output\n */\nexport function createStep<TStepId extends string, TStepOutput>(\n  agent: Agent<TStepId, any>,\n  agentOptions: AgentStepOptions<TStepOutput> & {\n    structuredOutput: { schema: TStepOutput };\n    retries?: number;\n    scorers?: DynamicArgument<MastraScorers>;\n    metadata?: StepMetadata;\n  },\n): Step<TStepId, unknown, { prompt: string }, TStepOutput, unknown, unknown, DefaultEngineType>;\n\n/**\n * Creates a step from an agent (defaults to { text: string } output)\n */\nexport function createStep<\n  TStepId extends string,\n  TStepInput extends { prompt: string },\n  TStepOutput extends { text: string },\n  TResume,\n  TSuspend,\n>(agent: Agent<TStepId, any>): Step<TStepId, any, TStepInput, TStepOutput, TResume, TSuspend, DefaultEngineType>;\n\n/**\n * Creates a step from a tool\n */\nexport function createStep<\n  TSchemaIn,\n  TSuspend,\n  TResume,\n  TSchemaOut,\n  TContext extends ToolExecutionContext<TSuspend, TResume, any>,\n  TId extends string,\n  TRequestContext extends Record<string, any> | unknown = unknown,\n>(\n  tool: Tool<TSchemaIn, TSchemaOut, TSuspend, TResume, TContext, TId, TRequestContext>,\n  toolOptions?: { retries?: number; scorers?: DynamicArgument<MastraScorers>; metadata?: StepMetadata },\n): Step<TId, any, TSchemaIn, TSchemaOut, TSuspend, TResume, DefaultEngineType, TRequestContext>;\n\n/**\n * Creates a step from a Processor - wraps a Processor as a workflow step\n * Note: We require at least one processor method to distinguish from StepParams\n */\nexport function createStep<TProcessorId extends string>(\n  processor:\n    | (Processor<TProcessorId> & { processInput: Function })\n    | (Processor<TProcessorId> & { processInputStream: Function })\n    | (Processor<TProcessorId> & { processInputStep: Function })\n    | (Processor<TProcessorId> & { processOutputStream: Function })\n    | (Processor<TProcessorId> & { processOutputResult: Function })\n    | (Processor<TProcessorId> & { processOutputStep: Function }),\n): Step<\n  `processor:${TProcessorId}`,\n  unknown,\n  InferSchemaOutput<typeof ProcessorStepSchema>,\n  InferSchemaOutput<typeof ProcessorStepOutputSchema>,\n  unknown,\n  unknown,\n  DefaultEngineType\n>;\n\n/**\n * IMPORTANT: Fallback overload - provides better error messages when StepParams doesn't match\n * This should be LAST and will show clearer errors about what's wrong\n * This is a copy of first one, KEEP THIS IN SYNC!\n */\nexport function createStep<\n  TStepId extends string,\n  TStateSchema extends z.ZodTypeAny | undefined,\n  TInputSchema extends z.ZodTypeAny,\n  TOutputSchema extends z.ZodTypeAny,\n  TResumeSchema extends z.ZodTypeAny | undefined = undefined,\n  TSuspendSchema extends z.ZodTypeAny | undefined = undefined,\n>(\n  params: StepParams<TStepId, TStateSchema, TInputSchema, TOutputSchema, TResumeSchema, TSuspendSchema>,\n): Step<\n  TStepId,\n  TStateSchema extends z.ZodTypeAny ? z.infer<TStateSchema> : unknown,\n  z.infer<TInputSchema>,\n  z.infer<TOutputSchema>,\n  TResumeSchema extends z.ZodTypeAny ? z.infer<TResumeSchema> : unknown,\n  TSuspendSchema extends z.ZodTypeAny ? z.infer<TSuspendSchema> : unknown,\n  DefaultEngineType\n>;\n\n// ============================================\n// Implementation (uses type guards for clean logic)\n// ============================================\n\nexport function createStep(params: any, agentOrToolOptions?: any): Step<any, any, any, any, any, any, any> {\n  // Type guards determine the correct factory function\n  // Overloads ensure type safety for consumers\n  if (isAgent(params)) {\n    return createStepFromAgent(params, agentOrToolOptions);\n  }\n\n  if (isToolStep(params)) {\n    return createStepFromTool(params, agentOrToolOptions);\n  }\n\n  if (isProcessor(params)) {\n    return createStepFromProcessor(params);\n  }\n\n  if (isStepParams(params)) {\n    return createStepFromParams(params);\n  }\n\n  throw new Error('Invalid input: expected StepParams, Agent, ToolStep, or Processor');\n}\n\n// ============================================\n// Internal Implementations\n// ============================================\n\nfunction createStepFromParams(\n  params: StepParams<any, any, any, any, any, any, any>,\n): Step<any, any, any, any, any, any, DefaultEngineType, any> {\n  return {\n    id: params.id,\n    description: params.description,\n    inputSchema: params.inputSchema,\n    stateSchema: params.stateSchema,\n    outputSchema: params.outputSchema,\n    resumeSchema: params.resumeSchema,\n    suspendSchema: params.suspendSchema,\n    requestContextSchema: params.requestContextSchema,\n    scorers: params.scorers,\n    retries: params.retries,\n    metadata: params.metadata,\n    execute: params.execute.bind(params),\n  };\n}\n\n/**\n * Processes an agent stream, publishing events and detecting tripwires.\n * This helper unifies the V1 and V2 stream processing paths.\n */\nasync function processAgentStream(params: {\n  fullStream: AsyncIterable<unknown>;\n  isV2Model: boolean;\n  pubsub: { publish: (channel: string, data: any) => Promise<void> };\n  runId: string;\n  toolData: { name: string; args: unknown };\n  logger?: { debug: (msg: string, data?: unknown) => void };\n}): Promise<{ tripwireChunk: TripwireChunk | null }> {\n  const { fullStream, isV2Model, pubsub, runId, toolData, logger } = params;\n\n  // Publish stream start event\n  try {\n    await pubsub.publish(`workflow.events.v2.${runId}`, {\n      type: 'watch',\n      runId,\n      data: { type: 'tool-call-streaming-start', ...toolData },\n    });\n  } catch (err) {\n    // Non-critical: continue even if publish fails\n    logger?.debug('Failed to publish stream start event', { runId, error: err });\n  }\n\n  let tripwireChunk: TripwireChunk | null = null;\n\n  for await (const chunk of fullStream) {\n    // Check for tripwire chunks from agent processors\n    if (isTripwireChunk(chunk)) {\n      tripwireChunk = chunk;\n      break;\n    }\n\n    // Publish text deltas\n    if (typeof chunk === 'object' && chunk !== null && 'type' in chunk && chunk.type === 'text-delta') {\n      const textDelta = getTextDeltaFromChunk(chunk as any, isV2Model);\n      if (textDelta) {\n        try {\n          await pubsub.publish(`workflow.events.v2.${runId}`, {\n            type: 'watch',\n            runId,\n            data: { type: 'tool-call-delta', ...toolData, argsTextDelta: textDelta },\n          });\n        } catch (err) {\n          // Non-critical: continue even if publish fails\n          logger?.debug('Failed to publish stream delta event', { runId, error: err });\n        }\n      }\n    }\n  }\n\n  // Publish stream finish event\n  try {\n    await pubsub.publish(`workflow.events.v2.${runId}`, {\n      type: 'watch',\n      runId,\n      data: { type: 'tool-call-streaming-finish', ...toolData },\n    });\n  } catch (err) {\n    // Non-critical: continue even if publish fails\n    logger?.debug('Failed to publish stream finish event', { runId, error: err });\n  }\n\n  return { tripwireChunk };\n}\n\n/**\n * Safely invokes the user's onFinish callback with error logging.\n */\nasync function safeOnFinish(\n  callback: ((result: unknown) => void | Promise<void>) | undefined,\n  result: unknown,\n  logger?: { warn: (msg: string, data?: unknown) => void },\n): Promise<void> {\n  if (!callback) return;\n  try {\n    await callback(result);\n  } catch (err) {\n    // User callback errors are logged but don't fail the step\n    logger?.warn('User onFinish callback threw an error', { error: err });\n  }\n}\n\nfunction createStepFromAgent<TStepId extends string, TStepOutput>(\n  params: Agent<TStepId, any>,\n  agentOrToolOptions?: Record<string, unknown>,\n): Step<TStepId, any, any, TStepOutput, unknown, unknown, DefaultEngineType> {\n  const options = (agentOrToolOptions ?? {}) as\n    | (AgentStepOptions<TStepOutput> & {\n        retries?: number;\n        scorers?: DynamicArgument<MastraScorers>;\n        metadata?: StepMetadata;\n      })\n    | undefined;\n  // Determine output schema based on structuredOutput option\n  const outputSchema = (options?.structuredOutput?.schema ??\n    z.object({ text: z.string() })) as unknown as SchemaWithValidation<TStepOutput>;\n  const { retries, scorers, metadata, ...agentOptions } = options ?? {};\n\n  return {\n    id: params.id,\n    description: params.getDescription(),\n    inputSchema: z.object({\n      prompt: z.string(),\n    }),\n    outputSchema,\n    retries,\n    scorers,\n    metadata,\n    execute: async ({\n      inputData,\n      runId,\n      mastra,\n      [PUBSUB_SYMBOL]: pubsub,\n      requestContext,\n      tracingContext,\n      abortSignal,\n      abort,\n    }) => {\n      const logger = mastra?.getLogger();\n      const toolData = {\n        name: params.name,\n        args: inputData,\n      };\n\n      // Detect model version to choose streaming method\n      const llm = await params.getLLM({ requestContext });\n      const modelInfo = llm.getModel();\n      const isV2Model = isSupportedLanguageModel(modelInfo);\n\n      // Track structured output result\n      let structuredResult: any = null;\n\n      // Common callback to capture structured output\n      const handleFinish = (result: { text: string; object?: unknown }) => {\n        const resultWithObject = result as typeof result & { object?: unknown };\n        if ((agentOptions as any)?.structuredOutput?.schema && resultWithObject.object) {\n          structuredResult = resultWithObject.object;\n        }\n      };\n\n      // Get the appropriate stream based on model version\n      let fullStream: AsyncIterable<unknown>;\n      let textPromise: Promise<string>;\n\n      if (isV2Model) {\n        // V2+ model path: use .stream() which returns MastraModelOutput\n        const modelOutput = await params.stream((inputData as { prompt: string }).prompt, {\n          ...(agentOptions ?? {}),\n          tracingContext,\n          requestContext,\n          onFinish: result => {\n            handleFinish(result);\n            void safeOnFinish((agentOptions as any)?.onFinish, result, logger);\n          },\n          abortSignal,\n        });\n        fullStream = modelOutput.fullStream;\n        textPromise = modelOutput.text;\n      } else {\n        // V1 model path: use .streamLegacy() for backwards compatibility\n        let resolveText: (value: string) => void;\n        textPromise = new Promise(resolve => {\n          resolveText = resolve;\n        });\n\n        const legacyResult = await params.streamLegacy((inputData as { prompt: string }).prompt, {\n          ...(agentOptions ?? {}),\n          tracingContext,\n          requestContext,\n          onFinish: result => {\n            handleFinish(result);\n            resolveText!(result.text);\n            void safeOnFinish((agentOptions as any)?.onFinish, result, logger);\n          },\n          abortSignal,\n        });\n        fullStream = legacyResult.fullStream;\n      }\n\n      if (abortSignal.aborted) {\n        return abort() as TStepOutput;\n      }\n\n      // Process the stream (unified for V1/V2)\n      const { tripwireChunk } = await processAgentStream({\n        fullStream,\n        isV2Model,\n        pubsub,\n        runId,\n        toolData,\n        logger,\n      });\n\n      // Handle tripwire if detected\n      if (tripwireChunk) {\n        throw createTripWireFromChunk(tripwireChunk);\n      }\n\n      // Return structured output if available, otherwise return text\n      if (structuredResult !== null) {\n        return structuredResult as TStepOutput;\n      }\n\n      return {\n        text: await textPromise,\n      } as TStepOutput;\n    },\n    component: params.component,\n  };\n}\n\nfunction createStepFromTool<TStepInput, TSuspend, TResume, TStepOutput>(\n  params: ToolStep<TStepInput, TSuspend, TResume, TStepOutput, any>,\n  agentOrToolOptions?: Record<string, unknown>,\n): Step<string, any, TStepInput, TStepOutput, TResume, TSuspend, DefaultEngineType> {\n  const toolOpts = agentOrToolOptions as\n    | { retries?: number; scorers?: DynamicArgument<MastraScorers>; metadata?: StepMetadata }\n    | undefined;\n  if (!params.inputSchema || !params.outputSchema) {\n    throw new Error('Tool must have input and output schemas defined');\n  }\n\n  return {\n    id: params.id,\n    description: params.description,\n    inputSchema: params.inputSchema,\n    outputSchema: params.outputSchema,\n    resumeSchema: params.resumeSchema,\n    suspendSchema: params.suspendSchema,\n    retries: toolOpts?.retries,\n    scorers: toolOpts?.scorers,\n    metadata: toolOpts?.metadata,\n    execute: async ({ inputData, mastra, requestContext, suspend, resumeData, runId, workflowId, state, setState }) => {\n      // Tools receive (input, context) - just call the tool's execute\n      if (!params.execute) {\n        throw new Error(`Tool ${params.id} does not have an execute function`);\n      }\n\n      // Build context matching ToolExecutionContext structure\n      const context = {\n        mastra,\n        requestContext,\n        tracingContext: { currentSpan: undefined }, // TODO: Pass proper tracing context when evented workflows support tracing\n        workflow: {\n          runId,\n          workflowId,\n          state,\n          setState,\n          suspend,\n          resumeData,\n        },\n      };\n\n      // Tool.execute already handles the v1.0 signature properly\n      return params.execute(inputData, context) as TStepOutput;\n    },\n    component: 'TOOL',\n  };\n}\n\nfunction createStepFromProcessor<TProcessorId extends string>(\n  processor: Processor<TProcessorId>,\n): Step<\n  `processor:${TProcessorId}`,\n  unknown,\n  InferSchemaOutput<typeof ProcessorStepSchema>,\n  InferSchemaOutput<typeof ProcessorStepOutputSchema>,\n  unknown,\n  unknown,\n  DefaultEngineType\n> {\n  // Helper to map phase to entity type\n  const getProcessorEntityType = (phase: string): EntityType => {\n    switch (phase) {\n      case 'input':\n        return EntityType.INPUT_PROCESSOR;\n      case 'inputStep':\n        return EntityType.INPUT_STEP_PROCESSOR;\n      case 'outputStream':\n      case 'outputResult':\n        return EntityType.OUTPUT_PROCESSOR;\n      case 'outputStep':\n        return EntityType.OUTPUT_STEP_PROCESSOR;\n      default:\n        return EntityType.OUTPUT_PROCESSOR;\n    }\n  };\n\n  // Helper to get span name prefix\n  const getSpanNamePrefix = (phase: string): string => {\n    switch (phase) {\n      case 'input':\n        return 'input processor';\n      case 'inputStep':\n        return 'input step processor';\n      case 'outputStream':\n        return 'output stream processor';\n      case 'outputResult':\n        return 'output processor';\n      case 'outputStep':\n        return 'output step processor';\n      default:\n        return 'processor';\n    }\n  };\n\n  // Helper to check if processor implements a phase\n  const hasPhaseMethod = (phase: string): boolean => {\n    switch (phase) {\n      case 'input':\n        return !!processor.processInput;\n      case 'inputStep':\n        return !!processor.processInputStep;\n      case 'outputStream':\n        return !!processor.processOutputStream;\n      case 'outputResult':\n        return !!processor.processOutputResult;\n      case 'outputStep':\n        return !!processor.processOutputStep;\n      default:\n        return false;\n    }\n  };\n\n  return {\n    id: `processor:${processor.id}`,\n    description: processor.name ?? `Processor ${processor.id}`,\n    inputSchema: ProcessorStepSchema,\n    outputSchema: ProcessorStepOutputSchema,\n    execute: async ({ inputData, requestContext, tracingContext }) => {\n      // Cast to output type for easier property access - the discriminated union\n      // ensures type safety at the schema level, but inside the execute function\n      // we need access to all possible properties\n      const input = inputData as ProcessorStepOutput & { abortSignal?: AbortSignal };\n      const {\n        phase,\n        messages,\n        messageList,\n        stepNumber,\n        systemMessages,\n        part,\n        streamParts,\n        state,\n        finishReason,\n        toolCalls,\n        text,\n        retryCount,\n        // inputStep phase fields for model/tools configuration\n        model,\n        tools,\n        toolChoice,\n        activeTools,\n        providerOptions,\n        modelSettings,\n        structuredOutput,\n        steps,\n        // Abort signal for cancelling in-flight processor work (e.g. OM observations)\n        abortSignal,\n      } = input;\n\n      // Create a minimal abort function that throws TripWire\n      const abort = (reason?: string, options?: { retry?: boolean; metadata?: unknown }): never => {\n        throw new TripWire(reason || `Tripwire triggered by ${processor.id}`, options, processor.id);\n      };\n\n      // Early return if processor doesn't implement this phase - no span created\n      // This prevents empty spans for phases the processor doesn't handle\n      if (!hasPhaseMethod(phase)) {\n        return input;\n      }\n\n      // Create processor span for non-stream phases\n      // outputStream phase doesn't need its own span (stream chunks are already tracked)\n      const currentSpan = tracingContext?.currentSpan;\n\n      // Find appropriate parent span:\n      // - For input/outputResult: find AGENT_RUN (processor runs once at start/end)\n      // - For inputStep/outputStep: find MODEL_STEP (processor runs per LLM call)\n      // When workflow is executed, currentSpan is WORKFLOW_STEP, so we walk up the parent chain\n      const parentSpan =\n        phase === 'inputStep' || phase === 'outputStep'\n          ? currentSpan?.findParent(SpanType.MODEL_STEP) || currentSpan\n          : currentSpan?.findParent(SpanType.AGENT_RUN) || currentSpan;\n\n      const processorSpan =\n        phase !== 'outputStream'\n          ? parentSpan?.createChildSpan({\n              type: SpanType.PROCESSOR_RUN,\n              name: `${getSpanNamePrefix(phase)}: ${processor.id}`,\n              entityType: getProcessorEntityType(phase),\n              entityId: processor.id,\n              entityName: processor.name ?? processor.id,\n              input: { phase, messageCount: messages?.length },\n              attributes: {\n                processorExecutor: 'workflow',\n                // Read processorIndex from processor (set in combineProcessorsIntoWorkflow)\n                processorIndex: processor.processorIndex,\n              },\n            })\n          : undefined;\n\n      // Create tracing context with processor span so internal agent calls nest correctly\n      const processorTracingContext: TracingContext | undefined = processorSpan\n        ? { currentSpan: processorSpan }\n        : tracingContext;\n\n      // Base context for all processor methods - includes requestContext for memory processors\n      // and tracingContext for proper span nesting when processors call internal agents\n      const baseContext = {\n        abort,\n        retryCount: retryCount ?? 0,\n        requestContext,\n        tracingContext: processorTracingContext,\n        state: state ?? {},\n        abortSignal,\n      };\n\n      // Pass-through data that should flow to the next processor in a chain\n      // This enables processor workflows to use .then(), .parallel(), .branch(), etc.\n      const passThrough = {\n        phase,\n        // Auto-create MessageList from messages if not provided\n        // This enables running processor workflows from the UI where messageList can't be serialized\n        messageList:\n          messageList ??\n          (Array.isArray(messages)\n            ? new MessageList()\n                .add(messages as MastraDBMessage[], 'input')\n                .addSystem((systemMessages ?? []) as CoreMessage[])\n            : undefined),\n        stepNumber,\n        systemMessages,\n        streamParts,\n        state,\n        finishReason,\n        toolCalls,\n        text,\n        retryCount,\n        // inputStep phase fields for model/tools configuration\n        model,\n        tools,\n        toolChoice,\n        activeTools,\n        providerOptions,\n        modelSettings,\n        structuredOutput,\n        steps,\n      };\n\n      // Helper to execute phase with proper span lifecycle management\n      const executePhaseWithSpan = async <T>(fn: () => Promise<T>): Promise<T> => {\n        try {\n          const result = await fn();\n          processorSpan?.end({ output: result });\n          return result;\n        } catch (error) {\n          // TripWire errors should end span but bubble up to halt the workflow\n          if (error instanceof TripWire) {\n            processorSpan?.end({ output: { tripwire: error.message } });\n          } else {\n            processorSpan?.error({ error: error as Error, endSpan: true });\n          }\n          throw error;\n        }\n      };\n\n      // Execute the phase with span lifecycle management\n      return executePhaseWithSpan(async () => {\n        switch (phase) {\n          case 'input': {\n            if (processor.processInput) {\n              if (!passThrough.messageList) {\n                throw new MastraError({\n                  category: ErrorCategory.USER,\n                  domain: ErrorDomain.MASTRA_WORKFLOW,\n                  id: 'PROCESSOR_MISSING_MESSAGE_LIST',\n                  text: `Processor ${processor.id} requires messageList or messages for processInput phase`,\n                });\n              }\n\n              // Create source checker before processing to preserve message sources\n              const idsBeforeProcessing = (messages as MastraDBMessage[]).map(m => m.id);\n              const check = passThrough.messageList.makeMessageSourceChecker();\n\n              const result = await processor.processInput({\n                ...baseContext,\n                messages: messages as MastraDBMessage[],\n                messageList: passThrough.messageList,\n                systemMessages: (systemMessages ?? []) as CoreMessage[],\n              });\n\n              if (result instanceof MessageList) {\n                // Validate same instance\n                if (result !== passThrough.messageList) {\n                  throw new MastraError({\n                    category: ErrorCategory.USER,\n                    domain: ErrorDomain.MASTRA_WORKFLOW,\n                    id: 'PROCESSOR_RETURNED_EXTERNAL_MESSAGE_LIST',\n                    text: `Processor ${processor.id} returned a MessageList instance other than the one passed in. Use the messageList argument instead.`,\n                  });\n                }\n                return {\n                  ...passThrough,\n                  messages: result.get.all.db(),\n                  systemMessages: result.getAllSystemMessages(),\n                };\n              } else if (Array.isArray(result)) {\n                // Processor returned an array of messages\n                ProcessorRunner.applyMessagesToMessageList(\n                  result as MastraDBMessage[],\n                  passThrough.messageList,\n                  idsBeforeProcessing,\n                  check,\n                  'input',\n                );\n                return { ...passThrough, messages: result };\n              } else if (result && 'messages' in result && 'systemMessages' in result) {\n                // Processor returned { messages, systemMessages }\n                const typedResult = result as { messages: MastraDBMessage[]; systemMessages: CoreMessage[] };\n                ProcessorRunner.applyMessagesToMessageList(\n                  typedResult.messages,\n                  passThrough.messageList,\n                  idsBeforeProcessing,\n                  check,\n                  'input',\n                );\n                passThrough.messageList.replaceAllSystemMessages(typedResult.systemMessages);\n                return {\n                  ...passThrough,\n                  messages: typedResult.messages,\n                  systemMessages: typedResult.systemMessages,\n                };\n              }\n              return { ...passThrough, messages };\n            }\n            return { ...passThrough, messages };\n          }\n\n          case 'inputStep': {\n            if (processor.processInputStep) {\n              if (!passThrough.messageList) {\n                throw new MastraError({\n                  category: ErrorCategory.USER,\n                  domain: ErrorDomain.MASTRA_WORKFLOW,\n                  id: 'PROCESSOR_MISSING_MESSAGE_LIST',\n                  text: `Processor ${processor.id} requires messageList or messages for processInputStep phase`,\n                });\n              }\n\n              // Create source checker before processing to preserve message sources\n              const idsBeforeProcessing = (messages as MastraDBMessage[]).map(m => m.id);\n              const check = passThrough.messageList.makeMessageSourceChecker();\n\n              const result = await processor.processInputStep({\n                ...baseContext,\n                messages: messages as MastraDBMessage[],\n                messageList: passThrough.messageList,\n                stepNumber: stepNumber ?? 0,\n                systemMessages: (systemMessages ?? []) as CoreMessage[],\n                // Pass model/tools configuration fields - types match ProcessInputStepArgs\n                model: model!,\n                tools,\n                toolChoice,\n                activeTools,\n                providerOptions,\n                modelSettings,\n                structuredOutput,\n                steps: steps ?? [],\n              });\n\n              const validatedResult = await ProcessorRunner.validateAndFormatProcessInputStepResult(result, {\n                messageList: passThrough.messageList,\n                processor,\n                stepNumber: stepNumber ?? 0,\n              });\n\n              if (validatedResult.messages) {\n                ProcessorRunner.applyMessagesToMessageList(\n                  validatedResult.messages,\n                  passThrough.messageList,\n                  idsBeforeProcessing,\n                  check,\n                );\n              }\n\n              if (validatedResult.systemMessages) {\n                passThrough.messageList!.replaceAllSystemMessages(validatedResult.systemMessages as CoreMessage[]);\n              }\n\n              // Preserve messages in return - passThrough doesn't include messages,\n              // so we must explicitly include it to avoid losing it for subsequent steps\n              return { ...passThrough, messages, ...validatedResult };\n            }\n            return { ...passThrough, messages };\n          }\n\n          case 'outputStream': {\n            if (processor.processOutputStream) {\n              // Manage per-processor span lifecycle across stream chunks\n              // Use unique key to store span on shared state object\n              const spanKey = `__outputStreamSpan_${processor.id}`;\n              const mutableState = (state ?? {}) as Record<string, unknown>;\n              let processorSpan = mutableState[spanKey] as\n                | ReturnType<NonNullable<typeof parentSpan>['createChildSpan']>\n                | undefined;\n\n              if (!processorSpan && parentSpan) {\n                // First chunk - create span for this processor\n                processorSpan = parentSpan.createChildSpan({\n                  type: SpanType.PROCESSOR_RUN,\n                  name: `output stream processor: ${processor.id}`,\n                  entityType: EntityType.OUTPUT_PROCESSOR,\n                  entityId: processor.id,\n                  entityName: processor.name ?? processor.id,\n                  input: { phase, streamParts: [] },\n                  attributes: {\n                    processorExecutor: 'workflow',\n                    processorIndex: processor.processorIndex,\n                  },\n                });\n                mutableState[spanKey] = processorSpan;\n              }\n\n              // Update span with current chunk data\n              if (processorSpan) {\n                processorSpan.input = {\n                  phase,\n                  streamParts: streamParts ?? [],\n                  totalChunks: (streamParts ?? []).length,\n                };\n              }\n\n              // Create tracing context with processor span for internal agent calls\n              const processorTracingContext = processorSpan\n                ? { currentSpan: processorSpan }\n                : baseContext.tracingContext;\n\n              // Handle outputStream span lifecycle explicitly (not via executePhaseWithSpan)\n              // because outputStream uses a per-processor span stored in mutableState\n              let result: ChunkType | null | undefined;\n              try {\n                result = await processor.processOutputStream({\n                  ...baseContext,\n                  tracingContext: processorTracingContext,\n                  part: part as ChunkType,\n                  streamParts: (streamParts ?? []) as ChunkType[],\n                  state: mutableState,\n                  messageList: passThrough.messageList, // Optional for stream processing\n                });\n\n                // End span on finish chunk\n                if (part && (part as ChunkType).type === 'finish') {\n                  processorSpan?.end({ output: result });\n                  delete mutableState[spanKey];\n                }\n              } catch (error) {\n                // End span with error and clean up state\n                if (error instanceof TripWire) {\n                  processorSpan?.end({ output: { tripwire: error.message } });\n                } else {\n                  processorSpan?.error({ error: error as Error, endSpan: true });\n                }\n                delete mutableState[spanKey];\n                throw error;\n              }\n\n              return { ...passThrough, state: mutableState, part: result };\n            }\n            return { ...passThrough, part };\n          }\n\n          case 'outputResult': {\n            if (processor.processOutputResult) {\n              if (!passThrough.messageList) {\n                throw new MastraError({\n                  category: ErrorCategory.USER,\n                  domain: ErrorDomain.MASTRA_WORKFLOW,\n                  id: 'PROCESSOR_MISSING_MESSAGE_LIST',\n                  text: `Processor ${processor.id} requires messageList or messages for processOutputResult phase`,\n                });\n              }\n\n              // Create source checker before processing to preserve message sources\n              const idsBeforeProcessing = (messages as MastraDBMessage[]).map(m => m.id);\n              const check = passThrough.messageList.makeMessageSourceChecker();\n\n              const result = await processor.processOutputResult({\n                ...baseContext,\n                messages: messages as MastraDBMessage[],\n                messageList: passThrough.messageList,\n              });\n\n              if (result instanceof MessageList) {\n                // Validate same instance\n                if (result !== passThrough.messageList) {\n                  throw new MastraError({\n                    category: ErrorCategory.USER,\n                    domain: ErrorDomain.MASTRA_WORKFLOW,\n                    id: 'PROCESSOR_RETURNED_EXTERNAL_MESSAGE_LIST',\n                    text: `Processor ${processor.id} returned a MessageList instance other than the one passed in. Use the messageList argument instead.`,\n                  });\n                }\n                return {\n                  ...passThrough,\n                  messages: result.get.all.db(),\n                  systemMessages: result.getAllSystemMessages(),\n                };\n              } else if (Array.isArray(result)) {\n                // Processor returned an array of messages\n                ProcessorRunner.applyMessagesToMessageList(\n                  result as MastraDBMessage[],\n                  passThrough.messageList,\n                  idsBeforeProcessing,\n                  check,\n                  'response',\n                );\n                return { ...passThrough, messages: result };\n              } else if (result && 'messages' in result && 'systemMessages' in result) {\n                // Processor returned { messages, systemMessages }\n                const typedResult = result as { messages: MastraDBMessage[]; systemMessages: CoreMessage[] };\n                ProcessorRunner.applyMessagesToMessageList(\n                  typedResult.messages,\n                  passThrough.messageList,\n                  idsBeforeProcessing,\n                  check,\n                  'response',\n                );\n                passThrough.messageList.replaceAllSystemMessages(typedResult.systemMessages);\n                return {\n                  ...passThrough,\n                  messages: typedResult.messages,\n                  systemMessages: typedResult.systemMessages,\n                };\n              }\n              return { ...passThrough, messages };\n            }\n            return { ...passThrough, messages };\n          }\n\n          case 'outputStep': {\n            if (processor.processOutputStep) {\n              if (!passThrough.messageList) {\n                throw new MastraError({\n                  category: ErrorCategory.USER,\n                  domain: ErrorDomain.MASTRA_WORKFLOW,\n                  id: 'PROCESSOR_MISSING_MESSAGE_LIST',\n                  text: `Processor ${processor.id} requires messageList or messages for processOutputStep phase`,\n                });\n              }\n\n              // Create source checker before processing to preserve message sources\n              const idsBeforeProcessing = (messages as MastraDBMessage[]).map(m => m.id);\n              const check = passThrough.messageList.makeMessageSourceChecker();\n\n              const result = await processor.processOutputStep({\n                ...baseContext,\n                messages: messages as MastraDBMessage[],\n                messageList: passThrough.messageList,\n                stepNumber: stepNumber ?? 0,\n                finishReason,\n                toolCalls: toolCalls as any,\n                text,\n                systemMessages: (systemMessages ?? []) as CoreMessage[],\n                steps: steps ?? [],\n              });\n\n              if (result instanceof MessageList) {\n                // Validate same instance\n                if (result !== passThrough.messageList) {\n                  throw new MastraError({\n                    category: ErrorCategory.USER,\n                    domain: ErrorDomain.MASTRA_WORKFLOW,\n                    id: 'PROCESSOR_RETURNED_EXTERNAL_MESSAGE_LIST',\n                    text: `Processor ${processor.id} returned a MessageList instance other than the one passed in. Use the messageList argument instead.`,\n                  });\n                }\n                return {\n                  ...passThrough,\n                  messages: result.get.all.db(),\n                  systemMessages: result.getAllSystemMessages(),\n                };\n              } else if (Array.isArray(result)) {\n                // Processor returned an array of messages\n                ProcessorRunner.applyMessagesToMessageList(\n                  result as MastraDBMessage[],\n                  passThrough.messageList,\n                  idsBeforeProcessing,\n                  check,\n                  'response',\n                );\n                return { ...passThrough, messages: result };\n              } else if (result && 'messages' in result && 'systemMessages' in result) {\n                // Processor returned { messages, systemMessages }\n                const typedResult = result as { messages: MastraDBMessage[]; systemMessages: CoreMessage[] };\n                ProcessorRunner.applyMessagesToMessageList(\n                  typedResult.messages,\n                  passThrough.messageList,\n                  idsBeforeProcessing,\n                  check,\n                  'response',\n                );\n                passThrough.messageList.replaceAllSystemMessages(typedResult.systemMessages);\n                return {\n                  ...passThrough,\n                  messages: typedResult.messages,\n                  systemMessages: typedResult.systemMessages,\n                };\n              }\n              return { ...passThrough, messages };\n            }\n            return { ...passThrough, messages };\n          }\n\n          default:\n            return { ...passThrough, messages };\n        }\n      });\n    },\n    component: 'PROCESSOR',\n  };\n}\n\nexport function createWorkflow<\n  TWorkflowId extends string = string,\n  TState = unknown,\n  TInput = unknown,\n  TOutput = unknown,\n  TSteps extends Step<string, any, any, any, any, any, EventedEngineType>[] = Step<\n    string,\n    any,\n    any,\n    any,\n    any,\n    any,\n    EventedEngineType\n  >[],\n>(params: WorkflowConfig<TWorkflowId, TState, TInput, TOutput, TSteps>) {\n  const eventProcessor = new WorkflowEventProcessor({ mastra: params.mastra! });\n  const executionEngine = new EventedExecutionEngine({\n    mastra: params.mastra!,\n    eventProcessor,\n    options: {\n      validateInputs: params.options?.validateInputs ?? true,\n      shouldPersistSnapshot: params.options?.shouldPersistSnapshot ?? (() => true),\n      tracingPolicy: params.options?.tracingPolicy,\n      onFinish: params.options?.onFinish,\n      onError: params.options?.onError,\n    },\n  });\n  return new EventedWorkflow<EventedEngineType, TSteps, TWorkflowId, TState, TInput, TOutput, TInput>({\n    ...params,\n    executionEngine,\n  });\n}\n\nexport class EventedWorkflow<\n  TEngineType = EventedEngineType,\n  TSteps extends Step<string, any, any>[] = Step<string, any, any>[],\n  TWorkflowId extends string = string,\n  TState = unknown,\n  TInput = unknown,\n  TOutput = unknown,\n  TPrevSchema = TInput,\n> extends Workflow<TEngineType, TSteps, TWorkflowId, TState, TInput, TOutput, TPrevSchema> {\n  constructor(params: WorkflowConfig<TWorkflowId, TState, TInput, TOutput, TSteps>) {\n    super(params);\n    this.engineType = 'evented';\n  }\n\n  __registerMastra(mastra: Mastra) {\n    super.__registerMastra(mastra);\n    this.executionEngine.__registerMastra(mastra);\n  }\n\n  async createRun(options?: {\n    runId?: string;\n    resourceId?: string;\n    disableScorers?: boolean;\n  }): Promise<Run<TEngineType, TSteps, TState, TInput, TOutput>> {\n    const runIdToUse = options?.runId || randomUUID();\n\n    // Return a new Run instance with object parameters\n    const run: Run<TEngineType, TSteps, TState, TInput, TOutput> =\n      this.runs.get(runIdToUse) ??\n      new EventedRun({\n        workflowId: this.id,\n        runId: runIdToUse,\n        resourceId: options?.resourceId,\n        executionEngine: this.executionEngine,\n        executionGraph: this.executionGraph,\n        serializedStepGraph: this.serializedStepGraph,\n        mastra: this.mastra,\n        retryConfig: this.retryConfig,\n        cleanup: () => this.runs.delete(runIdToUse),\n        workflowSteps: this.steps,\n        validateInputs: this.options?.validateInputs,\n        inputSchema: this.inputSchema,\n        stateSchema: this.stateSchema,\n        workflowEngineType: this.engineType,\n      });\n\n    this.runs.set(runIdToUse, run);\n\n    const shouldPersistSnapshot = this.options?.shouldPersistSnapshot?.({\n      workflowStatus: run.workflowRunStatus,\n      stepResults: {},\n    });\n\n    const existingRun = await this.getWorkflowRunById(runIdToUse, {\n      withNestedWorkflows: false,\n    });\n\n    // Check if run exists in persistent storage (not just in-memory)\n    const existsInStorage = existingRun && !existingRun.isFromInMemory;\n\n    // Sync status from storage to in-memory run (fixes status tracking across workflow instances)\n    if (existsInStorage && existingRun.status) {\n      run.workflowRunStatus = existingRun.status as WorkflowRunStatus;\n    }\n\n    if (!existsInStorage && shouldPersistSnapshot) {\n      const workflowsStore = await this.mastra?.getStorage()?.getStore('workflows');\n      await workflowsStore?.persistWorkflowSnapshot({\n        workflowName: this.id,\n        runId: runIdToUse,\n        resourceId: options?.resourceId,\n        snapshot: {\n          runId: runIdToUse,\n          status: 'pending',\n          value: {},\n          context: {},\n          activePaths: [],\n          serializedStepGraph: this.serializedStepGraph,\n          activeStepsPath: {},\n          suspendedPaths: {},\n          resumeLabels: {},\n          waitingPaths: {},\n          result: undefined,\n          error: undefined,\n          timestamp: Date.now(),\n        },\n      });\n    }\n\n    return run;\n  }\n}\n\nexport class EventedRun<\n  TEngineType = EventedEngineType,\n  TSteps extends Step<string, any, any>[] = Step<string, any, any>[],\n  TState = unknown,\n  TInput = unknown,\n  TOutput = unknown,\n> extends Run<TEngineType, TSteps, TState, TInput, TOutput> {\n  constructor(params: {\n    workflowId: string;\n    runId: string;\n    resourceId?: string;\n    executionEngine: ExecutionEngine;\n    executionGraph: ExecutionGraph;\n    serializedStepGraph: SerializedStepFlowEntry[];\n    mastra?: Mastra;\n    retryConfig?: {\n      attempts?: number;\n      delay?: number;\n    };\n    cleanup?: () => void;\n    workflowSteps: Record<string, StepWithComponent>;\n    validateInputs?: boolean;\n    inputSchema?: SchemaWithValidation<TInput>;\n    stateSchema?: SchemaWithValidation<TState>;\n    workflowEngineType: WorkflowEngineType;\n  }) {\n    super(params);\n    this.serializedStepGraph = params.serializedStepGraph;\n  }\n\n  /**\n   * Set up abort signal handler to publish workflow.cancel event when abortController.abort() is called.\n   * This ensures consistent cancellation behavior whether abort() is called directly or via cancel().\n   */\n  private setupAbortHandler(): void {\n    const abortHandler = () => {\n      this.mastra?.pubsub\n        .publish('workflows', {\n          type: 'workflow.cancel',\n          runId: this.runId,\n          data: {\n            workflowId: this.workflowId,\n            runId: this.runId,\n          },\n        })\n        .catch(err => {\n          this.mastra?.getLogger()?.error(`Failed to publish workflow.cancel for runId ${this.runId}:`, err);\n        });\n    };\n    this.abortController.signal.addEventListener('abort', abortHandler, { once: true });\n  }\n\n  async start({\n    inputData,\n    initialState,\n    requestContext,\n    perStep,\n    outputOptions,\n  }: {\n    inputData?: TInput;\n    requestContext?: RequestContext;\n    initialState?: TState;\n    perStep?: boolean;\n    outputOptions?: {\n      includeState?: boolean;\n      includeResumeLabels?: boolean;\n    };\n  }): Promise<WorkflowResult<TState, TInput, TOutput, TSteps>> {\n    // Add validation checks\n    if (this.serializedStepGraph.length === 0) {\n      throw new Error(\n        'Execution flow of workflow is not defined. Add steps to the workflow via .then(), .branch(), etc.',\n      );\n    }\n    if (!this.executionGraph.steps) {\n      throw new Error('Uncommitted step flow changes detected. Call .commit() to register the steps.');\n    }\n\n    requestContext = requestContext ?? new RequestContext();\n\n    const workflowsStore = await this.mastra?.getStorage()?.getStore('workflows');\n    await workflowsStore?.persistWorkflowSnapshot({\n      workflowName: this.workflowId,\n      runId: this.runId,\n      resourceId: this.resourceId,\n      snapshot: {\n        runId: this.runId,\n        serializedStepGraph: this.serializedStepGraph,\n        status: 'running',\n        value: {},\n        context: {} as any,\n        requestContext: Object.fromEntries(requestContext.entries()),\n        activePaths: [],\n        activeStepsPath: {},\n        suspendedPaths: {},\n        resumeLabels: {},\n        waitingPaths: {},\n        timestamp: Date.now(),\n      },\n    });\n\n    const inputDataToUse = await this._validateInput(inputData ?? ({} as TInput));\n    const initialStateToUse = await this._validateInitialState(initialState ?? ({} as TState));\n\n    if (!this.mastra?.pubsub) {\n      throw new Error('Mastra instance with pubsub is required for workflow execution');\n    }\n\n    this.setupAbortHandler();\n\n    const result = await this.executionEngine.execute<TState, TInput, WorkflowResult<TState, TInput, TOutput, TSteps>>({\n      workflowId: this.workflowId,\n      runId: this.runId,\n      resourceId: this.resourceId,\n      graph: this.executionGraph,\n      serializedStepGraph: this.serializedStepGraph,\n      input: inputDataToUse,\n      initialState: initialStateToUse,\n      pubsub: this.mastra.pubsub,\n      retryConfig: this.retryConfig,\n      requestContext,\n      abortController: this.abortController,\n      perStep,\n      outputOptions,\n    });\n\n    // console.dir({ startResult: result }, { depth: null });\n\n    if (result.status !== 'suspended') {\n      this.cleanup?.();\n    }\n\n    return result;\n  }\n\n  /**\n   * Starts the workflow execution without waiting for completion (fire-and-forget).\n   * Returns immediately with the runId. The workflow executes in the background via pubsub.\n   * Use this when you don't need to wait for the result or want to avoid polling failures.\n   */\n  async startAsync({\n    inputData,\n    initialState,\n    requestContext,\n    perStep,\n  }: {\n    inputData?: TInput;\n    requestContext?: RequestContext;\n    initialState?: TState;\n    perStep?: boolean;\n  }): Promise<{ runId: string }> {\n    // Add validation checks\n    if (this.serializedStepGraph.length === 0) {\n      throw new Error(\n        'Execution flow of workflow is not defined. Add steps to the workflow via .then(), .branch(), etc.',\n      );\n    }\n    if (!this.executionGraph.steps) {\n      throw new Error('Uncommitted step flow changes detected. Call .commit() to register the steps.');\n    }\n\n    requestContext = requestContext ?? new RequestContext();\n\n    const workflowsStore = await this.mastra?.getStorage()?.getStore('workflows');\n    await workflowsStore?.persistWorkflowSnapshot({\n      workflowName: this.workflowId,\n      runId: this.runId,\n      resourceId: this.resourceId,\n      snapshot: {\n        runId: this.runId,\n        serializedStepGraph: this.serializedStepGraph,\n        status: 'running',\n        value: {},\n        context: {} as any,\n        requestContext: Object.fromEntries(requestContext.entries()),\n        activePaths: [],\n        activeStepsPath: {},\n        suspendedPaths: {},\n        resumeLabels: {},\n        waitingPaths: {},\n        timestamp: Date.now(),\n      },\n    });\n\n    const inputDataToUse = await this._validateInput(inputData ?? ({} as TInput));\n    const initialStateToUse = await this._validateInitialState(initialState ?? ({} as TState));\n\n    if (!this.mastra?.pubsub) {\n      throw new Error('Mastra instance with pubsub is required for workflow execution');\n    }\n\n    // Fire-and-forget: publish the workflow start event without subscribing for completion\n    await this.mastra.pubsub.publish('workflows', {\n      type: 'workflow.start',\n      runId: this.runId,\n      data: {\n        workflowId: this.workflowId,\n        runId: this.runId,\n        prevResult: { status: 'success', output: inputDataToUse },\n        requestContext: Object.fromEntries(requestContext.entries()),\n        initialState: initialStateToUse,\n        perStep,\n      },\n    });\n\n    // Return immediately without waiting for completion\n    return { runId: this.runId };\n  }\n\n  /**\n   * Starts the workflow execution as a stream, returning a WorkflowRunOutput\n   * with .fullStream for iteration and .result for the final result.\n   */\n  stream({\n    inputData,\n    requestContext,\n    initialState,\n    closeOnSuspend = true,\n    perStep,\n    outputOptions,\n  }: (TInput extends unknown ? { inputData?: TInput } : { inputData: TInput }) &\n    (TState extends unknown ? { initialState?: TState } : { initialState: TState }) & {\n      requestContext?: RequestContext;\n      closeOnSuspend?: boolean;\n      perStep?: boolean;\n      outputOptions?: {\n        includeState?: boolean;\n        includeResumeLabels?: boolean;\n      };\n    }): WorkflowRunOutput<WorkflowResult<TState, TInput, TOutput, TSteps>> {\n    if (this.closeStreamAction && this.streamOutput) {\n      return this.streamOutput;\n    }\n\n    this.closeStreamAction = async () => {};\n\n    const self = this;\n    const stream = new ReadableStream<WorkflowStreamEvent>({\n      async start(controller) {\n        const unwatch = self.watch((event: WorkflowStreamEvent) => {\n          const { type, payload } = event;\n          controller.enqueue({\n            type,\n            runId: self.runId,\n            from: ChunkFrom.WORKFLOW,\n            payload: {\n              stepName: (payload as any)?.id,\n              ...payload,\n            },\n          } as WorkflowStreamEvent);\n        });\n\n        self.closeStreamAction = async () => {\n          unwatch();\n          try {\n            if (controller.desiredSize !== null) {\n              controller.close();\n            }\n          } catch (err) {\n            self.mastra?.getLogger()?.error('Error closing stream:', err);\n          }\n        };\n\n        try {\n          const executionResults = await self.start({\n            inputData: inputData as TInput,\n            requestContext,\n            initialState: initialState as TState,\n            perStep,\n            outputOptions,\n          });\n\n          if (self.streamOutput) {\n            self.streamOutput.updateResults(executionResults);\n          }\n\n          if (closeOnSuspend) {\n            self.closeStreamAction?.().catch(() => {});\n          } else if (executionResults.status !== 'suspended') {\n            self.closeStreamAction?.().catch(() => {});\n          }\n        } catch (err) {\n          self.streamOutput?.rejectResults(err as Error);\n          self.closeStreamAction?.().catch(() => {});\n        }\n      },\n    });\n\n    this.streamOutput = new WorkflowRunOutput<WorkflowResult<TState, TInput, TOutput, TSteps>>({\n      runId: this.runId,\n      workflowId: this.workflowId,\n      stream,\n    });\n\n    return this.streamOutput;\n  }\n\n  /**\n   * Resumes a suspended workflow as a stream, returning a WorkflowRunOutput\n   * with .fullStream for iteration and .result for the final result.\n   */\n  resumeStream<TResume>({\n    step,\n    resumeData,\n    requestContext,\n    perStep,\n    outputOptions,\n  }: {\n    resumeData?: TResume;\n    step?:\n      | Step<string, any, any, any, TResume, any, TEngineType>\n      | [\n          ...Step<string, any, any, any, any, any, TEngineType>[],\n          Step<string, any, any, any, TResume, any, TEngineType>,\n        ]\n      | string\n      | string[];\n    requestContext?: RequestContext;\n    perStep?: boolean;\n    outputOptions?: {\n      includeState?: boolean;\n      includeResumeLabels?: boolean;\n    };\n  } = {}): WorkflowRunOutput<WorkflowResult<TState, TInput, TOutput, TSteps>> {\n    this.closeStreamAction = async () => {};\n\n    const self = this;\n    const stream = new ReadableStream<WorkflowStreamEvent>({\n      async start(controller) {\n        const unwatch = self.watch((event: WorkflowStreamEvent) => {\n          const { type, payload } = event;\n          controller.enqueue({\n            type,\n            runId: self.runId,\n            from: ChunkFrom.WORKFLOW,\n            payload: {\n              stepName: (payload as any)?.id,\n              ...payload,\n            },\n          } as WorkflowStreamEvent);\n        });\n\n        self.closeStreamAction = async () => {\n          unwatch();\n          try {\n            if (controller.desiredSize !== null) {\n              controller.close();\n            }\n          } catch (err) {\n            self.mastra?.getLogger()?.error('Error closing stream:', err);\n          }\n        };\n\n        try {\n          const executionResults = await self.resume({\n            resumeData,\n            step,\n            requestContext,\n            perStep,\n            outputOptions,\n          });\n\n          if (self.streamOutput) {\n            self.streamOutput.updateResults(executionResults);\n          }\n\n          // Wait a microtask to let any pending events flush through\n          await new Promise(resolve => setTimeout(resolve, 0));\n\n          self.closeStreamAction?.().catch(() => {});\n        } catch (err) {\n          self.streamOutput?.rejectResults(err as Error);\n          self.closeStreamAction?.().catch(() => {});\n        }\n      },\n    });\n\n    this.streamOutput = new WorkflowRunOutput<WorkflowResult<TState, TInput, TOutput, TSteps>>({\n      runId: this.runId,\n      workflowId: this.workflowId,\n      stream,\n    });\n\n    return this.streamOutput;\n  }\n\n  async resume<TResumeSchema>(params: {\n    resumeData?: TResumeSchema;\n    step?:\n      | Step<string, any, any, TResumeSchema, any, any, TEngineType, any>\n      | [\n          ...Step<string, any, any, any, any, any, TEngineType, any>[],\n          Step<string, any, any, TResumeSchema, any, any, TEngineType, any>,\n        ]\n      | string\n      | string[];\n    label?: string;\n    forEachIndex?: number;\n    requestContext?: RequestContext;\n    perStep?: boolean;\n    outputOptions?: {\n      includeState?: boolean;\n      includeResumeLabels?: boolean;\n    };\n  }): Promise<WorkflowResult<TState, TInput, TOutput, TSteps>> {\n    const workflowsStore = await this.mastra?.getStorage()?.getStore('workflows');\n    if (!workflowsStore) {\n      throw new Error('Cannot resume workflow: workflows store is required');\n    }\n    const snapshot = await workflowsStore.loadWorkflowSnapshot({\n      workflowName: this.workflowId,\n      runId: this.runId,\n    });\n    if (!snapshot) {\n      throw new Error(`Cannot resume workflow: no snapshot found for runId ${this.runId}`);\n    }\n\n    // Check if workflow is suspended before proceeding\n    if (snapshot.status !== 'suspended') {\n      throw new Error('This workflow run was not suspended');\n    }\n\n    // Resolve label to step path if provided\n    const snapshotResumeLabel = params.label ? snapshot?.resumeLabels?.[params.label] : undefined;\n\n    // Validate label exists if provided\n    if (params.label && !snapshotResumeLabel) {\n      const availableLabels = Object.keys(snapshot?.resumeLabels ?? {});\n      throw new Error(\n        `Resume label \"${params.label}\" not found. ` + `Available labels: [${availableLabels.join(', ')}]`,\n      );\n    }\n\n    // Label takes precedence over step param\n    const stepParam = snapshotResumeLabel?.stepId ?? params.step;\n\n    // Auto-detect suspended steps if no step is provided\n    let steps: string[];\n    if (stepParam) {\n      if (typeof stepParam === 'string') {\n        steps = stepParam.split('.');\n      } else {\n        steps = (Array.isArray(stepParam) ? stepParam : [stepParam]).map(step =>\n          typeof step === 'string' ? step : step?.id,\n        );\n      }\n    } else {\n      // Use suspendedPaths to detect suspended steps\n      const suspendedStepPaths: string[][] = [];\n\n      Object.entries(snapshot?.suspendedPaths ?? {}).forEach(([stepId, _executionPath]) => {\n        // Check if this step has nested workflow suspension data\n        const stepResult = snapshot?.context?.[stepId];\n        if (stepResult && typeof stepResult === 'object' && 'status' in stepResult) {\n          const stepRes = stepResult as any;\n          if (stepRes.status === 'suspended') {\n            const nestedPath = stepRes.suspendPayload?.__workflow_meta?.path;\n            if (nestedPath && Array.isArray(nestedPath)) {\n              // For nested workflows, combine the parent step ID with the nested path\n              suspendedStepPaths.push([stepId, ...nestedPath]);\n            } else {\n              // For single-level suspension, just use the step ID\n              suspendedStepPaths.push([stepId]);\n            }\n          }\n        }\n      });\n\n      if (suspendedStepPaths.length === 0) {\n        throw new Error('No suspended steps found in this workflow run');\n      }\n\n      if (suspendedStepPaths.length === 1) {\n        // For single suspended step, use the full path\n        steps = suspendedStepPaths[0]!;\n      } else {\n        const pathStrings = suspendedStepPaths.map(path => `[${path.join(', ')}]`);\n        throw new Error(\n          `Multiple suspended steps found: ${pathStrings.join(', ')}. ` +\n            'Please specify which step to resume using the \"step\" parameter.',\n        );\n      }\n    }\n\n    // Validate that the step is actually suspended\n    const suspendedStepIds = Object.keys(snapshot?.suspendedPaths ?? {});\n    const isStepSuspended = suspendedStepIds.includes(steps?.[0] ?? '');\n\n    if (!isStepSuspended) {\n      throw new Error(\n        `This workflow step \"${steps?.[0]}\" was not suspended. Available suspended steps: [${suspendedStepIds.join(', ')}]`,\n      );\n    }\n\n    const resumePath = snapshot.suspendedPaths?.[steps[0]!] as any;\n\n    console.dir(\n      { resume: { requestContextObj: snapshot.requestContext, requestContext: params.requestContext } },\n      { depth: null },\n    );\n    // Start with the snapshot's request context (old values)\n    const requestContextObj = snapshot.requestContext ?? {};\n    const requestContext = new RequestContext();\n\n    // First, set values from the snapshot\n    for (const [key, value] of Object.entries(requestContextObj)) {\n      requestContext.set(key, value);\n    }\n\n    // Then, override with any values from the passed request context (new values take precedence)\n    if (params.requestContext) {\n      for (const [key, value] of params.requestContext.entries()) {\n        requestContext.set(key, value);\n      }\n    }\n\n    const suspendedStep = this.workflowSteps[steps?.[0] ?? ''];\n\n    const resumeDataToUse = await this._validateResumeData(params.resumeData, suspendedStep);\n\n    if (!this.mastra?.pubsub) {\n      throw new Error('Mastra instance with pubsub is required for workflow execution');\n    }\n\n    this.setupAbortHandler();\n\n    // Extract state from snapshot - could be in context.__state or in value\n    const resumeState = (snapshot?.context as any)?.__state ?? snapshot?.value ?? {};\n\n    const executionResultPromise = this.executionEngine\n      .execute<TState, TInput, WorkflowResult<TState, TInput, TOutput, TSteps>>({\n        workflowId: this.workflowId,\n        runId: this.runId,\n        graph: this.executionGraph,\n        serializedStepGraph: this.serializedStepGraph,\n        input: snapshot?.context?.input as TInput,\n        initialState: resumeState as TState,\n        resume: {\n          steps,\n          stepResults: snapshot?.context as any,\n          resumePayload: resumeDataToUse,\n          resumePath,\n          forEachIndex: params.forEachIndex ?? snapshotResumeLabel?.foreachIndex,\n        },\n        pubsub: this.mastra.pubsub,\n        requestContext,\n        abortController: this.abortController,\n        perStep: params.perStep,\n        outputOptions: params.outputOptions,\n      })\n      .then(result => {\n        if (result.status !== 'suspended') {\n          this.closeStreamAction?.().catch(() => {});\n        }\n\n        return result;\n      });\n\n    this.executionResults = executionResultPromise;\n\n    return executionResultPromise;\n  }\n\n  watch(cb: (event: WorkflowStreamEvent) => void): () => void {\n    const watchCb = async (event: Event, ack?: () => Promise<void>) => {\n      if (event.runId !== this.runId) {\n        return;\n      }\n\n      cb(event.data);\n      await ack?.();\n    };\n\n    this.mastra?.pubsub.subscribe(`workflow.events.v2.${this.runId}`, watchCb).catch(() => {});\n\n    return () => {\n      this.mastra?.pubsub.unsubscribe(`workflow.events.v2.${this.runId}`, watchCb).catch(() => {});\n    };\n  }\n\n  async watchAsync(cb: (event: WorkflowStreamEvent) => void): Promise<() => void> {\n    const watchCb = async (event: Event, ack?: () => Promise<void>) => {\n      if (event.runId !== this.runId) {\n        return;\n      }\n\n      cb(event.data);\n      await ack?.();\n    };\n\n    await this.mastra?.pubsub.subscribe(`workflow.events.v2.${this.runId}`, watchCb).catch(() => {});\n\n    return async () => {\n      await this.mastra?.pubsub.unsubscribe(`workflow.events.v2.${this.runId}`, watchCb).catch(() => {});\n    };\n  }\n\n  async cancel() {\n    // Update storage directly for immediate status update (same pattern as Inngest)\n    const workflowsStore = await this.mastra?.getStorage()?.getStore('workflows');\n    await workflowsStore?.updateWorkflowState({\n      workflowName: this.workflowId,\n      runId: this.runId,\n      opts: {\n        status: 'canceled',\n      },\n    });\n\n    // Trigger abort signal - the abort handler will publish the workflow.cancel event\n    // This ensures consistent behavior whether cancel() or abort() is called\n    this.abortController.abort();\n  }\n}\n","import type { Step, StepFlowEntry, Workflow } from '../..';\nimport type { Mastra } from '../../../mastra';\nimport { EventedWorkflow } from '../workflow';\nimport type { ParentWorkflow } from '.';\n\n/**\n * Type guard to check if a step is actually a Workflow.\n * A step is a Workflow if it's an EventedWorkflow instance or has component === 'WORKFLOW'.\n */\nfunction isWorkflowStep(step: unknown): step is Workflow {\n  if (!step || typeof step !== 'object') {\n    return false;\n  }\n  // Check for EventedWorkflow instance first (most specific)\n  if (step instanceof EventedWorkflow) {\n    return true;\n  }\n  // Check for the 'WORKFLOW' component discriminator (used for nested workflows)\n  if ('component' in step && (step as { component?: string }).component === 'WORKFLOW') {\n    return true;\n  }\n  return false;\n}\n\nexport function getNestedWorkflow(\n  mastra: Mastra,\n  { workflowId, executionPath, parentWorkflow }: ParentWorkflow,\n): Workflow | null {\n  let workflow: Workflow | null = null;\n\n  if (parentWorkflow) {\n    const nestedWorkflow = getNestedWorkflow(mastra, parentWorkflow);\n    if (!nestedWorkflow) {\n      return null;\n    }\n\n    workflow = nestedWorkflow;\n  }\n\n  workflow = workflow ?? mastra.getWorkflow(workflowId);\n  const stepGraph = workflow.stepGraph;\n  let parentStep = stepGraph[executionPath[0]!];\n  if (parentStep?.type === 'parallel' || parentStep?.type === 'conditional') {\n    parentStep = parentStep.steps[executionPath[1]!];\n  }\n\n  if (parentStep?.type === 'step' || parentStep?.type === 'loop') {\n    // Validate that the inner step is actually a Workflow before returning\n    if (isWorkflowStep(parentStep.step)) {\n      return parentStep.step;\n    }\n    // Not a workflow - this is a regular step, return null\n    return null;\n  }\n\n  // Handle foreach - validate that the inner step is actually a Workflow\n  if (parentStep?.type === 'foreach') {\n    if (isWorkflowStep(parentStep.step)) {\n      return parentStep.step;\n    }\n    // Not a workflow - this is a regular step in a foreach, return null\n    return null;\n  }\n\n  return null;\n}\n\nexport function getStep(workflow: Workflow, executionPath: number[]): Step<string, any, any, any, any, any> | null {\n  let idx = 0;\n  const stepGraph = workflow.stepGraph;\n  let parentStep = stepGraph[executionPath[0]!];\n  if (parentStep?.type === 'parallel' || parentStep?.type === 'conditional') {\n    parentStep = parentStep.steps[executionPath[1]!];\n    idx++;\n  } else if (parentStep?.type === 'foreach') {\n    return parentStep.step;\n  }\n\n  if (!(parentStep?.type === 'step' || parentStep?.type === 'loop')) {\n    return null;\n  }\n\n  if (parentStep instanceof EventedWorkflow) {\n    return getStep(parentStep, executionPath.slice(idx + 1));\n  }\n\n  return parentStep.step;\n}\n\nexport function isExecutableStep(step: StepFlowEntry<any>) {\n  return step.type === 'step' || step.type === 'loop' || step.type === 'foreach';\n}\n","import type { RequestContext } from '../../di';\nimport type { PubSub } from '../../events/pubsub';\nimport type { Event } from '../../events/types';\nimport type { Mastra } from '../../mastra';\nimport { ExecutionEngine } from '../../workflows/execution-engine';\nimport type { ExecutionEngineOptions, ExecutionGraph } from '../../workflows/execution-engine';\nimport type {\n  SerializedStepFlowEntry,\n  StepResult,\n  StepTripwireInfo,\n  RestartExecutionParams,\n  TimeTravelExecutionParams,\n  WorkflowRunStatus,\n} from '../types';\nimport { cleanStepResult, hydrateSerializedStepErrors } from '../utils';\nimport type { WorkflowEventProcessor } from './workflow-event-processor';\nimport { getStep } from './workflow-event-processor/utils';\n\nexport class EventedExecutionEngine extends ExecutionEngine {\n  protected eventProcessor: WorkflowEventProcessor;\n\n  constructor({\n    mastra,\n    eventProcessor,\n    options,\n  }: {\n    mastra?: Mastra;\n    eventProcessor: WorkflowEventProcessor;\n    options: ExecutionEngineOptions;\n  }) {\n    super({ mastra, options });\n    this.eventProcessor = eventProcessor;\n  }\n\n  __registerMastra(mastra: Mastra) {\n    super.__registerMastra(mastra);\n    this.eventProcessor.__registerMastra(mastra);\n  }\n\n  /**\n   * Executes a workflow run with the provided execution graph and input\n   * @param graph The execution graph to execute\n   * @param input The input data for the workflow\n   * @returns A promise that resolves to the workflow output\n   */\n  async execute<TState, TInput, TOutput>(params: {\n    workflowId: string;\n    runId: string;\n    resourceId?: string;\n    graph: ExecutionGraph;\n    serializedStepGraph: SerializedStepFlowEntry[];\n    input?: TInput;\n    initialState?: TState;\n    restart?: RestartExecutionParams;\n    timeTravel?: TimeTravelExecutionParams;\n    resume?: {\n      steps: string[];\n      stepResults: Record<string, StepResult<any, any, any, any>>;\n      resumePayload: any;\n      resumePath: number[];\n      forEachIndex?: number;\n    };\n    pubsub?: PubSub; // Not used - evented engine uses this.mastra.pubsub directly\n    requestContext: RequestContext;\n    retryConfig?: {\n      attempts?: number;\n      delay?: number;\n    };\n    abortController: AbortController;\n    format?: 'legacy' | 'vnext' | undefined;\n    outputOptions?: {\n      includeState?: boolean;\n      includeResumeLabels?: boolean;\n    };\n    perStep?: boolean;\n  }): Promise<TOutput> {\n    const pubsub = this.mastra?.pubsub;\n    if (!pubsub) {\n      throw new Error('No Pubsub adapter configured on the Mastra instance');\n    }\n\n    // Set up promise that will resolve when workflow finishes\n    // CRITICAL: Must subscribe BEFORE publishing events to avoid race condition\n    let resolveResult!: (data: any) => void;\n    let rejectResult!: (error: any) => void;\n    const resultPromise = new Promise<any>((resolve, reject) => {\n      resolveResult = resolve;\n      rejectResult = reject;\n    });\n\n    const finishCb = async (event: Event, ack?: () => Promise<void>) => {\n      if (event.runId !== params.runId) {\n        await ack?.();\n        return;\n      }\n\n      if (['workflow.end', 'workflow.fail', 'workflow.suspend'].includes(event.type)) {\n        await ack?.();\n        await pubsub.unsubscribe('workflows-finish', finishCb);\n        // Re-hydrate serialized errors back to Error instances when workflow fails\n        if (event.type === 'workflow.fail' && event.data.stepResults) {\n          event.data.stepResults = hydrateSerializedStepErrors(event.data.stepResults);\n        }\n        resolveResult(event.data);\n        return;\n      }\n\n      await ack?.();\n    };\n\n    // AWAIT subscription first - ensures listener is registered before any events fire\n    try {\n      await pubsub.subscribe('workflows-finish', finishCb);\n    } catch (err) {\n      this.mastra?.getLogger()?.error('Failed to subscribe to workflows-finish:', err);\n      throw err;\n    }\n\n    // NOW safe to publish - listener is guaranteed to be registered\n    // Wrap in try/catch to ensure proper cleanup and rejection on errors\n    try {\n      if (params.resume) {\n        const prevStep = getStep(this.mastra!.getWorkflow(params.workflowId), params.resume.resumePath);\n        const prevResult = params.resume.stepResults[prevStep?.id ?? 'input'];\n        // Extract state from stepResults.__state or use initialState\n        const resumeState = params.resume.stepResults?.__state ?? params.initialState ?? {};\n\n        await pubsub.publish('workflows', {\n          type: 'workflow.resume',\n          runId: params.runId,\n          data: {\n            workflowId: params.workflowId,\n            runId: params.runId,\n            executionPath: params.resume.resumePath,\n            stepResults: params.resume.stepResults,\n            resumeSteps: params.resume.steps,\n            prevResult: { status: 'success', output: prevResult?.payload },\n            resumeData: params.resume.resumePayload,\n            requestContext: Object.fromEntries(params.requestContext.entries()),\n            format: params.format,\n            perStep: params.perStep,\n            initialState: resumeState,\n            state: resumeState,\n            outputOptions: params.outputOptions,\n            forEachIndex: params.resume.forEachIndex,\n          },\n        });\n      } else if (params.timeTravel) {\n        const prevStep = getStep(this.mastra!.getWorkflow(params.workflowId), params.timeTravel.executionPath);\n        const prevResult = params.timeTravel.stepResults[prevStep?.id ?? 'input'];\n        await pubsub.publish('workflows', {\n          type: 'workflow.start',\n          runId: params.runId,\n          data: {\n            workflowId: params.workflowId,\n            runId: params.runId,\n            executionPath: params.timeTravel.executionPath,\n            stepResults: params.timeTravel.stepResults,\n            timeTravel: params.timeTravel,\n            prevResult: { status: 'success', output: prevResult?.payload },\n            requestContext: Object.fromEntries(params.requestContext.entries()),\n            format: params.format,\n            perStep: params.perStep,\n          },\n        });\n      } else {\n        await pubsub.publish('workflows', {\n          type: 'workflow.start',\n          runId: params.runId,\n          data: {\n            workflowId: params.workflowId,\n            runId: params.runId,\n            prevResult: { status: 'success', output: params.input },\n            requestContext: Object.fromEntries(params.requestContext.entries()),\n            format: params.format,\n            perStep: params.perStep,\n            initialState: params.initialState,\n            outputOptions: params.outputOptions,\n          },\n        });\n      }\n    } catch (err) {\n      // Clean up subscription and reject the promise on error\n      await pubsub.unsubscribe('workflows-finish', finishCb);\n      rejectResult(err);\n      throw err;\n    }\n\n    // Wait for workflow to complete\n    const resultData: any = await resultPromise;\n\n    // Extract state from resultData (stored in stepResults.__state)\n    const finalState = resultData.state ?? resultData.stepResults?.__state ?? params.initialState ?? {};\n\n    // Strip __state from stepResults at top level\n    const { __state: _removedState, ...stepResultsWithoutTopLevelState } = resultData.stepResults ?? {};\n\n    // Recursively clean each step result to remove internal properties (__state, nestedRunId)\n    // This handles both object and array step results (e.g., forEach outputs)\n    const cleanStepResults: Record<string, any> = {};\n    for (const [stepId, stepResult] of Object.entries(stepResultsWithoutTopLevelState)) {\n      cleanStepResults[stepId] = cleanStepResult(stepResult);\n    }\n\n    // Build the callback argument with proper typing for invokeLifecycleCallbacks\n    let callbackArg: {\n      status: WorkflowRunStatus;\n      result?: any;\n      error?: any;\n      steps: Record<string, StepResult<any, any, any, any>>;\n      state?: Record<string, any>;\n      tripwire?: StepTripwireInfo;\n    };\n\n    if (resultData.prevResult.status === 'failed') {\n      // Check if failure was due to TripWire by scanning step results\n      let tripwireData: StepTripwireInfo | undefined;\n      for (const stepResult of Object.values(cleanStepResults)) {\n        if (stepResult?.status === 'failed' && stepResult?.tripwire) {\n          tripwireData = stepResult.tripwire;\n          break;\n        }\n      }\n\n      if (tripwireData && typeof tripwireData === 'object' && 'reason' in tripwireData) {\n        callbackArg = {\n          status: 'tripwire',\n          steps: cleanStepResults,\n          state: finalState,\n          tripwire: tripwireData,\n        };\n      } else {\n        callbackArg = {\n          status: 'failed',\n          error: resultData.prevResult.error,\n          steps: cleanStepResults,\n          state: finalState,\n        };\n      }\n    } else if (resultData.prevResult.status === 'suspended') {\n      callbackArg = {\n        status: 'suspended',\n        steps: cleanStepResults,\n        state: finalState,\n      };\n    } else if (resultData.prevResult.status === 'paused' || params.perStep) {\n      callbackArg = {\n        status: 'paused',\n        steps: cleanStepResults,\n        state: finalState,\n      };\n    } else {\n      callbackArg = {\n        status: resultData.prevResult.status,\n        result: resultData.prevResult?.output,\n        steps: cleanStepResults,\n        state: finalState,\n      };\n    }\n\n    if (callbackArg.status !== 'paused') {\n      // Invoke lifecycle callbacks before returning\n      await this.invokeLifecycleCallbacks({\n        status: callbackArg.status,\n        result: callbackArg.result,\n        error: callbackArg.error,\n        steps: callbackArg.steps,\n        tripwire: callbackArg.tripwire,\n        runId: params.runId,\n        workflowId: params.workflowId,\n        resourceId: params.resourceId,\n        input: params.input,\n        requestContext: params.requestContext,\n        state: finalState,\n      });\n    }\n\n    // Build the final result with any additional fields needed for the return type\n    // Exclude state from result unless outputOptions.includeState is true\n    let result: TOutput;\n    if (resultData.prevResult.status === 'suspended') {\n      const suspendedSteps = Object.entries(resultData.stepResults)\n        .map(([_stepId, stepResult]: [string, any]) => {\n          if (stepResult.status === 'suspended') {\n            return stepResult.suspendPayload?.__workflow_meta?.path ?? [];\n          }\n          return null;\n        })\n        .filter(Boolean);\n      // Don't spread callbackArg directly to avoid including state\n      result = {\n        status: callbackArg.status,\n        steps: callbackArg.steps,\n        suspended: suspendedSteps,\n      } as TOutput;\n    } else if (resultData.prevResult.status === 'failed') {\n      // Check if this is actually a tripwire status (detected in callbackArg building)\n      if (callbackArg.status === 'tripwire' && callbackArg.tripwire) {\n        result = {\n          status: 'tripwire',\n          tripwire: callbackArg.tripwire,\n          steps: callbackArg.steps,\n        } as TOutput;\n      } else {\n        result = {\n          status: callbackArg.status,\n          error: callbackArg.error,\n          steps: callbackArg.steps,\n        } as TOutput;\n      }\n    } else if (resultData.prevResult.status === 'paused' || params.perStep) {\n      result = {\n        status: 'paused',\n        steps: callbackArg.steps,\n      } as TOutput;\n    } else {\n      result = {\n        status: callbackArg.status,\n        result: callbackArg.result,\n        steps: callbackArg.steps,\n      } as TOutput;\n    }\n\n    // Include state in result only if outputOptions.includeState is true\n    if (params.outputOptions?.includeState) {\n      (result as any).state = finalState;\n    }\n\n    return result;\n  }\n}\n"]}