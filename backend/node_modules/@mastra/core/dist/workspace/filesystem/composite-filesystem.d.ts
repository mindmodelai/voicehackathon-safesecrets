/**
 * CompositeFilesystem - Routes operations to mounted filesystems based on path.
 *
 * Creates a unified filesystem view by combining multiple filesystems at different
 * mount points. Useful for composing local storage, S3, and other backends.
 *
 * @example
 * ```typescript
 * const cfs = new CompositeFilesystem({
 *   mounts: {
 *     '/local': new LocalFilesystem({ basePath: './data' }),
 *     '/s3': new S3Filesystem({ bucket: 'my-bucket', ... }),
 *   }
 * });
 *
 * // readdir('/') returns ['local', 's3']
 * // readFile('/local/file.txt') reads from LocalFilesystem
 * // readFile('/s3/data.json') reads from S3Filesystem
 * ```
 */
import type { ProviderStatus } from '../lifecycle.js';
import type { WorkspaceFilesystem, FileContent, FileEntry, FileStat, ReadOptions, WriteOptions, ListOptions, CopyOptions, RemoveOptions } from './filesystem.js';
/**
 * Configuration for CompositeFilesystem.
 */
export interface CompositeFilesystemConfig {
    /** Map of mount paths to filesystem instances */
    mounts: Record<string, WorkspaceFilesystem>;
}
/**
 * CompositeFilesystem implementation.
 *
 * Routes file operations to the appropriate underlying filesystem based on path.
 * Supports cross-mount operations (copy/move between different filesystems).
 */
export declare class CompositeFilesystem implements WorkspaceFilesystem {
    readonly id: string;
    readonly name = "CompositeFilesystem";
    readonly provider = "composite";
    status: ProviderStatus;
    private readonly _mounts;
    constructor(config: CompositeFilesystemConfig);
    /**
     * Get all mount paths.
     */
    get mountPaths(): string[];
    /**
     * Get the mounts map.
     */
    get mounts(): ReadonlyMap<string, WorkspaceFilesystem>;
    /**
     * Get the underlying filesystem for a given path.
     * Returns undefined if the path doesn't resolve to any mount.
     */
    getFilesystemForPath(path: string): WorkspaceFilesystem | undefined;
    /**
     * Get the mount path for a given path.
     * Returns undefined if the path doesn't resolve to any mount.
     */
    getMountPathForPath(path: string): string | undefined;
    private normalizePath;
    private resolveMount;
    private getVirtualEntries;
    private isVirtualPath;
    /**
     * Assert that a filesystem is writable (not read-only).
     * @throws {PermissionError} if the filesystem is read-only
     */
    private assertWritable;
    init(): Promise<void>;
    destroy(): Promise<void>;
    readFile(path: string, options?: ReadOptions): Promise<string | Buffer>;
    writeFile(path: string, content: FileContent, options?: WriteOptions): Promise<void>;
    appendFile(path: string, content: FileContent): Promise<void>;
    deleteFile(path: string, options?: RemoveOptions): Promise<void>;
    copyFile(src: string, dest: string, options?: CopyOptions): Promise<void>;
    moveFile(src: string, dest: string, options?: CopyOptions): Promise<void>;
    readdir(path: string, options?: ListOptions): Promise<FileEntry[]>;
    mkdir(path: string, options?: {
        recursive?: boolean;
    }): Promise<void>;
    rmdir(path: string, options?: RemoveOptions): Promise<void>;
    exists(path: string): Promise<boolean>;
    stat(path: string): Promise<FileStat>;
    isFile(path: string): Promise<boolean>;
    isDirectory(path: string): Promise<boolean>;
    /**
     * Get instructions describing the mounted filesystems.
     * Used by agents to understand available storage locations.
     */
    getInstructions(): string;
}
//# sourceMappingURL=composite-filesystem.d.ts.map