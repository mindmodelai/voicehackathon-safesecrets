/**
 * Workspace Class
 *
 * A Workspace combines a Filesystem and a Sandbox to provide agents
 * with a complete environment for storing files and executing code.
 *
 * Users pass provider instances directly to the Workspace constructor.
 *
 * @example
 * ```typescript
 * import { Workspace } from '@mastra/core';
 * import { LocalFilesystem } from '@mastra/workspace-fs-local';
 * import { AgentFS } from '@mastra/workspace-fs-agentfs';
 * import { ComputeSDKSandbox } from '@mastra/workspace-sandbox-computesdk';
 *
 * // Simple workspace with local filesystem
 * const workspace = new Workspace({
 *   filesystem: new LocalFilesystem({ basePath: './workspace' }),
 * });
 *
 * // Full workspace with AgentFS and cloud sandbox
 * const fullWorkspace = new Workspace({
 *   filesystem: new AgentFS({ path: './agent.db' }),
 *   sandbox: new ComputeSDKSandbox({ provider: 'e2b' }),
 * });
 *
 * await fullWorkspace.init();
 * await fullWorkspace.filesystem?.writeFile('/code/app.py', 'print("Hello!")');
 * const result = await fullWorkspace.sandbox?.executeCommand?.('python3', ['app.py'], { cwd: '/code' });
 * ```
 */
import type { IMastraLogger } from '../logger/index.js';
import type { MastraVector } from '../vector/index.js';
import type { WorkspaceFilesystem, FilesystemInfo } from './filesystem/index.js';
import type { WorkspaceSandbox, OnMountHook } from './sandbox/index.js';
import type { BM25Config, Embedder, SearchOptions, SearchResult } from './search/index.js';
import type { WorkspaceSkills, SkillsResolver } from './skills/index.js';
import type { WorkspaceToolsConfig } from './tools/index.js';
import type { WorkspaceStatus } from './types.js';
/**
 * Configuration for creating a Workspace.
 * Users pass provider instances directly.
 */
export interface WorkspaceConfig {
    /** Unique identifier (auto-generated if not provided) */
    id?: string;
    /** Human-readable name */
    name?: string;
    /**
     * Filesystem provider instance.
     * Use LocalFilesystem for a folder on disk, or AgentFS for Turso-backed storage.
     * Extend MastraFilesystem for automatic logger integration.
     */
    filesystem?: WorkspaceFilesystem;
    /**
     * Sandbox provider instance.
     * Use ComputeSDKSandbox to access E2B, Modal, Docker, etc.
     * Extend MastraSandbox for automatic logger integration.
     */
    sandbox?: WorkspaceSandbox;
    /**
     * Mount multiple filesystems at different paths.
     * Creates a CompositeFilesystem that routes operations based on path.
     *
     * When a sandbox is configured, filesystems are automatically mounted
     * into the sandbox at their respective paths during init().
     *
     * Use the `onMount` hook to skip or customize mounting for specific filesystems.
     *
     * @example
     * ```typescript
     * const workspace = new Workspace({
     *   sandbox: new E2BSandbox({ timeout: 60000 }),
     *   mounts: {
     *     '/data': new S3Filesystem({ bucket: 'my-data', ... }),
     *     '/skills': new S3Filesystem({ bucket: 'skills', readOnly: true, ... }),
     *   },
     * });
     *
     * await workspace.init();
     * // Both filesystems mounted in sandbox at /data and /skills
     * ```
     */
    mounts?: Record<string, WorkspaceFilesystem>;
    /**
     * Hook called before mounting each filesystem into the sandbox.
     *
     * Return values:
     * - `false` - Skip mount entirely (don't mount this filesystem)
     * - `{ success: true }` - Hook handled the mount successfully
     * - `{ success: false, error?: string }` - Hook attempted mount but failed
     * - `undefined` / no return - Use provider's default mount behavior
     *
     * This is useful for:
     * - Skipping specific filesystems (e.g., local filesystems in remote sandbox)
     * - Custom mount implementations
     * - Syncing files instead of FUSE mounting
     *
     * Note: If your hook handles the mount, you're responsible for the entire
     * implementation. The sandbox provider won't do any additional tracking.
     *
     * @example Skip local filesystems
     * ```typescript
     * const workspace = new Workspace({
     *   sandbox: new E2BSandbox(),
     *   mounts: {
     *     '/data': new S3Filesystem({ bucket: 'data', ... }),
     *     '/local': new LocalFilesystem({ basePath: './data' }),
     *   },
     *   onMount: ({ filesystem }) => {
     *     if (filesystem.provider === 'local') return false;
     *   },
     * });
     * ```
     *
     * @example Custom mount implementation
     * ```typescript
     * onMount: async ({ filesystem, mountPath, config, sandbox }) => {
     *   if (config?.type === 's3') {
     *     await sandbox.executeCommand?.('my-s3-mount', [mountPath]);
     *     return { success: true };
     *   }
     * }
     * ```
     */
    onMount?: OnMountHook;
    /**
     * Vector store for semantic search.
     * When provided along with embedder, enables vector and hybrid search.
     */
    vectorStore?: MastraVector;
    /**
     * Embedder function for generating vectors.
     * Required when vectorStore is provided.
     */
    embedder?: Embedder;
    /**
     * Enable BM25 keyword search.
     * Pass true for defaults, or a BM25Config object for custom parameters.
     */
    bm25?: boolean | BM25Config;
    /**
     * Custom index name for the vector store.
     * If not provided, defaults to a sanitized version of `${id}_search`.
     *
     * Must be a valid SQL identifier for SQL-based stores (PgVector, LibSQL):
     * - Start with a letter or underscore
     * - Contain only letters, numbers, or underscores
     * - Maximum 63 characters
     *
     * @example 'my_workspace_vectors'
     */
    searchIndexName?: string;
    /**
     * Paths to auto-index on init().
     * Files in these directories will be indexed for search.
     * @example ['/docs', '/support']
     */
    autoIndexPaths?: string[];
    /**
     * Paths where skills are located.
     * Workspace will discover SKILL.md files in these directories.
     *
     * Can be a static array of paths or a function that returns paths
     * dynamically based on request context (e.g., user tier, tenant).
     *
     * @example Static paths
     * ```typescript
     * skills: ['/skills', '/node_modules/@myorg/skills']
     * ```
     *
     * @example Dynamic paths
     * ```typescript
     * skills: (ctx) => {
     *   const tier = ctx.requestContext?.get('userTier');
     *   return tier === 'premium'
     *     ? ['/skills/basic', '/skills/premium']
     *     : ['/skills/basic'];
     * }
     * ```
     */
    skills?: SkillsResolver;
    /**
     * Per-tool configuration for workspace tools.
     * Controls which tools are enabled and their safety settings.
     *
     * This replaces the provider-level `requireApproval` and `requireReadBeforeWrite`
     * settings, allowing more granular control per tool.
     *
     * @example
     * ```typescript
     * tools: {
     *   mastra_workspace_read_file: {
     *     enabled: true,
     *     requireApproval: false,
     *   },
     *   mastra_workspace_write_file: {
     *     enabled: true,
     *     requireApproval: true,
     *     requireReadBeforeWrite: true,
     *   },
     *   mastra_workspace_execute_command: {
     *     enabled: true,
     *     requireApproval: true,
     *   },
     * }
     * ```
     */
    tools?: WorkspaceToolsConfig;
    /** Auto-sync between fs and sandbox (default: false) */
    autoSync?: boolean;
    /** Timeout for individual operations in milliseconds */
    operationTimeout?: number;
}
export type { WorkspaceStatus } from './types.js';
/**
 * Information about how filesystem and sandbox paths relate.
 * Used by agents to understand how to access workspace files from sandbox code.
 */
export interface PathContext {
    /** Filesystem details (if available) */
    filesystem?: {
        provider: string;
        /** Absolute base path on disk (for local filesystems) */
        basePath?: string;
    };
    /** Sandbox details (if available) */
    sandbox?: {
        provider: string;
        /** Working directory for command execution */
        workingDirectory?: string;
    };
    /**
     * Human-readable instructions for how to access filesystem files from sandbox code.
     * Combined from filesystem and sandbox provider instructions.
     */
    instructions: string;
}
export interface WorkspaceInfo {
    id: string;
    name: string;
    status: WorkspaceStatus;
    createdAt: Date;
    lastAccessedAt: Date;
    /** Filesystem info (if available) */
    filesystem?: FilesystemInfo & {
        totalFiles?: number;
        totalSize?: number;
    };
    /** Sandbox info (if available) */
    sandbox?: {
        provider: string;
        status: string;
        resources?: {
            memoryMB?: number;
            memoryUsedMB?: number;
            cpuCores?: number;
            cpuPercent?: number;
            diskMB?: number;
            diskUsedMB?: number;
        };
    };
}
/**
 * Workspace provides agents with filesystem and execution capabilities.
 *
 * At minimum, a workspace has either a filesystem or a sandbox (or both).
 * Users pass instantiated provider objects to the constructor.
 */
export declare class Workspace {
    readonly id: string;
    readonly name: string;
    readonly createdAt: Date;
    lastAccessedAt: Date;
    private _status;
    private readonly _fs?;
    private readonly _sandbox?;
    private readonly _config;
    private readonly _searchEngine?;
    private _skills?;
    constructor(config: WorkspaceConfig);
    private generateId;
    private hasSkillsConfig;
    get status(): WorkspaceStatus;
    /**
     * The filesystem provider (if configured).
     */
    get filesystem(): WorkspaceFilesystem | undefined;
    /**
     * The sandbox provider (if configured).
     */
    get sandbox(): WorkspaceSandbox | undefined;
    /**
     * Get the per-tool configuration for this workspace.
     * Returns undefined if no tools config was provided.
     */
    getToolsConfig(): WorkspaceToolsConfig | undefined;
    /**
     * Access skills stored in this workspace.
     * Skills are SKILL.md files discovered from the configured skillPaths.
     *
     * Returns undefined if no skillPaths are configured.
     *
     * @example
     * ```typescript
     * const skills = await workspace.skills?.list();
     * const skill = await workspace.skills?.get('brand-guidelines');
     * const results = await workspace.skills?.search('brand colors');
     * ```
     */
    get skills(): WorkspaceSkills | undefined;
    /**
     * Check if BM25 keyword search is available.
     */
    get canBM25(): boolean;
    /**
     * Check if vector semantic search is available.
     */
    get canVector(): boolean;
    /**
     * Check if hybrid search is available.
     */
    get canHybrid(): boolean;
    /**
     * Index content for search.
     * The path becomes the document ID in search results.
     *
     * @param path - File path (used as document ID)
     * @param content - Text content to index
     * @param options - Index options (metadata, type hints)
     * @throws {SearchNotAvailableError} if search is not configured
     */
    index(path: string, content: string, options?: {
        type?: 'text' | 'image' | 'file';
        mimeType?: string;
        metadata?: Record<string, unknown>;
        startLineOffset?: number;
    }): Promise<void>;
    /**
     * Search indexed content.
     *
     * @param query - Search query string
     * @param options - Search options (topK, mode, filters)
     * @returns Array of search results
     * @throws {SearchNotAvailableError} if search is not configured
     */
    search(query: string, options?: SearchOptions): Promise<SearchResult[]>;
    /**
     * Rebuild the search index from filesystem paths.
     * Used internally for auto-indexing on init.
     */
    private rebuildSearchIndex;
    private getAllFiles;
    /**
     * Initialize the workspace.
     * Starts the sandbox, initializes the filesystem, and auto-mounts filesystems.
     */
    init(): Promise<void>;
    /**
     * Destroy the workspace and clean up all resources.
     */
    destroy(): Promise<void>;
    /**
     * Get workspace information.
     * @param options.includeFileCount - Whether to count total files (can be slow for large workspaces)
     */
    getInfo(options?: {
        includeFileCount?: boolean;
    }): Promise<WorkspaceInfo>;
    /**
     * Get information about how filesystem and sandbox paths relate.
     * Useful for understanding how to access workspace files from sandbox code.
     *
     * @returns PathContext with paths and instructions from providers
     */
    getPathContext(): PathContext;
    /**
     * Set the logger for this workspace and propagate to providers.
     * Called by Mastra when the logger is set.
     * @internal
     */
    __setLogger(logger: IMastraLogger): void;
}
//# sourceMappingURL=workspace.d.ts.map