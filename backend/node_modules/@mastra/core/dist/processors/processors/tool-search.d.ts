import type { Tool } from '../../tools/index.js';
import type { ProcessInputStepArgs, Processor } from '../index.js';
/**
 * Configuration options for ToolSearchProcessor
 */
export interface ToolSearchProcessorOptions {
    /**
     * All tools that can be searched and loaded dynamically.
     * These tools are not immediately available - they must be discovered via search and loaded on demand.
     */
    tools: Record<string, Tool<any, any>>;
    /**
     * Configuration for the search behavior
     */
    search?: {
        /**
         * Maximum number of tools to return in search results
         * @default 5
         */
        topK?: number;
        /**
         * Minimum relevance score (0-1) for including a tool in search results
         * @default 0
         */
        minScore?: number;
    };
    /**
     * Time-to-live for thread state in milliseconds.
     * After this duration of inactivity, thread state will be eligible for cleanup.
     * Set to 0 to disable TTL cleanup.
     * @default 3600000 (1 hour)
     */
    ttl?: number;
}
/**
 * Search result with ranking score
 */
interface SearchResult {
    name: string;
    description: string;
    score: number;
}
/**
 * Processor that enables dynamic tool discovery and loading.
 *
 * Instead of providing all tools to the agent upfront, this processor:
 * 1. Gives the agent two meta-tools: search_tools and load_tool
 * 2. Agent searches for relevant tools using keywords
 * 3. Agent loads specific tools into the conversation on demand
 * 4. Loaded tools become immediately available for use
 *
 * This pattern dramatically reduces context usage when working with many tools (100+).
 *
 * @example
 * ```typescript
 * const toolSearch = new ToolSearchProcessor({
 *   tools: {
 *     createIssue: githubTools.createIssue,
 *     sendEmail: emailTools.send,
 *     // ... 100+ tools
 *   },
 *   search: { topK: 5, minScore: 0 },
 *   ttl: 3600000, // 1 hour (default)
 * });
 *
 * const agent = new Agent({
 *   name: 'my-agent',
 *   inputProcessors: [toolSearch],
 *   tools: {}, // Always-available tools (if any)
 * });
 * ```
 */
export declare class ToolSearchProcessor implements Processor<'tool-search'> {
    readonly id = "tool-search";
    readonly name = "Tool Search Processor";
    readonly description = "Enables dynamic tool discovery and loading via search";
    private allTools;
    private searchConfig;
    private ttl;
    /** BM25 index for tool search */
    private bm25Index;
    /** Map from tool ID to full description (for result formatting) */
    private toolDescriptions;
    /**
     * Thread-scoped state management for loaded tools with TTL support.
     * Instance-scoped to prevent cross-processor interference.
     * Maps threadId -> ThreadState (tools + timestamp)
     */
    private threadLoadedTools;
    constructor(options: ToolSearchProcessorOptions);
    /**
     * Get the thread ID from the request context, or use 'default' as fallback.
     */
    private getThreadId;
    /**
     * Get the set of loaded tool names for the current thread.
     * Updates the lastAccessed timestamp for TTL management.
     */
    private getLoadedToolNames;
    /**
     * Get loaded tools as Tool objects for the current thread.
     */
    private getLoadedTools;
    /**
     * Clear loaded tools for a specific thread (useful for testing).
     *
     * @param threadId - The thread ID to clear, or 'default' if not provided
     */
    clearState(threadId?: string): void;
    /**
     * Clear all thread state for this processor instance (useful for testing).
     */
    clearAllState(): void;
    /**
     * Clean up stale thread state based on TTL.
     * Removes threads that haven't been accessed within the TTL period.
     *
     * @returns Number of threads cleaned up
     */
    private cleanupStaleState;
    /**
     * Schedule periodic cleanup of stale thread state.
     * Runs cleanup every TTL/2 milliseconds to prevent unbounded memory growth.
     */
    private scheduleCleanup;
    /**
     * Get statistics about current thread state (useful for monitoring).
     *
     * @returns Object with thread count and oldest access time
     */
    getStateStats(): {
        threadCount: number;
        oldestAccessTime: number | null;
    };
    /**
     * Manually trigger cleanup of stale state (useful for testing and monitoring).
     *
     * @returns Number of threads cleaned up
     */
    cleanupNow(): number;
    /**
     * Index all tools into the BM25 index
     */
    private indexTools;
    /**
     * Search for tools matching the query using BM25 ranking
     * with name-match boosting.
     *
     * @param query - Search keywords
     * @returns Array of matching tools with scores, sorted by relevance
     */
    private searchTools;
    processInputStep(args: ProcessInputStepArgs): Promise<{
        tools: {
            search_tools: Tool<{
                query: string;
            }, {
                results: SearchResult[];
                message: string;
            }, unknown, unknown, import("../../tools").ToolExecutionContext<unknown, unknown, unknown>, "search_tools", unknown>;
            load_tool: Tool<{
                toolName: string;
            }, {
                success: boolean;
                message: string;
                toolName?: undefined;
            } | {
                success: boolean;
                message: string;
                toolName: string;
            }, unknown, unknown, import("../../tools").ToolExecutionContext<unknown, unknown, unknown>, "load_tool", unknown>;
        };
    }>;
}
export {};
//# sourceMappingURL=tool-search.d.ts.map