{"version":3,"sources":["../src/tools/validation.ts","../src/tools/tool.ts","../src/tools/toolchecks.ts"],"names":["MASTRA_RESOURCE_ID_KEY","MASTRA_THREAD_ID_KEY","isZodArray","isZodObject","unwrapZodType","getZodTypeName","RequestContext","resumeData"],"mappings":"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","file":"chunk-7UWHFWST.cjs","sourcesContent":["import type { z } from 'zod';\nimport { MASTRA_RESOURCE_ID_KEY, MASTRA_THREAD_ID_KEY } from '../request-context';\nimport type { RequestContext } from '../request-context';\nimport type { SchemaWithValidation } from '../stream/base/schema';\nimport { getZodTypeName, isZodArray, isZodObject, unwrapZodType } from '../utils/zod-utils';\n\n/**\n * Keys that should be redacted from error messages to prevent sensitive data leakage.\n */\nconst SENSITIVE_KEYS = new Set([\n  MASTRA_RESOURCE_ID_KEY,\n  MASTRA_THREAD_ID_KEY,\n  'apiKey',\n  'api_key',\n  'token',\n  'secret',\n  'password',\n  'credential',\n  'authorization',\n]);\n\n/**\n * Redacts sensitive keys from an object before logging.\n * @param data The data to redact\n * @returns A new object with sensitive values replaced with '[REDACTED]'\n */\nfunction redactSensitiveKeys(data: Record<string, unknown>): Record<string, unknown> {\n  const result: Record<string, unknown> = {};\n  for (const [key, value] of Object.entries(data)) {\n    if (SENSITIVE_KEYS.has(key) || key.toLowerCase().includes('secret') || key.toLowerCase().includes('password')) {\n      result[key] = '[REDACTED]';\n    } else {\n      result[key] = value;\n    }\n  }\n  return result;\n}\n\nexport interface ValidationError<T = any> {\n  error: true;\n  message: string;\n  validationErrors: z.ZodFormattedError<T>;\n}\n\n/**\n * Safely truncates data for error messages to avoid exposing sensitive information.\n * @param data The data to truncate\n * @param maxLength Maximum length of the truncated string (default: 200)\n * @returns Truncated string representation\n */\nfunction truncateForLogging(data: unknown, maxLength: number = 200): string {\n  try {\n    const stringified = JSON.stringify(data, null, 2);\n    if (stringified.length <= maxLength) {\n      return stringified;\n    }\n    return stringified.slice(0, maxLength) + '... (truncated)';\n  } catch {\n    return '[Unable to serialize data]';\n  }\n}\n\n/**\n * Validates raw suspend data against a Zod schema.\n *\n * @param schema The Zod schema to validate against\n * @param suspendData The raw suspend data to validate\n * @param toolId Optional tool ID for better error messages\n * @returns The validated data or a validation error\n */\nexport function validateToolSuspendData<T = any>(\n  schema: SchemaWithValidation<T> | undefined,\n  suspendData: unknown,\n  toolId?: string,\n): { data: T | unknown; error?: ValidationError<T> } {\n  // If no schema, return suspend data as-is\n  if (!schema || !('safeParse' in schema)) {\n    return { data: suspendData };\n  }\n\n  // Validate the input directly - no unwrapping needed in v1.0\n  const validation = schema.safeParse(suspendData);\n\n  if (validation.success) {\n    return { data: validation.data };\n  }\n\n  // Validation failed, return error\n  const errorMessages = validation.error.issues.map(e => `- ${e.path?.join('.') || 'root'}: ${e.message}`).join('\\n');\n\n  const error: ValidationError<T> = {\n    error: true,\n    message: `Tool suspension data validation failed${toolId ? ` for ${toolId}` : ''}. Please fix the following errors and try again:\\n${errorMessages}\\n\\nProvided arguments: ${truncateForLogging(suspendData)}`,\n    validationErrors: validation.error.format() as z.ZodFormattedError<T>,\n  };\n\n  return { data: suspendData, error };\n}\n\n/**\n * Normalizes undefined/null input to an appropriate default value based on schema type.\n * This handles LLMs (Claude Sonnet 4.5, Gemini 2.4, etc.) that send undefined/null\n * instead of {} or [] when all parameters are optional.\n *\n * @param schema The Zod schema to check\n * @param input The input to normalize\n * @returns The normalized input (original value, {}, or [])\n */\nfunction normalizeNullishInput(schema: SchemaWithValidation<unknown>, input: unknown): unknown {\n  if (input !== undefined && input !== null) {\n    return input;\n  }\n\n  // Check if schema is an array type (using typeName to avoid dual-package hazard)\n  if (isZodArray(schema)) {\n    return [];\n  }\n\n  // Check if schema is an object type (using typeName to avoid dual-package hazard)\n  if (isZodObject(schema)) {\n    return {};\n  }\n\n  // For other schema types, return the original input and let Zod validate\n  return input;\n}\n\n/**\n * Checks if a value is a plain object (created by {} or new Object()).\n * This excludes class instances, built-in objects like Date/Map/URL, etc.\n *\n * @param value The value to check\n * @returns true if the value is a plain object\n */\nfunction isPlainObject(value: unknown): value is Record<string, unknown> {\n  if (value === null || typeof value !== 'object') {\n    return false;\n  }\n  const proto = Object.getPrototypeOf(value);\n  return proto === Object.prototype || proto === null;\n}\n\n/**\n * Recursively strips null and undefined values from object properties.\n * This handles LLMs (e.g. Gemini) that send null for optional fields,\n * since Zod's .optional() only accepts undefined, not null. (GitHub #12362)\n *\n * When a property value is null or undefined, it is omitted from the result\n * object entirely, which is equivalent to \"not provided\" for Zod validation.\n *\n * Only recurses into plain objects to preserve class instances and built-in objects\n * like Date, Map, URL, etc.\n *\n * NOTE: This function should NOT be called unconditionally because it breaks\n * schemas that use .nullable() (where null is a valid value). It is used as\n * a fallback when initial validation fails. See validateToolInput for usage.\n *\n * @param input The input to process\n * @returns The processed input with null/undefined values stripped\n */\nfunction stripNullishValues(input: unknown): unknown {\n  // Top-level null/undefined becomes undefined\n  if (input === null || input === undefined) {\n    return undefined;\n  }\n\n  if (typeof input !== 'object') {\n    return input;\n  }\n\n  if (Array.isArray(input)) {\n    // For arrays, recursively process elements but keep nulls in arrays\n    // (array elements with null may be intentional)\n    return input.map(item => (item === null ? null : stripNullishValues(item)));\n  }\n\n  // Only recurse into plain objects - preserve class instances, built-in objects\n  if (!isPlainObject(input)) {\n    return input;\n  }\n\n  // It's a plain object - recursively process all properties, omitting null/undefined values\n  const result: Record<string, unknown> = {};\n  for (const [key, value] of Object.entries(input)) {\n    if (value === null || value === undefined) {\n      // Omit null/undefined values - equivalent to \"not provided\" for optional fields\n      continue;\n    }\n    result[key] = stripNullishValues(value);\n  }\n  return result;\n}\n\n/**\n * Recursively converts undefined values to null in an object.\n * This is needed for OpenAI compat layers which convert .optional() to .nullable()\n * for strict mode compliance. When fields are omitted (undefined), we convert them\n * to null so the schema validation passes, and the transform then converts null back\n * to undefined. (GitHub #11457)\n *\n * Only recurses into plain objects to preserve class instances and built-in objects\n * like Date, Map, URL, etc. (GitHub #11502)\n *\n * @param input The input to process\n * @returns The processed input with undefined values converted to null\n */\nfunction convertUndefinedToNull(input: unknown): unknown {\n  if (input === undefined) {\n    return null;\n  }\n\n  if (input === null || typeof input !== 'object') {\n    return input;\n  }\n\n  if (Array.isArray(input)) {\n    return input.map(convertUndefinedToNull);\n  }\n\n  // Only recurse into plain objects - preserve class instances, built-in objects\n  // (Date, Map, Set, URL, etc.) and any other non-plain objects\n  if (!isPlainObject(input)) {\n    return input;\n  }\n\n  // It's a plain object - recursively process all properties\n  const result: Record<string, unknown> = {};\n  for (const [key, value] of Object.entries(input)) {\n    result[key] = convertUndefinedToNull(value);\n  }\n  return result;\n}\n\n/**\n * Coerces stringified JSON values in object properties when the schema expects\n * an array or object but the LLM returned a JSON string.\n *\n * Some LLMs (e.g., GLM4.7) return stringified JSON for array/object parameters:\n *   { \"args\": \"[\\\"parse_excel.py\\\"]\" }\n * instead of:\n *   { \"args\": [\"parse_excel.py\"] }\n *\n * This function walks the top-level properties of a plain object and attempts\n * to JSON.parse string values when the schema expects a non-string type.\n * (GitHub #12757)\n *\n * @param schema The Zod schema to check field types against\n * @param input The input to process\n * @returns The input with stringified JSON values coerced, or the original input\n */\nfunction coerceStringifiedJsonValues(schema: SchemaWithValidation<unknown>, input: unknown): unknown {\n  // Only process plain objects with object schemas\n  if (!isPlainObject(input)) {\n    return input;\n  }\n\n  const unwrapped = unwrapZodType(schema as any);\n  if (!isZodObject(unwrapped)) {\n    return input;\n  }\n\n  const shape = (unwrapped as any).shape;\n  if (!shape || typeof shape !== 'object') {\n    return input;\n  }\n\n  let changed = false;\n  const result: Record<string, unknown> = { ...input };\n\n  for (const [key, value] of Object.entries(input)) {\n    if (typeof value !== 'string') {\n      continue;\n    }\n\n    const fieldSchema = shape[key];\n    if (!fieldSchema) {\n      continue;\n    }\n\n    // Unwrap the field schema to find the base type\n    const baseFieldSchema = unwrapZodType(fieldSchema);\n\n    // Only attempt coercion if the schema expects a non-string type\n    // and the string looks like it could be JSON (starts with [ or {)\n    if (getZodTypeName(baseFieldSchema) === 'ZodString') {\n      continue;\n    }\n\n    const trimmed = value.trim();\n    if (\n      (isZodArray(baseFieldSchema) && trimmed.startsWith('[')) ||\n      (isZodObject(baseFieldSchema) && trimmed.startsWith('{'))\n    ) {\n      try {\n        const parsed = JSON.parse(value);\n        if (\n          (isZodArray(baseFieldSchema) && Array.isArray(parsed)) ||\n          (isZodObject(baseFieldSchema) && isPlainObject(parsed))\n        ) {\n          result[key] = parsed;\n          changed = true;\n        }\n      } catch {\n        // Not valid JSON, leave as-is\n      }\n    }\n  }\n\n  return changed ? result : input;\n}\n\n/**\n * Validates raw input data against a Zod schema.\n *\n * @param schema The Zod schema to validate against\n * @param input The raw input data to validate\n * @param toolId Optional tool ID for better error messages\n * @returns The validated data or a validation error\n */\nexport function validateToolInput<T = any>(\n  schema: SchemaWithValidation<T> | undefined,\n  input: unknown,\n  toolId?: string,\n): { data: T | unknown; error?: ValidationError<T> } {\n  // If no schema, return input as-is\n  if (!schema || !('safeParse' in schema)) {\n    return { data: input };\n  }\n\n  // Validation pipeline:\n  //\n  // 1. normalizeNullishInput: Convert top-level null/undefined to {} or [] based on schema type.\n  //    Handles LLMs that send undefined instead of {} or [] for all-optional parameters.\n  //\n  // 2. convertUndefinedToNull: Convert undefined values to null in object properties.\n  //    Needed for OpenAI compat layers that convert .optional() to .nullable() for\n  //    strict mode compliance. The schema's transform converts null back to undefined.\n  //    (GitHub #11457)\n  //\n  // 3. First validation attempt with null values preserved. This handles .nullable()\n  //    schemas correctly (where null is a valid value).\n  //\n  // 4. If validation fails, retry with stringified JSON values coerced to their\n  //    proper types. Some LLMs (e.g. GLM4.7) return JSON arrays/objects as strings.\n  //    (GitHub #12757)\n  //\n  // 5. If validation still fails, retry with null values stripped from object properties.\n  //    This handles LLMs (e.g. Gemini) that send null for .optional() fields, where\n  //    Zod expects undefined, not null. (GitHub #12362)\n\n  // Step 1: Normalize top-level null/undefined to appropriate default\n  let normalizedInput = normalizeNullishInput(schema, input);\n\n  // Step 2: Convert undefined values to null recursively (GitHub #11457)\n  normalizedInput = convertUndefinedToNull(normalizedInput);\n\n  // Step 3: Try validation with null values preserved\n  const validation = schema.safeParse(normalizedInput);\n  if (validation.success) {\n    return { data: validation.data };\n  }\n\n  // Step 4: Retry with stringified JSON values coerced (GitHub #12757)\n  // LLMs like GLM4.7 send stringified JSON for array/object parameters, e.g.\n  // { \"args\": \"[\\\"file.py\\\"]\" } instead of { \"args\": [\"file.py\"] }.\n  const coercedInput = coerceStringifiedJsonValues(schema, normalizedInput);\n  if (coercedInput !== normalizedInput) {\n    const coercedValidation = schema.safeParse(coercedInput);\n    if (coercedValidation.success) {\n      return { data: coercedValidation.data };\n    }\n  }\n\n  // Step 5: Retry with null values stripped (GitHub #12362)\n  // LLMs like Gemini send null for optional fields, but Zod's .optional() only\n  // accepts undefined, not null. By stripping nullish values and retrying, we\n  // handle this case without breaking .nullable() schemas that passed in step 3.\n  const strippedInput = stripNullishValues(input);\n  const normalizedStripped = normalizeNullishInput(schema, strippedInput);\n  const retryValidation = schema.safeParse(normalizedStripped);\n\n  if (retryValidation.success) {\n    return { data: retryValidation.data };\n  }\n\n  // All attempts failed - return the original (non-stripped) error since it's\n  // more informative about what the schema actually expects\n  const errorMessages = validation.error.issues.map(e => `- ${e.path?.join('.') || 'root'}: ${e.message}`).join('\\n');\n\n  const error: ValidationError<T> = {\n    error: true,\n    message: `Tool input validation failed${toolId ? ` for ${toolId}` : ''}. Please fix the following errors and try again:\\n${errorMessages}\\n\\nProvided arguments: ${truncateForLogging(input)}`,\n    validationErrors: validation.error.format() as z.ZodFormattedError<T>,\n  };\n\n  return { data: input, error };\n}\n\n/**\n * Validates tool output data against a Zod schema.\n *\n * @param schema The Zod schema to validate against\n * @param output The output data to validate\n * @param toolId Optional tool ID for better error messages\n * @returns The validated data or a validation error\n */\nexport function validateToolOutput<T = any>(\n  schema: SchemaWithValidation<T> | undefined,\n  output: unknown,\n  toolId?: string,\n  suspendCalled?: boolean,\n): { data: T | unknown; error?: ValidationError<T> } {\n  // If no schema, return output as-is\n  if (!schema || !('safeParse' in schema) || suspendCalled) {\n    return { data: output };\n  }\n\n  // Validate the output\n  const validation = schema.safeParse(output);\n\n  if (validation.success) {\n    return { data: validation.data };\n  }\n\n  // Validation failed, return error\n  const errorMessages = validation.error.issues.map(e => `- ${e.path?.join('.') || 'root'}: ${e.message}`).join('\\n');\n\n  const error: ValidationError<T> = {\n    error: true,\n    message: `Tool output validation failed${toolId ? ` for ${toolId}` : ''}. The tool returned invalid output:\\n${errorMessages}\\n\\nReturned output: ${truncateForLogging(output)}`,\n    validationErrors: validation.error.format() as z.ZodFormattedError<T>,\n  };\n\n  return { data: output, error };\n}\n\n/**\n * Validates request context values against a Zod schema.\n *\n * @param schema The Zod schema to validate against\n * @param requestContext The RequestContext instance to validate\n * @param identifier Optional identifier for better error messages (e.g., tool ID, agent ID)\n * @returns The validated data or a validation error\n */\nexport function validateRequestContext<T = any>(\n  schema: SchemaWithValidation<T> | undefined,\n  requestContext: RequestContext | undefined,\n  identifier?: string,\n): { data: T | Record<string, any>; error?: ValidationError<T> } {\n  // Get all values from the requestContext\n  const contextValues = requestContext?.all ?? {};\n\n  // If no schema, return context values as-is\n  if (!schema || !('safeParse' in schema)) {\n    return { data: contextValues };\n  }\n\n  // Validate the context values\n  const validation = schema.safeParse(contextValues);\n\n  if (validation.success) {\n    return { data: validation.data };\n  }\n\n  // Validation failed, return error\n  const errorMessages = validation.error.issues.map(e => `- ${e.path?.join('.') || 'root'}: ${e.message}`).join('\\n');\n\n  // Redact sensitive keys before including in error message\n  const redactedContextValues = redactSensitiveKeys(contextValues);\n\n  const error: ValidationError<T> = {\n    error: true,\n    message: `Request context validation failed${identifier ? ` for ${identifier}` : ''}. Please fix the following errors and try again:\\n${errorMessages}\\n\\nProvided context: ${truncateForLogging(redactedContextValues)}`,\n    validationErrors: validation.error.format() as z.ZodFormattedError<T>,\n  };\n\n  return { data: contextValues, error };\n}\n","import type { Mastra } from '../mastra';\nimport { RequestContext } from '../request-context';\nimport type { SchemaWithValidation } from '../stream/base/schema';\nimport type { SuspendOptions } from '../workflows';\nimport type { MCPToolProperties, ToolAction, ToolExecutionContext } from './types';\nimport { validateToolInput, validateToolOutput, validateToolSuspendData, validateRequestContext } from './validation';\n\n/**\n * A type-safe tool that agents and workflows can call to perform specific actions.\n *\n * @template TSchemaIn - Input schema type\n * @template TSchemaOut - Output schema type\n * @template TSuspendSchema - Suspend operation schema type\n * @template TResumeSchema - Resume operation schema type\n * @template TContext - Execution context type\n *\n * @example Basic tool with validation\n * ```typescript\n * const weatherTool = createTool({\n *   id: 'get-weather',\n *   description: 'Get weather for a location',\n *   inputSchema: z.object({\n *     location: z.string(),\n *     units: z.enum(['celsius', 'fahrenheit']).optional()\n *   }),\n *   execute: async (inputData) => {\n *     return await fetchWeather(inputData.location, inputData.units);\n *   }\n * });\n * ```\n *\n * @example Tool requiring approval\n * ```typescript\n * const deleteFileTool = createTool({\n *   id: 'delete-file',\n *   description: 'Delete a file',\n *   requireApproval: true,\n *   inputSchema: z.object({ filepath: z.string() }),\n *   execute: async (inputData) => {\n *     await fs.unlink(inputData.filepath);\n *     return { deleted: true };\n *   }\n * });\n * ```\n *\n * @example Tool with Mastra integration\n * ```typescript\n * const saveTool = createTool({\n *   id: 'save-data',\n *   description: 'Save data to storage',\n *   inputSchema: z.object({ key: z.string(), value: z.any() }),\n *   execute: async (inputData, context) => {\n *     const storage = context?.mastra?.getStorage();\n *     await storage?.set(inputData.key, inputData.value);\n *     return { saved: true };\n *   }\n * });\n * ```\n */\nexport class Tool<\n  TSchemaIn = unknown,\n  TSchemaOut = unknown,\n  TSuspendSchema = unknown,\n  TResumeSchema = unknown,\n  TContext extends ToolExecutionContext<TSuspendSchema, TResumeSchema, any> = ToolExecutionContext<\n    TSuspendSchema,\n    TResumeSchema\n  >,\n  TId extends string = string,\n  TRequestContext extends Record<string, any> | unknown = unknown,\n> implements ToolAction<TSchemaIn, TSchemaOut, TSuspendSchema, TResumeSchema, TContext, TId, TRequestContext> {\n  /** Unique identifier for the tool */\n  id: TId;\n\n  /** Description of what the tool does */\n  description: string;\n\n  /** Schema for validating input parameters */\n  inputSchema?: SchemaWithValidation<TSchemaIn>;\n\n  /** Schema for validating output structure */\n  outputSchema?: SchemaWithValidation<TSchemaOut>;\n\n  /** Schema for suspend operation data */\n  suspendSchema?: SchemaWithValidation<TSuspendSchema>;\n\n  /** Schema for resume operation data */\n  resumeSchema?: SchemaWithValidation<TResumeSchema>;\n\n  /**\n   * Schema for validating request context values.\n   * When provided, the request context will be validated against this schema before tool execution.\n   */\n  requestContextSchema?: SchemaWithValidation<TRequestContext>;\n\n  /**\n   * Tool execution function\n   * @param inputData - The raw, validated input data\n   * @param context - Optional execution context with metadata\n   * @returns Promise resolving to tool output or a ValidationError if input validation fails\n   */\n  execute?: ToolAction<TSchemaIn, TSchemaOut, TSuspendSchema, TResumeSchema, TContext, TId, TRequestContext>['execute'];\n\n  /** Parent Mastra instance for accessing shared resources */\n  mastra?: Mastra;\n\n  /**\n   * Whether the tool requires explicit user approval before execution\n   * @example\n   * ```typescript\n   * // For destructive operations\n   * requireApproval: true\n   * ```\n   */\n  requireApproval?: boolean;\n\n  /**\n   * Provider-specific options passed to the model when this tool is used.\n   * Keys are provider names (e.g., 'anthropic', 'openai'), values are provider-specific configs.\n   * @example\n   * ```typescript\n   * providerOptions: {\n   *   anthropic: {\n   *     cacheControl: { type: 'ephemeral' }\n   *   }\n   * }\n   * ```\n   */\n  providerOptions?: Record<string, Record<string, unknown>>;\n\n  /**\n   * Optional MCP-specific properties including annotations and metadata.\n   * Only relevant when the tool is being used in an MCP context.\n   * @example\n   * ```typescript\n   * mcp: {\n   *   annotations: {\n   *     title: 'Weather Lookup',\n   *     readOnlyHint: true,\n   *     destructiveHint: false\n   *   },\n   *   _meta: {\n   *     version: '1.0.0',\n   *     author: 'team@example.com'\n   *   }\n   * }\n   * ```\n   */\n  mcp?: MCPToolProperties;\n\n  /**\n   * Creates a new Tool instance with input validation wrapper.\n   *\n   * @param opts - Tool configuration and execute function\n   * @example\n   * ```typescript\n   * const tool = new Tool({\n   *   id: 'my-tool',\n   *   description: 'Does something useful',\n   *   inputSchema: z.object({ name: z.string() }),\n   *   execute: async (inputData) => ({ greeting: `Hello ${inputData.name}` })\n   * });\n   * ```\n   */\n  constructor(opts: ToolAction<TSchemaIn, TSchemaOut, TSuspendSchema, TResumeSchema, TContext, TId, TRequestContext>) {\n    this.id = opts.id;\n    this.description = opts.description;\n    this.inputSchema = opts.inputSchema;\n    this.outputSchema = opts.outputSchema;\n    this.suspendSchema = opts.suspendSchema;\n    this.resumeSchema = opts.resumeSchema;\n    this.requestContextSchema = opts.requestContextSchema;\n    this.mastra = opts.mastra;\n    this.requireApproval = opts.requireApproval || false;\n    this.providerOptions = opts.providerOptions;\n    this.mcp = opts.mcp;\n\n    // Tools receive two parameters:\n    // 1. input - The raw, validated input data\n    // 2. context - Execution metadata (mastra, suspend, etc.)\n    if (opts.execute) {\n      const originalExecute = opts.execute;\n      this.execute = async (inputData: unknown, context?: any) => {\n        // Validate input if schema exists\n        const { data, error } = validateToolInput(this.inputSchema, inputData, this.id);\n        if (error) {\n          return error as any;\n        }\n\n        // Validate request context if schema exists\n        const { error: requestContextError } = validateRequestContext(\n          this.requestContextSchema,\n          context?.requestContext,\n          this.id,\n        );\n        if (requestContextError) {\n          return requestContextError as any;\n        }\n\n        let suspendData = null;\n\n        const baseContext = context\n          ? {\n              ...context,\n              ...(context.suspend\n                ? {\n                    suspend: (args: any, suspendOptions?: SuspendOptions) => {\n                      suspendData = args;\n                      return context.suspend?.(args, suspendOptions);\n                    },\n                  }\n                : {}),\n            }\n          : {};\n\n        // Organize context based on execution source\n        let organizedContext = baseContext;\n        if (!context) {\n          // No context provided - create a minimal context with requestContext\n          organizedContext = {\n            requestContext: new RequestContext(),\n            mastra: undefined,\n          };\n        } else {\n          // Check if this is agent execution (has toolCallId and messages)\n          const isAgentExecution = baseContext.toolCallId && baseContext.messages;\n\n          // Check if this is workflow execution (has workflow properties)\n          // Agent execution takes precedence - don't treat as workflow if it's an agent call\n          const isWorkflowExecution = !isAgentExecution && (baseContext.workflow || baseContext.workflowId);\n\n          if (isAgentExecution && !baseContext.agent) {\n            // Reorganize agent context - nest agent-specific properties under 'agent' key\n            const { toolCallId, messages, suspend, resumeData, threadId, resourceId, writableStream, ...rest } =\n              baseContext;\n            organizedContext = {\n              ...rest,\n              agent: {\n                toolCallId,\n                messages,\n                suspend,\n                resumeData,\n                threadId,\n                resourceId,\n                writableStream,\n              },\n              // Ensure requestContext is always present\n              requestContext: rest.requestContext || new RequestContext(),\n            };\n          } else if (isWorkflowExecution && !baseContext.workflow) {\n            // Reorganize workflow context - nest workflow-specific properties under 'workflow' key\n            const { workflowId, runId, state, setState, suspend, resumeData, ...rest } = baseContext;\n            organizedContext = {\n              ...rest,\n              workflow: {\n                workflowId,\n                runId,\n                state,\n                setState,\n                suspend,\n                resumeData,\n              },\n              // Ensure requestContext is always present\n              requestContext: rest.requestContext || new RequestContext(),\n            };\n          } else {\n            // Ensure requestContext is always present even for direct execution\n            organizedContext = {\n              ...baseContext,\n              agent: baseContext.agent\n                ? {\n                    ...baseContext.agent,\n                    suspend: (args: any, suspendOptions?: SuspendOptions) => {\n                      suspendData = args;\n                      return baseContext.agent?.suspend?.(args, suspendOptions);\n                    },\n                  }\n                : baseContext.agent,\n              workflow: baseContext.workflow\n                ? {\n                    ...baseContext.workflow,\n                    suspend: (args: any, suspendOptions?: SuspendOptions) => {\n                      suspendData = args;\n                      return baseContext.workflow?.suspend?.(args, suspendOptions);\n                    },\n                  }\n                : baseContext.workflow,\n              requestContext: baseContext.requestContext || new RequestContext(),\n            };\n          }\n        }\n\n        const resumeData =\n          organizedContext.agent?.resumeData ?? organizedContext.workflow?.resumeData ?? organizedContext?.resumeData;\n\n        if (resumeData) {\n          const resumeValidation = validateToolInput(this.resumeSchema, resumeData, this.id);\n          if (resumeValidation.error) {\n            return resumeValidation.error as any;\n          }\n        }\n\n        // Call the original execute with validated input and organized context\n        const output = await originalExecute(data as any, organizedContext);\n\n        if (suspendData) {\n          const suspendValidation = validateToolSuspendData(this.suspendSchema, suspendData, this.id);\n          if (suspendValidation.error) {\n            return suspendValidation.error as any;\n          }\n        }\n\n        const skiptOutputValidation = !!(typeof output === 'undefined' && suspendData);\n\n        // Validate output if schema exists\n        const outputValidation = validateToolOutput(this.outputSchema, output, this.id, skiptOutputValidation);\n        if (outputValidation.error) {\n          return outputValidation.error as any;\n        }\n\n        return outputValidation.data;\n      };\n    }\n  }\n}\n\n/**\n * Creates a type-safe tool with automatic input validation.\n *\n * @template TSchemaIn - Input schema type\n * @template TSchemaOut - Output schema type\n * @template TSuspendSchema - Suspend operation schema type\n * @template TResumeSchema - Resume operation schema type\n * @template TContext - Execution context type\n * @template TExecute - Execute function type\n *\n * @param opts - Tool configuration including schemas and execute function\n * @returns Type-safe Tool instance with conditional typing based on schemas\n *\n * @example Simple tool\n * ```typescript\n * const greetTool = createTool({\n *   id: 'greet',\n *   description: 'Say hello',\n *   execute: async () => ({ message: 'Hello!' })\n * });\n * ```\n *\n * @example Tool with input validation\n * ```typescript\n * const calculateTool = createTool({\n *   id: 'calculate',\n *   description: 'Perform calculations',\n *   inputSchema: z.object({\n *     operation: z.enum(['add', 'subtract']),\n *     a: z.number(),\n *     b: z.number()\n *   }),\n *   execute: async (inputData) => {\n *     const result = inputData.operation === 'add'\n *       ? inputData.a + inputData.b\n *       : inputData.a - inputData.b;\n *     return { result };\n *   }\n * });\n * ```\n *\n * @example Tool with output schema\n * ```typescript\n * const userTool = createTool({\n *   id: 'get-user',\n *   description: 'Get user data',\n *   inputSchema: z.object({ userId: z.string() }),\n *   outputSchema: z.object({\n *     id: z.string(),\n *     name: z.string(),\n *     email: z.string()\n *   }),\n *   execute: async (inputData) => {\n *     return await fetchUser(inputData.userId);\n *   }\n * });\n * ```\n *\n * @example Tool with external API\n * ```typescript\n * const weatherTool = createTool({\n *   id: 'weather',\n *   description: 'Get weather data',\n *   inputSchema: z.object({\n *     city: z.string(),\n *     units: z.enum(['metric', 'imperial']).default('metric')\n *   }),\n *   execute: async (inputData) => {\n *     const response = await fetch(\n *       `https://api.weather.com/v1/weather?q=${inputData.city}&units=${inputData.units}`\n *     );\n *     return response.json();\n *   }\n * });\n * ```\n */\nexport function createTool<\n  TId extends string = string,\n  TSchemaIn = unknown,\n  TSchemaOut = unknown,\n  TSuspend = unknown,\n  TResume = unknown,\n  TRequestContext extends Record<string, any> | unknown = unknown,\n  TContext extends ToolExecutionContext<TSuspend, TResume, TRequestContext> = ToolExecutionContext<\n    TSuspend,\n    TResume,\n    TRequestContext\n  >,\n>(\n  opts: ToolAction<TSchemaIn, TSchemaOut, TSuspend, TResume, TContext, TId, TRequestContext>,\n): Tool<TSchemaIn, TSchemaOut, TSuspend, TResume, TContext, TId, TRequestContext> {\n  return new Tool(opts);\n}\n","import { Tool } from './tool';\nimport type { ToolToConvert } from './tool-builder/builder';\nimport type { VercelTool } from './types';\n\n/**\n * Checks if a tool is a Vercel Tool (AI SDK tool)\n * @param tool - The tool to check\n * @returns True if the tool is a Vercel Tool, false otherwise\n */\nexport function isVercelTool(tool?: ToolToConvert): tool is VercelTool {\n  // Checks if this tool is not an instance of Mastra's Tool class\n  // AI SDK tools must have an execute function and either:\n  // - 'parameters' (v4) or 'inputSchema' (v5/v6)\n  // This prevents plain objects with inputSchema (like client tools) from being treated as VercelTools\n  return !!(\n    tool &&\n    !(tool instanceof Tool) &&\n    ('parameters' in tool || ('execute' in tool && typeof tool.execute === 'function' && 'inputSchema' in tool))\n  );\n}\n"]}