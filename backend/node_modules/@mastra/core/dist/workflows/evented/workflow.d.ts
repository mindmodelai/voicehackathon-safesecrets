import { z } from 'zod';
import { Agent } from '../../agent/index.js';
import { RequestContext } from '../../di/index.js';
import type { MastraScorers } from '../../evals/index.js';
import type { Mastra } from '../../mastra/index.js';
import type { Processor } from '../../processors/index.js';
import { ProcessorStepOutputSchema, ProcessorStepSchema } from '../../processors/index.js';
import type { InferSchemaOutput, SchemaWithValidation } from '../../stream/base/schema.js';
import { WorkflowRunOutput } from '../../stream/RunOutput.js';
import { Tool } from '../../tools/index.js';
import type { ToolExecutionContext } from '../../tools/types.js';
import type { DynamicArgument } from '../../types/index.js';
import { Workflow, Run } from '../../workflows/index.js';
import type { AgentStepOptions } from '../../workflows/index.js';
import type { ExecutionEngine, ExecutionGraph } from '../../workflows/execution-engine.js';
import type { Step } from '../../workflows/step.js';
import type { SerializedStepFlowEntry, WorkflowConfig, WorkflowResult, StepWithComponent, WorkflowStreamEvent, WorkflowEngineType, StepParams, DefaultEngineType, StepMetadata } from '../../workflows/types.js';
export type EventedEngineType = {};
export declare function cloneWorkflow<TWorkflowId extends string = string, TState = unknown, TInput = unknown, TOutput = unknown, TSteps extends Step<string, any, any, any, any, any, EventedEngineType>[] = Step<string, any, any, any, any, any, EventedEngineType>[], TPrevSchema = TInput>(workflow: Workflow<EventedEngineType, TSteps, string, TState, TInput, TOutput, TPrevSchema>, opts: {
    id: TWorkflowId;
}): Workflow<EventedEngineType, TSteps, TWorkflowId, TState, TInput, TOutput, TPrevSchema>;
export declare function cloneStep<TStepId extends string>(step: Step<string, any, any, any, any, any, EventedEngineType>, opts: {
    id: TStepId;
}): Step<TStepId, any, any, any, any, any, EventedEngineType>;
/**
 * Creates a step from explicit params (FIRST overload for best error messages)
 * @param params Configuration parameters for the step
 * @param params.id Unique identifier for the step
 * @param params.description Optional description of what the step does
 * @param params.inputSchema Zod schema defining the input structure
 * @param params.outputSchema Zod schema defining the output structure
 * @param params.execute Function that performs the step's operations
 * @returns A Step object that can be added to the workflow
 */
export declare function createStep<TStepId extends string, TStateSchema extends z.ZodTypeAny | undefined, TInputSchema extends z.ZodTypeAny, TOutputSchema extends z.ZodTypeAny, TResumeSchema extends z.ZodTypeAny | undefined = undefined, TSuspendSchema extends z.ZodTypeAny | undefined = undefined>(params: StepParams<TStepId, TStateSchema, TInputSchema, TOutputSchema, TResumeSchema, TSuspendSchema>): Step<TStepId, TStateSchema extends z.ZodTypeAny ? z.infer<TStateSchema> : unknown, z.infer<TInputSchema>, z.infer<TOutputSchema>, TResumeSchema extends z.ZodTypeAny ? z.infer<TResumeSchema> : unknown, TSuspendSchema extends z.ZodTypeAny ? z.infer<TSuspendSchema> : unknown, DefaultEngineType>;
/**
 * Creates a step from an agent with structured output
 */
export declare function createStep<TStepId extends string, TStepOutput>(agent: Agent<TStepId, any>, agentOptions: AgentStepOptions<TStepOutput> & {
    structuredOutput: {
        schema: TStepOutput;
    };
    retries?: number;
    scorers?: DynamicArgument<MastraScorers>;
    metadata?: StepMetadata;
}): Step<TStepId, unknown, {
    prompt: string;
}, TStepOutput, unknown, unknown, DefaultEngineType>;
/**
 * Creates a step from an agent (defaults to { text: string } output)
 */
export declare function createStep<TStepId extends string, TStepInput extends {
    prompt: string;
}, TStepOutput extends {
    text: string;
}, TResume, TSuspend>(agent: Agent<TStepId, any>): Step<TStepId, any, TStepInput, TStepOutput, TResume, TSuspend, DefaultEngineType>;
/**
 * Creates a step from a tool
 */
export declare function createStep<TSchemaIn, TSuspend, TResume, TSchemaOut, TContext extends ToolExecutionContext<TSuspend, TResume, any>, TId extends string, TRequestContext extends Record<string, any> | unknown = unknown>(tool: Tool<TSchemaIn, TSchemaOut, TSuspend, TResume, TContext, TId, TRequestContext>, toolOptions?: {
    retries?: number;
    scorers?: DynamicArgument<MastraScorers>;
    metadata?: StepMetadata;
}): Step<TId, any, TSchemaIn, TSchemaOut, TSuspend, TResume, DefaultEngineType, TRequestContext>;
/**
 * Creates a step from a Processor - wraps a Processor as a workflow step
 * Note: We require at least one processor method to distinguish from StepParams
 */
export declare function createStep<TProcessorId extends string>(processor: (Processor<TProcessorId> & {
    processInput: Function;
}) | (Processor<TProcessorId> & {
    processInputStream: Function;
}) | (Processor<TProcessorId> & {
    processInputStep: Function;
}) | (Processor<TProcessorId> & {
    processOutputStream: Function;
}) | (Processor<TProcessorId> & {
    processOutputResult: Function;
}) | (Processor<TProcessorId> & {
    processOutputStep: Function;
})): Step<`processor:${TProcessorId}`, unknown, InferSchemaOutput<typeof ProcessorStepSchema>, InferSchemaOutput<typeof ProcessorStepOutputSchema>, unknown, unknown, DefaultEngineType>;
/**
 * IMPORTANT: Fallback overload - provides better error messages when StepParams doesn't match
 * This should be LAST and will show clearer errors about what's wrong
 * This is a copy of first one, KEEP THIS IN SYNC!
 */
export declare function createStep<TStepId extends string, TStateSchema extends z.ZodTypeAny | undefined, TInputSchema extends z.ZodTypeAny, TOutputSchema extends z.ZodTypeAny, TResumeSchema extends z.ZodTypeAny | undefined = undefined, TSuspendSchema extends z.ZodTypeAny | undefined = undefined>(params: StepParams<TStepId, TStateSchema, TInputSchema, TOutputSchema, TResumeSchema, TSuspendSchema>): Step<TStepId, TStateSchema extends z.ZodTypeAny ? z.infer<TStateSchema> : unknown, z.infer<TInputSchema>, z.infer<TOutputSchema>, TResumeSchema extends z.ZodTypeAny ? z.infer<TResumeSchema> : unknown, TSuspendSchema extends z.ZodTypeAny ? z.infer<TSuspendSchema> : unknown, DefaultEngineType>;
export declare function createWorkflow<TWorkflowId extends string = string, TState = unknown, TInput = unknown, TOutput = unknown, TSteps extends Step<string, any, any, any, any, any, EventedEngineType>[] = Step<string, any, any, any, any, any, EventedEngineType>[]>(params: WorkflowConfig<TWorkflowId, TState, TInput, TOutput, TSteps>): EventedWorkflow<EventedEngineType, TSteps, TWorkflowId, TState, TInput, TOutput, TInput>;
export declare class EventedWorkflow<TEngineType = EventedEngineType, TSteps extends Step<string, any, any>[] = Step<string, any, any>[], TWorkflowId extends string = string, TState = unknown, TInput = unknown, TOutput = unknown, TPrevSchema = TInput> extends Workflow<TEngineType, TSteps, TWorkflowId, TState, TInput, TOutput, TPrevSchema> {
    constructor(params: WorkflowConfig<TWorkflowId, TState, TInput, TOutput, TSteps>);
    __registerMastra(mastra: Mastra): void;
    createRun(options?: {
        runId?: string;
        resourceId?: string;
        disableScorers?: boolean;
    }): Promise<Run<TEngineType, TSteps, TState, TInput, TOutput>>;
}
export declare class EventedRun<TEngineType = EventedEngineType, TSteps extends Step<string, any, any>[] = Step<string, any, any>[], TState = unknown, TInput = unknown, TOutput = unknown> extends Run<TEngineType, TSteps, TState, TInput, TOutput> {
    constructor(params: {
        workflowId: string;
        runId: string;
        resourceId?: string;
        executionEngine: ExecutionEngine;
        executionGraph: ExecutionGraph;
        serializedStepGraph: SerializedStepFlowEntry[];
        mastra?: Mastra;
        retryConfig?: {
            attempts?: number;
            delay?: number;
        };
        cleanup?: () => void;
        workflowSteps: Record<string, StepWithComponent>;
        validateInputs?: boolean;
        inputSchema?: SchemaWithValidation<TInput>;
        stateSchema?: SchemaWithValidation<TState>;
        workflowEngineType: WorkflowEngineType;
    });
    /**
     * Set up abort signal handler to publish workflow.cancel event when abortController.abort() is called.
     * This ensures consistent cancellation behavior whether abort() is called directly or via cancel().
     */
    private setupAbortHandler;
    start({ inputData, initialState, requestContext, perStep, outputOptions, }: {
        inputData?: TInput;
        requestContext?: RequestContext;
        initialState?: TState;
        perStep?: boolean;
        outputOptions?: {
            includeState?: boolean;
            includeResumeLabels?: boolean;
        };
    }): Promise<WorkflowResult<TState, TInput, TOutput, TSteps>>;
    /**
     * Starts the workflow execution without waiting for completion (fire-and-forget).
     * Returns immediately with the runId. The workflow executes in the background via pubsub.
     * Use this when you don't need to wait for the result or want to avoid polling failures.
     */
    startAsync({ inputData, initialState, requestContext, perStep, }: {
        inputData?: TInput;
        requestContext?: RequestContext;
        initialState?: TState;
        perStep?: boolean;
    }): Promise<{
        runId: string;
    }>;
    /**
     * Starts the workflow execution as a stream, returning a WorkflowRunOutput
     * with .fullStream for iteration and .result for the final result.
     */
    stream({ inputData, requestContext, initialState, closeOnSuspend, perStep, outputOptions, }: (TInput extends unknown ? {
        inputData?: TInput;
    } : {
        inputData: TInput;
    }) & (TState extends unknown ? {
        initialState?: TState;
    } : {
        initialState: TState;
    }) & {
        requestContext?: RequestContext;
        closeOnSuspend?: boolean;
        perStep?: boolean;
        outputOptions?: {
            includeState?: boolean;
            includeResumeLabels?: boolean;
        };
    }): WorkflowRunOutput<WorkflowResult<TState, TInput, TOutput, TSteps>>;
    /**
     * Resumes a suspended workflow as a stream, returning a WorkflowRunOutput
     * with .fullStream for iteration and .result for the final result.
     */
    resumeStream<TResume>({ step, resumeData, requestContext, perStep, outputOptions, }?: {
        resumeData?: TResume;
        step?: Step<string, any, any, any, TResume, any, TEngineType> | [
            ...Step<string, any, any, any, any, any, TEngineType>[],
            Step<string, any, any, any, TResume, any, TEngineType>
        ] | string | string[];
        requestContext?: RequestContext;
        perStep?: boolean;
        outputOptions?: {
            includeState?: boolean;
            includeResumeLabels?: boolean;
        };
    }): WorkflowRunOutput<WorkflowResult<TState, TInput, TOutput, TSteps>>;
    resume<TResumeSchema>(params: {
        resumeData?: TResumeSchema;
        step?: Step<string, any, any, TResumeSchema, any, any, TEngineType, any> | [
            ...Step<string, any, any, any, any, any, TEngineType, any>[],
            Step<string, any, any, TResumeSchema, any, any, TEngineType, any>
        ] | string | string[];
        label?: string;
        forEachIndex?: number;
        requestContext?: RequestContext;
        perStep?: boolean;
        outputOptions?: {
            includeState?: boolean;
            includeResumeLabels?: boolean;
        };
    }): Promise<WorkflowResult<TState, TInput, TOutput, TSteps>>;
    watch(cb: (event: WorkflowStreamEvent) => void): () => void;
    watchAsync(cb: (event: WorkflowStreamEvent) => void): Promise<() => void>;
    cancel(): Promise<void>;
}
//# sourceMappingURL=workflow.d.ts.map