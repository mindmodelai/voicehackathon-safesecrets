import { MastraBase } from '../../base.js';
import type { RequestContext } from '../../di/index.js';
import type { Mastra } from '../../mastra/index.js';
import type { LoopConditionFunction, Step } from '../step.js';
import type { StepFlowEntry, StepResult } from '../types.js';
export declare class StepExecutor extends MastraBase {
    protected mastra?: Mastra;
    constructor({ mastra }: {
        mastra?: Mastra;
    });
    __registerMastra(mastra: Mastra): void;
    /**
     * Creates an output writer function that publishes chunks to the workflow event stream.
     * @param runId - The workflow run ID
     * @returns An async function that writes chunks to the pubsub
     */
    private createOutputWriter;
    execute(params: {
        workflowId: string;
        step: Step<any, any, any, any>;
        runId: string;
        input?: any;
        resumeData?: any;
        stepResults: Record<string, StepResult<any, any, any, any>>;
        state: Record<string, any>;
        requestContext: RequestContext;
        retryCount?: number;
        foreachIdx?: number;
        validateInputs?: boolean;
        abortController?: AbortController;
        perStep?: boolean;
    }): Promise<StepResult<any, any, any, any>>;
    evaluateConditions(params: {
        workflowId: string;
        step: Extract<StepFlowEntry, {
            type: 'conditional';
        }>;
        runId: string;
        input?: any;
        resumeData?: any;
        stepResults: Record<string, StepResult<any, any, any, any>>;
        state: Record<string, any>;
        requestContext: RequestContext;
        retryCount?: number;
        abortController?: AbortController;
    }): Promise<number[]>;
    evaluateCondition({ workflowId, condition, runId, inputData, resumeData, stepResults, state, requestContext, abortController, retryCount, iterationCount, }: {
        workflowId: string;
        condition: LoopConditionFunction<any, any, any, any, any, any>;
        runId: string;
        inputData?: any;
        resumeData?: any;
        stepResults: Record<string, StepResult<any, any, any, any>>;
        state: Record<string, any>;
        requestContext: RequestContext;
        abortController: AbortController;
        retryCount?: number;
        iterationCount: number;
    }): Promise<boolean>;
    resolveSleep(params: {
        workflowId: string;
        step: Extract<StepFlowEntry, {
            type: 'sleep';
        }>;
        runId: string;
        input?: any;
        resumeData?: any;
        stepResults: Record<string, StepResult<any, any, any, any>>;
        state?: Record<string, any>;
        requestContext: RequestContext;
        retryCount?: number;
        abortController?: AbortController;
    }): Promise<number>;
    resolveSleepUntil(params: {
        workflowId: string;
        step: Extract<StepFlowEntry, {
            type: 'sleepUntil';
        }>;
        runId: string;
        input?: any;
        resumeData?: any;
        stepResults: Record<string, StepResult<any, any, any, any>>;
        state?: Record<string, any>;
        requestContext: RequestContext;
        retryCount?: number;
        abortController?: AbortController;
    }): Promise<number>;
}
//# sourceMappingURL=step-executor.d.ts.map