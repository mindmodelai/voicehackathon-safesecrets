'use strict';

var chunkSH4PCZ3X_cjs = require('./chunk-SH4PCZ3X.cjs');
var v4 = require('zod/v4');

var VERSION = "1.0.36" ;
var cerebrasErrorSchema = v4.z.object({
  message: v4.z.string(),
  type: v4.z.string(),
  param: v4.z.string(),
  code: v4.z.string()
});
var cerebrasErrorStructure = {
  errorSchema: cerebrasErrorSchema,
  errorToMessage: (data) => data.message
};
function createCerebras(options = {}) {
  var _a15;
  const baseURL = chunkSH4PCZ3X_cjs.withoutTrailingSlash(
    (_a15 = options.baseURL) != null ? _a15 : "https://api.cerebras.ai/v1"
  );
  const getHeaders = () => chunkSH4PCZ3X_cjs.withUserAgentSuffix(
    {
      Authorization: `Bearer ${chunkSH4PCZ3X_cjs.loadApiKey({
        apiKey: options.apiKey,
        environmentVariableName: "CEREBRAS_API_KEY",
        description: "Cerebras API key"
      })}`,
      ...options.headers
    },
    `ai-sdk/cerebras/${VERSION}`
  );
  const createLanguageModel = (modelId) => {
    return new chunkSH4PCZ3X_cjs.OpenAICompatibleChatLanguageModel(modelId, {
      provider: `cerebras.chat`,
      url: ({ path }) => `${baseURL}${path}`,
      headers: getHeaders,
      fetch: options.fetch,
      errorStructure: cerebrasErrorStructure,
      supportsStructuredOutputs: true
    });
  };
  const provider = (modelId) => createLanguageModel(modelId);
  provider.languageModel = createLanguageModel;
  provider.chat = createLanguageModel;
  provider.textEmbeddingModel = (modelId) => {
    throw new chunkSH4PCZ3X_cjs.NoSuchModelError({ modelId, modelType: "textEmbeddingModel" });
  };
  provider.imageModel = (modelId) => {
    throw new chunkSH4PCZ3X_cjs.NoSuchModelError({ modelId, modelType: "imageModel" });
  };
  return provider;
}
createCerebras();
var DeepInfraImageModel = class {
  constructor(modelId, config) {
    this.modelId = modelId;
    this.config = config;
    this.specificationVersion = "v2";
    this.maxImagesPerCall = 1;
  }
  get provider() {
    return this.config.provider;
  }
  async doGenerate({
    prompt,
    n,
    size,
    aspectRatio,
    seed,
    providerOptions,
    headers,
    abortSignal
  }) {
    var _a15, _b, _c, _d;
    const warnings = [];
    const splitSize = size == null ? void 0 : size.split("x");
    const currentDate = (_c = (_b = (_a15 = this.config._internal) == null ? void 0 : _a15.currentDate) == null ? void 0 : _b.call(_a15)) != null ? _c : /* @__PURE__ */ new Date();
    const { value: response, responseHeaders } = await chunkSH4PCZ3X_cjs.postJsonToApi({
      url: `${this.config.baseURL}/${this.modelId}`,
      headers: chunkSH4PCZ3X_cjs.combineHeaders(this.config.headers(), headers),
      body: {
        prompt,
        num_images: n,
        ...aspectRatio && { aspect_ratio: aspectRatio },
        ...splitSize && { width: splitSize[0], height: splitSize[1] },
        ...seed != null && { seed },
        ...(_d = providerOptions.deepinfra) != null ? _d : {}
      },
      failedResponseHandler: chunkSH4PCZ3X_cjs.createJsonErrorResponseHandler({
        errorSchema: deepInfraErrorSchema,
        errorToMessage: (error) => error.detail.error
      }),
      successfulResponseHandler: chunkSH4PCZ3X_cjs.createJsonResponseHandler(
        deepInfraImageResponseSchema
      ),
      abortSignal,
      fetch: this.config.fetch
    });
    return {
      images: response.images.map(
        (image) => image.replace(/^data:image\/\w+;base64,/, "")
      ),
      warnings,
      response: {
        timestamp: currentDate,
        modelId: this.modelId,
        headers: responseHeaders
      }
    };
  }
};
var deepInfraErrorSchema = v4.z.object({
  detail: v4.z.object({
    error: v4.z.string()
  })
});
var deepInfraImageResponseSchema = v4.z.object({
  images: v4.z.array(v4.z.string())
});
var DeepInfraChatLanguageModel = class extends chunkSH4PCZ3X_cjs.OpenAICompatibleChatLanguageModel {
  constructor(modelId, config) {
    super(modelId, config);
  }
  fixUsage(usage) {
    var _a15, _b;
    const outputTokens = (_a15 = usage.outputTokens) != null ? _a15 : 0;
    const reasoningTokens = (_b = usage.reasoningTokens) != null ? _b : 0;
    if (reasoningTokens > outputTokens) {
      const correctedOutputTokens = outputTokens + reasoningTokens;
      return {
        ...usage,
        outputTokens: correctedOutputTokens,
        totalTokens: usage.totalTokens != null ? usage.totalTokens + reasoningTokens : void 0
      };
    }
    return usage;
  }
  async doGenerate(options) {
    const result = await super.doGenerate(options);
    return {
      ...result,
      usage: this.fixUsage(result.usage)
    };
  }
  async doStream(options) {
    const result = await super.doStream(options);
    const fixUsage = this.fixUsage.bind(this);
    const transformedStream = result.stream.pipeThrough(
      new TransformStream({
        transform(chunk, controller) {
          if (chunk.type === "finish") {
            controller.enqueue({
              ...chunk,
              usage: fixUsage(chunk.usage)
            });
          } else {
            controller.enqueue(chunk);
          }
        }
      })
    );
    return {
      ...result,
      stream: transformedStream
    };
  }
};
var VERSION2 = "1.0.35" ;
function createDeepInfra(options = {}) {
  var _a15;
  const baseURL = chunkSH4PCZ3X_cjs.withoutTrailingSlash(
    (_a15 = options.baseURL) != null ? _a15 : "https://api.deepinfra.com/v1"
  );
  const getHeaders = () => chunkSH4PCZ3X_cjs.withUserAgentSuffix(
    {
      Authorization: `Bearer ${chunkSH4PCZ3X_cjs.loadApiKey({
        apiKey: options.apiKey,
        environmentVariableName: "DEEPINFRA_API_KEY",
        description: "DeepInfra's API key"
      })}`,
      ...options.headers
    },
    `ai-sdk/deepinfra/${VERSION2}`
  );
  const getCommonModelConfig = (modelType) => ({
    provider: `deepinfra.${modelType}`,
    url: ({ path }) => `${baseURL}/openai${path}`,
    headers: getHeaders,
    fetch: options.fetch
  });
  const createChatModel = (modelId) => {
    return new DeepInfraChatLanguageModel(
      modelId,
      getCommonModelConfig("chat")
    );
  };
  const createCompletionModel = (modelId) => new chunkSH4PCZ3X_cjs.OpenAICompatibleCompletionLanguageModel(
    modelId,
    getCommonModelConfig("completion")
  );
  const createTextEmbeddingModel = (modelId) => new chunkSH4PCZ3X_cjs.OpenAICompatibleEmbeddingModel(
    modelId,
    getCommonModelConfig("embedding")
  );
  const createImageModel = (modelId) => new DeepInfraImageModel(modelId, {
    ...getCommonModelConfig("image"),
    baseURL: baseURL ? `${baseURL}/inference` : "https://api.deepinfra.com/v1/inference"
  });
  const provider = (modelId) => createChatModel(modelId);
  provider.completionModel = createCompletionModel;
  provider.chatModel = createChatModel;
  provider.image = createImageModel;
  provider.imageModel = createImageModel;
  provider.languageModel = createChatModel;
  provider.textEmbeddingModel = createTextEmbeddingModel;
  return provider;
}
createDeepInfra();
function convertToDeepSeekChatMessages({
  prompt,
  responseFormat
}) {
  const messages = [];
  const warnings = [];
  if ((responseFormat == null ? void 0 : responseFormat.type) === "json") {
    if (responseFormat.schema == null) {
      messages.push({
        role: "system",
        content: "Return JSON."
      });
    } else {
      messages.push({
        role: "system",
        content: "Return JSON that conforms to the following schema: " + JSON.stringify(responseFormat.schema)
      });
    }
  }
  let lastUserMessageIndex = -1;
  for (let i = prompt.length - 1; i >= 0; i--) {
    if (prompt[i].role === "user") {
      lastUserMessageIndex = i;
      break;
    }
  }
  let index = -1;
  for (const { role, content } of prompt) {
    index++;
    switch (role) {
      case "system": {
        messages.push({ role: "system", content });
        break;
      }
      case "user": {
        let userContent = "";
        for (const part of content) {
          if (part.type === "text") {
            userContent += part.text;
          } else {
            warnings.push({
              type: "other",
              message: `Unsupported user message part type: ${part.type}`
            });
          }
        }
        messages.push({
          role: "user",
          content: userContent
        });
        break;
      }
      case "assistant": {
        let text = "";
        let reasoning;
        const toolCalls = [];
        for (const part of content) {
          switch (part.type) {
            case "text": {
              text += part.text;
              break;
            }
            case "reasoning": {
              if (index <= lastUserMessageIndex) {
                break;
              }
              if (reasoning == null) {
                reasoning = part.text;
              } else {
                reasoning += part.text;
              }
              break;
            }
            case "tool-call": {
              toolCalls.push({
                id: part.toolCallId,
                type: "function",
                function: {
                  name: part.toolName,
                  arguments: JSON.stringify(part.input)
                }
              });
              break;
            }
          }
        }
        messages.push({
          role: "assistant",
          content: text,
          reasoning_content: reasoning,
          tool_calls: toolCalls.length > 0 ? toolCalls : void 0
        });
        break;
      }
      case "tool": {
        for (const toolResponse of content) {
          const output = toolResponse.output;
          let contentValue;
          switch (output.type) {
            case "text":
            case "error-text":
              contentValue = output.value;
              break;
            case "content":
            case "json":
            case "error-json":
              contentValue = JSON.stringify(output.value);
              break;
          }
          messages.push({
            role: "tool",
            tool_call_id: toolResponse.toolCallId,
            content: contentValue
          });
        }
        break;
      }
      default: {
        warnings.push({
          type: "other",
          message: `Unsupported message role: ${role}`
        });
        break;
      }
    }
  }
  return { messages, warnings };
}
var tokenUsageSchema = v4.z.object({
  prompt_tokens: v4.z.number().nullish(),
  completion_tokens: v4.z.number().nullish(),
  prompt_cache_hit_tokens: v4.z.number().nullish(),
  prompt_cache_miss_tokens: v4.z.number().nullish(),
  total_tokens: v4.z.number().nullish(),
  completion_tokens_details: v4.z.object({
    reasoning_tokens: v4.z.number().nullish()
  }).nullish()
}).nullish();
var deepSeekErrorSchema = v4.z.object({
  error: v4.z.object({
    message: v4.z.string(),
    type: v4.z.string().nullish(),
    param: v4.z.any().nullish(),
    code: v4.z.union([v4.z.string(), v4.z.number()]).nullish()
  })
});
var deepseekChatResponseSchema = v4.z.object({
  id: v4.z.string().nullish(),
  created: v4.z.number().nullish(),
  model: v4.z.string().nullish(),
  choices: v4.z.array(
    v4.z.object({
      message: v4.z.object({
        role: v4.z.literal("assistant").nullish(),
        content: v4.z.string().nullish(),
        reasoning_content: v4.z.string().nullish(),
        tool_calls: v4.z.array(
          v4.z.object({
            id: v4.z.string().nullish(),
            function: v4.z.object({
              name: v4.z.string(),
              arguments: v4.z.string()
            })
          })
        ).nullish()
      }),
      finish_reason: v4.z.string().nullish()
    })
  ),
  usage: tokenUsageSchema
});
var deepseekChatChunkSchema = chunkSH4PCZ3X_cjs.lazySchema(
  () => chunkSH4PCZ3X_cjs.zodSchema(
    v4.z.union([
      v4.z.object({
        id: v4.z.string().nullish(),
        created: v4.z.number().nullish(),
        model: v4.z.string().nullish(),
        choices: v4.z.array(
          v4.z.object({
            delta: v4.z.object({
              role: v4.z.enum(["assistant"]).nullish(),
              content: v4.z.string().nullish(),
              reasoning_content: v4.z.string().nullish(),
              tool_calls: v4.z.array(
                v4.z.object({
                  index: v4.z.number(),
                  id: v4.z.string().nullish(),
                  function: v4.z.object({
                    name: v4.z.string().nullish(),
                    arguments: v4.z.string().nullish()
                  })
                })
              ).nullish()
            }).nullish(),
            finish_reason: v4.z.string().nullish()
          })
        ),
        usage: tokenUsageSchema
      }),
      deepSeekErrorSchema
    ])
  )
);
var deepseekChatOptions = v4.z.object({
  /**
   * Type of thinking to use. Defaults to `enabled`.
   */
  thinking: v4.z.object({
    type: v4.z.enum(["enabled", "disabled"]).optional()
  }).optional()
});
function prepareTools({
  tools,
  toolChoice
}) {
  tools = (tools == null ? void 0 : tools.length) ? tools : void 0;
  const toolWarnings = [];
  if (tools == null) {
    return { tools: void 0, toolChoice: void 0, toolWarnings };
  }
  const deepseekTools = [];
  for (const tool of tools) {
    if (tool.type === "provider-defined") {
      toolWarnings.push({
        type: "unsupported-tool",
        tool
      });
    } else {
      deepseekTools.push({
        type: "function",
        function: {
          name: tool.name,
          description: tool.description,
          parameters: tool.inputSchema
        }
      });
    }
  }
  if (toolChoice == null) {
    return { tools: deepseekTools, toolChoice: void 0, toolWarnings };
  }
  const type = toolChoice.type;
  switch (type) {
    case "auto":
    case "none":
    case "required":
      return { tools: deepseekTools, toolChoice: type, toolWarnings };
    case "tool":
      return {
        tools: deepseekTools,
        toolChoice: {
          type: "function",
          function: { name: toolChoice.toolName }
        },
        toolWarnings
      };
    default: {
      const _exhaustiveCheck = type;
      throw new chunkSH4PCZ3X_cjs.UnsupportedFunctionalityError({
        functionality: `tool choice type: ${_exhaustiveCheck}`
      });
    }
  }
}
function getResponseMetadata({
  id,
  model,
  created
}) {
  return {
    id: id != null ? id : void 0,
    modelId: model != null ? model : void 0,
    timestamp: created != null ? new Date(created * 1e3) : void 0
  };
}
function mapDeepSeekFinishReason(finishReason) {
  switch (finishReason) {
    case "stop":
      return "stop";
    case "length":
      return "length";
    case "content_filter":
      return "content-filter";
    case "tool_calls":
      return "tool-calls";
    case "insufficient_system_resource":
      return "error";
    default:
      return "unknown";
  }
}
var DeepSeekChatLanguageModel = class {
  constructor(modelId, config) {
    this.specificationVersion = "v2";
    this.supportedUrls = {};
    this.modelId = modelId;
    this.config = config;
    this.failedResponseHandler = chunkSH4PCZ3X_cjs.createJsonErrorResponseHandler({
      errorSchema: deepSeekErrorSchema,
      errorToMessage: (error) => error.error.message
    });
  }
  get provider() {
    return this.config.provider;
  }
  get providerOptionsName() {
    return this.config.provider.split(".")[0].trim();
  }
  async getArgs({
    prompt,
    maxOutputTokens,
    temperature,
    topP,
    topK,
    frequencyPenalty,
    presencePenalty,
    providerOptions,
    stopSequences,
    responseFormat,
    tools,
    toolChoice,
    seed
  }) {
    var _a15, _b;
    const deepseekOptions = (_a15 = await chunkSH4PCZ3X_cjs.parseProviderOptions({
      provider: this.providerOptionsName,
      providerOptions,
      schema: deepseekChatOptions
    })) != null ? _a15 : {};
    const { messages, warnings } = convertToDeepSeekChatMessages({
      prompt,
      responseFormat
    });
    if (topK != null) {
      warnings.push({ type: "unsupported-setting", setting: "topK" });
    }
    if (seed != null) {
      warnings.push({ type: "unsupported-setting", setting: "seed" });
    }
    const {
      tools: deepseekTools,
      toolChoice: deepseekToolChoices,
      toolWarnings
    } = prepareTools({
      tools,
      toolChoice
    });
    return {
      args: {
        model: this.modelId,
        max_tokens: maxOutputTokens,
        temperature,
        top_p: topP,
        frequency_penalty: frequencyPenalty,
        presence_penalty: presencePenalty,
        response_format: (responseFormat == null ? void 0 : responseFormat.type) === "json" ? { type: "json_object" } : void 0,
        stop: stopSequences,
        messages,
        tools: deepseekTools,
        tool_choice: deepseekToolChoices,
        thinking: ((_b = deepseekOptions.thinking) == null ? void 0 : _b.type) != null ? { type: deepseekOptions.thinking.type } : void 0
      },
      warnings: [...warnings, ...toolWarnings]
    };
  }
  async doGenerate(options) {
    var _a15, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p;
    const { args, warnings } = await this.getArgs({ ...options });
    const {
      responseHeaders,
      value: responseBody,
      rawValue: rawResponse
    } = await chunkSH4PCZ3X_cjs.postJsonToApi({
      url: this.config.url({
        path: "/chat/completions",
        modelId: this.modelId
      }),
      headers: chunkSH4PCZ3X_cjs.combineHeaders(this.config.headers(), options.headers),
      body: args,
      failedResponseHandler: this.failedResponseHandler,
      successfulResponseHandler: chunkSH4PCZ3X_cjs.createJsonResponseHandler(
        deepseekChatResponseSchema
      ),
      abortSignal: options.abortSignal,
      fetch: this.config.fetch
    });
    const choice = responseBody.choices[0];
    const content = [];
    const reasoning = choice.message.reasoning_content;
    if (reasoning != null && reasoning.length > 0) {
      content.push({
        type: "reasoning",
        text: reasoning
      });
    }
    if (choice.message.tool_calls != null) {
      for (const toolCall of choice.message.tool_calls) {
        content.push({
          type: "tool-call",
          toolCallId: (_a15 = toolCall.id) != null ? _a15 : chunkSH4PCZ3X_cjs.generateId(),
          toolName: toolCall.function.name,
          input: toolCall.function.arguments
        });
      }
    }
    const text = choice.message.content;
    if (text != null && text.length > 0) {
      content.push({ type: "text", text });
    }
    return {
      content,
      finishReason: mapDeepSeekFinishReason(choice.finish_reason),
      usage: {
        inputTokens: (_c = (_b = responseBody.usage) == null ? void 0 : _b.prompt_tokens) != null ? _c : void 0,
        outputTokens: (_e = (_d = responseBody.usage) == null ? void 0 : _d.completion_tokens) != null ? _e : void 0,
        totalTokens: (_g = (_f = responseBody.usage) == null ? void 0 : _f.total_tokens) != null ? _g : void 0,
        reasoningTokens: (_j = (_i = (_h = responseBody.usage) == null ? void 0 : _h.completion_tokens_details) == null ? void 0 : _i.reasoning_tokens) != null ? _j : void 0,
        cachedInputTokens: (_l = (_k = responseBody.usage) == null ? void 0 : _k.prompt_cache_hit_tokens) != null ? _l : void 0
      },
      providerMetadata: {
        [this.providerOptionsName]: {
          promptCacheHitTokens: (_n = (_m = responseBody.usage) == null ? void 0 : _m.prompt_cache_hit_tokens) != null ? _n : null,
          promptCacheMissTokens: (_p = (_o = responseBody.usage) == null ? void 0 : _o.prompt_cache_miss_tokens) != null ? _p : null
        }
      },
      request: { body: args },
      response: {
        ...getResponseMetadata(responseBody),
        headers: responseHeaders,
        body: rawResponse
      },
      warnings
    };
  }
  async doStream(options) {
    const { args, warnings } = await this.getArgs({ ...options });
    const body = {
      ...args,
      stream: true,
      stream_options: { include_usage: true }
    };
    const { responseHeaders, value: response } = await chunkSH4PCZ3X_cjs.postJsonToApi({
      url: this.config.url({
        path: "/chat/completions",
        modelId: this.modelId
      }),
      headers: chunkSH4PCZ3X_cjs.combineHeaders(this.config.headers(), options.headers),
      body,
      failedResponseHandler: this.failedResponseHandler,
      successfulResponseHandler: chunkSH4PCZ3X_cjs.createEventSourceResponseHandler(
        deepseekChatChunkSchema
      ),
      abortSignal: options.abortSignal,
      fetch: this.config.fetch
    });
    const toolCalls = [];
    let finishReason = "unknown";
    let usage = void 0;
    let isFirstChunk = true;
    const providerOptionsName = this.providerOptionsName;
    let isActiveReasoning = false;
    let isActiveText = false;
    return {
      stream: response.pipeThrough(
        new TransformStream({
          start(controller) {
            controller.enqueue({ type: "stream-start", warnings });
          },
          transform(chunk, controller) {
            var _a15, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l;
            if (options.includeRawChunks) {
              controller.enqueue({ type: "raw", rawValue: chunk.rawValue });
            }
            if (!chunk.success) {
              finishReason = "error";
              controller.enqueue({ type: "error", error: chunk.error });
              return;
            }
            const value = chunk.value;
            if ("error" in value) {
              finishReason = "error";
              controller.enqueue({ type: "error", error: value.error.message });
              return;
            }
            if (isFirstChunk) {
              isFirstChunk = false;
              controller.enqueue({
                type: "response-metadata",
                ...getResponseMetadata(value)
              });
            }
            if (value.usage != null) {
              usage = value.usage;
            }
            const choice = value.choices[0];
            if ((choice == null ? void 0 : choice.finish_reason) != null) {
              finishReason = mapDeepSeekFinishReason(choice.finish_reason);
            }
            if ((choice == null ? void 0 : choice.delta) == null) {
              return;
            }
            const delta = choice.delta;
            const reasoningContent = delta.reasoning_content;
            if (reasoningContent) {
              if (!isActiveReasoning) {
                controller.enqueue({
                  type: "reasoning-start",
                  id: "reasoning-0"
                });
                isActiveReasoning = true;
              }
              controller.enqueue({
                type: "reasoning-delta",
                id: "reasoning-0",
                delta: reasoningContent
              });
            }
            if (delta.content) {
              if (!isActiveText) {
                controller.enqueue({ type: "text-start", id: "txt-0" });
                isActiveText = true;
              }
              if (isActiveReasoning) {
                controller.enqueue({
                  type: "reasoning-end",
                  id: "reasoning-0"
                });
                isActiveReasoning = false;
              }
              controller.enqueue({
                type: "text-delta",
                id: "txt-0",
                delta: delta.content
              });
            }
            if (delta.tool_calls != null) {
              if (isActiveReasoning) {
                controller.enqueue({
                  type: "reasoning-end",
                  id: "reasoning-0"
                });
                isActiveReasoning = false;
              }
              for (const toolCallDelta of delta.tool_calls) {
                const index = toolCallDelta.index;
                if (toolCalls[index] == null) {
                  if (toolCallDelta.id == null) {
                    throw new chunkSH4PCZ3X_cjs.InvalidResponseDataError({
                      data: toolCallDelta,
                      message: `Expected 'id' to be a string.`
                    });
                  }
                  if (((_a15 = toolCallDelta.function) == null ? void 0 : _a15.name) == null) {
                    throw new chunkSH4PCZ3X_cjs.InvalidResponseDataError({
                      data: toolCallDelta,
                      message: `Expected 'function.name' to be a string.`
                    });
                  }
                  controller.enqueue({
                    type: "tool-input-start",
                    id: toolCallDelta.id,
                    toolName: toolCallDelta.function.name
                  });
                  toolCalls[index] = {
                    id: toolCallDelta.id,
                    type: "function",
                    function: {
                      name: toolCallDelta.function.name,
                      arguments: (_b = toolCallDelta.function.arguments) != null ? _b : ""
                    },
                    hasFinished: false
                  };
                  const toolCall2 = toolCalls[index];
                  if (((_c = toolCall2.function) == null ? void 0 : _c.name) != null && ((_d = toolCall2.function) == null ? void 0 : _d.arguments) != null) {
                    if (toolCall2.function.arguments.length > 0) {
                      controller.enqueue({
                        type: "tool-input-delta",
                        id: toolCall2.id,
                        delta: toolCall2.function.arguments
                      });
                    }
                    if (chunkSH4PCZ3X_cjs.isParsableJson(toolCall2.function.arguments)) {
                      controller.enqueue({
                        type: "tool-input-end",
                        id: toolCall2.id
                      });
                      controller.enqueue({
                        type: "tool-call",
                        toolCallId: (_e = toolCall2.id) != null ? _e : chunkSH4PCZ3X_cjs.generateId(),
                        toolName: toolCall2.function.name,
                        input: toolCall2.function.arguments
                      });
                      toolCall2.hasFinished = true;
                    }
                  }
                  continue;
                }
                const toolCall = toolCalls[index];
                if (toolCall.hasFinished) {
                  continue;
                }
                if (((_f = toolCallDelta.function) == null ? void 0 : _f.arguments) != null) {
                  toolCall.function.arguments += (_h = (_g = toolCallDelta.function) == null ? void 0 : _g.arguments) != null ? _h : "";
                }
                controller.enqueue({
                  type: "tool-input-delta",
                  id: toolCall.id,
                  delta: (_i = toolCallDelta.function.arguments) != null ? _i : ""
                });
                if (((_j = toolCall.function) == null ? void 0 : _j.name) != null && ((_k = toolCall.function) == null ? void 0 : _k.arguments) != null && chunkSH4PCZ3X_cjs.isParsableJson(toolCall.function.arguments)) {
                  controller.enqueue({
                    type: "tool-input-end",
                    id: toolCall.id
                  });
                  controller.enqueue({
                    type: "tool-call",
                    toolCallId: (_l = toolCall.id) != null ? _l : chunkSH4PCZ3X_cjs.generateId(),
                    toolName: toolCall.function.name,
                    input: toolCall.function.arguments
                  });
                  toolCall.hasFinished = true;
                }
              }
            }
          },
          flush(controller) {
            var _a15, _b, _c, _d, _e, _f, _g, _h, _i;
            if (isActiveReasoning) {
              controller.enqueue({ type: "reasoning-end", id: "reasoning-0" });
            }
            if (isActiveText) {
              controller.enqueue({ type: "text-end", id: "txt-0" });
            }
            for (const toolCall of toolCalls.filter(
              (toolCall2) => !toolCall2.hasFinished
            )) {
              controller.enqueue({
                type: "tool-input-end",
                id: toolCall.id
              });
              controller.enqueue({
                type: "tool-call",
                toolCallId: (_a15 = toolCall.id) != null ? _a15 : chunkSH4PCZ3X_cjs.generateId(),
                toolName: toolCall.function.name,
                input: toolCall.function.arguments
              });
            }
            controller.enqueue({
              type: "finish",
              finishReason,
              usage: {
                inputTokens: (_b = usage == null ? void 0 : usage.prompt_tokens) != null ? _b : void 0,
                outputTokens: (_c = usage == null ? void 0 : usage.completion_tokens) != null ? _c : void 0,
                totalTokens: (_d = usage == null ? void 0 : usage.total_tokens) != null ? _d : void 0,
                reasoningTokens: (_f = (_e = usage == null ? void 0 : usage.completion_tokens_details) == null ? void 0 : _e.reasoning_tokens) != null ? _f : void 0,
                cachedInputTokens: (_g = usage == null ? void 0 : usage.prompt_cache_hit_tokens) != null ? _g : void 0
              },
              providerMetadata: {
                [providerOptionsName]: {
                  promptCacheHitTokens: (_h = usage == null ? void 0 : usage.prompt_cache_hit_tokens) != null ? _h : null,
                  promptCacheMissTokens: (_i = usage == null ? void 0 : usage.prompt_cache_miss_tokens) != null ? _i : null
                }
              }
            });
          }
        })
      ),
      request: { body },
      response: { headers: responseHeaders }
    };
  }
};
var VERSION3 = "1.0.33" ;
function createDeepSeek(options = {}) {
  var _a15;
  const baseURL = chunkSH4PCZ3X_cjs.withoutTrailingSlash(
    (_a15 = options.baseURL) != null ? _a15 : "https://api.deepseek.com"
  );
  const getHeaders = () => chunkSH4PCZ3X_cjs.withUserAgentSuffix(
    {
      Authorization: `Bearer ${chunkSH4PCZ3X_cjs.loadApiKey({
        apiKey: options.apiKey,
        environmentVariableName: "DEEPSEEK_API_KEY",
        description: "DeepSeek API key"
      })}`,
      ...options.headers
    },
    `ai-sdk/deepseek/${VERSION3}`
  );
  const createLanguageModel = (modelId) => {
    return new DeepSeekChatLanguageModel(modelId, {
      provider: `deepseek.chat`,
      url: ({ path }) => `${baseURL}${path}`,
      headers: getHeaders,
      fetch: options.fetch
    });
  };
  const provider = (modelId) => createLanguageModel(modelId);
  provider.languageModel = createLanguageModel;
  provider.chat = createLanguageModel;
  provider.textEmbeddingModel = (modelId) => {
    throw new chunkSH4PCZ3X_cjs.NoSuchModelError({ modelId, modelType: "textEmbeddingModel" });
  };
  provider.imageModel = (modelId) => {
    throw new chunkSH4PCZ3X_cjs.NoSuchModelError({ modelId, modelType: "imageModel" });
  };
  return provider;
}
createDeepSeek();
function convertToGroqChatMessages(prompt) {
  const messages = [];
  for (const { role, content } of prompt) {
    switch (role) {
      case "system": {
        messages.push({ role: "system", content });
        break;
      }
      case "user": {
        if (content.length === 1 && content[0].type === "text") {
          messages.push({ role: "user", content: content[0].text });
          break;
        }
        messages.push({
          role: "user",
          content: content.map((part) => {
            switch (part.type) {
              case "text": {
                return { type: "text", text: part.text };
              }
              case "file": {
                if (!part.mediaType.startsWith("image/")) {
                  throw new chunkSH4PCZ3X_cjs.UnsupportedFunctionalityError({
                    functionality: "Non-image file content parts"
                  });
                }
                const mediaType = part.mediaType === "image/*" ? "image/jpeg" : part.mediaType;
                return {
                  type: "image_url",
                  image_url: {
                    url: part.data instanceof URL ? part.data.toString() : `data:${mediaType};base64,${chunkSH4PCZ3X_cjs.convertToBase64(part.data)}`
                  }
                };
              }
            }
          })
        });
        break;
      }
      case "assistant": {
        let text = "";
        let reasoning = "";
        const toolCalls = [];
        for (const part of content) {
          switch (part.type) {
            // groq supports reasoning for tool-calls in multi-turn conversations
            // https://github.com/vercel/ai/issues/7860
            case "reasoning": {
              reasoning += part.text;
              break;
            }
            case "text": {
              text += part.text;
              break;
            }
            case "tool-call": {
              toolCalls.push({
                id: part.toolCallId,
                type: "function",
                function: {
                  name: part.toolName,
                  arguments: JSON.stringify(part.input)
                }
              });
              break;
            }
          }
        }
        messages.push({
          role: "assistant",
          content: text,
          ...reasoning.length > 0 ? { reasoning } : null,
          ...toolCalls.length > 0 ? { tool_calls: toolCalls } : null
        });
        break;
      }
      case "tool": {
        for (const toolResponse of content) {
          const output = toolResponse.output;
          let contentValue;
          switch (output.type) {
            case "text":
            case "error-text":
              contentValue = output.value;
              break;
            case "content":
            case "json":
            case "error-json":
              contentValue = JSON.stringify(output.value);
              break;
          }
          messages.push({
            role: "tool",
            tool_call_id: toolResponse.toolCallId,
            content: contentValue
          });
        }
        break;
      }
      default: {
        const _exhaustiveCheck = role;
        throw new Error(`Unsupported role: ${_exhaustiveCheck}`);
      }
    }
  }
  return messages;
}
function getResponseMetadata2({
  id,
  model,
  created
}) {
  return {
    id: id != null ? id : void 0,
    modelId: model != null ? model : void 0,
    timestamp: created != null ? new Date(created * 1e3) : void 0
  };
}
var groqProviderOptions = v4.z.object({
  reasoningFormat: v4.z.enum(["parsed", "raw", "hidden"]).optional(),
  /**
   * Specifies the reasoning effort level for model inference.
   * @see https://console.groq.com/docs/reasoning#reasoning-effort
   */
  reasoningEffort: v4.z.enum(["none", "default", "low", "medium", "high"]).optional(),
  /**
   * Whether to enable parallel function calling during tool use. Default to true.
   */
  parallelToolCalls: v4.z.boolean().optional(),
  /**
   * A unique identifier representing your end-user, which can help OpenAI to
   * monitor and detect abuse. Learn more.
   */
  user: v4.z.string().optional(),
  /**
   * Whether to use structured outputs.
   *
   * @default true
   */
  structuredOutputs: v4.z.boolean().optional(),
  /**
   * Service tier for the request.
   * - 'on_demand': Default tier with consistent performance and fairness
   * - 'flex': Higher throughput tier optimized for workloads that can handle occasional request failures
   * - 'auto': Uses on_demand rate limits, then falls back to flex tier if exceeded
   *
   * @default 'on_demand'
   */
  serviceTier: v4.z.enum(["on_demand", "flex", "auto"]).optional()
});
var groqErrorDataSchema = v4.z.object({
  error: v4.z.object({
    message: v4.z.string(),
    type: v4.z.string()
  })
});
var groqFailedResponseHandler = chunkSH4PCZ3X_cjs.createJsonErrorResponseHandler({
  errorSchema: groqErrorDataSchema,
  errorToMessage: (data) => data.error.message
});
var BROWSER_SEARCH_SUPPORTED_MODELS = [
  "openai/gpt-oss-20b",
  "openai/gpt-oss-120b"
];
function isBrowserSearchSupportedModel(modelId) {
  return BROWSER_SEARCH_SUPPORTED_MODELS.includes(modelId);
}
function getSupportedModelsString() {
  return BROWSER_SEARCH_SUPPORTED_MODELS.join(", ");
}
function prepareTools2({
  tools,
  toolChoice,
  modelId
}) {
  tools = (tools == null ? void 0 : tools.length) ? tools : void 0;
  const toolWarnings = [];
  if (tools == null) {
    return { tools: void 0, toolChoice: void 0, toolWarnings };
  }
  const groqTools2 = [];
  for (const tool of tools) {
    if (tool.type === "provider-defined") {
      if (tool.id === "groq.browser_search") {
        if (!isBrowserSearchSupportedModel(modelId)) {
          toolWarnings.push({
            type: "unsupported-tool",
            tool,
            details: `Browser search is only supported on the following models: ${getSupportedModelsString()}. Current model: ${modelId}`
          });
        } else {
          groqTools2.push({
            type: "browser_search"
          });
        }
      } else {
        toolWarnings.push({ type: "unsupported-tool", tool });
      }
    } else {
      groqTools2.push({
        type: "function",
        function: {
          name: tool.name,
          description: tool.description,
          parameters: tool.inputSchema
        }
      });
    }
  }
  if (toolChoice == null) {
    return { tools: groqTools2, toolChoice: void 0, toolWarnings };
  }
  const type = toolChoice.type;
  switch (type) {
    case "auto":
    case "none":
    case "required":
      return { tools: groqTools2, toolChoice: type, toolWarnings };
    case "tool":
      return {
        tools: groqTools2,
        toolChoice: {
          type: "function",
          function: {
            name: toolChoice.toolName
          }
        },
        toolWarnings
      };
    default: {
      const _exhaustiveCheck = type;
      throw new chunkSH4PCZ3X_cjs.UnsupportedFunctionalityError({
        functionality: `tool choice type: ${_exhaustiveCheck}`
      });
    }
  }
}
function mapGroqFinishReason(finishReason) {
  switch (finishReason) {
    case "stop":
      return "stop";
    case "length":
      return "length";
    case "content_filter":
      return "content-filter";
    case "function_call":
    case "tool_calls":
      return "tool-calls";
    default:
      return "unknown";
  }
}
var GroqChatLanguageModel = class {
  constructor(modelId, config) {
    this.specificationVersion = "v2";
    this.supportedUrls = {
      "image/*": [/^https?:\/\/.*$/]
    };
    this.modelId = modelId;
    this.config = config;
  }
  get provider() {
    return this.config.provider;
  }
  async getArgs({
    prompt,
    maxOutputTokens,
    temperature,
    topP,
    topK,
    frequencyPenalty,
    presencePenalty,
    stopSequences,
    responseFormat,
    seed,
    stream,
    tools,
    toolChoice,
    providerOptions
  }) {
    var _a15, _b;
    const warnings = [];
    const groqOptions = await chunkSH4PCZ3X_cjs.parseProviderOptions({
      provider: "groq",
      providerOptions,
      schema: groqProviderOptions
    });
    const structuredOutputs = (_a15 = groqOptions == null ? void 0 : groqOptions.structuredOutputs) != null ? _a15 : true;
    if (topK != null) {
      warnings.push({
        type: "unsupported-setting",
        setting: "topK"
      });
    }
    if ((responseFormat == null ? void 0 : responseFormat.type) === "json" && responseFormat.schema != null && !structuredOutputs) {
      warnings.push({
        type: "unsupported-setting",
        setting: "responseFormat",
        details: "JSON response format schema is only supported with structuredOutputs"
      });
    }
    const {
      tools: groqTools2,
      toolChoice: groqToolChoice,
      toolWarnings
    } = prepareTools2({ tools, toolChoice, modelId: this.modelId });
    return {
      args: {
        // model id:
        model: this.modelId,
        // model specific settings:
        user: groqOptions == null ? void 0 : groqOptions.user,
        parallel_tool_calls: groqOptions == null ? void 0 : groqOptions.parallelToolCalls,
        // standardized settings:
        max_tokens: maxOutputTokens,
        temperature,
        top_p: topP,
        frequency_penalty: frequencyPenalty,
        presence_penalty: presencePenalty,
        stop: stopSequences,
        seed,
        // response format:
        response_format: (responseFormat == null ? void 0 : responseFormat.type) === "json" ? structuredOutputs && responseFormat.schema != null ? {
          type: "json_schema",
          json_schema: {
            schema: responseFormat.schema,
            name: (_b = responseFormat.name) != null ? _b : "response",
            description: responseFormat.description
          }
        } : { type: "json_object" } : void 0,
        // provider options:
        reasoning_format: groqOptions == null ? void 0 : groqOptions.reasoningFormat,
        reasoning_effort: groqOptions == null ? void 0 : groqOptions.reasoningEffort,
        service_tier: groqOptions == null ? void 0 : groqOptions.serviceTier,
        // messages:
        messages: convertToGroqChatMessages(prompt),
        // tools:
        tools: groqTools2,
        tool_choice: groqToolChoice
      },
      warnings: [...warnings, ...toolWarnings]
    };
  }
  async doGenerate(options) {
    var _a15, _b, _c, _d, _e, _f, _g, _h, _i, _j;
    const { args, warnings } = await this.getArgs({
      ...options,
      stream: false
    });
    const body = JSON.stringify(args);
    const {
      responseHeaders,
      value: response,
      rawValue: rawResponse
    } = await chunkSH4PCZ3X_cjs.postJsonToApi({
      url: this.config.url({
        path: "/chat/completions",
        modelId: this.modelId
      }),
      headers: chunkSH4PCZ3X_cjs.combineHeaders(this.config.headers(), options.headers),
      body: args,
      failedResponseHandler: groqFailedResponseHandler,
      successfulResponseHandler: chunkSH4PCZ3X_cjs.createJsonResponseHandler(
        groqChatResponseSchema
      ),
      abortSignal: options.abortSignal,
      fetch: this.config.fetch
    });
    const choice = response.choices[0];
    const content = [];
    const text = choice.message.content;
    if (text != null && text.length > 0) {
      content.push({ type: "text", text });
    }
    const reasoning = choice.message.reasoning;
    if (reasoning != null && reasoning.length > 0) {
      content.push({
        type: "reasoning",
        text: reasoning
      });
    }
    if (choice.message.tool_calls != null) {
      for (const toolCall of choice.message.tool_calls) {
        content.push({
          type: "tool-call",
          toolCallId: (_a15 = toolCall.id) != null ? _a15 : chunkSH4PCZ3X_cjs.generateId(),
          toolName: toolCall.function.name,
          input: toolCall.function.arguments
        });
      }
    }
    return {
      content,
      finishReason: mapGroqFinishReason(choice.finish_reason),
      usage: {
        inputTokens: (_c = (_b = response.usage) == null ? void 0 : _b.prompt_tokens) != null ? _c : void 0,
        outputTokens: (_e = (_d = response.usage) == null ? void 0 : _d.completion_tokens) != null ? _e : void 0,
        totalTokens: (_g = (_f = response.usage) == null ? void 0 : _f.total_tokens) != null ? _g : void 0,
        cachedInputTokens: (_j = (_i = (_h = response.usage) == null ? void 0 : _h.prompt_tokens_details) == null ? void 0 : _i.cached_tokens) != null ? _j : void 0
      },
      response: {
        ...getResponseMetadata2(response),
        headers: responseHeaders,
        body: rawResponse
      },
      warnings,
      request: { body }
    };
  }
  async doStream(options) {
    const { args, warnings } = await this.getArgs({ ...options, stream: true });
    const body = JSON.stringify({ ...args, stream: true });
    const { responseHeaders, value: response } = await chunkSH4PCZ3X_cjs.postJsonToApi({
      url: this.config.url({
        path: "/chat/completions",
        modelId: this.modelId
      }),
      headers: chunkSH4PCZ3X_cjs.combineHeaders(this.config.headers(), options.headers),
      body: {
        ...args,
        stream: true
      },
      failedResponseHandler: groqFailedResponseHandler,
      successfulResponseHandler: chunkSH4PCZ3X_cjs.createEventSourceResponseHandler(groqChatChunkSchema),
      abortSignal: options.abortSignal,
      fetch: this.config.fetch
    });
    const toolCalls = [];
    let finishReason = "unknown";
    const usage = {
      inputTokens: void 0,
      outputTokens: void 0,
      totalTokens: void 0,
      cachedInputTokens: void 0
    };
    let isFirstChunk = true;
    let isActiveText = false;
    let isActiveReasoning = false;
    return {
      stream: response.pipeThrough(
        new TransformStream({
          start(controller) {
            controller.enqueue({ type: "stream-start", warnings });
          },
          transform(chunk, controller) {
            var _a15, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r;
            if (options.includeRawChunks) {
              controller.enqueue({ type: "raw", rawValue: chunk.rawValue });
            }
            if (!chunk.success) {
              finishReason = "error";
              controller.enqueue({ type: "error", error: chunk.error });
              return;
            }
            const value = chunk.value;
            if ("error" in value) {
              finishReason = "error";
              controller.enqueue({ type: "error", error: value.error });
              return;
            }
            if (isFirstChunk) {
              isFirstChunk = false;
              controller.enqueue({
                type: "response-metadata",
                ...getResponseMetadata2(value)
              });
            }
            if (((_a15 = value.x_groq) == null ? void 0 : _a15.usage) != null) {
              usage.inputTokens = (_b = value.x_groq.usage.prompt_tokens) != null ? _b : void 0;
              usage.outputTokens = (_c = value.x_groq.usage.completion_tokens) != null ? _c : void 0;
              usage.totalTokens = (_d = value.x_groq.usage.total_tokens) != null ? _d : void 0;
              usage.cachedInputTokens = (_f = (_e = value.x_groq.usage.prompt_tokens_details) == null ? void 0 : _e.cached_tokens) != null ? _f : void 0;
            }
            const choice = value.choices[0];
            if ((choice == null ? void 0 : choice.finish_reason) != null) {
              finishReason = mapGroqFinishReason(choice.finish_reason);
            }
            if ((choice == null ? void 0 : choice.delta) == null) {
              return;
            }
            const delta = choice.delta;
            if (delta.reasoning != null && delta.reasoning.length > 0) {
              if (!isActiveReasoning) {
                controller.enqueue({
                  type: "reasoning-start",
                  id: "reasoning-0"
                });
                isActiveReasoning = true;
              }
              controller.enqueue({
                type: "reasoning-delta",
                id: "reasoning-0",
                delta: delta.reasoning
              });
            }
            if (delta.content != null && delta.content.length > 0) {
              if (!isActiveText) {
                controller.enqueue({ type: "text-start", id: "txt-0" });
                isActiveText = true;
              }
              controller.enqueue({
                type: "text-delta",
                id: "txt-0",
                delta: delta.content
              });
            }
            if (delta.tool_calls != null) {
              for (const toolCallDelta of delta.tool_calls) {
                const index = toolCallDelta.index;
                if (toolCalls[index] == null) {
                  if (toolCallDelta.type !== "function") {
                    throw new chunkSH4PCZ3X_cjs.InvalidResponseDataError({
                      data: toolCallDelta,
                      message: `Expected 'function' type.`
                    });
                  }
                  if (toolCallDelta.id == null) {
                    throw new chunkSH4PCZ3X_cjs.InvalidResponseDataError({
                      data: toolCallDelta,
                      message: `Expected 'id' to be a string.`
                    });
                  }
                  if (((_g = toolCallDelta.function) == null ? void 0 : _g.name) == null) {
                    throw new chunkSH4PCZ3X_cjs.InvalidResponseDataError({
                      data: toolCallDelta,
                      message: `Expected 'function.name' to be a string.`
                    });
                  }
                  controller.enqueue({
                    type: "tool-input-start",
                    id: toolCallDelta.id,
                    toolName: toolCallDelta.function.name
                  });
                  toolCalls[index] = {
                    id: toolCallDelta.id,
                    type: "function",
                    function: {
                      name: toolCallDelta.function.name,
                      arguments: (_h = toolCallDelta.function.arguments) != null ? _h : ""
                    },
                    hasFinished: false
                  };
                  const toolCall2 = toolCalls[index];
                  if (((_i = toolCall2.function) == null ? void 0 : _i.name) != null && ((_j = toolCall2.function) == null ? void 0 : _j.arguments) != null) {
                    if (toolCall2.function.arguments.length > 0) {
                      controller.enqueue({
                        type: "tool-input-delta",
                        id: toolCall2.id,
                        delta: toolCall2.function.arguments
                      });
                    }
                    if (chunkSH4PCZ3X_cjs.isParsableJson(toolCall2.function.arguments)) {
                      controller.enqueue({
                        type: "tool-input-end",
                        id: toolCall2.id
                      });
                      controller.enqueue({
                        type: "tool-call",
                        toolCallId: (_k = toolCall2.id) != null ? _k : chunkSH4PCZ3X_cjs.generateId(),
                        toolName: toolCall2.function.name,
                        input: toolCall2.function.arguments
                      });
                      toolCall2.hasFinished = true;
                    }
                  }
                  continue;
                }
                const toolCall = toolCalls[index];
                if (toolCall.hasFinished) {
                  continue;
                }
                if (((_l = toolCallDelta.function) == null ? void 0 : _l.arguments) != null) {
                  toolCall.function.arguments += (_n = (_m = toolCallDelta.function) == null ? void 0 : _m.arguments) != null ? _n : "";
                }
                controller.enqueue({
                  type: "tool-input-delta",
                  id: toolCall.id,
                  delta: (_o = toolCallDelta.function.arguments) != null ? _o : ""
                });
                if (((_p = toolCall.function) == null ? void 0 : _p.name) != null && ((_q = toolCall.function) == null ? void 0 : _q.arguments) != null && chunkSH4PCZ3X_cjs.isParsableJson(toolCall.function.arguments)) {
                  controller.enqueue({
                    type: "tool-input-end",
                    id: toolCall.id
                  });
                  controller.enqueue({
                    type: "tool-call",
                    toolCallId: (_r = toolCall.id) != null ? _r : chunkSH4PCZ3X_cjs.generateId(),
                    toolName: toolCall.function.name,
                    input: toolCall.function.arguments
                  });
                  toolCall.hasFinished = true;
                }
              }
            }
          },
          flush(controller) {
            if (isActiveReasoning) {
              controller.enqueue({ type: "reasoning-end", id: "reasoning-0" });
            }
            if (isActiveText) {
              controller.enqueue({ type: "text-end", id: "txt-0" });
            }
            controller.enqueue({
              type: "finish",
              finishReason,
              usage,
              ...{}
            });
          }
        })
      ),
      request: { body },
      response: { headers: responseHeaders }
    };
  }
};
var groqChatResponseSchema = v4.z.object({
  id: v4.z.string().nullish(),
  created: v4.z.number().nullish(),
  model: v4.z.string().nullish(),
  choices: v4.z.array(
    v4.z.object({
      message: v4.z.object({
        content: v4.z.string().nullish(),
        reasoning: v4.z.string().nullish(),
        tool_calls: v4.z.array(
          v4.z.object({
            id: v4.z.string().nullish(),
            type: v4.z.literal("function"),
            function: v4.z.object({
              name: v4.z.string(),
              arguments: v4.z.string()
            })
          })
        ).nullish()
      }),
      index: v4.z.number(),
      finish_reason: v4.z.string().nullish()
    })
  ),
  usage: v4.z.object({
    prompt_tokens: v4.z.number().nullish(),
    completion_tokens: v4.z.number().nullish(),
    total_tokens: v4.z.number().nullish(),
    prompt_tokens_details: v4.z.object({
      cached_tokens: v4.z.number().nullish()
    }).nullish()
  }).nullish()
});
var groqChatChunkSchema = v4.z.union([
  v4.z.object({
    id: v4.z.string().nullish(),
    created: v4.z.number().nullish(),
    model: v4.z.string().nullish(),
    choices: v4.z.array(
      v4.z.object({
        delta: v4.z.object({
          content: v4.z.string().nullish(),
          reasoning: v4.z.string().nullish(),
          tool_calls: v4.z.array(
            v4.z.object({
              index: v4.z.number(),
              id: v4.z.string().nullish(),
              type: v4.z.literal("function").optional(),
              function: v4.z.object({
                name: v4.z.string().nullish(),
                arguments: v4.z.string().nullish()
              })
            })
          ).nullish()
        }).nullish(),
        finish_reason: v4.z.string().nullable().optional(),
        index: v4.z.number()
      })
    ),
    x_groq: v4.z.object({
      usage: v4.z.object({
        prompt_tokens: v4.z.number().nullish(),
        completion_tokens: v4.z.number().nullish(),
        total_tokens: v4.z.number().nullish(),
        prompt_tokens_details: v4.z.object({
          cached_tokens: v4.z.number().nullish()
        }).nullish()
      }).nullish()
    }).nullish()
  }),
  groqErrorDataSchema
]);
var groqProviderOptionsSchema = v4.z.object({
  language: v4.z.string().nullish(),
  prompt: v4.z.string().nullish(),
  responseFormat: v4.z.string().nullish(),
  temperature: v4.z.number().min(0).max(1).nullish(),
  timestampGranularities: v4.z.array(v4.z.string()).nullish()
});
var GroqTranscriptionModel = class {
  constructor(modelId, config) {
    this.modelId = modelId;
    this.config = config;
    this.specificationVersion = "v2";
  }
  get provider() {
    return this.config.provider;
  }
  async getArgs({
    audio,
    mediaType,
    providerOptions
  }) {
    var _a15, _b, _c, _d, _e;
    const warnings = [];
    const groqOptions = await chunkSH4PCZ3X_cjs.parseProviderOptions({
      provider: "groq",
      providerOptions,
      schema: groqProviderOptionsSchema
    });
    const formData = new FormData();
    const blob = audio instanceof Uint8Array ? new Blob([audio]) : new Blob([chunkSH4PCZ3X_cjs.convertBase64ToUint8Array(audio)]);
    formData.append("model", this.modelId);
    const fileExtension = chunkSH4PCZ3X_cjs.mediaTypeToExtension(mediaType);
    formData.append(
      "file",
      new File([blob], "audio", { type: mediaType }),
      `audio.${fileExtension}`
    );
    if (groqOptions) {
      const transcriptionModelOptions = {
        language: (_a15 = groqOptions.language) != null ? _a15 : void 0,
        prompt: (_b = groqOptions.prompt) != null ? _b : void 0,
        response_format: (_c = groqOptions.responseFormat) != null ? _c : void 0,
        temperature: (_d = groqOptions.temperature) != null ? _d : void 0,
        timestamp_granularities: (_e = groqOptions.timestampGranularities) != null ? _e : void 0
      };
      for (const key in transcriptionModelOptions) {
        const value = transcriptionModelOptions[key];
        if (value !== void 0) {
          formData.append(key, String(value));
        }
      }
    }
    return {
      formData,
      warnings
    };
  }
  async doGenerate(options) {
    var _a15, _b, _c, _d, _e, _f, _g;
    const currentDate = (_c = (_b = (_a15 = this.config._internal) == null ? void 0 : _a15.currentDate) == null ? void 0 : _b.call(_a15)) != null ? _c : /* @__PURE__ */ new Date();
    const { formData, warnings } = await this.getArgs(options);
    const {
      value: response,
      responseHeaders,
      rawValue: rawResponse
    } = await chunkSH4PCZ3X_cjs.postFormDataToApi({
      url: this.config.url({
        path: "/audio/transcriptions",
        modelId: this.modelId
      }),
      headers: chunkSH4PCZ3X_cjs.combineHeaders(this.config.headers(), options.headers),
      formData,
      failedResponseHandler: groqFailedResponseHandler,
      successfulResponseHandler: chunkSH4PCZ3X_cjs.createJsonResponseHandler(
        groqTranscriptionResponseSchema
      ),
      abortSignal: options.abortSignal,
      fetch: this.config.fetch
    });
    return {
      text: response.text,
      segments: (_e = (_d = response.segments) == null ? void 0 : _d.map((segment) => ({
        text: segment.text,
        startSecond: segment.start,
        endSecond: segment.end
      }))) != null ? _e : [],
      language: (_f = response.language) != null ? _f : void 0,
      durationInSeconds: (_g = response.duration) != null ? _g : void 0,
      warnings,
      response: {
        timestamp: currentDate,
        modelId: this.modelId,
        headers: responseHeaders,
        body: rawResponse
      }
    };
  }
};
var groqTranscriptionResponseSchema = v4.z.object({
  text: v4.z.string(),
  x_groq: v4.z.object({
    id: v4.z.string()
  }),
  // additional properties are returned when `response_format: 'verbose_json'` is
  task: v4.z.string().nullish(),
  language: v4.z.string().nullish(),
  duration: v4.z.number().nullish(),
  segments: v4.z.array(
    v4.z.object({
      id: v4.z.number(),
      seek: v4.z.number(),
      start: v4.z.number(),
      end: v4.z.number(),
      text: v4.z.string(),
      tokens: v4.z.array(v4.z.number()),
      temperature: v4.z.number(),
      avg_logprob: v4.z.number(),
      compression_ratio: v4.z.number(),
      no_speech_prob: v4.z.number()
    })
  ).nullish()
});
var browserSearch = chunkSH4PCZ3X_cjs.createProviderDefinedToolFactory({
  id: "groq.browser_search",
  name: "browser_search",
  inputSchema: v4.z.object({})
});
var groqTools = {
  browserSearch
};
var VERSION4 = "2.0.34" ;
function createGroq(options = {}) {
  var _a15;
  const baseURL = (_a15 = chunkSH4PCZ3X_cjs.withoutTrailingSlash(options.baseURL)) != null ? _a15 : "https://api.groq.com/openai/v1";
  const getHeaders = () => chunkSH4PCZ3X_cjs.withUserAgentSuffix(
    {
      Authorization: `Bearer ${chunkSH4PCZ3X_cjs.loadApiKey({
        apiKey: options.apiKey,
        environmentVariableName: "GROQ_API_KEY",
        description: "Groq"
      })}`,
      ...options.headers
    },
    `ai-sdk/groq/${VERSION4}`
  );
  const createChatModel = (modelId) => new GroqChatLanguageModel(modelId, {
    provider: "groq.chat",
    url: ({ path }) => `${baseURL}${path}`,
    headers: getHeaders,
    fetch: options.fetch
  });
  const createLanguageModel = (modelId) => {
    if (new.target) {
      throw new Error(
        "The Groq model function cannot be called with the new keyword."
      );
    }
    return createChatModel(modelId);
  };
  const createTranscriptionModel = (modelId) => {
    return new GroqTranscriptionModel(modelId, {
      provider: "groq.transcription",
      url: ({ path }) => `${baseURL}${path}`,
      headers: getHeaders,
      fetch: options.fetch
    });
  };
  const provider = function(modelId) {
    return createLanguageModel(modelId);
  };
  provider.languageModel = createLanguageModel;
  provider.chat = createChatModel;
  provider.textEmbeddingModel = (modelId) => {
    throw new chunkSH4PCZ3X_cjs.NoSuchModelError({ modelId, modelType: "textEmbeddingModel" });
  };
  provider.imageModel = (modelId) => {
    throw new chunkSH4PCZ3X_cjs.NoSuchModelError({ modelId, modelType: "imageModel" });
  };
  provider.transcription = createTranscriptionModel;
  provider.transcriptionModel = createTranscriptionModel;
  provider.tools = groqTools;
  return provider;
}
createGroq();
function convertToMistralChatMessages(prompt) {
  const messages = [];
  for (let i = 0; i < prompt.length; i++) {
    const { role, content } = prompt[i];
    const isLastMessage = i === prompt.length - 1;
    switch (role) {
      case "system": {
        messages.push({ role: "system", content });
        break;
      }
      case "user": {
        messages.push({
          role: "user",
          content: content.map((part) => {
            switch (part.type) {
              case "text": {
                return { type: "text", text: part.text };
              }
              case "file": {
                if (part.mediaType.startsWith("image/")) {
                  const mediaType = part.mediaType === "image/*" ? "image/jpeg" : part.mediaType;
                  return {
                    type: "image_url",
                    image_url: part.data instanceof URL ? part.data.toString() : `data:${mediaType};base64,${chunkSH4PCZ3X_cjs.convertToBase64(part.data)}`
                  };
                } else if (part.mediaType === "application/pdf") {
                  return {
                    type: "document_url",
                    document_url: part.data.toString()
                  };
                } else {
                  throw new chunkSH4PCZ3X_cjs.UnsupportedFunctionalityError({
                    functionality: "Only images and PDF file parts are supported"
                  });
                }
              }
            }
          })
        });
        break;
      }
      case "assistant": {
        let text = "";
        const toolCalls = [];
        for (const part of content) {
          switch (part.type) {
            case "text": {
              text += part.text;
              break;
            }
            case "tool-call": {
              toolCalls.push({
                id: part.toolCallId,
                type: "function",
                function: {
                  name: part.toolName,
                  arguments: JSON.stringify(part.input)
                }
              });
              break;
            }
            case "reasoning": {
              text += part.text;
              break;
            }
            default: {
              throw new Error(
                `Unsupported content type in assistant message: ${part.type}`
              );
            }
          }
        }
        messages.push({
          role: "assistant",
          content: text,
          prefix: isLastMessage ? true : void 0,
          tool_calls: toolCalls.length > 0 ? toolCalls : void 0
        });
        break;
      }
      case "tool": {
        for (const toolResponse of content) {
          const output = toolResponse.output;
          let contentValue;
          switch (output.type) {
            case "text":
            case "error-text":
              contentValue = output.value;
              break;
            case "content":
            case "json":
            case "error-json":
              contentValue = JSON.stringify(output.value);
              break;
          }
          messages.push({
            role: "tool",
            name: toolResponse.toolName,
            tool_call_id: toolResponse.toolCallId,
            content: contentValue
          });
        }
        break;
      }
      default: {
        const _exhaustiveCheck = role;
        throw new Error(`Unsupported role: ${_exhaustiveCheck}`);
      }
    }
  }
  return messages;
}
function getResponseMetadata3({
  id,
  model,
  created
}) {
  return {
    id: id != null ? id : void 0,
    modelId: model != null ? model : void 0,
    timestamp: created != null ? new Date(created * 1e3) : void 0
  };
}
function mapMistralFinishReason(finishReason) {
  switch (finishReason) {
    case "stop":
      return "stop";
    case "length":
    case "model_length":
      return "length";
    case "tool_calls":
      return "tool-calls";
    default:
      return "unknown";
  }
}
var mistralLanguageModelOptions = v4.z.object({
  /**
  Whether to inject a safety prompt before all conversations.
  
  Defaults to `false`.
     */
  safePrompt: v4.z.boolean().optional(),
  documentImageLimit: v4.z.number().optional(),
  documentPageLimit: v4.z.number().optional(),
  /**
   * Whether to use structured outputs.
   *
   * @default true
   */
  structuredOutputs: v4.z.boolean().optional(),
  /**
   * Whether to use strict JSON schema validation.
   *
   * @default false
   */
  strictJsonSchema: v4.z.boolean().optional(),
  /**
   * Whether to enable parallel function calling during tool use.
   * When set to false, the model will use at most one tool per response.
   *
   * @default true
   */
  parallelToolCalls: v4.z.boolean().optional()
});
var mistralErrorDataSchema = v4.z.object({
  object: v4.z.literal("error"),
  message: v4.z.string(),
  type: v4.z.string(),
  param: v4.z.string().nullable(),
  code: v4.z.string().nullable()
});
var mistralFailedResponseHandler = chunkSH4PCZ3X_cjs.createJsonErrorResponseHandler({
  errorSchema: mistralErrorDataSchema,
  errorToMessage: (data) => data.message
});
function prepareTools3({
  tools,
  toolChoice
}) {
  tools = (tools == null ? void 0 : tools.length) ? tools : void 0;
  const toolWarnings = [];
  if (tools == null) {
    return { tools: void 0, toolChoice: void 0, toolWarnings };
  }
  const mistralTools = [];
  for (const tool of tools) {
    if (tool.type === "provider-defined") {
      toolWarnings.push({ type: "unsupported-tool", tool });
    } else {
      mistralTools.push({
        type: "function",
        function: {
          name: tool.name,
          description: tool.description,
          parameters: tool.inputSchema
        }
      });
    }
  }
  if (toolChoice == null) {
    return { tools: mistralTools, toolChoice: void 0, toolWarnings };
  }
  const type = toolChoice.type;
  switch (type) {
    case "auto":
    case "none":
      return { tools: mistralTools, toolChoice: type, toolWarnings };
    case "required":
      return { tools: mistralTools, toolChoice: "any", toolWarnings };
    // mistral does not support tool mode directly,
    // so we filter the tools and force the tool choice through 'any'
    case "tool":
      return {
        tools: mistralTools.filter(
          (tool) => tool.function.name === toolChoice.toolName
        ),
        toolChoice: "any",
        toolWarnings
      };
    default: {
      const _exhaustiveCheck = type;
      throw new chunkSH4PCZ3X_cjs.UnsupportedFunctionalityError({
        functionality: `tool choice type: ${_exhaustiveCheck}`
      });
    }
  }
}
var MistralChatLanguageModel = class {
  constructor(modelId, config) {
    this.specificationVersion = "v2";
    this.supportedUrls = {
      "application/pdf": [/^https:\/\/.*$/]
    };
    var _a15;
    this.modelId = modelId;
    this.config = config;
    this.generateId = (_a15 = config.generateId) != null ? _a15 : chunkSH4PCZ3X_cjs.generateId;
  }
  get provider() {
    return this.config.provider;
  }
  async getArgs({
    prompt,
    maxOutputTokens,
    temperature,
    topP,
    topK,
    frequencyPenalty,
    presencePenalty,
    stopSequences,
    responseFormat,
    seed,
    providerOptions,
    tools,
    toolChoice
  }) {
    var _a15, _b, _c, _d;
    const warnings = [];
    const options = (_a15 = await chunkSH4PCZ3X_cjs.parseProviderOptions({
      provider: "mistral",
      providerOptions,
      schema: mistralLanguageModelOptions
    })) != null ? _a15 : {};
    if (topK != null) {
      warnings.push({
        type: "unsupported-setting",
        setting: "topK"
      });
    }
    if (frequencyPenalty != null) {
      warnings.push({
        type: "unsupported-setting",
        setting: "frequencyPenalty"
      });
    }
    if (presencePenalty != null) {
      warnings.push({
        type: "unsupported-setting",
        setting: "presencePenalty"
      });
    }
    if (stopSequences != null) {
      warnings.push({
        type: "unsupported-setting",
        setting: "stopSequences"
      });
    }
    const structuredOutputs = (_b = options.structuredOutputs) != null ? _b : true;
    const strictJsonSchema = (_c = options.strictJsonSchema) != null ? _c : false;
    if ((responseFormat == null ? void 0 : responseFormat.type) === "json" && !(responseFormat == null ? void 0 : responseFormat.schema)) {
      prompt = chunkSH4PCZ3X_cjs.injectJsonInstructionIntoMessages({
        messages: prompt,
        schema: responseFormat.schema
      });
    }
    const baseArgs = {
      // model id:
      model: this.modelId,
      // model specific settings:
      safe_prompt: options.safePrompt,
      // standardized settings:
      max_tokens: maxOutputTokens,
      temperature,
      top_p: topP,
      random_seed: seed,
      // response format:
      response_format: (responseFormat == null ? void 0 : responseFormat.type) === "json" ? structuredOutputs && (responseFormat == null ? void 0 : responseFormat.schema) != null ? {
        type: "json_schema",
        json_schema: {
          schema: responseFormat.schema,
          strict: strictJsonSchema,
          name: (_d = responseFormat.name) != null ? _d : "response",
          description: responseFormat.description
        }
      } : { type: "json_object" } : void 0,
      // mistral-specific provider options:
      document_image_limit: options.documentImageLimit,
      document_page_limit: options.documentPageLimit,
      // messages:
      messages: convertToMistralChatMessages(prompt)
    };
    const {
      tools: mistralTools,
      toolChoice: mistralToolChoice,
      toolWarnings
    } = prepareTools3({
      tools,
      toolChoice
    });
    return {
      args: {
        ...baseArgs,
        tools: mistralTools,
        tool_choice: mistralToolChoice,
        ...mistralTools != null && options.parallelToolCalls !== void 0 ? { parallel_tool_calls: options.parallelToolCalls } : {}
      },
      warnings: [...warnings, ...toolWarnings]
    };
  }
  async doGenerate(options) {
    const { args: body, warnings } = await this.getArgs(options);
    const {
      responseHeaders,
      value: response,
      rawValue: rawResponse
    } = await chunkSH4PCZ3X_cjs.postJsonToApi({
      url: `${this.config.baseURL}/chat/completions`,
      headers: chunkSH4PCZ3X_cjs.combineHeaders(this.config.headers(), options.headers),
      body,
      failedResponseHandler: mistralFailedResponseHandler,
      successfulResponseHandler: chunkSH4PCZ3X_cjs.createJsonResponseHandler(
        mistralChatResponseSchema
      ),
      abortSignal: options.abortSignal,
      fetch: this.config.fetch
    });
    const choice = response.choices[0];
    const content = [];
    if (choice.message.content != null && Array.isArray(choice.message.content)) {
      for (const part of choice.message.content) {
        if (part.type === "thinking") {
          const reasoningText = extractReasoningContent(part.thinking);
          if (reasoningText.length > 0) {
            content.push({ type: "reasoning", text: reasoningText });
          }
        } else if (part.type === "text") {
          if (part.text.length > 0) {
            content.push({ type: "text", text: part.text });
          }
        }
      }
    } else {
      const text = extractTextContent(choice.message.content);
      if (text != null && text.length > 0) {
        content.push({ type: "text", text });
      }
    }
    if (choice.message.tool_calls != null) {
      for (const toolCall of choice.message.tool_calls) {
        content.push({
          type: "tool-call",
          toolCallId: toolCall.id,
          toolName: toolCall.function.name,
          input: toolCall.function.arguments
        });
      }
    }
    return {
      content,
      finishReason: mapMistralFinishReason(choice.finish_reason),
      usage: {
        inputTokens: response.usage.prompt_tokens,
        outputTokens: response.usage.completion_tokens,
        totalTokens: response.usage.total_tokens
      },
      request: { body },
      response: {
        ...getResponseMetadata3(response),
        headers: responseHeaders,
        body: rawResponse
      },
      warnings
    };
  }
  async doStream(options) {
    const { args, warnings } = await this.getArgs(options);
    const body = { ...args, stream: true };
    const { responseHeaders, value: response } = await chunkSH4PCZ3X_cjs.postJsonToApi({
      url: `${this.config.baseURL}/chat/completions`,
      headers: chunkSH4PCZ3X_cjs.combineHeaders(this.config.headers(), options.headers),
      body,
      failedResponseHandler: mistralFailedResponseHandler,
      successfulResponseHandler: chunkSH4PCZ3X_cjs.createEventSourceResponseHandler(
        mistralChatChunkSchema
      ),
      abortSignal: options.abortSignal,
      fetch: this.config.fetch
    });
    let finishReason = "unknown";
    const usage = {
      inputTokens: void 0,
      outputTokens: void 0,
      totalTokens: void 0
    };
    let isFirstChunk = true;
    let activeText = false;
    let activeReasoningId = null;
    const generateId22 = this.generateId;
    return {
      stream: response.pipeThrough(
        new TransformStream({
          start(controller) {
            controller.enqueue({ type: "stream-start", warnings });
          },
          transform(chunk, controller) {
            if (options.includeRawChunks) {
              controller.enqueue({ type: "raw", rawValue: chunk.rawValue });
            }
            if (!chunk.success) {
              controller.enqueue({ type: "error", error: chunk.error });
              return;
            }
            const value = chunk.value;
            if (isFirstChunk) {
              isFirstChunk = false;
              controller.enqueue({
                type: "response-metadata",
                ...getResponseMetadata3(value)
              });
            }
            if (value.usage != null) {
              usage.inputTokens = value.usage.prompt_tokens;
              usage.outputTokens = value.usage.completion_tokens;
              usage.totalTokens = value.usage.total_tokens;
            }
            const choice = value.choices[0];
            const delta = choice.delta;
            const textContent = extractTextContent(delta.content);
            if (delta.content != null && Array.isArray(delta.content)) {
              for (const part of delta.content) {
                if (part.type === "thinking") {
                  const reasoningDelta = extractReasoningContent(part.thinking);
                  if (reasoningDelta.length > 0) {
                    if (activeReasoningId == null) {
                      if (activeText) {
                        controller.enqueue({ type: "text-end", id: "0" });
                        activeText = false;
                      }
                      activeReasoningId = generateId22();
                      controller.enqueue({
                        type: "reasoning-start",
                        id: activeReasoningId
                      });
                    }
                    controller.enqueue({
                      type: "reasoning-delta",
                      id: activeReasoningId,
                      delta: reasoningDelta
                    });
                  }
                }
              }
            }
            if (textContent != null && textContent.length > 0) {
              if (!activeText) {
                if (activeReasoningId != null) {
                  controller.enqueue({
                    type: "reasoning-end",
                    id: activeReasoningId
                  });
                  activeReasoningId = null;
                }
                controller.enqueue({ type: "text-start", id: "0" });
                activeText = true;
              }
              controller.enqueue({
                type: "text-delta",
                id: "0",
                delta: textContent
              });
            }
            if ((delta == null ? void 0 : delta.tool_calls) != null) {
              for (const toolCall of delta.tool_calls) {
                const toolCallId = toolCall.id;
                const toolName = toolCall.function.name;
                const input = toolCall.function.arguments;
                controller.enqueue({
                  type: "tool-input-start",
                  id: toolCallId,
                  toolName
                });
                controller.enqueue({
                  type: "tool-input-delta",
                  id: toolCallId,
                  delta: input
                });
                controller.enqueue({
                  type: "tool-input-end",
                  id: toolCallId
                });
                controller.enqueue({
                  type: "tool-call",
                  toolCallId,
                  toolName,
                  input
                });
              }
            }
            if (choice.finish_reason != null) {
              finishReason = mapMistralFinishReason(choice.finish_reason);
            }
          },
          flush(controller) {
            if (activeReasoningId != null) {
              controller.enqueue({
                type: "reasoning-end",
                id: activeReasoningId
              });
            }
            if (activeText) {
              controller.enqueue({ type: "text-end", id: "0" });
            }
            controller.enqueue({
              type: "finish",
              finishReason,
              usage
            });
          }
        })
      ),
      request: { body },
      response: { headers: responseHeaders }
    };
  }
};
function extractReasoningContent(thinking) {
  return thinking.filter((chunk) => chunk.type === "text").map((chunk) => chunk.text).join("");
}
function extractTextContent(content) {
  if (typeof content === "string") {
    return content;
  }
  if (content == null) {
    return void 0;
  }
  const textContent = [];
  for (const chunk of content) {
    const { type } = chunk;
    switch (type) {
      case "text":
        textContent.push(chunk.text);
        break;
      case "thinking":
      case "image_url":
      case "reference":
        break;
      default: {
        const _exhaustiveCheck = type;
        throw new Error(`Unsupported type: ${_exhaustiveCheck}`);
      }
    }
  }
  return textContent.length ? textContent.join("") : void 0;
}
var mistralContentSchema = v4.z.union([
  v4.z.string(),
  v4.z.array(
    v4.z.discriminatedUnion("type", [
      v4.z.object({
        type: v4.z.literal("text"),
        text: v4.z.string()
      }),
      v4.z.object({
        type: v4.z.literal("image_url"),
        image_url: v4.z.union([
          v4.z.string(),
          v4.z.object({
            url: v4.z.string(),
            detail: v4.z.string().nullable()
          })
        ])
      }),
      v4.z.object({
        type: v4.z.literal("reference"),
        reference_ids: v4.z.array(v4.z.number())
      }),
      v4.z.object({
        type: v4.z.literal("thinking"),
        thinking: v4.z.array(
          v4.z.object({
            type: v4.z.literal("text"),
            text: v4.z.string()
          })
        )
      })
    ])
  )
]).nullish();
var mistralUsageSchema = v4.z.object({
  prompt_tokens: v4.z.number(),
  completion_tokens: v4.z.number(),
  total_tokens: v4.z.number()
});
var mistralChatResponseSchema = v4.z.object({
  id: v4.z.string().nullish(),
  created: v4.z.number().nullish(),
  model: v4.z.string().nullish(),
  choices: v4.z.array(
    v4.z.object({
      message: v4.z.object({
        role: v4.z.literal("assistant"),
        content: mistralContentSchema,
        tool_calls: v4.z.array(
          v4.z.object({
            id: v4.z.string(),
            function: v4.z.object({ name: v4.z.string(), arguments: v4.z.string() })
          })
        ).nullish()
      }),
      index: v4.z.number(),
      finish_reason: v4.z.string().nullish()
    })
  ),
  object: v4.z.literal("chat.completion"),
  usage: mistralUsageSchema
});
var mistralChatChunkSchema = v4.z.object({
  id: v4.z.string().nullish(),
  created: v4.z.number().nullish(),
  model: v4.z.string().nullish(),
  choices: v4.z.array(
    v4.z.object({
      delta: v4.z.object({
        role: v4.z.enum(["assistant"]).optional(),
        content: mistralContentSchema,
        tool_calls: v4.z.array(
          v4.z.object({
            id: v4.z.string(),
            function: v4.z.object({ name: v4.z.string(), arguments: v4.z.string() })
          })
        ).nullish()
      }),
      finish_reason: v4.z.string().nullish(),
      index: v4.z.number()
    })
  ),
  usage: mistralUsageSchema.nullish()
});
var MistralEmbeddingModel = class {
  constructor(modelId, config) {
    this.specificationVersion = "v2";
    this.maxEmbeddingsPerCall = 32;
    this.supportsParallelCalls = false;
    this.modelId = modelId;
    this.config = config;
  }
  get provider() {
    return this.config.provider;
  }
  async doEmbed({
    values,
    abortSignal,
    headers
  }) {
    if (values.length > this.maxEmbeddingsPerCall) {
      throw new chunkSH4PCZ3X_cjs.TooManyEmbeddingValuesForCallError({
        provider: this.provider,
        modelId: this.modelId,
        maxEmbeddingsPerCall: this.maxEmbeddingsPerCall,
        values
      });
    }
    const {
      responseHeaders,
      value: response,
      rawValue
    } = await chunkSH4PCZ3X_cjs.postJsonToApi({
      url: `${this.config.baseURL}/embeddings`,
      headers: chunkSH4PCZ3X_cjs.combineHeaders(this.config.headers(), headers),
      body: {
        model: this.modelId,
        input: values,
        encoding_format: "float"
      },
      failedResponseHandler: mistralFailedResponseHandler,
      successfulResponseHandler: chunkSH4PCZ3X_cjs.createJsonResponseHandler(
        MistralTextEmbeddingResponseSchema
      ),
      abortSignal,
      fetch: this.config.fetch
    });
    return {
      embeddings: response.data.map((item) => item.embedding),
      usage: response.usage ? { tokens: response.usage.prompt_tokens } : void 0,
      response: { headers: responseHeaders, body: rawValue }
    };
  }
};
var MistralTextEmbeddingResponseSchema = v4.z.object({
  data: v4.z.array(v4.z.object({ embedding: v4.z.array(v4.z.number()) })),
  usage: v4.z.object({ prompt_tokens: v4.z.number() }).nullish()
});
var VERSION5 = "2.0.27" ;
function createMistral(options = {}) {
  var _a15;
  const baseURL = (_a15 = chunkSH4PCZ3X_cjs.withoutTrailingSlash(options.baseURL)) != null ? _a15 : "https://api.mistral.ai/v1";
  const getHeaders = () => chunkSH4PCZ3X_cjs.withUserAgentSuffix(
    {
      Authorization: `Bearer ${chunkSH4PCZ3X_cjs.loadApiKey({
        apiKey: options.apiKey,
        environmentVariableName: "MISTRAL_API_KEY",
        description: "Mistral"
      })}`,
      ...options.headers
    },
    `ai-sdk/mistral/${VERSION5}`
  );
  const createChatModel = (modelId) => new MistralChatLanguageModel(modelId, {
    provider: "mistral.chat",
    baseURL,
    headers: getHeaders,
    fetch: options.fetch,
    generateId: options.generateId
  });
  const createEmbeddingModel = (modelId) => new MistralEmbeddingModel(modelId, {
    provider: "mistral.embedding",
    baseURL,
    headers: getHeaders,
    fetch: options.fetch
  });
  const provider = function(modelId) {
    if (new.target) {
      throw new Error(
        "The Mistral model function cannot be called with the new keyword."
      );
    }
    return createChatModel(modelId);
  };
  provider.languageModel = createChatModel;
  provider.chat = createChatModel;
  provider.embedding = createEmbeddingModel;
  provider.textEmbedding = createEmbeddingModel;
  provider.textEmbeddingModel = createEmbeddingModel;
  provider.imageModel = (modelId) => {
    throw new chunkSH4PCZ3X_cjs.NoSuchModelError({ modelId, modelType: "imageModel" });
  };
  return provider;
}
createMistral();
function convertToPerplexityMessages(prompt) {
  const messages = [];
  for (const { role, content } of prompt) {
    switch (role) {
      case "system": {
        messages.push({ role: "system", content });
        break;
      }
      case "user":
      case "assistant": {
        const hasMultipartContent = content.some(
          (part) => part.type === "file" && part.mediaType.startsWith("image/") || part.type === "file" && part.mediaType === "application/pdf"
        );
        const messageContent = content.map((part, index) => {
          var _a15;
          switch (part.type) {
            case "text": {
              return {
                type: "text",
                text: part.text
              };
            }
            case "file": {
              if (part.mediaType === "application/pdf") {
                return part.data instanceof URL ? {
                  type: "file_url",
                  file_url: {
                    url: part.data.toString()
                  },
                  file_name: part.filename
                } : {
                  type: "file_url",
                  file_url: {
                    url: typeof part.data === "string" ? part.data : chunkSH4PCZ3X_cjs.convertUint8ArrayToBase64(part.data)
                  },
                  file_name: part.filename || `document-${index}.pdf`
                };
              } else if (part.mediaType.startsWith("image/")) {
                return part.data instanceof URL ? {
                  type: "image_url",
                  image_url: {
                    url: part.data.toString()
                  }
                } : {
                  type: "image_url",
                  image_url: {
                    url: `data:${(_a15 = part.mediaType) != null ? _a15 : "image/jpeg"};base64,${typeof part.data === "string" ? part.data : chunkSH4PCZ3X_cjs.convertUint8ArrayToBase64(part.data)}`
                  }
                };
              }
            }
          }
        }).filter(Boolean);
        messages.push({
          role,
          content: hasMultipartContent ? messageContent : messageContent.filter((part) => part.type === "text").map((part) => part.text).join("")
        });
        break;
      }
      case "tool": {
        throw new chunkSH4PCZ3X_cjs.UnsupportedFunctionalityError({
          functionality: "Tool messages"
        });
      }
      default: {
        const _exhaustiveCheck = role;
        throw new Error(`Unsupported role: ${_exhaustiveCheck}`);
      }
    }
  }
  return messages;
}
function mapPerplexityFinishReason(finishReason) {
  switch (finishReason) {
    case "stop":
    case "length":
      return finishReason;
    default:
      return "unknown";
  }
}
var PerplexityLanguageModel = class {
  constructor(modelId, config) {
    this.specificationVersion = "v2";
    this.provider = "perplexity";
    this.supportedUrls = {
      // No URLs are supported.
    };
    this.modelId = modelId;
    this.config = config;
  }
  getArgs({
    prompt,
    maxOutputTokens,
    temperature,
    topP,
    topK,
    frequencyPenalty,
    presencePenalty,
    stopSequences,
    responseFormat,
    seed,
    providerOptions
  }) {
    var _a15;
    const warnings = [];
    if (topK != null) {
      warnings.push({
        type: "unsupported-setting",
        setting: "topK"
      });
    }
    if (stopSequences != null) {
      warnings.push({
        type: "unsupported-setting",
        setting: "stopSequences"
      });
    }
    if (seed != null) {
      warnings.push({
        type: "unsupported-setting",
        setting: "seed"
      });
    }
    return {
      args: {
        // model id:
        model: this.modelId,
        // standardized settings:
        frequency_penalty: frequencyPenalty,
        max_tokens: maxOutputTokens,
        presence_penalty: presencePenalty,
        temperature,
        top_k: topK,
        top_p: topP,
        // response format:
        response_format: (responseFormat == null ? void 0 : responseFormat.type) === "json" ? {
          type: "json_schema",
          json_schema: { schema: responseFormat.schema }
        } : void 0,
        // provider extensions
        ...(_a15 = providerOptions == null ? void 0 : providerOptions.perplexity) != null ? _a15 : {},
        // messages:
        messages: convertToPerplexityMessages(prompt)
      },
      warnings
    };
  }
  async doGenerate(options) {
    var _a15, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l;
    const { args: body, warnings } = this.getArgs(options);
    const {
      responseHeaders,
      value: response,
      rawValue: rawResponse
    } = await chunkSH4PCZ3X_cjs.postJsonToApi({
      url: `${this.config.baseURL}/chat/completions`,
      headers: chunkSH4PCZ3X_cjs.combineHeaders(this.config.headers(), options.headers),
      body,
      failedResponseHandler: chunkSH4PCZ3X_cjs.createJsonErrorResponseHandler({
        errorSchema: perplexityErrorSchema,
        errorToMessage
      }),
      successfulResponseHandler: chunkSH4PCZ3X_cjs.createJsonResponseHandler(
        perplexityResponseSchema
      ),
      abortSignal: options.abortSignal,
      fetch: this.config.fetch
    });
    const choice = response.choices[0];
    const content = [];
    const text = choice.message.content;
    if (text.length > 0) {
      content.push({ type: "text", text });
    }
    if (response.citations != null) {
      for (const url of response.citations) {
        content.push({
          type: "source",
          sourceType: "url",
          id: this.config.generateId(),
          url
        });
      }
    }
    return {
      content,
      finishReason: mapPerplexityFinishReason(choice.finish_reason),
      usage: {
        inputTokens: (_a15 = response.usage) == null ? void 0 : _a15.prompt_tokens,
        outputTokens: (_b = response.usage) == null ? void 0 : _b.completion_tokens,
        totalTokens: (_d = (_c = response.usage) == null ? void 0 : _c.total_tokens) != null ? _d : void 0,
        reasoningTokens: (_f = (_e = response.usage) == null ? void 0 : _e.reasoning_tokens) != null ? _f : void 0
      },
      request: { body },
      response: {
        ...getResponseMetadata4(response),
        headers: responseHeaders,
        body: rawResponse
      },
      warnings,
      providerMetadata: {
        perplexity: {
          images: (_h = (_g = response.images) == null ? void 0 : _g.map((image) => ({
            imageUrl: image.image_url,
            originUrl: image.origin_url,
            height: image.height,
            width: image.width
          }))) != null ? _h : null,
          usage: {
            citationTokens: (_j = (_i = response.usage) == null ? void 0 : _i.citation_tokens) != null ? _j : null,
            numSearchQueries: (_l = (_k = response.usage) == null ? void 0 : _k.num_search_queries) != null ? _l : null
          }
        }
      }
    };
  }
  async doStream(options) {
    const { args, warnings } = this.getArgs(options);
    const body = { ...args, stream: true };
    const { responseHeaders, value: response } = await chunkSH4PCZ3X_cjs.postJsonToApi({
      url: `${this.config.baseURL}/chat/completions`,
      headers: chunkSH4PCZ3X_cjs.combineHeaders(this.config.headers(), options.headers),
      body,
      failedResponseHandler: chunkSH4PCZ3X_cjs.createJsonErrorResponseHandler({
        errorSchema: perplexityErrorSchema,
        errorToMessage
      }),
      successfulResponseHandler: chunkSH4PCZ3X_cjs.createEventSourceResponseHandler(
        perplexityChunkSchema
      ),
      abortSignal: options.abortSignal,
      fetch: this.config.fetch
    });
    let finishReason = "unknown";
    const usage = {
      inputTokens: void 0,
      outputTokens: void 0,
      totalTokens: void 0,
      reasoningTokens: void 0
    };
    const providerMetadata = {
      perplexity: {
        usage: {
          citationTokens: null,
          numSearchQueries: null
        },
        images: null
      }
    };
    let isFirstChunk = true;
    let isActive = false;
    const self = this;
    return {
      stream: response.pipeThrough(
        new TransformStream({
          start(controller) {
            controller.enqueue({ type: "stream-start", warnings });
          },
          transform(chunk, controller) {
            var _a15, _b, _c, _d;
            if (options.includeRawChunks) {
              controller.enqueue({ type: "raw", rawValue: chunk.rawValue });
            }
            if (!chunk.success) {
              controller.enqueue({ type: "error", error: chunk.error });
              return;
            }
            const value = chunk.value;
            if (isFirstChunk) {
              controller.enqueue({
                type: "response-metadata",
                ...getResponseMetadata4(value)
              });
              (_a15 = value.citations) == null ? void 0 : _a15.forEach((url) => {
                controller.enqueue({
                  type: "source",
                  sourceType: "url",
                  id: self.config.generateId(),
                  url
                });
              });
              isFirstChunk = false;
            }
            if (value.usage != null) {
              usage.inputTokens = value.usage.prompt_tokens;
              usage.outputTokens = value.usage.completion_tokens;
              usage.reasoningTokens = (_b = value.usage.reasoning_tokens) != null ? _b : void 0;
              providerMetadata.perplexity.usage = {
                citationTokens: (_c = value.usage.citation_tokens) != null ? _c : null,
                numSearchQueries: (_d = value.usage.num_search_queries) != null ? _d : null
              };
            }
            if (value.images != null) {
              providerMetadata.perplexity.images = value.images.map((image) => ({
                imageUrl: image.image_url,
                originUrl: image.origin_url,
                height: image.height,
                width: image.width
              }));
            }
            const choice = value.choices[0];
            if ((choice == null ? void 0 : choice.finish_reason) != null) {
              finishReason = mapPerplexityFinishReason(choice.finish_reason);
            }
            if ((choice == null ? void 0 : choice.delta) == null) {
              return;
            }
            const delta = choice.delta;
            const textContent = delta.content;
            if (textContent != null) {
              if (!isActive) {
                controller.enqueue({ type: "text-start", id: "0" });
                isActive = true;
              }
              controller.enqueue({
                type: "text-delta",
                id: "0",
                delta: textContent
              });
            }
          },
          flush(controller) {
            if (isActive) {
              controller.enqueue({ type: "text-end", id: "0" });
            }
            controller.enqueue({
              type: "finish",
              finishReason,
              usage,
              providerMetadata
            });
          }
        })
      ),
      request: { body },
      response: { headers: responseHeaders }
    };
  }
};
function getResponseMetadata4({
  id,
  model,
  created
}) {
  return {
    id,
    modelId: model,
    timestamp: new Date(created * 1e3)
  };
}
var perplexityUsageSchema = v4.z.object({
  prompt_tokens: v4.z.number(),
  completion_tokens: v4.z.number(),
  total_tokens: v4.z.number().nullish(),
  citation_tokens: v4.z.number().nullish(),
  num_search_queries: v4.z.number().nullish(),
  reasoning_tokens: v4.z.number().nullish()
});
var perplexityImageSchema = v4.z.object({
  image_url: v4.z.string(),
  origin_url: v4.z.string(),
  height: v4.z.number(),
  width: v4.z.number()
});
var perplexityResponseSchema = v4.z.object({
  id: v4.z.string(),
  created: v4.z.number(),
  model: v4.z.string(),
  choices: v4.z.array(
    v4.z.object({
      message: v4.z.object({
        role: v4.z.literal("assistant"),
        content: v4.z.string()
      }),
      finish_reason: v4.z.string().nullish()
    })
  ),
  citations: v4.z.array(v4.z.string()).nullish(),
  images: v4.z.array(perplexityImageSchema).nullish(),
  usage: perplexityUsageSchema.nullish()
});
var perplexityChunkSchema = v4.z.object({
  id: v4.z.string(),
  created: v4.z.number(),
  model: v4.z.string(),
  choices: v4.z.array(
    v4.z.object({
      delta: v4.z.object({
        role: v4.z.literal("assistant"),
        content: v4.z.string()
      }),
      finish_reason: v4.z.string().nullish()
    })
  ),
  citations: v4.z.array(v4.z.string()).nullish(),
  images: v4.z.array(perplexityImageSchema).nullish(),
  usage: perplexityUsageSchema.nullish()
});
var perplexityErrorSchema = v4.z.object({
  error: v4.z.object({
    code: v4.z.number(),
    message: v4.z.string().nullish(),
    type: v4.z.string().nullish()
  })
});
var errorToMessage = (data) => {
  var _a15, _b;
  return (_b = (_a15 = data.error.message) != null ? _a15 : data.error.type) != null ? _b : "unknown error";
};
var VERSION6 = "2.0.23" ;
function createPerplexity(options = {}) {
  const getHeaders = () => chunkSH4PCZ3X_cjs.withUserAgentSuffix(
    {
      Authorization: `Bearer ${chunkSH4PCZ3X_cjs.loadApiKey({
        apiKey: options.apiKey,
        environmentVariableName: "PERPLEXITY_API_KEY",
        description: "Perplexity"
      })}`,
      ...options.headers
    },
    `ai-sdk/perplexity/${VERSION6}`
  );
  const createLanguageModel = (modelId) => {
    var _a15;
    return new PerplexityLanguageModel(modelId, {
      baseURL: chunkSH4PCZ3X_cjs.withoutTrailingSlash(
        (_a15 = options.baseURL) != null ? _a15 : "https://api.perplexity.ai"
      ),
      headers: getHeaders,
      generateId: chunkSH4PCZ3X_cjs.generateId,
      fetch: options.fetch
    });
  };
  const provider = (modelId) => createLanguageModel(modelId);
  provider.languageModel = createLanguageModel;
  provider.textEmbeddingModel = (modelId) => {
    throw new chunkSH4PCZ3X_cjs.NoSuchModelError({ modelId, modelType: "textEmbeddingModel" });
  };
  provider.imageModel = (modelId) => {
    throw new chunkSH4PCZ3X_cjs.NoSuchModelError({ modelId, modelType: "imageModel" });
  };
  return provider;
}
createPerplexity();
var TogetherAIImageModel = class {
  constructor(modelId, config) {
    this.modelId = modelId;
    this.config = config;
    this.specificationVersion = "v2";
    this.maxImagesPerCall = 1;
  }
  get provider() {
    return this.config.provider;
  }
  async doGenerate({
    prompt,
    n,
    size,
    seed,
    providerOptions,
    headers,
    abortSignal
  }) {
    var _a15, _b, _c, _d;
    const warnings = [];
    if (size != null) {
      warnings.push({
        type: "unsupported-setting",
        setting: "aspectRatio",
        details: "This model does not support the `aspectRatio` option. Use `size` instead."
      });
    }
    const currentDate = (_c = (_b = (_a15 = this.config._internal) == null ? void 0 : _a15.currentDate) == null ? void 0 : _b.call(_a15)) != null ? _c : /* @__PURE__ */ new Date();
    const splitSize = size == null ? void 0 : size.split("x");
    const { value: response, responseHeaders } = await chunkSH4PCZ3X_cjs.postJsonToApi({
      url: `${this.config.baseURL}/images/generations`,
      headers: chunkSH4PCZ3X_cjs.combineHeaders(this.config.headers(), headers),
      body: {
        model: this.modelId,
        prompt,
        seed,
        ...n > 1 ? { n } : {},
        ...splitSize && {
          width: parseInt(splitSize[0]),
          height: parseInt(splitSize[1])
        },
        response_format: "base64",
        ...(_d = providerOptions.togetherai) != null ? _d : {}
      },
      failedResponseHandler: chunkSH4PCZ3X_cjs.createJsonErrorResponseHandler({
        errorSchema: togetheraiErrorSchema,
        errorToMessage: (data) => data.error.message
      }),
      successfulResponseHandler: chunkSH4PCZ3X_cjs.createJsonResponseHandler(
        togetheraiImageResponseSchema
      ),
      abortSignal,
      fetch: this.config.fetch
    });
    return {
      images: response.data.map((item) => item.b64_json),
      warnings,
      response: {
        timestamp: currentDate,
        modelId: this.modelId,
        headers: responseHeaders
      }
    };
  }
};
var togetheraiImageResponseSchema = v4.z.object({
  data: v4.z.array(
    v4.z.object({
      b64_json: v4.z.string()
    })
  )
});
var togetheraiErrorSchema = v4.z.object({
  error: v4.z.object({
    message: v4.z.string()
  })
});
var VERSION7 = "1.0.34" ;
function createTogetherAI(options = {}) {
  var _a15;
  const baseURL = chunkSH4PCZ3X_cjs.withoutTrailingSlash(
    (_a15 = options.baseURL) != null ? _a15 : "https://api.together.xyz/v1/"
  );
  const getHeaders = () => chunkSH4PCZ3X_cjs.withUserAgentSuffix(
    {
      Authorization: `Bearer ${chunkSH4PCZ3X_cjs.loadApiKey({
        apiKey: options.apiKey,
        environmentVariableName: "TOGETHER_AI_API_KEY",
        description: "TogetherAI"
      })}`,
      ...options.headers
    },
    `ai-sdk/togetherai/${VERSION7}`
  );
  const getCommonModelConfig = (modelType) => ({
    provider: `togetherai.${modelType}`,
    url: ({ path }) => `${baseURL}${path}`,
    headers: getHeaders,
    fetch: options.fetch
  });
  const createChatModel = (modelId) => {
    return new chunkSH4PCZ3X_cjs.OpenAICompatibleChatLanguageModel(
      modelId,
      getCommonModelConfig("chat")
    );
  };
  const createCompletionModel = (modelId) => new chunkSH4PCZ3X_cjs.OpenAICompatibleCompletionLanguageModel(
    modelId,
    getCommonModelConfig("completion")
  );
  const createTextEmbeddingModel = (modelId) => new chunkSH4PCZ3X_cjs.OpenAICompatibleEmbeddingModel(
    modelId,
    getCommonModelConfig("embedding")
  );
  const createImageModel = (modelId) => new TogetherAIImageModel(modelId, {
    ...getCommonModelConfig("image"),
    baseURL: baseURL != null ? baseURL : "https://api.together.xyz/v1/"
  });
  const provider = (modelId) => createChatModel(modelId);
  provider.completionModel = createCompletionModel;
  provider.languageModel = createChatModel;
  provider.chatModel = createChatModel;
  provider.textEmbeddingModel = createTextEmbeddingModel;
  provider.image = createImageModel;
  provider.imageModel = createImageModel;
  return provider;
}
createTogetherAI();
function convertToXaiChatMessages(prompt) {
  const messages = [];
  const warnings = [];
  for (const { role, content } of prompt) {
    switch (role) {
      case "system": {
        messages.push({ role: "system", content });
        break;
      }
      case "user": {
        if (content.length === 1 && content[0].type === "text") {
          messages.push({ role: "user", content: content[0].text });
          break;
        }
        messages.push({
          role: "user",
          content: content.map((part) => {
            switch (part.type) {
              case "text": {
                return { type: "text", text: part.text };
              }
              case "file": {
                if (part.mediaType.startsWith("image/")) {
                  const mediaType = part.mediaType === "image/*" ? "image/jpeg" : part.mediaType;
                  return {
                    type: "image_url",
                    image_url: {
                      url: part.data instanceof URL ? part.data.toString() : `data:${mediaType};base64,${chunkSH4PCZ3X_cjs.convertToBase64(part.data)}`
                    }
                  };
                } else {
                  throw new chunkSH4PCZ3X_cjs.UnsupportedFunctionalityError({
                    functionality: `file part media type ${part.mediaType}`
                  });
                }
              }
            }
          })
        });
        break;
      }
      case "assistant": {
        let text = "";
        const toolCalls = [];
        for (const part of content) {
          switch (part.type) {
            case "text": {
              text += part.text;
              break;
            }
            case "tool-call": {
              toolCalls.push({
                id: part.toolCallId,
                type: "function",
                function: {
                  name: part.toolName,
                  arguments: JSON.stringify(part.input)
                }
              });
              break;
            }
          }
        }
        messages.push({
          role: "assistant",
          content: text,
          tool_calls: toolCalls.length > 0 ? toolCalls : void 0
        });
        break;
      }
      case "tool": {
        for (const toolResponse of content) {
          const output = toolResponse.output;
          let contentValue;
          switch (output.type) {
            case "text":
            case "error-text":
              contentValue = output.value;
              break;
            case "content":
            case "json":
            case "error-json":
              contentValue = JSON.stringify(output.value);
              break;
          }
          messages.push({
            role: "tool",
            tool_call_id: toolResponse.toolCallId,
            content: contentValue
          });
        }
        break;
      }
      default: {
        const _exhaustiveCheck = role;
        throw new Error(`Unsupported role: ${_exhaustiveCheck}`);
      }
    }
  }
  return { messages, warnings };
}
function getResponseMetadata5({
  id,
  model,
  created,
  created_at
}) {
  const unixTime = created != null ? created : created_at;
  return {
    id: id != null ? id : void 0,
    modelId: model != null ? model : void 0,
    timestamp: unixTime != null ? new Date(unixTime * 1e3) : void 0
  };
}
function mapXaiFinishReason(finishReason) {
  switch (finishReason) {
    case "stop":
      return "stop";
    case "length":
      return "length";
    case "tool_calls":
    case "function_call":
      return "tool-calls";
    case "content_filter":
      return "content-filter";
    default:
      return "unknown";
  }
}
var webSourceSchema = v4.z.object({
  type: v4.z.literal("web"),
  country: v4.z.string().length(2).optional(),
  excludedWebsites: v4.z.array(v4.z.string()).max(5).optional(),
  allowedWebsites: v4.z.array(v4.z.string()).max(5).optional(),
  safeSearch: v4.z.boolean().optional()
});
var xSourceSchema = v4.z.object({
  type: v4.z.literal("x"),
  excludedXHandles: v4.z.array(v4.z.string()).optional(),
  includedXHandles: v4.z.array(v4.z.string()).optional(),
  postFavoriteCount: v4.z.number().int().optional(),
  postViewCount: v4.z.number().int().optional(),
  /**
   * @deprecated use `includedXHandles` instead
   */
  xHandles: v4.z.array(v4.z.string()).optional()
});
var newsSourceSchema = v4.z.object({
  type: v4.z.literal("news"),
  country: v4.z.string().length(2).optional(),
  excludedWebsites: v4.z.array(v4.z.string()).max(5).optional(),
  safeSearch: v4.z.boolean().optional()
});
var rssSourceSchema = v4.z.object({
  type: v4.z.literal("rss"),
  links: v4.z.array(v4.z.string().url()).max(1)
  // currently only supports one RSS link
});
var searchSourceSchema = v4.z.discriminatedUnion("type", [
  webSourceSchema,
  xSourceSchema,
  newsSourceSchema,
  rssSourceSchema
]);
var xaiProviderOptions = v4.z.object({
  reasoningEffort: v4.z.enum(["low", "high"]).optional(),
  /**
   * Whether to enable parallel function calling during tool use.
   * When true, the model can call multiple functions in parallel.
   * When false, the model will call functions sequentially.
   * Defaults to true.
   */
  parallel_function_calling: v4.z.boolean().optional(),
  searchParameters: v4.z.object({
    /**
     * search mode preference
     * - "off": disables search completely
     * - "auto": model decides whether to search (default)
     * - "on": always enables search
     */
    mode: v4.z.enum(["off", "auto", "on"]),
    /**
     * whether to return citations in the response
     * defaults to true
     */
    returnCitations: v4.z.boolean().optional(),
    /**
     * start date for search data (ISO8601 format: YYYY-MM-DD)
     */
    fromDate: v4.z.string().optional(),
    /**
     * end date for search data (ISO8601 format: YYYY-MM-DD)
     */
    toDate: v4.z.string().optional(),
    /**
     * maximum number of search results to consider
     * defaults to 20
     */
    maxSearchResults: v4.z.number().min(1).max(50).optional(),
    /**
     * data sources to search from.
     * defaults to [{ type: 'web' }, { type: 'x' }] if not specified.
     *
     * @example
     * sources: [{ type: 'web', country: 'US' }, { type: 'x' }]
     */
    sources: v4.z.array(searchSourceSchema).optional()
  }).optional()
});
var xaiErrorDataSchema = v4.z.object({
  error: v4.z.object({
    message: v4.z.string(),
    type: v4.z.string().nullish(),
    param: v4.z.any().nullish(),
    code: v4.z.union([v4.z.string(), v4.z.number()]).nullish()
  })
});
var xaiFailedResponseHandler = chunkSH4PCZ3X_cjs.createJsonErrorResponseHandler({
  errorSchema: xaiErrorDataSchema,
  errorToMessage: (data) => data.error.message
});
function prepareTools4({
  tools,
  toolChoice
}) {
  tools = (tools == null ? void 0 : tools.length) ? tools : void 0;
  const toolWarnings = [];
  if (tools == null) {
    return { tools: void 0, toolChoice: void 0, toolWarnings };
  }
  const xaiTools2 = [];
  for (const tool of tools) {
    if (tool.type === "provider-defined") {
      toolWarnings.push({ type: "unsupported-tool", tool });
    } else {
      xaiTools2.push({
        type: "function",
        function: {
          name: tool.name,
          description: tool.description,
          parameters: tool.inputSchema
        }
      });
    }
  }
  if (toolChoice == null) {
    return { tools: xaiTools2, toolChoice: void 0, toolWarnings };
  }
  const type = toolChoice.type;
  switch (type) {
    case "auto":
    case "none":
      return { tools: xaiTools2, toolChoice: type, toolWarnings };
    case "required":
      return { tools: xaiTools2, toolChoice: "required", toolWarnings };
    case "tool":
      return {
        tools: xaiTools2,
        toolChoice: {
          type: "function",
          function: { name: toolChoice.toolName }
        },
        toolWarnings
      };
    default: {
      const _exhaustiveCheck = type;
      throw new chunkSH4PCZ3X_cjs.UnsupportedFunctionalityError({
        functionality: `tool choice type: ${_exhaustiveCheck}`
      });
    }
  }
}
var XaiChatLanguageModel = class {
  constructor(modelId, config) {
    this.specificationVersion = "v2";
    this.supportedUrls = {
      "image/*": [/^https?:\/\/.*$/]
    };
    this.modelId = modelId;
    this.config = config;
  }
  get provider() {
    return this.config.provider;
  }
  async getArgs({
    prompt,
    maxOutputTokens,
    temperature,
    topP,
    topK,
    frequencyPenalty,
    presencePenalty,
    stopSequences,
    seed,
    responseFormat,
    providerOptions,
    tools,
    toolChoice
  }) {
    var _a15, _b, _c;
    const warnings = [];
    const options = (_a15 = await chunkSH4PCZ3X_cjs.parseProviderOptions({
      provider: "xai",
      providerOptions,
      schema: xaiProviderOptions
    })) != null ? _a15 : {};
    if (topK != null) {
      warnings.push({
        type: "unsupported-setting",
        setting: "topK"
      });
    }
    if (frequencyPenalty != null) {
      warnings.push({
        type: "unsupported-setting",
        setting: "frequencyPenalty"
      });
    }
    if (presencePenalty != null) {
      warnings.push({
        type: "unsupported-setting",
        setting: "presencePenalty"
      });
    }
    if (stopSequences != null) {
      warnings.push({
        type: "unsupported-setting",
        setting: "stopSequences"
      });
    }
    const { messages, warnings: messageWarnings } = convertToXaiChatMessages(prompt);
    warnings.push(...messageWarnings);
    const {
      tools: xaiTools2,
      toolChoice: xaiToolChoice,
      toolWarnings
    } = prepareTools4({
      tools,
      toolChoice
    });
    warnings.push(...toolWarnings);
    const baseArgs = {
      // model id
      model: this.modelId,
      // standard generation settings
      max_completion_tokens: maxOutputTokens,
      temperature,
      top_p: topP,
      seed,
      reasoning_effort: options.reasoningEffort,
      // parallel function calling
      parallel_function_calling: options.parallel_function_calling,
      // response format
      response_format: (responseFormat == null ? void 0 : responseFormat.type) === "json" ? responseFormat.schema != null ? {
        type: "json_schema",
        json_schema: {
          name: (_b = responseFormat.name) != null ? _b : "response",
          schema: responseFormat.schema,
          strict: true
        }
      } : { type: "json_object" } : void 0,
      // search parameters
      search_parameters: options.searchParameters ? {
        mode: options.searchParameters.mode,
        return_citations: options.searchParameters.returnCitations,
        from_date: options.searchParameters.fromDate,
        to_date: options.searchParameters.toDate,
        max_search_results: options.searchParameters.maxSearchResults,
        sources: (_c = options.searchParameters.sources) == null ? void 0 : _c.map((source) => {
          var _a22;
          return {
            type: source.type,
            ...source.type === "web" && {
              country: source.country,
              excluded_websites: source.excludedWebsites,
              allowed_websites: source.allowedWebsites,
              safe_search: source.safeSearch
            },
            ...source.type === "x" && {
              excluded_x_handles: source.excludedXHandles,
              included_x_handles: (_a22 = source.includedXHandles) != null ? _a22 : source.xHandles,
              post_favorite_count: source.postFavoriteCount,
              post_view_count: source.postViewCount
            },
            ...source.type === "news" && {
              country: source.country,
              excluded_websites: source.excludedWebsites,
              safe_search: source.safeSearch
            },
            ...source.type === "rss" && {
              links: source.links
            }
          };
        })
      } : void 0,
      // messages in xai format
      messages,
      // tools in xai format
      tools: xaiTools2,
      tool_choice: xaiToolChoice
    };
    return {
      args: baseArgs,
      warnings
    };
  }
  async doGenerate(options) {
    var _a15, _b, _c, _d, _e, _f, _g, _h, _i, _j;
    const { args: body, warnings } = await this.getArgs(options);
    const url = `${(_a15 = this.config.baseURL) != null ? _a15 : "https://api.x.ai/v1"}/chat/completions`;
    const {
      responseHeaders,
      value: response,
      rawValue: rawResponse
    } = await chunkSH4PCZ3X_cjs.postJsonToApi({
      url,
      headers: chunkSH4PCZ3X_cjs.combineHeaders(this.config.headers(), options.headers),
      body,
      failedResponseHandler: xaiFailedResponseHandler,
      successfulResponseHandler: chunkSH4PCZ3X_cjs.createJsonResponseHandler(
        xaiChatResponseSchema
      ),
      abortSignal: options.abortSignal,
      fetch: this.config.fetch
    });
    if (response.error != null) {
      throw new chunkSH4PCZ3X_cjs.APICallError({
        message: response.error,
        url,
        requestBodyValues: body,
        statusCode: 200,
        responseHeaders,
        responseBody: JSON.stringify(rawResponse),
        isRetryable: response.code === "The service is currently unavailable"
      });
    }
    if (!response.choices || response.choices.length === 0) {
      throw new chunkSH4PCZ3X_cjs.APICallError({
        message: "No choices returned from the API",
        url,
        requestBodyValues: body,
        statusCode: 200,
        responseHeaders,
        responseBody: JSON.stringify(rawResponse)
      });
    }
    const choice = response.choices[0];
    const content = [];
    if (choice.message.content != null && choice.message.content.length > 0) {
      let text = choice.message.content;
      const lastMessage = body.messages[body.messages.length - 1];
      if ((lastMessage == null ? void 0 : lastMessage.role) === "assistant" && text === lastMessage.content) {
        text = "";
      }
      if (text.length > 0) {
        content.push({ type: "text", text });
      }
    }
    if (choice.message.reasoning_content != null && choice.message.reasoning_content.length > 0) {
      content.push({
        type: "reasoning",
        text: choice.message.reasoning_content
      });
    }
    if (choice.message.tool_calls != null) {
      for (const toolCall of choice.message.tool_calls) {
        content.push({
          type: "tool-call",
          toolCallId: toolCall.id,
          toolName: toolCall.function.name,
          input: toolCall.function.arguments
        });
      }
    }
    if (response.citations != null) {
      for (const url2 of response.citations) {
        content.push({
          type: "source",
          sourceType: "url",
          id: this.config.generateId(),
          url: url2
        });
      }
    }
    return {
      content,
      finishReason: mapXaiFinishReason(choice.finish_reason),
      usage: {
        inputTokens: (_b = response.usage) == null ? void 0 : _b.prompt_tokens,
        outputTokens: (_c = response.usage) == null ? void 0 : _c.completion_tokens,
        totalTokens: (_d = response.usage) == null ? void 0 : _d.total_tokens,
        reasoningTokens: (_g = (_f = (_e = response.usage) == null ? void 0 : _e.completion_tokens_details) == null ? void 0 : _f.reasoning_tokens) != null ? _g : void 0,
        cachedInputTokens: (_j = (_i = (_h = response.usage) == null ? void 0 : _h.prompt_tokens_details) == null ? void 0 : _i.cached_tokens) != null ? _j : void 0
      },
      request: { body },
      response: {
        ...getResponseMetadata5(response),
        headers: responseHeaders,
        body: rawResponse
      },
      warnings
    };
  }
  async doStream(options) {
    var _a15;
    const { args, warnings } = await this.getArgs(options);
    const body = {
      ...args,
      stream: true,
      stream_options: {
        include_usage: true
      }
    };
    const url = `${(_a15 = this.config.baseURL) != null ? _a15 : "https://api.x.ai/v1"}/chat/completions`;
    const { responseHeaders, value: response } = await chunkSH4PCZ3X_cjs.postJsonToApi({
      url,
      headers: chunkSH4PCZ3X_cjs.combineHeaders(this.config.headers(), options.headers),
      body,
      failedResponseHandler: xaiFailedResponseHandler,
      successfulResponseHandler: async ({ response: response2 }) => {
        const responseHeaders2 = chunkSH4PCZ3X_cjs.extractResponseHeaders(response2);
        const contentType = response2.headers.get("content-type");
        if (contentType == null ? void 0 : contentType.includes("application/json")) {
          const responseBody = await response2.text();
          const parsedError = await chunkSH4PCZ3X_cjs.safeParseJSON({
            text: responseBody,
            schema: xaiStreamErrorSchema
          });
          if (parsedError.success) {
            throw new chunkSH4PCZ3X_cjs.APICallError({
              message: parsedError.value.error,
              url,
              requestBodyValues: body,
              statusCode: 200,
              responseHeaders: responseHeaders2,
              responseBody,
              isRetryable: parsedError.value.code === "The service is currently unavailable"
            });
          }
          throw new chunkSH4PCZ3X_cjs.APICallError({
            message: "Invalid JSON response",
            url,
            requestBodyValues: body,
            statusCode: 200,
            responseHeaders: responseHeaders2,
            responseBody
          });
        }
        return chunkSH4PCZ3X_cjs.createEventSourceResponseHandler(xaiChatChunkSchema)({
          response: response2,
          url,
          requestBodyValues: body
        });
      },
      abortSignal: options.abortSignal,
      fetch: this.config.fetch
    });
    let finishReason = "unknown";
    const usage = {
      inputTokens: void 0,
      outputTokens: void 0,
      totalTokens: void 0,
      reasoningTokens: void 0,
      cachedInputTokens: void 0
    };
    let isFirstChunk = true;
    const contentBlocks = {};
    const lastReasoningDeltas = {};
    let activeReasoningBlockId = void 0;
    const self = this;
    return {
      stream: response.pipeThrough(
        new TransformStream({
          start(controller) {
            controller.enqueue({ type: "stream-start", warnings });
          },
          transform(chunk, controller) {
            var _a22, _b, _c, _d;
            if (options.includeRawChunks) {
              controller.enqueue({ type: "raw", rawValue: chunk.rawValue });
            }
            if (!chunk.success) {
              controller.enqueue({ type: "error", error: chunk.error });
              return;
            }
            const value = chunk.value;
            if (isFirstChunk) {
              controller.enqueue({
                type: "response-metadata",
                ...getResponseMetadata5(value)
              });
              isFirstChunk = false;
            }
            if (value.citations != null) {
              for (const url2 of value.citations) {
                controller.enqueue({
                  type: "source",
                  sourceType: "url",
                  id: self.config.generateId(),
                  url: url2
                });
              }
            }
            if (value.usage != null) {
              usage.inputTokens = value.usage.prompt_tokens;
              usage.outputTokens = value.usage.completion_tokens;
              usage.totalTokens = value.usage.total_tokens;
              usage.reasoningTokens = (_b = (_a22 = value.usage.completion_tokens_details) == null ? void 0 : _a22.reasoning_tokens) != null ? _b : void 0;
              usage.cachedInputTokens = (_d = (_c = value.usage.prompt_tokens_details) == null ? void 0 : _c.cached_tokens) != null ? _d : void 0;
            }
            const choice = value.choices[0];
            if ((choice == null ? void 0 : choice.finish_reason) != null) {
              finishReason = mapXaiFinishReason(choice.finish_reason);
            }
            if ((choice == null ? void 0 : choice.delta) == null) {
              return;
            }
            const delta = choice.delta;
            const choiceIndex = choice.index;
            if (delta.content != null && delta.content.length > 0) {
              const textContent = delta.content;
              if (activeReasoningBlockId != null && !contentBlocks[activeReasoningBlockId].ended) {
                controller.enqueue({
                  type: "reasoning-end",
                  id: activeReasoningBlockId
                });
                contentBlocks[activeReasoningBlockId].ended = true;
                activeReasoningBlockId = void 0;
              }
              const lastMessage = body.messages[body.messages.length - 1];
              if ((lastMessage == null ? void 0 : lastMessage.role) === "assistant" && textContent === lastMessage.content) {
                return;
              }
              const blockId = `text-${value.id || choiceIndex}`;
              if (contentBlocks[blockId] == null) {
                contentBlocks[blockId] = { type: "text", ended: false };
                controller.enqueue({
                  type: "text-start",
                  id: blockId
                });
              }
              controller.enqueue({
                type: "text-delta",
                id: blockId,
                delta: textContent
              });
            }
            if (delta.reasoning_content != null && delta.reasoning_content.length > 0) {
              const blockId = `reasoning-${value.id || choiceIndex}`;
              if (lastReasoningDeltas[blockId] === delta.reasoning_content) {
                return;
              }
              lastReasoningDeltas[blockId] = delta.reasoning_content;
              if (contentBlocks[blockId] == null) {
                contentBlocks[blockId] = { type: "reasoning", ended: false };
                activeReasoningBlockId = blockId;
                controller.enqueue({
                  type: "reasoning-start",
                  id: blockId
                });
              }
              controller.enqueue({
                type: "reasoning-delta",
                id: blockId,
                delta: delta.reasoning_content
              });
            }
            if (delta.tool_calls != null) {
              if (activeReasoningBlockId != null && !contentBlocks[activeReasoningBlockId].ended) {
                controller.enqueue({
                  type: "reasoning-end",
                  id: activeReasoningBlockId
                });
                contentBlocks[activeReasoningBlockId].ended = true;
                activeReasoningBlockId = void 0;
              }
              for (const toolCall of delta.tool_calls) {
                const toolCallId = toolCall.id;
                controller.enqueue({
                  type: "tool-input-start",
                  id: toolCallId,
                  toolName: toolCall.function.name
                });
                controller.enqueue({
                  type: "tool-input-delta",
                  id: toolCallId,
                  delta: toolCall.function.arguments
                });
                controller.enqueue({
                  type: "tool-input-end",
                  id: toolCallId
                });
                controller.enqueue({
                  type: "tool-call",
                  toolCallId,
                  toolName: toolCall.function.name,
                  input: toolCall.function.arguments
                });
              }
            }
          },
          flush(controller) {
            for (const [blockId, block] of Object.entries(contentBlocks)) {
              if (!block.ended) {
                controller.enqueue({
                  type: block.type === "text" ? "text-end" : "reasoning-end",
                  id: blockId
                });
              }
            }
            controller.enqueue({ type: "finish", finishReason, usage });
          }
        })
      ),
      request: { body },
      response: { headers: responseHeaders }
    };
  }
};
var xaiUsageSchema = v4.z.object({
  prompt_tokens: v4.z.number(),
  completion_tokens: v4.z.number(),
  total_tokens: v4.z.number(),
  prompt_tokens_details: v4.z.object({
    text_tokens: v4.z.number().nullish(),
    audio_tokens: v4.z.number().nullish(),
    image_tokens: v4.z.number().nullish(),
    cached_tokens: v4.z.number().nullish()
  }).nullish(),
  completion_tokens_details: v4.z.object({
    reasoning_tokens: v4.z.number().nullish(),
    audio_tokens: v4.z.number().nullish(),
    accepted_prediction_tokens: v4.z.number().nullish(),
    rejected_prediction_tokens: v4.z.number().nullish()
  }).nullish()
});
var xaiChatResponseSchema = v4.z.object({
  id: v4.z.string().nullish(),
  created: v4.z.number().nullish(),
  model: v4.z.string().nullish(),
  choices: v4.z.array(
    v4.z.object({
      message: v4.z.object({
        role: v4.z.literal("assistant"),
        content: v4.z.string().nullish(),
        reasoning_content: v4.z.string().nullish(),
        tool_calls: v4.z.array(
          v4.z.object({
            id: v4.z.string(),
            type: v4.z.literal("function"),
            function: v4.z.object({
              name: v4.z.string(),
              arguments: v4.z.string()
            })
          })
        ).nullish()
      }),
      index: v4.z.number(),
      finish_reason: v4.z.string().nullish()
    })
  ).nullish(),
  object: v4.z.literal("chat.completion").nullish(),
  usage: xaiUsageSchema.nullish(),
  citations: v4.z.array(v4.z.string().url()).nullish(),
  code: v4.z.string().nullish(),
  error: v4.z.string().nullish()
});
var xaiChatChunkSchema = v4.z.object({
  id: v4.z.string().nullish(),
  created: v4.z.number().nullish(),
  model: v4.z.string().nullish(),
  choices: v4.z.array(
    v4.z.object({
      delta: v4.z.object({
        role: v4.z.enum(["assistant"]).optional(),
        content: v4.z.string().nullish(),
        reasoning_content: v4.z.string().nullish(),
        tool_calls: v4.z.array(
          v4.z.object({
            id: v4.z.string(),
            type: v4.z.literal("function"),
            function: v4.z.object({
              name: v4.z.string(),
              arguments: v4.z.string()
            })
          })
        ).nullish()
      }),
      finish_reason: v4.z.string().nullish(),
      index: v4.z.number()
    })
  ),
  usage: xaiUsageSchema.nullish(),
  citations: v4.z.array(v4.z.string().url()).nullish()
});
var xaiStreamErrorSchema = v4.z.object({
  code: v4.z.string(),
  error: v4.z.string()
});
var annotationSchema = v4.z.union([
  v4.z.object({
    type: v4.z.literal("url_citation"),
    url: v4.z.string(),
    title: v4.z.string().optional()
  }),
  v4.z.object({
    type: v4.z.string()
  })
]);
var messageContentPartSchema = v4.z.object({
  type: v4.z.string(),
  text: v4.z.string().optional(),
  logprobs: v4.z.array(v4.z.any()).optional(),
  annotations: v4.z.array(annotationSchema).optional()
});
var reasoningSummaryPartSchema = v4.z.object({
  type: v4.z.string(),
  text: v4.z.string()
});
var toolCallSchema = v4.z.object({
  name: v4.z.string().optional(),
  arguments: v4.z.string().optional(),
  input: v4.z.string().optional(),
  call_id: v4.z.string().optional(),
  id: v4.z.string(),
  status: v4.z.string(),
  action: v4.z.any().optional()
});
var outputItemSchema = v4.z.discriminatedUnion("type", [
  v4.z.object({
    type: v4.z.literal("web_search_call"),
    ...toolCallSchema.shape
  }),
  v4.z.object({
    type: v4.z.literal("x_search_call"),
    ...toolCallSchema.shape
  }),
  v4.z.object({
    type: v4.z.literal("code_interpreter_call"),
    ...toolCallSchema.shape
  }),
  v4.z.object({
    type: v4.z.literal("code_execution_call"),
    ...toolCallSchema.shape
  }),
  v4.z.object({
    type: v4.z.literal("view_image_call"),
    ...toolCallSchema.shape
  }),
  v4.z.object({
    type: v4.z.literal("view_x_video_call"),
    ...toolCallSchema.shape
  }),
  v4.z.object({
    type: v4.z.literal("custom_tool_call"),
    ...toolCallSchema.shape
  }),
  v4.z.object({
    type: v4.z.literal("message"),
    role: v4.z.string(),
    content: v4.z.array(messageContentPartSchema),
    id: v4.z.string(),
    status: v4.z.string()
  }),
  v4.z.object({
    type: v4.z.literal("function_call"),
    name: v4.z.string(),
    arguments: v4.z.string(),
    call_id: v4.z.string(),
    id: v4.z.string()
  }),
  v4.z.object({
    type: v4.z.literal("reasoning"),
    id: v4.z.string(),
    summary: v4.z.array(reasoningSummaryPartSchema),
    status: v4.z.string(),
    encrypted_content: v4.z.string().nullish()
  })
]);
var xaiResponsesUsageSchema = v4.z.object({
  input_tokens: v4.z.number(),
  output_tokens: v4.z.number(),
  total_tokens: v4.z.number().optional(),
  input_tokens_details: v4.z.object({
    cached_tokens: v4.z.number().optional()
  }).optional(),
  output_tokens_details: v4.z.object({
    reasoning_tokens: v4.z.number().optional()
  }).optional(),
  num_sources_used: v4.z.number().optional(),
  num_server_side_tools_used: v4.z.number().optional()
});
var xaiResponsesResponseSchema = v4.z.object({
  id: v4.z.string().nullish(),
  created_at: v4.z.number().nullish(),
  model: v4.z.string().nullish(),
  object: v4.z.literal("response"),
  output: v4.z.array(outputItemSchema),
  usage: xaiResponsesUsageSchema.nullish(),
  status: v4.z.string()
});
var xaiResponsesChunkSchema = v4.z.union([
  v4.z.object({
    type: v4.z.literal("response.created"),
    response: xaiResponsesResponseSchema.partial({ usage: true, status: true })
  }),
  v4.z.object({
    type: v4.z.literal("response.in_progress"),
    response: xaiResponsesResponseSchema.partial({ usage: true, status: true })
  }),
  v4.z.object({
    type: v4.z.literal("response.output_item.added"),
    item: outputItemSchema,
    output_index: v4.z.number()
  }),
  v4.z.object({
    type: v4.z.literal("response.output_item.done"),
    item: outputItemSchema,
    output_index: v4.z.number()
  }),
  v4.z.object({
    type: v4.z.literal("response.content_part.added"),
    item_id: v4.z.string(),
    output_index: v4.z.number(),
    content_index: v4.z.number(),
    part: messageContentPartSchema
  }),
  v4.z.object({
    type: v4.z.literal("response.content_part.done"),
    item_id: v4.z.string(),
    output_index: v4.z.number(),
    content_index: v4.z.number(),
    part: messageContentPartSchema
  }),
  v4.z.object({
    type: v4.z.literal("response.output_text.delta"),
    item_id: v4.z.string(),
    output_index: v4.z.number(),
    content_index: v4.z.number(),
    delta: v4.z.string(),
    logprobs: v4.z.array(v4.z.any()).optional()
  }),
  v4.z.object({
    type: v4.z.literal("response.output_text.done"),
    item_id: v4.z.string(),
    output_index: v4.z.number(),
    content_index: v4.z.number(),
    text: v4.z.string(),
    logprobs: v4.z.array(v4.z.any()).optional(),
    annotations: v4.z.array(annotationSchema).optional()
  }),
  v4.z.object({
    type: v4.z.literal("response.output_text.annotation.added"),
    item_id: v4.z.string(),
    output_index: v4.z.number(),
    content_index: v4.z.number(),
    annotation_index: v4.z.number(),
    annotation: annotationSchema
  }),
  v4.z.object({
    type: v4.z.literal("response.reasoning_summary_part.added"),
    item_id: v4.z.string(),
    output_index: v4.z.number(),
    summary_index: v4.z.number(),
    part: reasoningSummaryPartSchema
  }),
  v4.z.object({
    type: v4.z.literal("response.reasoning_summary_part.done"),
    item_id: v4.z.string(),
    output_index: v4.z.number(),
    summary_index: v4.z.number(),
    part: reasoningSummaryPartSchema
  }),
  v4.z.object({
    type: v4.z.literal("response.reasoning_summary_text.delta"),
    item_id: v4.z.string(),
    output_index: v4.z.number(),
    summary_index: v4.z.number(),
    delta: v4.z.string()
  }),
  v4.z.object({
    type: v4.z.literal("response.reasoning_summary_text.done"),
    item_id: v4.z.string(),
    output_index: v4.z.number(),
    summary_index: v4.z.number(),
    text: v4.z.string()
  }),
  v4.z.object({
    type: v4.z.literal("response.reasoning_text.delta"),
    item_id: v4.z.string(),
    output_index: v4.z.number(),
    content_index: v4.z.number(),
    delta: v4.z.string()
  }),
  v4.z.object({
    type: v4.z.literal("response.reasoning_text.done"),
    item_id: v4.z.string(),
    output_index: v4.z.number(),
    content_index: v4.z.number(),
    text: v4.z.string()
  }),
  v4.z.object({
    type: v4.z.literal("response.web_search_call.in_progress"),
    item_id: v4.z.string(),
    output_index: v4.z.number()
  }),
  v4.z.object({
    type: v4.z.literal("response.web_search_call.searching"),
    item_id: v4.z.string(),
    output_index: v4.z.number()
  }),
  v4.z.object({
    type: v4.z.literal("response.web_search_call.completed"),
    item_id: v4.z.string(),
    output_index: v4.z.number()
  }),
  v4.z.object({
    type: v4.z.literal("response.x_search_call.in_progress"),
    item_id: v4.z.string(),
    output_index: v4.z.number()
  }),
  v4.z.object({
    type: v4.z.literal("response.x_search_call.searching"),
    item_id: v4.z.string(),
    output_index: v4.z.number()
  }),
  v4.z.object({
    type: v4.z.literal("response.x_search_call.completed"),
    item_id: v4.z.string(),
    output_index: v4.z.number()
  }),
  v4.z.object({
    type: v4.z.literal("response.custom_tool_call_input.done"),
    item_id: v4.z.string(),
    output_index: v4.z.number()
  }),
  v4.z.object({
    type: v4.z.literal("response.custom_tool_call_input.delta"),
    item_id: v4.z.string(),
    output_index: v4.z.number()
  }),
  v4.z.object({
    type: v4.z.literal("response.code_execution_call.in_progress"),
    item_id: v4.z.string(),
    output_index: v4.z.number()
  }),
  v4.z.object({
    type: v4.z.literal("response.code_execution_call.executing"),
    item_id: v4.z.string(),
    output_index: v4.z.number()
  }),
  v4.z.object({
    type: v4.z.literal("response.code_execution_call.completed"),
    item_id: v4.z.string(),
    output_index: v4.z.number()
  }),
  v4.z.object({
    type: v4.z.literal("response.code_interpreter_call.in_progress"),
    item_id: v4.z.string(),
    output_index: v4.z.number()
  }),
  v4.z.object({
    type: v4.z.literal("response.code_interpreter_call.executing"),
    item_id: v4.z.string(),
    output_index: v4.z.number()
  }),
  v4.z.object({
    type: v4.z.literal("response.code_interpreter_call.interpreting"),
    item_id: v4.z.string(),
    output_index: v4.z.number()
  }),
  v4.z.object({
    type: v4.z.literal("response.code_interpreter_call.completed"),
    item_id: v4.z.string(),
    output_index: v4.z.number()
  }),
  // Code interpreter code streaming events
  v4.z.object({
    type: v4.z.literal("response.code_interpreter_call_code.delta"),
    item_id: v4.z.string(),
    output_index: v4.z.number(),
    delta: v4.z.string()
  }),
  v4.z.object({
    type: v4.z.literal("response.code_interpreter_call_code.done"),
    item_id: v4.z.string(),
    output_index: v4.z.number(),
    code: v4.z.string()
  }),
  v4.z.object({
    type: v4.z.literal("response.done"),
    response: xaiResponsesResponseSchema
  }),
  v4.z.object({
    type: v4.z.literal("response.completed"),
    response: xaiResponsesResponseSchema
  })
]);
function mapXaiResponsesFinishReason(finishReason) {
  switch (finishReason) {
    case "stop":
    case "completed":
      return "stop";
    case "length":
      return "length";
    case "tool_calls":
    case "function_call":
      return "tool-calls";
    case "content_filter":
      return "content-filter";
    default:
      return "unknown";
  }
}
var xaiResponsesProviderOptions = v4.z.object({
  /**
   * Constrains how hard a reasoning model thinks before responding.
   * Possible values are `low` (uses fewer reasoning tokens), `medium` and `high` (uses more reasoning tokens).
   */
  reasoningEffort: v4.z.enum(["low", "medium", "high"]).optional(),
  /**
   * Whether to store the input message(s) and model response for later retrieval.
   * @default true
   */
  store: v4.z.boolean().optional(),
  /**
   * The ID of the previous response from the model.
   */
  previousResponseId: v4.z.string().optional()
});
async function convertToXaiResponsesInput({
  prompt
}) {
  var _a15, _b, _c, _d;
  const input = [];
  const inputWarnings = [];
  for (const message of prompt) {
    switch (message.role) {
      case "system": {
        input.push({
          role: "system",
          content: message.content
        });
        break;
      }
      case "user": {
        const contentParts = [];
        for (const block of message.content) {
          switch (block.type) {
            case "text": {
              contentParts.push({ type: "input_text", text: block.text });
              break;
            }
            case "file": {
              if (block.mediaType.startsWith("image/")) {
                const mediaType = block.mediaType === "image/*" ? "image/jpeg" : block.mediaType;
                const imageUrl = block.data instanceof URL ? block.data.toString() : `data:${mediaType};base64,${chunkSH4PCZ3X_cjs.convertToBase64(block.data)}`;
                contentParts.push({ type: "input_image", image_url: imageUrl });
              } else {
                throw new chunkSH4PCZ3X_cjs.UnsupportedFunctionalityError({
                  functionality: `file part media type ${block.mediaType}`
                });
              }
              break;
            }
            default: {
              inputWarnings.push({
                type: "other",
                message: "xAI Responses API does not support this content type in user messages"
              });
            }
          }
        }
        input.push({
          role: "user",
          content: contentParts
        });
        break;
      }
      case "assistant": {
        for (const part of message.content) {
          switch (part.type) {
            case "text": {
              const id = typeof ((_b = (_a15 = part.providerOptions) == null ? void 0 : _a15.xai) == null ? void 0 : _b.itemId) === "string" ? part.providerOptions.xai.itemId : void 0;
              input.push({
                role: "assistant",
                content: part.text,
                id
              });
              break;
            }
            case "tool-call": {
              if (part.providerExecuted) {
                break;
              }
              const id = typeof ((_d = (_c = part.providerOptions) == null ? void 0 : _c.xai) == null ? void 0 : _d.itemId) === "string" ? part.providerOptions.xai.itemId : void 0;
              input.push({
                type: "function_call",
                id: id != null ? id : part.toolCallId,
                call_id: part.toolCallId,
                name: part.toolName,
                arguments: JSON.stringify(part.input),
                status: "completed"
              });
              break;
            }
            case "tool-result": {
              break;
            }
            case "reasoning":
            case "file": {
              inputWarnings.push({
                type: "other",
                message: `xAI Responses API does not support ${part.type} in assistant messages`
              });
              break;
            }
            default: {
              inputWarnings.push({
                type: "other",
                message: "xAI Responses API does not support this content type in assistant messages"
              });
            }
          }
        }
        break;
      }
      case "tool": {
        for (const part of message.content) {
          const output = part.output;
          let outputValue;
          switch (output.type) {
            case "text":
            case "error-text":
              outputValue = output.value;
              break;
            case "json":
            case "error-json":
              outputValue = JSON.stringify(output.value);
              break;
            case "content":
              outputValue = output.value.map((item) => {
                if (item.type === "text") {
                  return item.text;
                }
                return "";
              }).join("");
              break;
            default: {
              outputValue = "";
            }
          }
          input.push({
            type: "function_call_output",
            call_id: part.toolCallId,
            output: outputValue
          });
        }
        break;
      }
      default: {
        inputWarnings.push({
          type: "other",
          message: "unsupported message role"
        });
      }
    }
  }
  return { input, inputWarnings };
}
var webSearchArgsSchema = chunkSH4PCZ3X_cjs.lazySchema(
  () => chunkSH4PCZ3X_cjs.zodSchema(
    v4.z.object({
      allowedDomains: v4.z.array(v4.z.string()).max(5).optional(),
      excludedDomains: v4.z.array(v4.z.string()).max(5).optional(),
      enableImageUnderstanding: v4.z.boolean().optional()
    })
  )
);
var webSearchOutputSchema = chunkSH4PCZ3X_cjs.lazySchema(
  () => chunkSH4PCZ3X_cjs.zodSchema(
    v4.z.object({
      query: v4.z.string(),
      sources: v4.z.array(
        v4.z.object({
          title: v4.z.string(),
          url: v4.z.string(),
          snippet: v4.z.string()
        })
      )
    })
  )
);
var webSearchToolFactory = chunkSH4PCZ3X_cjs.createProviderDefinedToolFactoryWithOutputSchema({
  id: "xai.web_search",
  name: "web_search",
  inputSchema: chunkSH4PCZ3X_cjs.lazySchema(() => chunkSH4PCZ3X_cjs.zodSchema(v4.z.object({}))),
  outputSchema: webSearchOutputSchema
});
var webSearch = (args = {}) => webSearchToolFactory(args);
var xSearchArgsSchema = chunkSH4PCZ3X_cjs.lazySchema(
  () => chunkSH4PCZ3X_cjs.zodSchema(
    v4.z.object({
      allowedXHandles: v4.z.array(v4.z.string()).max(10).optional(),
      excludedXHandles: v4.z.array(v4.z.string()).max(10).optional(),
      fromDate: v4.z.string().optional(),
      toDate: v4.z.string().optional(),
      enableImageUnderstanding: v4.z.boolean().optional(),
      enableVideoUnderstanding: v4.z.boolean().optional()
    })
  )
);
var xSearchOutputSchema = chunkSH4PCZ3X_cjs.lazySchema(
  () => chunkSH4PCZ3X_cjs.zodSchema(
    v4.z.object({
      query: v4.z.string(),
      posts: v4.z.array(
        v4.z.object({
          author: v4.z.string(),
          text: v4.z.string(),
          url: v4.z.string(),
          likes: v4.z.number()
        })
      )
    })
  )
);
var xSearchToolFactory = chunkSH4PCZ3X_cjs.createProviderDefinedToolFactoryWithOutputSchema({
  id: "xai.x_search",
  name: "x_search",
  inputSchema: chunkSH4PCZ3X_cjs.lazySchema(() => chunkSH4PCZ3X_cjs.zodSchema(v4.z.object({}))),
  outputSchema: xSearchOutputSchema
});
var xSearch = (args = {}) => xSearchToolFactory(args);
async function prepareResponsesTools({
  tools,
  toolChoice
}) {
  const normalizedTools = (tools == null ? void 0 : tools.length) ? tools : void 0;
  const toolWarnings = [];
  if (normalizedTools == null) {
    return { tools: void 0, toolChoice: void 0, toolWarnings };
  }
  const xaiTools2 = [];
  const toolByName = /* @__PURE__ */ new Map();
  for (const tool of normalizedTools) {
    toolByName.set(tool.name, tool);
    if (tool.type === "provider-defined") {
      switch (tool.id) {
        case "xai.web_search": {
          const args = await chunkSH4PCZ3X_cjs.validateTypes({
            value: tool.args,
            schema: webSearchArgsSchema
          });
          xaiTools2.push({
            type: "web_search",
            allowed_domains: args.allowedDomains,
            excluded_domains: args.excludedDomains,
            enable_image_understanding: args.enableImageUnderstanding
          });
          break;
        }
        case "xai.x_search": {
          const args = await chunkSH4PCZ3X_cjs.validateTypes({
            value: tool.args,
            schema: xSearchArgsSchema
          });
          xaiTools2.push({
            type: "x_search",
            allowed_x_handles: args.allowedXHandles,
            excluded_x_handles: args.excludedXHandles,
            from_date: args.fromDate,
            to_date: args.toDate,
            enable_image_understanding: args.enableImageUnderstanding,
            enable_video_understanding: args.enableVideoUnderstanding
          });
          break;
        }
        case "xai.code_execution": {
          xaiTools2.push({
            type: "code_interpreter"
          });
          break;
        }
        case "xai.view_image": {
          xaiTools2.push({
            type: "view_image"
          });
          break;
        }
        case "xai.view_x_video": {
          xaiTools2.push({
            type: "view_x_video"
          });
          break;
        }
        case "xai.file_search": {
          xaiTools2.push({
            type: "file_search"
          });
          break;
        }
        case "xai.mcp": {
          xaiTools2.push({
            type: "mcp"
          });
          break;
        }
        default: {
          toolWarnings.push({ type: "unsupported-tool", tool });
          break;
        }
      }
    } else {
      xaiTools2.push({
        type: "function",
        name: tool.name,
        description: tool.description,
        parameters: tool.inputSchema
      });
    }
  }
  if (toolChoice == null) {
    return { tools: xaiTools2, toolChoice: void 0, toolWarnings };
  }
  const type = toolChoice.type;
  switch (type) {
    case "auto":
    case "none":
      return { tools: xaiTools2, toolChoice: type, toolWarnings };
    case "required":
      return { tools: xaiTools2, toolChoice: "required", toolWarnings };
    case "tool": {
      const selectedTool = toolByName.get(toolChoice.toolName);
      if (selectedTool == null) {
        return {
          tools: xaiTools2,
          toolChoice: void 0,
          toolWarnings
        };
      }
      if (selectedTool.type === "provider-defined") {
        switch (selectedTool.id) {
          case "xai.web_search":
            return {
              tools: xaiTools2,
              toolChoice: { type: "web_search" },
              toolWarnings
            };
          case "xai.x_search":
            return {
              tools: xaiTools2,
              toolChoice: { type: "x_search" },
              toolWarnings
            };
          case "xai.code_execution":
            return {
              tools: xaiTools2,
              toolChoice: { type: "code_interpreter" },
              toolWarnings
            };
          case "xai.view_image":
            return {
              tools: xaiTools2,
              toolChoice: { type: "view_image" },
              toolWarnings
            };
          case "xai.view_x_video":
            return {
              tools: xaiTools2,
              toolChoice: { type: "view_x_video" },
              toolWarnings
            };
          case "xai.file_search":
            return {
              tools: xaiTools2,
              toolChoice: { type: "file_search" },
              toolWarnings
            };
          case "xai.mcp":
            return {
              tools: xaiTools2,
              toolChoice: { type: "mcp" },
              toolWarnings
            };
          default:
            toolWarnings.push({ type: "unsupported-tool", tool: selectedTool });
            return { tools: xaiTools2, toolChoice: void 0, toolWarnings };
        }
      }
      return {
        tools: xaiTools2,
        toolChoice: { type: "function", name: selectedTool.name },
        toolWarnings
      };
    }
    default: {
      const _exhaustiveCheck = type;
      throw new chunkSH4PCZ3X_cjs.UnsupportedFunctionalityError({
        functionality: `tool choice type: ${_exhaustiveCheck}`
      });
    }
  }
}
var XaiResponsesLanguageModel = class {
  constructor(modelId, config) {
    this.specificationVersion = "v2";
    this.supportedUrls = {
      "image/*": [/^https?:\/\/.*$/]
    };
    this.modelId = modelId;
    this.config = config;
  }
  get provider() {
    return this.config.provider;
  }
  async getArgs({
    prompt,
    maxOutputTokens,
    temperature,
    topP,
    stopSequences,
    seed,
    responseFormat,
    providerOptions,
    tools,
    toolChoice
  }) {
    var _a15, _b, _c, _d, _e;
    const warnings = [];
    const options = (_a15 = await chunkSH4PCZ3X_cjs.parseProviderOptions({
      provider: "xai",
      providerOptions,
      schema: xaiResponsesProviderOptions
    })) != null ? _a15 : {};
    if (stopSequences != null) {
      warnings.push({
        type: "unsupported-setting",
        setting: "stopSequences"
      });
    }
    const webSearchToolName = (_b = tools == null ? void 0 : tools.find(
      (tool) => tool.type === "provider-defined" && tool.id === "xai.web_search"
    )) == null ? void 0 : _b.name;
    const xSearchToolName = (_c = tools == null ? void 0 : tools.find(
      (tool) => tool.type === "provider-defined" && tool.id === "xai.x_search"
    )) == null ? void 0 : _c.name;
    const codeExecutionToolName = (_d = tools == null ? void 0 : tools.find(
      (tool) => tool.type === "provider-defined" && tool.id === "xai.code_execution"
    )) == null ? void 0 : _d.name;
    const { input, inputWarnings } = await convertToXaiResponsesInput({
      prompt});
    warnings.push(...inputWarnings);
    const {
      tools: xaiTools2,
      toolChoice: xaiToolChoice,
      toolWarnings
    } = await prepareResponsesTools({
      tools,
      toolChoice
    });
    warnings.push(...toolWarnings);
    const baseArgs = {
      model: this.modelId,
      input,
      max_output_tokens: maxOutputTokens,
      temperature,
      top_p: topP,
      seed,
      ...(responseFormat == null ? void 0 : responseFormat.type) === "json" && {
        text: {
          format: responseFormat.schema != null ? {
            type: "json_schema",
            strict: true,
            name: (_e = responseFormat.name) != null ? _e : "response",
            description: responseFormat.description,
            schema: responseFormat.schema
          } : { type: "json_object" }
        }
      },
      ...options.reasoningEffort != null && {
        reasoning: { effort: options.reasoningEffort }
      },
      ...options.store === false && {
        store: options.store,
        include: ["reasoning.encrypted_content"]
      },
      ...options.previousResponseId != null && {
        previous_response_id: options.previousResponseId
      }
    };
    if (xaiTools2 && xaiTools2.length > 0) {
      baseArgs.tools = xaiTools2;
    }
    if (xaiToolChoice != null) {
      baseArgs.tool_choice = xaiToolChoice;
    }
    return {
      args: baseArgs,
      warnings,
      webSearchToolName,
      xSearchToolName,
      codeExecutionToolName
    };
  }
  async doGenerate(options) {
    var _a15, _b, _c, _d, _e, _f, _g, _h, _i;
    const {
      args: body,
      warnings,
      webSearchToolName,
      xSearchToolName,
      codeExecutionToolName
    } = await this.getArgs(options);
    const {
      responseHeaders,
      value: response,
      rawValue: rawResponse
    } = await chunkSH4PCZ3X_cjs.postJsonToApi({
      url: `${(_a15 = this.config.baseURL) != null ? _a15 : "https://api.x.ai/v1"}/responses`,
      headers: chunkSH4PCZ3X_cjs.combineHeaders(this.config.headers(), options.headers),
      body,
      failedResponseHandler: xaiFailedResponseHandler,
      successfulResponseHandler: chunkSH4PCZ3X_cjs.createJsonResponseHandler(
        xaiResponsesResponseSchema
      ),
      abortSignal: options.abortSignal,
      fetch: this.config.fetch
    });
    const content = [];
    const webSearchSubTools = [
      "web_search",
      "web_search_with_snippets",
      "browse_page"
    ];
    const xSearchSubTools = [
      "x_user_search",
      "x_keyword_search",
      "x_semantic_search",
      "x_thread_fetch"
    ];
    for (const part of response.output) {
      if (part.type === "web_search_call" || part.type === "x_search_call" || part.type === "code_interpreter_call" || part.type === "code_execution_call" || part.type === "view_image_call" || part.type === "view_x_video_call" || part.type === "custom_tool_call") {
        let toolName = (_b = part.name) != null ? _b : "";
        if (webSearchSubTools.includes((_c = part.name) != null ? _c : "") || part.type === "web_search_call") {
          toolName = webSearchToolName != null ? webSearchToolName : "web_search";
        } else if (xSearchSubTools.includes((_d = part.name) != null ? _d : "") || part.type === "x_search_call") {
          toolName = xSearchToolName != null ? xSearchToolName : "x_search";
        } else if (part.name === "code_execution" || part.type === "code_interpreter_call" || part.type === "code_execution_call") {
          toolName = codeExecutionToolName != null ? codeExecutionToolName : "code_execution";
        }
        const toolInput = part.type === "custom_tool_call" ? (_e = part.input) != null ? _e : "" : (_f = part.arguments) != null ? _f : "";
        content.push({
          type: "tool-call",
          toolCallId: part.id,
          toolName,
          input: toolInput,
          providerExecuted: true
        });
        continue;
      }
      switch (part.type) {
        case "message": {
          for (const contentPart of part.content) {
            if (contentPart.text) {
              content.push({
                type: "text",
                text: contentPart.text
              });
            }
            if (contentPart.annotations) {
              for (const annotation of contentPart.annotations) {
                if (annotation.type === "url_citation" && "url" in annotation) {
                  content.push({
                    type: "source",
                    sourceType: "url",
                    id: this.config.generateId(),
                    url: annotation.url,
                    title: (_g = annotation.title) != null ? _g : annotation.url
                  });
                }
              }
            }
          }
          break;
        }
        case "function_call": {
          content.push({
            type: "tool-call",
            toolCallId: part.call_id,
            toolName: part.name,
            input: part.arguments
          });
          break;
        }
        case "reasoning": {
          const summaryTexts = part.summary.map((s) => s.text).filter((text) => text && text.length > 0);
          if (summaryTexts.length > 0) {
            const reasoningText = summaryTexts.join("");
            if (part.encrypted_content || part.id) {
              content.push({
                type: "reasoning",
                text: reasoningText,
                providerMetadata: {
                  xai: {
                    ...part.encrypted_content && {
                      reasoningEncryptedContent: part.encrypted_content
                    },
                    ...part.id && { itemId: part.id }
                  }
                }
              });
            } else {
              content.push({
                type: "reasoning",
                text: reasoningText
              });
            }
          }
          break;
        }
      }
    }
    return {
      content,
      finishReason: mapXaiResponsesFinishReason(response.status),
      usage: response.usage ? {
        inputTokens: response.usage.input_tokens,
        outputTokens: response.usage.output_tokens,
        totalTokens: response.usage.total_tokens,
        reasoningTokens: (_h = response.usage.output_tokens_details) == null ? void 0 : _h.reasoning_tokens,
        cachedInputTokens: (_i = response.usage.input_tokens_details) == null ? void 0 : _i.cached_tokens
      } : {
        inputTokens: 0,
        outputTokens: 0,
        totalTokens: 0
      },
      request: { body },
      response: {
        ...getResponseMetadata5(response),
        headers: responseHeaders,
        body: rawResponse
      },
      warnings
    };
  }
  async doStream(options) {
    var _a15;
    const {
      args,
      warnings,
      webSearchToolName,
      xSearchToolName,
      codeExecutionToolName
    } = await this.getArgs(options);
    const body = {
      ...args,
      stream: true
    };
    const { responseHeaders, value: response } = await chunkSH4PCZ3X_cjs.postJsonToApi({
      url: `${(_a15 = this.config.baseURL) != null ? _a15 : "https://api.x.ai/v1"}/responses`,
      headers: chunkSH4PCZ3X_cjs.combineHeaders(this.config.headers(), options.headers),
      body,
      failedResponseHandler: xaiFailedResponseHandler,
      successfulResponseHandler: chunkSH4PCZ3X_cjs.createEventSourceResponseHandler(
        xaiResponsesChunkSchema
      ),
      abortSignal: options.abortSignal,
      fetch: this.config.fetch
    });
    let finishReason = "unknown";
    const usage = {
      inputTokens: void 0,
      outputTokens: void 0,
      totalTokens: void 0
    };
    let isFirstChunk = true;
    const contentBlocks = {};
    const seenToolCalls = /* @__PURE__ */ new Set();
    const activeReasoning = {};
    const self = this;
    return {
      stream: response.pipeThrough(
        new TransformStream({
          start(controller) {
            controller.enqueue({ type: "stream-start", warnings });
          },
          transform(chunk, controller) {
            var _a22, _b, _c, _d, _e, _f, _g, _h, _i, _j;
            if (options.includeRawChunks) {
              controller.enqueue({ type: "raw", rawValue: chunk.rawValue });
            }
            if (!chunk.success) {
              controller.enqueue({ type: "error", error: chunk.error });
              return;
            }
            const event = chunk.value;
            if (event.type === "response.created" || event.type === "response.in_progress") {
              if (isFirstChunk) {
                controller.enqueue({
                  type: "response-metadata",
                  ...getResponseMetadata5(event.response)
                });
                isFirstChunk = false;
              }
              return;
            }
            if (event.type === "response.reasoning_summary_part.added") {
              const blockId = `reasoning-${event.item_id}`;
              controller.enqueue({
                type: "reasoning-start",
                id: blockId,
                providerMetadata: {
                  xai: {
                    itemId: event.item_id
                  }
                }
              });
            }
            if (event.type === "response.reasoning_summary_text.delta") {
              const blockId = `reasoning-${event.item_id}`;
              controller.enqueue({
                type: "reasoning-delta",
                id: blockId,
                delta: event.delta,
                providerMetadata: {
                  xai: {
                    itemId: event.item_id
                  }
                }
              });
              return;
            }
            if (event.type === "response.reasoning_summary_text.done") {
              return;
            }
            if (event.type === "response.reasoning_text.delta") {
              const blockId = `reasoning-${event.item_id}`;
              if (activeReasoning[event.item_id] == null) {
                activeReasoning[event.item_id] = {};
                controller.enqueue({
                  type: "reasoning-start",
                  id: blockId,
                  providerMetadata: {
                    xai: {
                      itemId: event.item_id
                    }
                  }
                });
              }
              controller.enqueue({
                type: "reasoning-delta",
                id: blockId,
                delta: event.delta,
                providerMetadata: {
                  xai: {
                    itemId: event.item_id
                  }
                }
              });
              return;
            }
            if (event.type === "response.reasoning_text.done") {
              return;
            }
            if (event.type === "response.output_text.delta") {
              const blockId = `text-${event.item_id}`;
              if (contentBlocks[blockId] == null) {
                contentBlocks[blockId] = { type: "text" };
                controller.enqueue({
                  type: "text-start",
                  id: blockId
                });
              }
              controller.enqueue({
                type: "text-delta",
                id: blockId,
                delta: event.delta
              });
              return;
            }
            if (event.type === "response.output_text.done") {
              if (event.annotations) {
                for (const annotation of event.annotations) {
                  if (annotation.type === "url_citation" && "url" in annotation) {
                    controller.enqueue({
                      type: "source",
                      sourceType: "url",
                      id: self.config.generateId(),
                      url: annotation.url,
                      title: (_a22 = annotation.title) != null ? _a22 : annotation.url
                    });
                  }
                }
              }
              return;
            }
            if (event.type === "response.output_text.annotation.added") {
              const annotation = event.annotation;
              if (annotation.type === "url_citation" && "url" in annotation) {
                controller.enqueue({
                  type: "source",
                  sourceType: "url",
                  id: self.config.generateId(),
                  url: annotation.url,
                  title: (_b = annotation.title) != null ? _b : annotation.url
                });
              }
              return;
            }
            if (event.type === "response.done" || event.type === "response.completed") {
              const response2 = event.response;
              if (response2.usage) {
                usage.inputTokens = response2.usage.input_tokens;
                usage.cachedInputTokens = (_c = response2.usage.input_tokens_details) == null ? void 0 : _c.cached_tokens;
                usage.outputTokens = response2.usage.output_tokens;
                usage.totalTokens = response2.usage.total_tokens;
                usage.reasoningTokens = (_d = response2.usage.output_tokens_details) == null ? void 0 : _d.reasoning_tokens;
              }
              if (response2.status) {
                finishReason = mapXaiResponsesFinishReason(response2.status);
              }
              return;
            }
            if (event.type === "response.output_item.added" || event.type === "response.output_item.done") {
              const part = event.item;
              if (part.type === "reasoning") {
                if (event.type === "response.output_item.done") {
                  if (activeReasoning[part.id] == null) {
                    controller.enqueue({
                      type: "reasoning-start",
                      id: `reasoning-${part.id}`,
                      providerMetadata: {
                        xai: {
                          itemId: part.id
                        }
                      }
                    });
                  }
                  controller.enqueue({
                    type: "reasoning-end",
                    id: `reasoning-${part.id}`,
                    providerMetadata: {
                      xai: {
                        ...part.encrypted_content && {
                          reasoningEncryptedContent: part.encrypted_content
                        },
                        ...part.id && { itemId: part.id }
                      }
                    }
                  });
                  delete activeReasoning[part.id];
                }
                return;
              }
              if (part.type === "web_search_call" || part.type === "x_search_call" || part.type === "code_interpreter_call" || part.type === "code_execution_call" || part.type === "view_image_call" || part.type === "view_x_video_call" || part.type === "custom_tool_call") {
                const webSearchSubTools = [
                  "web_search",
                  "web_search_with_snippets",
                  "browse_page"
                ];
                const xSearchSubTools = [
                  "x_user_search",
                  "x_keyword_search",
                  "x_semantic_search",
                  "x_thread_fetch"
                ];
                let toolName = (_e = part.name) != null ? _e : "";
                if (webSearchSubTools.includes((_f = part.name) != null ? _f : "") || part.type === "web_search_call") {
                  toolName = webSearchToolName != null ? webSearchToolName : "web_search";
                } else if (xSearchSubTools.includes((_g = part.name) != null ? _g : "") || part.type === "x_search_call") {
                  toolName = xSearchToolName != null ? xSearchToolName : "x_search";
                } else if (part.name === "code_execution" || part.type === "code_interpreter_call" || part.type === "code_execution_call") {
                  toolName = codeExecutionToolName != null ? codeExecutionToolName : "code_execution";
                }
                const toolInput = part.type === "custom_tool_call" ? (_h = part.input) != null ? _h : "" : (_i = part.arguments) != null ? _i : "";
                const shouldEmit = part.type === "custom_tool_call" ? event.type === "response.output_item.done" : !seenToolCalls.has(part.id);
                if (shouldEmit && !seenToolCalls.has(part.id)) {
                  seenToolCalls.add(part.id);
                  controller.enqueue({
                    type: "tool-input-start",
                    id: part.id,
                    toolName
                  });
                  controller.enqueue({
                    type: "tool-input-delta",
                    id: part.id,
                    delta: toolInput
                  });
                  controller.enqueue({
                    type: "tool-input-end",
                    id: part.id
                  });
                  controller.enqueue({
                    type: "tool-call",
                    toolCallId: part.id,
                    toolName,
                    input: toolInput,
                    providerExecuted: true
                  });
                }
                return;
              }
              if (part.type === "message") {
                for (const contentPart of part.content) {
                  if (contentPart.text && contentPart.text.length > 0) {
                    const blockId = `text-${part.id}`;
                    if (contentBlocks[blockId] == null) {
                      contentBlocks[blockId] = { type: "text" };
                      controller.enqueue({
                        type: "text-start",
                        id: blockId
                      });
                      controller.enqueue({
                        type: "text-delta",
                        id: blockId,
                        delta: contentPart.text
                      });
                    }
                  }
                  if (contentPart.annotations) {
                    for (const annotation of contentPart.annotations) {
                      if (annotation.type === "url_citation" && "url" in annotation) {
                        controller.enqueue({
                          type: "source",
                          sourceType: "url",
                          id: self.config.generateId(),
                          url: annotation.url,
                          title: (_j = annotation.title) != null ? _j : annotation.url
                        });
                      }
                    }
                  }
                }
              } else if (part.type === "function_call") {
                if (!seenToolCalls.has(part.call_id)) {
                  seenToolCalls.add(part.call_id);
                  controller.enqueue({
                    type: "tool-input-start",
                    id: part.call_id,
                    toolName: part.name
                  });
                  controller.enqueue({
                    type: "tool-input-delta",
                    id: part.call_id,
                    delta: part.arguments
                  });
                  controller.enqueue({
                    type: "tool-input-end",
                    id: part.call_id
                  });
                  controller.enqueue({
                    type: "tool-call",
                    toolCallId: part.call_id,
                    toolName: part.name,
                    input: part.arguments
                  });
                }
              }
            }
          },
          flush(controller) {
            for (const [blockId, block] of Object.entries(contentBlocks)) {
              if (block.type === "text") {
                controller.enqueue({
                  type: "text-end",
                  id: blockId
                });
              }
            }
            controller.enqueue({ type: "finish", finishReason, usage });
          }
        })
      ),
      request: { body },
      response: { headers: responseHeaders }
    };
  }
};
var codeExecutionOutputSchema = v4.z.object({
  output: v4.z.string().describe("the output of the code execution"),
  error: v4.z.string().optional().describe("any error that occurred")
});
var codeExecutionToolFactory = chunkSH4PCZ3X_cjs.createProviderDefinedToolFactoryWithOutputSchema({
  id: "xai.code_execution",
  name: "code_execution",
  inputSchema: v4.z.object({}).describe("no input parameters"),
  outputSchema: codeExecutionOutputSchema
});
var codeExecution = (args = {}) => codeExecutionToolFactory(args);
var viewImageOutputSchema = v4.z.object({
  description: v4.z.string().describe("description of the image"),
  objects: v4.z.array(v4.z.string()).optional().describe("objects detected in the image")
});
var viewImageToolFactory = chunkSH4PCZ3X_cjs.createProviderDefinedToolFactoryWithOutputSchema({
  id: "xai.view_image",
  name: "view_image",
  inputSchema: v4.z.object({}).describe("no input parameters"),
  outputSchema: viewImageOutputSchema
});
var viewImage = (args = {}) => viewImageToolFactory(args);
var viewXVideoOutputSchema = v4.z.object({
  transcript: v4.z.string().optional().describe("transcript of the video"),
  description: v4.z.string().describe("description of the video content"),
  duration: v4.z.number().optional().describe("duration in seconds")
});
var viewXVideoToolFactory = chunkSH4PCZ3X_cjs.createProviderDefinedToolFactoryWithOutputSchema({
  id: "xai.view_x_video",
  name: "view_x_video",
  inputSchema: v4.z.object({}).describe("no input parameters"),
  outputSchema: viewXVideoOutputSchema
});
var viewXVideo = (args = {}) => viewXVideoToolFactory(args);
var xaiTools = {
  codeExecution,
  viewImage,
  viewXVideo,
  webSearch,
  xSearch
};
var VERSION8 = "2.0.57" ;
var xaiErrorStructure = {
  errorSchema: xaiErrorDataSchema,
  errorToMessage: (data) => data.error.message
};
function createXai(options = {}) {
  var _a15;
  const baseURL = chunkSH4PCZ3X_cjs.withoutTrailingSlash(
    (_a15 = options.baseURL) != null ? _a15 : "https://api.x.ai/v1"
  );
  const getHeaders = () => chunkSH4PCZ3X_cjs.withUserAgentSuffix(
    {
      Authorization: `Bearer ${chunkSH4PCZ3X_cjs.loadApiKey({
        apiKey: options.apiKey,
        environmentVariableName: "XAI_API_KEY",
        description: "xAI API key"
      })}`,
      ...options.headers
    },
    `ai-sdk/xai/${VERSION8}`
  );
  const createChatLanguageModel = (modelId) => {
    return new XaiChatLanguageModel(modelId, {
      provider: "xai.chat",
      baseURL,
      headers: getHeaders,
      generateId: chunkSH4PCZ3X_cjs.generateId,
      fetch: options.fetch
    });
  };
  const createResponsesLanguageModel = (modelId) => {
    return new XaiResponsesLanguageModel(modelId, {
      provider: "xai.responses",
      baseURL,
      headers: getHeaders,
      generateId: chunkSH4PCZ3X_cjs.generateId,
      fetch: options.fetch
    });
  };
  const createImageModel = (modelId) => {
    return new chunkSH4PCZ3X_cjs.OpenAICompatibleImageModel(modelId, {
      provider: "xai.image",
      url: ({ path }) => `${baseURL}${path}`,
      headers: getHeaders,
      fetch: options.fetch,
      errorStructure: xaiErrorStructure
    });
  };
  const provider = (modelId) => createChatLanguageModel(modelId);
  provider.specificationVersion = "v2";
  provider.languageModel = createChatLanguageModel;
  provider.chat = createChatLanguageModel;
  provider.responses = createResponsesLanguageModel;
  provider.textEmbeddingModel = (modelId) => {
    throw new chunkSH4PCZ3X_cjs.NoSuchModelError({ modelId, modelType: "textEmbeddingModel" });
  };
  provider.imageModel = createImageModel;
  provider.image = createImageModel;
  provider.tools = xaiTools;
  return provider;
}
createXai();
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var marker = "vercel.ai.error";
var symbol = Symbol.for(marker);
var _a;
var _AISDKError = class _AISDKError2 extends Error {
  /**
   * Creates an AI SDK Error.
   *
   * @param {Object} params - The parameters for creating the error.
   * @param {string} params.name - The name of the error.
   * @param {string} params.message - The error message.
   * @param {unknown} [params.cause] - The underlying cause of the error.
   */
  constructor({
    name: name14,
    message,
    cause
  }) {
    super(message);
    this[_a] = true;
    this.name = name14;
    this.cause = cause;
  }
  /**
   * Checks if the given error is an AI SDK Error.
   * @param {unknown} error - The error to check.
   * @returns {boolean} True if the error is an AI SDK Error, false otherwise.
   */
  static isInstance(error) {
    return _AISDKError2.hasMarker(error, marker);
  }
  static hasMarker(error, marker15) {
    const markerSymbol = Symbol.for(marker15);
    return error != null && typeof error === "object" && markerSymbol in error && typeof error[markerSymbol] === "boolean" && error[markerSymbol] === true;
  }
};
_a = symbol;
var AISDKError = _AISDKError;
var name = "AI_APICallError";
var marker2 = `vercel.ai.error.${name}`;
var symbol2 = Symbol.for(marker2);
var _a2;
var APICallError2 = class extends AISDKError {
  constructor({
    message,
    url,
    requestBodyValues,
    statusCode,
    responseHeaders,
    responseBody,
    cause,
    isRetryable = statusCode != null && (statusCode === 408 || // request timeout
    statusCode === 409 || // conflict
    statusCode === 429 || // too many requests
    statusCode >= 500),
    // server error
    data
  }) {
    super({ name, message, cause });
    this[_a2] = true;
    this.url = url;
    this.requestBodyValues = requestBodyValues;
    this.statusCode = statusCode;
    this.responseHeaders = responseHeaders;
    this.responseBody = responseBody;
    this.isRetryable = isRetryable;
    this.data = data;
  }
  static isInstance(error) {
    return AISDKError.hasMarker(error, marker2);
  }
};
_a2 = symbol2;
var name2 = "AI_EmptyResponseBodyError";
var marker3 = `vercel.ai.error.${name2}`;
var symbol3 = Symbol.for(marker3);
var _a3;
var EmptyResponseBodyError = class extends AISDKError {
  // used in isInstance
  constructor({ message = "Empty response body" } = {}) {
    super({ name: name2, message });
    this[_a3] = true;
  }
  static isInstance(error) {
    return AISDKError.hasMarker(error, marker3);
  }
};
_a3 = symbol3;
function getErrorMessage(error) {
  if (error == null) {
    return "unknown error";
  }
  if (typeof error === "string") {
    return error;
  }
  if (error instanceof Error) {
    return error.message;
  }
  return JSON.stringify(error);
}
var name3 = "AI_InvalidArgumentError";
var marker4 = `vercel.ai.error.${name3}`;
var symbol4 = Symbol.for(marker4);
var _a4;
var InvalidArgumentError = class extends AISDKError {
  constructor({
    message,
    cause,
    argument
  }) {
    super({ name: name3, message, cause });
    this[_a4] = true;
    this.argument = argument;
  }
  static isInstance(error) {
    return AISDKError.hasMarker(error, marker4);
  }
};
_a4 = symbol4;
var name4 = "AI_InvalidPromptError";
var marker5 = `vercel.ai.error.${name4}`;
var symbol5 = Symbol.for(marker5);
var _a5;
var InvalidPromptError = class extends AISDKError {
  constructor({
    prompt,
    message,
    cause
  }) {
    super({ name: name4, message: `Invalid prompt: ${message}`, cause });
    this[_a5] = true;
    this.prompt = prompt;
  }
  static isInstance(error) {
    return AISDKError.hasMarker(error, marker5);
  }
};
_a5 = symbol5;
var name5 = "AI_InvalidResponseDataError";
var marker6 = `vercel.ai.error.${name5}`;
var symbol6 = Symbol.for(marker6);
var _a6;
var InvalidResponseDataError2 = class extends AISDKError {
  constructor({
    data,
    message = `Invalid response data: ${JSON.stringify(data)}.`
  }) {
    super({ name: name5, message });
    this[_a6] = true;
    this.data = data;
  }
  static isInstance(error) {
    return AISDKError.hasMarker(error, marker6);
  }
};
_a6 = symbol6;
var name6 = "AI_JSONParseError";
var marker7 = `vercel.ai.error.${name6}`;
var symbol7 = Symbol.for(marker7);
var _a7;
var JSONParseError = class extends AISDKError {
  constructor({ text, cause }) {
    super({
      name: name6,
      message: `JSON parsing failed: Text: ${text}.
Error message: ${getErrorMessage(cause)}`,
      cause
    });
    this[_a7] = true;
    this.text = text;
  }
  static isInstance(error) {
    return AISDKError.hasMarker(error, marker7);
  }
};
_a7 = symbol7;
var name7 = "AI_LoadAPIKeyError";
var marker8 = `vercel.ai.error.${name7}`;
var symbol8 = Symbol.for(marker8);
var _a8;
var LoadAPIKeyError = class extends AISDKError {
  // used in isInstance
  constructor({ message }) {
    super({ name: name7, message });
    this[_a8] = true;
  }
  static isInstance(error) {
    return AISDKError.hasMarker(error, marker8);
  }
};
_a8 = symbol8;
var name9 = "AI_NoContentGeneratedError";
var marker10 = `vercel.ai.error.${name9}`;
var symbol10 = Symbol.for(marker10);
var _a10;
var NoContentGeneratedError = class extends AISDKError {
  // used in isInstance
  constructor({
    message = "No content generated."
  } = {}) {
    super({ name: name9, message });
    this[_a10] = true;
  }
  static isInstance(error) {
    return AISDKError.hasMarker(error, marker10);
  }
};
_a10 = symbol10;
var name12 = "AI_TypeValidationError";
var marker13 = `vercel.ai.error.${name12}`;
var symbol13 = Symbol.for(marker13);
var _a13;
var _TypeValidationError = class _TypeValidationError2 extends AISDKError {
  constructor({ value, cause }) {
    super({
      name: name12,
      message: `Type validation failed: Value: ${JSON.stringify(value)}.
Error message: ${getErrorMessage(cause)}`,
      cause
    });
    this[_a13] = true;
    this.value = value;
  }
  static isInstance(error) {
    return AISDKError.hasMarker(error, marker13);
  }
  /**
   * Wraps an error into a TypeValidationError.
   * If the cause is already a TypeValidationError with the same value, it returns the cause.
   * Otherwise, it creates a new TypeValidationError.
   *
   * @param {Object} params - The parameters for wrapping the error.
   * @param {unknown} params.value - The value that failed validation.
   * @param {unknown} params.cause - The original error or cause of the validation failure.
   * @returns {TypeValidationError} A TypeValidationError instance.
   */
  static wrap({
    value,
    cause
  }) {
    return _TypeValidationError2.isInstance(cause) && cause.value === value ? cause : new _TypeValidationError2({ value, cause });
  }
};
_a13 = symbol13;
var TypeValidationError = _TypeValidationError;
var name13 = "AI_UnsupportedFunctionalityError";
var marker14 = `vercel.ai.error.${name13}`;
var symbol14 = Symbol.for(marker14);
var _a14;
var UnsupportedFunctionalityError2 = class extends AISDKError {
  constructor({
    functionality,
    message = `'${functionality}' functionality not supported.`
  }) {
    super({ name: name13, message });
    this[_a14] = true;
    this.functionality = functionality;
  }
  static isInstance(error) {
    return AISDKError.hasMarker(error, marker14);
  }
};
_a14 = symbol14;
var ParseError = class extends Error {
  constructor(message, options) {
    super(message), this.name = "ParseError", this.type = options.type, this.field = options.field, this.value = options.value, this.line = options.line;
  }
};
function noop(_arg) {
}
function createParser(callbacks) {
  if (typeof callbacks == "function")
    throw new TypeError(
      "`callbacks` must be an object, got a function instead. Did you mean `{onEvent: fn}`?"
    );
  const { onEvent = noop, onError = noop, onRetry = noop, onComment } = callbacks;
  let incompleteLine = "", isFirstChunk = true, id, data = "", eventType = "";
  function feed(newChunk) {
    const chunk = isFirstChunk ? newChunk.replace(/^\xEF\xBB\xBF/, "") : newChunk, [complete, incomplete] = splitLines(`${incompleteLine}${chunk}`);
    for (const line of complete)
      parseLine(line);
    incompleteLine = incomplete, isFirstChunk = false;
  }
  function parseLine(line) {
    if (line === "") {
      dispatchEvent();
      return;
    }
    if (line.startsWith(":")) {
      onComment && onComment(line.slice(line.startsWith(": ") ? 2 : 1));
      return;
    }
    const fieldSeparatorIndex = line.indexOf(":");
    if (fieldSeparatorIndex !== -1) {
      const field = line.slice(0, fieldSeparatorIndex), offset = line[fieldSeparatorIndex + 1] === " " ? 2 : 1, value = line.slice(fieldSeparatorIndex + offset);
      processField(field, value, line);
      return;
    }
    processField(line, "", line);
  }
  function processField(field, value, line) {
    switch (field) {
      case "event":
        eventType = value;
        break;
      case "data":
        data = `${data}${value}
`;
        break;
      case "id":
        id = value.includes("\0") ? void 0 : value;
        break;
      case "retry":
        /^\d+$/.test(value) ? onRetry(parseInt(value, 10)) : onError(
          new ParseError(`Invalid \`retry\` value: "${value}"`, {
            type: "invalid-retry",
            value,
            line
          })
        );
        break;
      default:
        onError(
          new ParseError(
            `Unknown field "${field.length > 20 ? `${field.slice(0, 20)}\u2026` : field}"`,
            { type: "unknown-field", field, value, line }
          )
        );
        break;
    }
  }
  function dispatchEvent() {
    data.length > 0 && onEvent({
      id,
      event: eventType || void 0,
      // If the data buffer's last character is a U+000A LINE FEED (LF) character,
      // then remove the last character from the data buffer.
      data: data.endsWith(`
`) ? data.slice(0, -1) : data
    }), id = void 0, data = "", eventType = "";
  }
  function reset(options = {}) {
    incompleteLine && options.consume && parseLine(incompleteLine), isFirstChunk = true, id = void 0, data = "", eventType = "", incompleteLine = "";
  }
  return { feed, reset };
}
function splitLines(chunk) {
  const lines = [];
  let incompleteLine = "", searchIndex = 0;
  for (; searchIndex < chunk.length; ) {
    const crIndex = chunk.indexOf("\r", searchIndex), lfIndex = chunk.indexOf(`
`, searchIndex);
    let lineEnd = -1;
    if (crIndex !== -1 && lfIndex !== -1 ? lineEnd = Math.min(crIndex, lfIndex) : crIndex !== -1 ? lineEnd = crIndex : lfIndex !== -1 && (lineEnd = lfIndex), lineEnd === -1) {
      incompleteLine = chunk.slice(searchIndex);
      break;
    } else {
      const line = chunk.slice(searchIndex, lineEnd);
      lines.push(line), searchIndex = lineEnd + 1, chunk[searchIndex - 1] === "\r" && chunk[searchIndex] === `
` && searchIndex++;
    }
  }
  return [lines, incompleteLine];
}
var EventSourceParserStream = class extends TransformStream {
  constructor({ onError, onRetry, onComment } = {}) {
    let parser;
    super({
      start(controller) {
        parser = createParser({
          onEvent: (event) => {
            controller.enqueue(event);
          },
          onError(error) {
            onError === "terminate" ? controller.error(error) : typeof onError == "function" && onError(error);
          },
          onRetry,
          onComment
        });
      },
      transform(chunk) {
        parser.feed(chunk);
      }
    });
  }
};
new Set("ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvxyz0123456789");
function combineHeaders2(...headers) {
  return headers.reduce(
    (combinedHeaders, currentHeaders) => __spreadValues(__spreadValues({}, combinedHeaders), currentHeaders != null ? currentHeaders : {}),
    {}
  );
}
function extractResponseHeaders2(response) {
  return Object.fromEntries([...response.headers]);
}
var createIdGenerator = ({
  prefix,
  size = 16,
  alphabet = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz",
  separator = "-"
} = {}) => {
  const generator = () => {
    const alphabetLength = alphabet.length;
    const chars = new Array(size);
    for (let i = 0; i < size; i++) {
      chars[i] = alphabet[Math.random() * alphabetLength | 0];
    }
    return chars.join("");
  };
  if (prefix == null) {
    return generator;
  }
  if (alphabet.includes(separator)) {
    throw new InvalidArgumentError({
      argument: "separator",
      message: `The separator "${separator}" must not be part of the alphabet "${alphabet}".`
    });
  }
  return () => `${prefix}${separator}${generator()}`;
};
var generateId2 = createIdGenerator();
function isAbortError(error) {
  return (error instanceof Error || error instanceof DOMException) && (error.name === "AbortError" || error.name === "ResponseAborted" || // Next.js
  error.name === "TimeoutError");
}
var FETCH_FAILED_ERROR_MESSAGES = ["fetch failed", "failed to fetch"];
function handleFetchError({
  error,
  url,
  requestBodyValues
}) {
  if (isAbortError(error)) {
    return error;
  }
  if (error instanceof TypeError && FETCH_FAILED_ERROR_MESSAGES.includes(error.message.toLowerCase())) {
    const cause = error.cause;
    if (cause != null) {
      return new APICallError2({
        message: `Cannot connect to API: ${cause.message}`,
        cause,
        url,
        requestBodyValues,
        isRetryable: true
        // retry when network error
      });
    }
  }
  return error;
}
function removeUndefinedEntries(record) {
  return Object.fromEntries(
    Object.entries(record).filter(([_key, value]) => value != null)
  );
}
function loadApiKey2({
  apiKey,
  environmentVariableName,
  apiKeyParameterName = "apiKey",
  description
}) {
  if (typeof apiKey === "string") {
    return apiKey;
  }
  if (apiKey != null) {
    throw new LoadAPIKeyError({
      message: `${description} API key must be a string.`
    });
  }
  if (typeof process === "undefined") {
    throw new LoadAPIKeyError({
      message: `${description} API key is missing. Pass it using the '${apiKeyParameterName}' parameter. Environment variables is not supported in this environment.`
    });
  }
  apiKey = process.env[environmentVariableName];
  if (apiKey == null) {
    throw new LoadAPIKeyError({
      message: `${description} API key is missing. Pass it using the '${apiKeyParameterName}' parameter or the ${environmentVariableName} environment variable.`
    });
  }
  if (typeof apiKey !== "string") {
    throw new LoadAPIKeyError({
      message: `${description} API key must be a string. The value of the ${environmentVariableName} environment variable is not a string.`
    });
  }
  return apiKey;
}
var suspectProtoRx = /"__proto__"\s*:/;
var suspectConstructorRx = /"constructor"\s*:/;
function _parse(text) {
  const obj = JSON.parse(text);
  if (obj === null || typeof obj !== "object") {
    return obj;
  }
  if (suspectProtoRx.test(text) === false && suspectConstructorRx.test(text) === false) {
    return obj;
  }
  return filter(obj);
}
function filter(obj) {
  let next = [obj];
  while (next.length) {
    const nodes = next;
    next = [];
    for (const node of nodes) {
      if (Object.prototype.hasOwnProperty.call(node, "__proto__")) {
        throw new SyntaxError("Object contains forbidden prototype property");
      }
      if (Object.prototype.hasOwnProperty.call(node, "constructor") && Object.prototype.hasOwnProperty.call(node.constructor, "prototype")) {
        throw new SyntaxError("Object contains forbidden prototype property");
      }
      for (const key in node) {
        const value = node[key];
        if (value && typeof value === "object") {
          next.push(value);
        }
      }
    }
  }
  return obj;
}
function secureJsonParse(text) {
  const { stackTraceLimit } = Error;
  Error.stackTraceLimit = 0;
  try {
    return _parse(text);
  } finally {
    Error.stackTraceLimit = stackTraceLimit;
  }
}
var validatorSymbol = /* @__PURE__ */ Symbol.for("vercel.ai.validator");
function validator(validate) {
  return { [validatorSymbol]: true, validate };
}
function isValidator(value) {
  return typeof value === "object" && value !== null && validatorSymbol in value && value[validatorSymbol] === true && "validate" in value;
}
function asValidator(value) {
  return isValidator(value) ? value : standardSchemaValidator(value);
}
function standardSchemaValidator(standardSchema) {
  return validator(async (value) => {
    const result = await standardSchema["~standard"].validate(value);
    return result.issues == null ? { success: true, value: result.value } : {
      success: false,
      error: new TypeValidationError({
        value,
        cause: result.issues
      })
    };
  });
}
async function validateTypes2({
  value,
  schema
}) {
  const result = await safeValidateTypes({ value, schema });
  if (!result.success) {
    throw TypeValidationError.wrap({ value, cause: result.error });
  }
  return result.value;
}
async function safeValidateTypes({
  value,
  schema
}) {
  const validator2 = asValidator(schema);
  try {
    if (validator2.validate == null) {
      return { success: true, value, rawValue: value };
    }
    const result = await validator2.validate(value);
    if (result.success) {
      return { success: true, value: result.value, rawValue: value };
    }
    return {
      success: false,
      error: TypeValidationError.wrap({ value, cause: result.error }),
      rawValue: value
    };
  } catch (error) {
    return {
      success: false,
      error: TypeValidationError.wrap({ value, cause: error }),
      rawValue: value
    };
  }
}
async function parseJSON({
  text,
  schema
}) {
  try {
    const value = secureJsonParse(text);
    if (schema == null) {
      return value;
    }
    return validateTypes2({ value, schema });
  } catch (error) {
    if (JSONParseError.isInstance(error) || TypeValidationError.isInstance(error)) {
      throw error;
    }
    throw new JSONParseError({ text, cause: error });
  }
}
async function safeParseJSON2({
  text,
  schema
}) {
  try {
    const value = secureJsonParse(text);
    if (schema == null) {
      return { success: true, value, rawValue: value };
    }
    return await safeValidateTypes({ value, schema });
  } catch (error) {
    return {
      success: false,
      error: JSONParseError.isInstance(error) ? error : new JSONParseError({ text, cause: error }),
      rawValue: void 0
    };
  }
}
function isParsableJson2(input) {
  try {
    secureJsonParse(input);
    return true;
  } catch (e) {
    return false;
  }
}
function parseJsonEventStream({
  stream,
  schema
}) {
  return stream.pipeThrough(new TextDecoderStream()).pipeThrough(new EventSourceParserStream()).pipeThrough(
    new TransformStream({
      async transform({ data }, controller) {
        if (data === "[DONE]") {
          return;
        }
        controller.enqueue(await safeParseJSON2({ text: data, schema }));
      }
    })
  );
}
var getOriginalFetch2 = () => globalThis.fetch;
var postJsonToApi2 = async ({
  url,
  headers,
  body,
  failedResponseHandler,
  successfulResponseHandler,
  abortSignal,
  fetch: fetch2
}) => postToApi({
  url,
  headers: __spreadValues({
    "Content-Type": "application/json"
  }, headers),
  body: {
    content: JSON.stringify(body),
    values: body
  },
  failedResponseHandler,
  successfulResponseHandler,
  abortSignal,
  fetch: fetch2
});
var postToApi = async ({
  url,
  headers = {},
  body,
  successfulResponseHandler,
  failedResponseHandler,
  abortSignal,
  fetch: fetch2 = getOriginalFetch2()
}) => {
  try {
    const response = await fetch2(url, {
      method: "POST",
      headers: removeUndefinedEntries(headers),
      body: body.content,
      signal: abortSignal
    });
    const responseHeaders = extractResponseHeaders2(response);
    if (!response.ok) {
      let errorInformation;
      try {
        errorInformation = await failedResponseHandler({
          response,
          url,
          requestBodyValues: body.values
        });
      } catch (error) {
        if (isAbortError(error) || APICallError2.isInstance(error)) {
          throw error;
        }
        throw new APICallError2({
          message: "Failed to process error response",
          cause: error,
          statusCode: response.status,
          url,
          responseHeaders,
          requestBodyValues: body.values
        });
      }
      throw errorInformation.value;
    }
    try {
      return await successfulResponseHandler({
        response,
        url,
        requestBodyValues: body.values
      });
    } catch (error) {
      if (error instanceof Error) {
        if (isAbortError(error) || APICallError2.isInstance(error)) {
          throw error;
        }
      }
      throw new APICallError2({
        message: "Failed to process successful response",
        cause: error,
        statusCode: response.status,
        url,
        responseHeaders,
        requestBodyValues: body.values
      });
    }
  } catch (error) {
    throw handleFetchError({ error, url, requestBodyValues: body.values });
  }
};
var createJsonErrorResponseHandler2 = ({
  errorSchema,
  errorToMessage: errorToMessage2,
  isRetryable
}) => async ({ response, url, requestBodyValues }) => {
  const responseBody = await response.text();
  const responseHeaders = extractResponseHeaders2(response);
  if (responseBody.trim() === "") {
    return {
      responseHeaders,
      value: new APICallError2({
        message: response.statusText,
        url,
        requestBodyValues,
        statusCode: response.status,
        responseHeaders,
        responseBody,
        isRetryable: isRetryable == null ? void 0 : isRetryable(response)
      })
    };
  }
  try {
    const parsedError = await parseJSON({
      text: responseBody,
      schema: errorSchema
    });
    return {
      responseHeaders,
      value: new APICallError2({
        message: errorToMessage2(parsedError),
        url,
        requestBodyValues,
        statusCode: response.status,
        responseHeaders,
        responseBody,
        data: parsedError,
        isRetryable: isRetryable == null ? void 0 : isRetryable(response, parsedError)
      })
    };
  } catch (parseError) {
    return {
      responseHeaders,
      value: new APICallError2({
        message: response.statusText,
        url,
        requestBodyValues,
        statusCode: response.status,
        responseHeaders,
        responseBody,
        isRetryable: isRetryable == null ? void 0 : isRetryable(response)
      })
    };
  }
};
var createEventSourceResponseHandler2 = (chunkSchema) => async ({ response }) => {
  const responseHeaders = extractResponseHeaders2(response);
  if (response.body == null) {
    throw new EmptyResponseBodyError({});
  }
  return {
    responseHeaders,
    value: parseJsonEventStream({
      stream: response.body,
      schema: chunkSchema
    })
  };
};
var createJsonResponseHandler2 = (responseSchema) => async ({ response, url, requestBodyValues }) => {
  const responseBody = await response.text();
  const parsedResult = await safeParseJSON2({
    text: responseBody,
    schema: responseSchema
  });
  const responseHeaders = extractResponseHeaders2(response);
  if (!parsedResult.success) {
    throw new APICallError2({
      message: "Invalid JSON response",
      cause: parsedResult.error,
      statusCode: response.status,
      responseHeaders,
      responseBody,
      url,
      requestBodyValues
    });
  }
  return {
    responseHeaders,
    value: parsedResult.value,
    rawValue: parsedResult.rawValue
  };
};
var { btoa} = globalThis;
function convertUint8ArrayToBase642(array) {
  let latin1string = "";
  for (let i = 0; i < array.length; i++) {
    latin1string += String.fromCodePoint(array[i]);
  }
  return btoa(latin1string);
}
function withoutTrailingSlash2(url) {
  return url == null ? void 0 : url.replace(/\/$/, "");
}
function isDefinedOrNotNull(value) {
  return value !== null && value !== void 0;
}
var ReasoningFormat = /* @__PURE__ */ ((ReasoningFormat2) => {
  ReasoningFormat2["Unknown"] = "unknown";
  ReasoningFormat2["OpenAIResponsesV1"] = "openai-responses-v1";
  ReasoningFormat2["XAIResponsesV1"] = "xai-responses-v1";
  ReasoningFormat2["AnthropicClaudeV1"] = "anthropic-claude-v1";
  return ReasoningFormat2;
})(ReasoningFormat || {});
var CommonReasoningDetailSchema = v4.z.object({
  id: v4.z.string().nullish(),
  format: v4.z.nativeEnum(ReasoningFormat).nullish(),
  index: v4.z.number().optional()
}).passthrough();
var ReasoningDetailSummarySchema = v4.z.object({
  type: v4.z.literal(
    "reasoning.summary"
    /* Summary */
  ),
  summary: v4.z.string()
}).extend(CommonReasoningDetailSchema.shape);
var ReasoningDetailEncryptedSchema = v4.z.object({
  type: v4.z.literal(
    "reasoning.encrypted"
    /* Encrypted */
  ),
  data: v4.z.string()
}).extend(CommonReasoningDetailSchema.shape);
var ReasoningDetailTextSchema = v4.z.object({
  type: v4.z.literal(
    "reasoning.text"
    /* Text */
  ),
  text: v4.z.string().nullish(),
  signature: v4.z.string().nullish()
}).extend(CommonReasoningDetailSchema.shape);
var ReasoningDetailUnionSchema = v4.z.union([
  ReasoningDetailSummarySchema,
  ReasoningDetailEncryptedSchema,
  ReasoningDetailTextSchema
]);
var ReasoningDetailsWithUnknownSchema = v4.z.union([
  ReasoningDetailUnionSchema,
  v4.z.unknown().transform(() => null)
]);
var ReasoningDetailArraySchema = v4.z.array(ReasoningDetailsWithUnknownSchema).transform((d) => d.filter((d2) => !!d2));
v4.z.union([
  v4.z.object({
    delta: v4.z.object({
      reasoning_details: v4.z.array(ReasoningDetailsWithUnknownSchema)
    })
  }).transform(
    (data) => data.delta.reasoning_details.filter(isDefinedOrNotNull)
  ),
  v4.z.object({
    message: v4.z.object({
      reasoning_details: v4.z.array(ReasoningDetailsWithUnknownSchema)
    })
  }).transform(
    (data) => data.message.reasoning_details.filter(isDefinedOrNotNull)
  ),
  v4.z.object({
    text: v4.z.string(),
    reasoning_details: v4.z.array(ReasoningDetailsWithUnknownSchema)
  }).transform((data) => data.reasoning_details.filter(isDefinedOrNotNull))
]);
var OpenRouterErrorResponseSchema = v4.z.object({
  error: v4.z.object({
    code: v4.z.union([v4.z.string(), v4.z.number()]).nullable().optional().default(null),
    message: v4.z.string(),
    type: v4.z.string().nullable().optional().default(null),
    param: v4.z.any().nullable().optional().default(null)
  }).passthrough()
}).passthrough();
var openrouterFailedResponseHandler = createJsonErrorResponseHandler2({
  errorSchema: OpenRouterErrorResponseSchema,
  errorToMessage: (data) => data.error.message
});
var OpenRouterProviderMetadataSchema = v4.z.object({
  provider: v4.z.string(),
  reasoning_details: v4.z.array(ReasoningDetailUnionSchema).optional(),
  usage: v4.z.object({
    promptTokens: v4.z.number(),
    promptTokensDetails: v4.z.object({
      cachedTokens: v4.z.number()
    }).passthrough().optional(),
    completionTokens: v4.z.number(),
    completionTokensDetails: v4.z.object({
      reasoningTokens: v4.z.number()
    }).passthrough().optional(),
    totalTokens: v4.z.number(),
    cost: v4.z.number().optional(),
    costDetails: v4.z.object({
      upstreamInferenceCost: v4.z.number()
    }).passthrough()
  }).passthrough()
}).passthrough();
var OpenRouterProviderOptionsSchema = v4.z.object({
  openrouter: v4.z.object({
    reasoning_details: v4.z.array(ReasoningDetailUnionSchema).optional()
  }).optional()
}).optional();
function mapOpenRouterFinishReason(finishReason) {
  switch (finishReason) {
    case "stop":
      return "stop";
    case "length":
      return "length";
    case "content_filter":
      return "content-filter";
    case "function_call":
    case "tool_calls":
      return "tool-calls";
    default:
      return "unknown";
  }
}
function isUrl({
  url,
  protocols
}) {
  try {
    const urlObj = new URL(url);
    return protocols.has(urlObj.protocol);
  } catch (_) {
    return false;
  }
}
function getFileUrl({
  part,
  defaultMediaType
}) {
  var _a15, _b;
  if (part.data instanceof Uint8Array) {
    const base64 = convertUint8ArrayToBase642(part.data);
    return `data:${(_a15 = part.mediaType) != null ? _a15 : defaultMediaType};base64,${base64}`;
  }
  const stringUrl = part.data.toString();
  if (isUrl({
    url: stringUrl,
    protocols: /* @__PURE__ */ new Set(["http:", "https:"])
  })) {
    return stringUrl;
  }
  return stringUrl.startsWith("data:") ? stringUrl : `data:${(_b = part.mediaType) != null ? _b : defaultMediaType};base64,${stringUrl}`;
}
function getMediaType(dataUrl, defaultMediaType) {
  var _a15;
  const match = dataUrl.match(/^data:([^;]+)/);
  return match ? (_a15 = match[1]) != null ? _a15 : defaultMediaType : defaultMediaType;
}
function getBase64FromDataUrl(dataUrl) {
  const match = dataUrl.match(/^data:[^;]*;base64,(.+)$/);
  return match ? match[1] : dataUrl;
}
function getCacheControl(providerMetadata) {
  var _a15, _b, _c;
  const anthropic = providerMetadata == null ? void 0 : providerMetadata.anthropic;
  const openrouter2 = providerMetadata == null ? void 0 : providerMetadata.openrouter;
  return (_c = (_b = (_a15 = openrouter2 == null ? void 0 : openrouter2.cacheControl) != null ? _a15 : openrouter2 == null ? void 0 : openrouter2.cache_control) != null ? _b : anthropic == null ? void 0 : anthropic.cacheControl) != null ? _c : anthropic == null ? void 0 : anthropic.cache_control;
}
function convertToOpenRouterChatMessages(prompt) {
  var _a15, _b, _c, _d, _e;
  const messages = [];
  for (const { role, content, providerOptions } of prompt) {
    switch (role) {
      case "system": {
        messages.push({
          role: "system",
          content,
          cache_control: getCacheControl(providerOptions)
        });
        break;
      }
      case "user": {
        if (content.length === 1 && ((_a15 = content[0]) == null ? void 0 : _a15.type) === "text") {
          const cacheControl = (_b = getCacheControl(providerOptions)) != null ? _b : getCacheControl(content[0].providerOptions);
          const contentWithCacheControl = cacheControl ? [
            {
              type: "text",
              text: content[0].text,
              cache_control: cacheControl
            }
          ] : content[0].text;
          messages.push({
            role: "user",
            content: contentWithCacheControl
          });
          break;
        }
        const messageCacheControl = getCacheControl(providerOptions);
        const contentParts = content.map(
          (part) => {
            var _a16, _b2, _c2, _d2, _e2, _f;
            const cacheControl = (_a16 = getCacheControl(part.providerOptions)) != null ? _a16 : messageCacheControl;
            switch (part.type) {
              case "text":
                return {
                  type: "text",
                  text: part.text,
                  // For text parts, only use part-specific cache control
                  cache_control: cacheControl
                };
              case "file": {
                if ((_b2 = part.mediaType) == null ? void 0 : _b2.startsWith("image/")) {
                  const url = getFileUrl({
                    part,
                    defaultMediaType: "image/jpeg"
                  });
                  return {
                    type: "image_url",
                    image_url: {
                      url
                    },
                    // For image parts, use part-specific or message-level cache control
                    cache_control: cacheControl
                  };
                }
                const fileName = String(
                  (_f = (_e2 = (_d2 = (_c2 = part.providerOptions) == null ? void 0 : _c2.openrouter) == null ? void 0 : _d2.filename) != null ? _e2 : part.filename) != null ? _f : ""
                );
                const fileData = getFileUrl({
                  part,
                  defaultMediaType: "application/pdf"
                });
                if (isUrl({
                  url: fileData,
                  protocols: /* @__PURE__ */ new Set(["http:", "https:"])
                })) {
                  return {
                    type: "file",
                    file: {
                      filename: fileName,
                      file_data: fileData
                    }
                  };
                }
                return {
                  type: "file",
                  file: {
                    filename: fileName,
                    file_data: fileData
                  },
                  cache_control: cacheControl
                };
              }
              default: {
                return {
                  type: "text",
                  text: "",
                  cache_control: cacheControl
                };
              }
            }
          }
        );
        messages.push({
          role: "user",
          content: contentParts
        });
        break;
      }
      case "assistant": {
        let text = "";
        let reasoning = "";
        const toolCalls = [];
        for (const part of content) {
          switch (part.type) {
            case "text": {
              text += part.text;
              break;
            }
            case "tool-call": {
              toolCalls.push({
                id: part.toolCallId,
                type: "function",
                function: {
                  name: part.toolName,
                  arguments: JSON.stringify(part.input)
                }
              });
              break;
            }
            case "reasoning": {
              reasoning += part.text;
              break;
            }
          }
        }
        const parsedProviderOptions = OpenRouterProviderOptionsSchema.safeParse(providerOptions);
        const preservedReasoningDetails = parsedProviderOptions.success ? (_d = (_c = parsedProviderOptions.data) == null ? void 0 : _c.openrouter) == null ? void 0 : _d.reasoning_details : void 0;
        messages.push({
          role: "assistant",
          content: text,
          tool_calls: toolCalls.length > 0 ? toolCalls : void 0,
          reasoning: reasoning || void 0,
          // Only include reasoning_details if we have the preserved original version
          reasoning_details: preservedReasoningDetails && Array.isArray(preservedReasoningDetails) && preservedReasoningDetails.length > 0 ? preservedReasoningDetails : void 0,
          cache_control: getCacheControl(providerOptions)
        });
        break;
      }
      case "tool": {
        for (const toolResponse of content) {
          const content2 = getToolResultContent(toolResponse);
          messages.push({
            role: "tool",
            tool_call_id: toolResponse.toolCallId,
            content: content2,
            cache_control: (_e = getCacheControl(providerOptions)) != null ? _e : getCacheControl(toolResponse.providerOptions)
          });
        }
        break;
      }
    }
  }
  return messages;
}
function getToolResultContent(input) {
  return input.output.type === "text" ? input.output.value : JSON.stringify(input.output.value);
}
v4.z.union([
  v4.z.literal("auto"),
  v4.z.literal("none"),
  v4.z.literal("required"),
  v4.z.object({
    type: v4.z.literal("function"),
    function: v4.z.object({
      name: v4.z.string()
    })
  })
]);
function getChatCompletionToolChoice(toolChoice) {
  switch (toolChoice.type) {
    case "auto":
    case "none":
    case "required":
      return toolChoice.type;
    case "tool": {
      return {
        type: "function",
        function: { name: toolChoice.toolName }
      };
    }
    default: {
      throw new InvalidArgumentError({
        argument: "toolChoice",
        message: `Invalid tool choice type: ${JSON.stringify(toolChoice)}`
      });
    }
  }
}
var ImageResponseSchema = v4.z.object({
  type: v4.z.literal("image_url"),
  image_url: v4.z.object({
    url: v4.z.string()
  }).passthrough()
}).passthrough();
var ImageResponseWithUnknownSchema = v4.z.union([
  ImageResponseSchema,
  v4.z.unknown().transform(() => null)
]);
var ImageResponseArraySchema = v4.z.array(ImageResponseWithUnknownSchema).transform((d) => d.filter((d2) => !!d2));
var OpenRouterChatCompletionBaseResponseSchema = v4.z.object({
  id: v4.z.string().optional(),
  model: v4.z.string().optional(),
  provider: v4.z.string().optional(),
  usage: v4.z.object({
    prompt_tokens: v4.z.number(),
    prompt_tokens_details: v4.z.object({
      cached_tokens: v4.z.number()
    }).passthrough().nullish(),
    completion_tokens: v4.z.number(),
    completion_tokens_details: v4.z.object({
      reasoning_tokens: v4.z.number()
    }).passthrough().nullish(),
    total_tokens: v4.z.number(),
    cost: v4.z.number().optional(),
    cost_details: v4.z.object({
      upstream_inference_cost: v4.z.number().nullish()
    }).passthrough().nullish()
  }).passthrough().nullish()
}).passthrough();
var OpenRouterNonStreamChatCompletionResponseSchema = v4.z.union([
  // Success response with choices
  OpenRouterChatCompletionBaseResponseSchema.extend({
    choices: v4.z.array(
      v4.z.object({
        message: v4.z.object({
          role: v4.z.literal("assistant"),
          content: v4.z.string().nullable().optional(),
          reasoning: v4.z.string().nullable().optional(),
          reasoning_details: ReasoningDetailArraySchema.nullish(),
          images: ImageResponseArraySchema.nullish(),
          tool_calls: v4.z.array(
            v4.z.object({
              id: v4.z.string().optional().nullable(),
              type: v4.z.literal("function"),
              function: v4.z.object({
                name: v4.z.string(),
                arguments: v4.z.string()
              }).passthrough()
            }).passthrough()
          ).optional(),
          annotations: v4.z.array(
            v4.z.union([
              // URL citation from web search
              v4.z.object({
                type: v4.z.literal("url_citation"),
                url_citation: v4.z.object({
                  end_index: v4.z.number(),
                  start_index: v4.z.number(),
                  title: v4.z.string(),
                  url: v4.z.string(),
                  content: v4.z.string().optional()
                }).passthrough()
              }).passthrough(),
              // File annotation from FileParserPlugin (old format)
              v4.z.object({
                type: v4.z.literal("file_annotation"),
                file_annotation: v4.z.object({
                  file_id: v4.z.string(),
                  quote: v4.z.string().optional()
                }).passthrough()
              }).passthrough(),
              // File annotation from FileParserPlugin (new format)
              v4.z.object({
                type: v4.z.literal("file"),
                file: v4.z.object({
                  hash: v4.z.string(),
                  name: v4.z.string(),
                  content: v4.z.array(
                    v4.z.object({
                      type: v4.z.string(),
                      text: v4.z.string()
                    }).passthrough()
                  ).optional()
                }).passthrough()
              }).passthrough()
            ])
          ).nullish()
        }).passthrough(),
        index: v4.z.number().nullish(),
        logprobs: v4.z.object({
          content: v4.z.array(
            v4.z.object({
              token: v4.z.string(),
              logprob: v4.z.number(),
              top_logprobs: v4.z.array(
                v4.z.object({
                  token: v4.z.string(),
                  logprob: v4.z.number()
                }).passthrough()
              )
            }).passthrough()
          ).nullable()
        }).passthrough().nullable().optional(),
        finish_reason: v4.z.string().optional().nullable()
      }).passthrough()
    )
  }),
  // Error response (HTTP 200 with error payload)
  OpenRouterErrorResponseSchema.extend({
    user_id: v4.z.string().optional()
  })
]);
var OpenRouterStreamChatCompletionChunkSchema = v4.z.union([
  OpenRouterChatCompletionBaseResponseSchema.extend({
    choices: v4.z.array(
      v4.z.object({
        delta: v4.z.object({
          role: v4.z.enum(["assistant"]).optional(),
          content: v4.z.string().nullish(),
          reasoning: v4.z.string().nullish().optional(),
          reasoning_details: ReasoningDetailArraySchema.nullish(),
          images: ImageResponseArraySchema.nullish(),
          tool_calls: v4.z.array(
            v4.z.object({
              index: v4.z.number().nullish(),
              id: v4.z.string().nullish(),
              type: v4.z.literal("function").optional(),
              function: v4.z.object({
                name: v4.z.string().nullish(),
                arguments: v4.z.string().nullish()
              }).passthrough()
            }).passthrough()
          ).nullish(),
          annotations: v4.z.array(
            v4.z.union([
              // URL citation from web search
              v4.z.object({
                type: v4.z.literal("url_citation"),
                url_citation: v4.z.object({
                  end_index: v4.z.number(),
                  start_index: v4.z.number(),
                  title: v4.z.string(),
                  url: v4.z.string(),
                  content: v4.z.string().optional()
                }).passthrough()
              }).passthrough(),
              // File annotation from FileParserPlugin (old format)
              v4.z.object({
                type: v4.z.literal("file_annotation"),
                file_annotation: v4.z.object({
                  file_id: v4.z.string(),
                  quote: v4.z.string().optional()
                }).passthrough()
              }).passthrough(),
              // File annotation from FileParserPlugin (new format)
              v4.z.object({
                type: v4.z.literal("file"),
                file: v4.z.object({
                  hash: v4.z.string(),
                  name: v4.z.string(),
                  content: v4.z.array(
                    v4.z.object({
                      type: v4.z.string(),
                      text: v4.z.string()
                    }).passthrough()
                  ).optional()
                }).passthrough()
              }).passthrough()
            ])
          ).nullish()
        }).passthrough().nullish(),
        logprobs: v4.z.object({
          content: v4.z.array(
            v4.z.object({
              token: v4.z.string(),
              logprob: v4.z.number(),
              top_logprobs: v4.z.array(
                v4.z.object({
                  token: v4.z.string(),
                  logprob: v4.z.number()
                }).passthrough()
              )
            }).passthrough()
          ).nullable()
        }).passthrough().nullish(),
        finish_reason: v4.z.string().nullable().optional(),
        index: v4.z.number().nullish()
      }).passthrough()
    )
  }),
  OpenRouterErrorResponseSchema
]);
var OpenRouterChatLanguageModel = class {
  constructor(modelId, settings, config) {
    this.specificationVersion = "v2";
    this.provider = "openrouter";
    this.defaultObjectGenerationMode = "tool";
    this.supportedUrls = {
      "image/*": [
        /^data:image\/[a-zA-Z]+;base64,/,
        /^https?:\/\/.+\.(jpg|jpeg|png|gif|webp)$/i
      ],
      // 'text/*': [/^data:text\//, /^https?:\/\/.+$/],
      "application/*": [/^data:application\//, /^https?:\/\/.+$/]
    };
    this.modelId = modelId;
    this.settings = settings;
    this.config = config;
  }
  getArgs({
    prompt,
    maxOutputTokens,
    temperature,
    topP,
    frequencyPenalty,
    presencePenalty,
    seed,
    stopSequences,
    responseFormat,
    topK,
    tools,
    toolChoice
  }) {
    var _a15;
    const baseArgs = __spreadValues(__spreadValues({
      // model id:
      model: this.modelId,
      models: this.settings.models,
      // model specific settings:
      logit_bias: this.settings.logitBias,
      logprobs: this.settings.logprobs === true || typeof this.settings.logprobs === "number" ? true : void 0,
      top_logprobs: typeof this.settings.logprobs === "number" ? this.settings.logprobs : typeof this.settings.logprobs === "boolean" ? this.settings.logprobs ? 0 : void 0 : void 0,
      user: this.settings.user,
      parallel_tool_calls: this.settings.parallelToolCalls,
      // standardized settings:
      max_tokens: maxOutputTokens,
      temperature,
      top_p: topP,
      frequency_penalty: frequencyPenalty,
      presence_penalty: presencePenalty,
      seed,
      stop: stopSequences,
      response_format: responseFormat,
      top_k: topK,
      // messages:
      messages: convertToOpenRouterChatMessages(prompt),
      // OpenRouter specific settings:
      include_reasoning: this.settings.includeReasoning,
      reasoning: this.settings.reasoning,
      usage: this.settings.usage,
      // Web search settings:
      plugins: this.settings.plugins,
      web_search_options: this.settings.web_search_options,
      // Provider routing settings:
      provider: this.settings.provider
    }, this.config.extraBody), this.settings.extraBody);
    if ((responseFormat == null ? void 0 : responseFormat.type) === "json" && responseFormat.schema != null) {
      return __spreadProps(__spreadValues({}, baseArgs), {
        response_format: {
          type: "json_schema",
          json_schema: __spreadValues({
            schema: responseFormat.schema,
            strict: true,
            name: (_a15 = responseFormat.name) != null ? _a15 : "response"
          }, responseFormat.description && {
            description: responseFormat.description
          })
        }
      });
    }
    if (tools && tools.length > 0) {
      const mappedTools = tools.filter((tool) => tool.type === "function").map((tool) => ({
        type: "function",
        function: {
          name: tool.name,
          description: tool.description,
          parameters: tool.inputSchema
        }
      }));
      return __spreadProps(__spreadValues({}, baseArgs), {
        tools: mappedTools,
        tool_choice: toolChoice ? getChatCompletionToolChoice(toolChoice) : void 0
      });
    }
    return baseArgs;
  }
  async doGenerate(options) {
    var _a15, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y;
    const providerOptions = options.providerOptions || {};
    const openrouterOptions = providerOptions.openrouter || {};
    const args = __spreadValues(__spreadValues({}, this.getArgs(options)), openrouterOptions);
    const { value: responseValue, responseHeaders } = await postJsonToApi2({
      url: this.config.url({
        path: "/chat/completions",
        modelId: this.modelId
      }),
      headers: combineHeaders2(this.config.headers(), options.headers),
      body: args,
      failedResponseHandler: openrouterFailedResponseHandler,
      successfulResponseHandler: createJsonResponseHandler2(
        OpenRouterNonStreamChatCompletionResponseSchema
      ),
      abortSignal: options.abortSignal,
      fetch: this.config.fetch
    });
    if ("error" in responseValue) {
      const errorData = responseValue.error;
      throw new APICallError2({
        message: errorData.message,
        url: this.config.url({
          path: "/chat/completions",
          modelId: this.modelId
        }),
        requestBodyValues: args,
        statusCode: 200,
        responseHeaders,
        data: errorData
      });
    }
    const response = responseValue;
    const choice = response.choices[0];
    if (!choice) {
      throw new NoContentGeneratedError({
        message: "No choice in response"
      });
    }
    const usageInfo = response.usage ? {
      inputTokens: (_a15 = response.usage.prompt_tokens) != null ? _a15 : 0,
      outputTokens: (_b = response.usage.completion_tokens) != null ? _b : 0,
      totalTokens: ((_c = response.usage.prompt_tokens) != null ? _c : 0) + ((_d = response.usage.completion_tokens) != null ? _d : 0),
      reasoningTokens: (_f = (_e = response.usage.completion_tokens_details) == null ? void 0 : _e.reasoning_tokens) != null ? _f : 0,
      cachedInputTokens: (_h = (_g = response.usage.prompt_tokens_details) == null ? void 0 : _g.cached_tokens) != null ? _h : 0
    } : {
      inputTokens: 0,
      outputTokens: 0,
      totalTokens: 0,
      reasoningTokens: 0,
      cachedInputTokens: 0
    };
    const reasoningDetails = (_i = choice.message.reasoning_details) != null ? _i : [];
    const reasoning = reasoningDetails.length > 0 ? reasoningDetails.map((detail) => {
      switch (detail.type) {
        case "reasoning.text": {
          if (detail.text) {
            return {
              type: "reasoning",
              text: detail.text
            };
          }
          break;
        }
        case "reasoning.summary": {
          if (detail.summary) {
            return {
              type: "reasoning",
              text: detail.summary
            };
          }
          break;
        }
        case "reasoning.encrypted": {
          if (detail.data) {
            return {
              type: "reasoning",
              text: "[REDACTED]"
            };
          }
          break;
        }
      }
      return null;
    }).filter((p) => p !== null) : choice.message.reasoning ? [
      {
        type: "reasoning",
        text: choice.message.reasoning
      }
    ] : [];
    const content = [];
    content.push(...reasoning);
    if (choice.message.content) {
      content.push({
        type: "text",
        text: choice.message.content
      });
    }
    if (choice.message.tool_calls) {
      for (const toolCall of choice.message.tool_calls) {
        content.push({
          type: "tool-call",
          toolCallId: (_j = toolCall.id) != null ? _j : generateId2(),
          toolName: toolCall.function.name,
          input: toolCall.function.arguments
        });
      }
    }
    if (choice.message.images) {
      for (const image of choice.message.images) {
        content.push({
          type: "file",
          mediaType: getMediaType(image.image_url.url, "image/jpeg"),
          data: getBase64FromDataUrl(image.image_url.url)
        });
      }
    }
    if (choice.message.annotations) {
      for (const annotation of choice.message.annotations) {
        if (annotation.type === "url_citation") {
          content.push({
            type: "source",
            sourceType: "url",
            id: annotation.url_citation.url,
            url: annotation.url_citation.url,
            title: annotation.url_citation.title,
            providerMetadata: {
              openrouter: {
                content: annotation.url_citation.content || ""
              }
            }
          });
        }
      }
    }
    return {
      content,
      finishReason: mapOpenRouterFinishReason(choice.finish_reason),
      usage: usageInfo,
      warnings: [],
      providerMetadata: {
        openrouter: OpenRouterProviderMetadataSchema.parse({
          provider: (_k = response.provider) != null ? _k : "",
          reasoning_details: (_l = choice.message.reasoning_details) != null ? _l : [],
          usage: {
            promptTokens: (_m = usageInfo.inputTokens) != null ? _m : 0,
            completionTokens: (_n = usageInfo.outputTokens) != null ? _n : 0,
            totalTokens: (_o = usageInfo.totalTokens) != null ? _o : 0,
            cost: (_p = response.usage) == null ? void 0 : _p.cost,
            promptTokensDetails: {
              cachedTokens: (_s = (_r = (_q = response.usage) == null ? void 0 : _q.prompt_tokens_details) == null ? void 0 : _r.cached_tokens) != null ? _s : 0
            },
            completionTokensDetails: {
              reasoningTokens: (_v = (_u = (_t = response.usage) == null ? void 0 : _t.completion_tokens_details) == null ? void 0 : _u.reasoning_tokens) != null ? _v : 0
            },
            costDetails: {
              upstreamInferenceCost: (_y = (_x = (_w = response.usage) == null ? void 0 : _w.cost_details) == null ? void 0 : _x.upstream_inference_cost) != null ? _y : 0
            }
          }
        })
      },
      request: { body: args },
      response: {
        id: response.id,
        modelId: response.model,
        headers: responseHeaders
      }
    };
  }
  async doStream(options) {
    var _a15;
    const providerOptions = options.providerOptions || {};
    const openrouterOptions = providerOptions.openrouter || {};
    const args = __spreadValues(__spreadValues({}, this.getArgs(options)), openrouterOptions);
    const { value: response, responseHeaders } = await postJsonToApi2({
      url: this.config.url({
        path: "/chat/completions",
        modelId: this.modelId
      }),
      headers: combineHeaders2(this.config.headers(), options.headers),
      body: __spreadProps(__spreadValues({}, args), {
        stream: true,
        // only include stream_options when in strict compatibility mode:
        stream_options: this.config.compatibility === "strict" ? __spreadValues({
          include_usage: true
        }, ((_a15 = this.settings.usage) == null ? void 0 : _a15.include) ? { include_usage: true } : {}) : void 0
      }),
      failedResponseHandler: openrouterFailedResponseHandler,
      successfulResponseHandler: createEventSourceResponseHandler2(
        OpenRouterStreamChatCompletionChunkSchema
      ),
      abortSignal: options.abortSignal,
      fetch: this.config.fetch
    });
    const toolCalls = [];
    let finishReason = "other";
    const usage = {
      inputTokens: Number.NaN,
      outputTokens: Number.NaN,
      totalTokens: Number.NaN,
      reasoningTokens: Number.NaN,
      cachedInputTokens: Number.NaN
    };
    const openrouterUsage = {};
    const accumulatedReasoningDetails = [];
    let textStarted = false;
    let reasoningStarted = false;
    let textId;
    let reasoningId;
    let openrouterResponseId;
    let provider;
    return {
      stream: response.pipeThrough(
        new TransformStream({
          transform(chunk, controller) {
            var _a16, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n;
            if (!chunk.success) {
              finishReason = "error";
              controller.enqueue({ type: "error", error: chunk.error });
              return;
            }
            const value = chunk.value;
            if ("error" in value) {
              finishReason = "error";
              controller.enqueue({ type: "error", error: value.error });
              return;
            }
            if (value.provider) {
              provider = value.provider;
            }
            if (value.id) {
              openrouterResponseId = value.id;
              controller.enqueue({
                type: "response-metadata",
                id: value.id
              });
            }
            if (value.model) {
              controller.enqueue({
                type: "response-metadata",
                modelId: value.model
              });
            }
            if (value.usage != null) {
              usage.inputTokens = value.usage.prompt_tokens;
              usage.outputTokens = value.usage.completion_tokens;
              usage.totalTokens = value.usage.prompt_tokens + value.usage.completion_tokens;
              openrouterUsage.promptTokens = value.usage.prompt_tokens;
              if (value.usage.prompt_tokens_details) {
                const cachedInputTokens = (_a16 = value.usage.prompt_tokens_details.cached_tokens) != null ? _a16 : 0;
                usage.cachedInputTokens = cachedInputTokens;
                openrouterUsage.promptTokensDetails = {
                  cachedTokens: cachedInputTokens
                };
              }
              openrouterUsage.completionTokens = value.usage.completion_tokens;
              if (value.usage.completion_tokens_details) {
                const reasoningTokens = (_b = value.usage.completion_tokens_details.reasoning_tokens) != null ? _b : 0;
                usage.reasoningTokens = reasoningTokens;
                openrouterUsage.completionTokensDetails = {
                  reasoningTokens
                };
              }
              openrouterUsage.cost = value.usage.cost;
              openrouterUsage.totalTokens = value.usage.total_tokens;
            }
            const choice = value.choices[0];
            if ((choice == null ? void 0 : choice.finish_reason) != null) {
              finishReason = mapOpenRouterFinishReason(choice.finish_reason);
            }
            if ((choice == null ? void 0 : choice.delta) == null) {
              return;
            }
            const delta = choice.delta;
            const emitReasoningChunk = (chunkText) => {
              if (!reasoningStarted) {
                reasoningId = openrouterResponseId || generateId2();
                controller.enqueue({
                  type: "reasoning-start",
                  id: reasoningId
                });
                reasoningStarted = true;
              }
              controller.enqueue({
                type: "reasoning-delta",
                delta: chunkText,
                id: reasoningId || generateId2()
              });
            };
            if (delta.reasoning_details && delta.reasoning_details.length > 0) {
              accumulatedReasoningDetails.push(...delta.reasoning_details);
              for (const detail of delta.reasoning_details) {
                switch (detail.type) {
                  case "reasoning.text": {
                    if (detail.text) {
                      emitReasoningChunk(detail.text);
                    }
                    break;
                  }
                  case "reasoning.encrypted": {
                    if (detail.data) {
                      emitReasoningChunk("[REDACTED]");
                    }
                    break;
                  }
                  case "reasoning.summary": {
                    if (detail.summary) {
                      emitReasoningChunk(detail.summary);
                    }
                    break;
                  }
                }
              }
            } else if (delta.reasoning) {
              emitReasoningChunk(delta.reasoning);
            }
            if (delta.content) {
              if (reasoningStarted && !textStarted) {
                controller.enqueue({
                  type: "reasoning-end",
                  id: reasoningId || generateId2()
                });
                reasoningStarted = false;
              }
              if (!textStarted) {
                textId = openrouterResponseId || generateId2();
                controller.enqueue({
                  type: "text-start",
                  id: textId
                });
                textStarted = true;
              }
              controller.enqueue({
                type: "text-delta",
                delta: delta.content,
                id: textId || generateId2()
              });
            }
            if (delta.annotations) {
              for (const annotation of delta.annotations) {
                if (annotation.type === "url_citation") {
                  controller.enqueue({
                    type: "source",
                    sourceType: "url",
                    id: annotation.url_citation.url,
                    url: annotation.url_citation.url,
                    title: annotation.url_citation.title,
                    providerMetadata: {
                      openrouter: {
                        content: annotation.url_citation.content || ""
                      }
                    }
                  });
                }
              }
            }
            if (delta.tool_calls != null) {
              for (const toolCallDelta of delta.tool_calls) {
                const index = (_c = toolCallDelta.index) != null ? _c : toolCalls.length - 1;
                if (toolCalls[index] == null) {
                  if (toolCallDelta.type !== "function") {
                    throw new InvalidResponseDataError2({
                      data: toolCallDelta,
                      message: `Expected 'function' type.`
                    });
                  }
                  if (toolCallDelta.id == null) {
                    throw new InvalidResponseDataError2({
                      data: toolCallDelta,
                      message: `Expected 'id' to be a string.`
                    });
                  }
                  if (((_d = toolCallDelta.function) == null ? void 0 : _d.name) == null) {
                    throw new InvalidResponseDataError2({
                      data: toolCallDelta,
                      message: `Expected 'function.name' to be a string.`
                    });
                  }
                  toolCalls[index] = {
                    id: toolCallDelta.id,
                    type: "function",
                    function: {
                      name: toolCallDelta.function.name,
                      arguments: (_e = toolCallDelta.function.arguments) != null ? _e : ""
                    },
                    inputStarted: false,
                    sent: false
                  };
                  const toolCall2 = toolCalls[index];
                  if (toolCall2 == null) {
                    throw new InvalidResponseDataError2({
                      data: { index, toolCallsLength: toolCalls.length },
                      message: `Tool call at index ${index} is missing after creation.`
                    });
                  }
                  if (((_f = toolCall2.function) == null ? void 0 : _f.name) != null && ((_g = toolCall2.function) == null ? void 0 : _g.arguments) != null && isParsableJson2(toolCall2.function.arguments)) {
                    toolCall2.inputStarted = true;
                    controller.enqueue({
                      type: "tool-input-start",
                      id: toolCall2.id,
                      toolName: toolCall2.function.name
                    });
                    controller.enqueue({
                      type: "tool-input-delta",
                      id: toolCall2.id,
                      delta: toolCall2.function.arguments
                    });
                    controller.enqueue({
                      type: "tool-input-end",
                      id: toolCall2.id
                    });
                    controller.enqueue({
                      type: "tool-call",
                      toolCallId: toolCall2.id,
                      toolName: toolCall2.function.name,
                      input: toolCall2.function.arguments
                    });
                    toolCall2.sent = true;
                  }
                  continue;
                }
                const toolCall = toolCalls[index];
                if (toolCall == null) {
                  throw new InvalidResponseDataError2({
                    data: {
                      index,
                      toolCallsLength: toolCalls.length,
                      toolCallDelta
                    },
                    message: `Tool call at index ${index} is missing during merge.`
                  });
                }
                if (!toolCall.inputStarted) {
                  toolCall.inputStarted = true;
                  controller.enqueue({
                    type: "tool-input-start",
                    id: toolCall.id,
                    toolName: toolCall.function.name
                  });
                }
                if (((_h = toolCallDelta.function) == null ? void 0 : _h.arguments) != null) {
                  toolCall.function.arguments += (_j = (_i = toolCallDelta.function) == null ? void 0 : _i.arguments) != null ? _j : "";
                }
                controller.enqueue({
                  type: "tool-input-delta",
                  id: toolCall.id,
                  delta: (_k = toolCallDelta.function.arguments) != null ? _k : ""
                });
                if (((_l = toolCall.function) == null ? void 0 : _l.name) != null && ((_m = toolCall.function) == null ? void 0 : _m.arguments) != null && isParsableJson2(toolCall.function.arguments)) {
                  controller.enqueue({
                    type: "tool-call",
                    toolCallId: (_n = toolCall.id) != null ? _n : generateId2(),
                    toolName: toolCall.function.name,
                    input: toolCall.function.arguments
                  });
                  toolCall.sent = true;
                }
              }
            }
            if (delta.images != null) {
              for (const image of delta.images) {
                controller.enqueue({
                  type: "file",
                  mediaType: getMediaType(image.image_url.url, "image/jpeg"),
                  data: getBase64FromDataUrl(image.image_url.url)
                });
              }
            }
          },
          flush(controller) {
            var _a16;
            if (finishReason === "tool-calls") {
              for (const toolCall of toolCalls) {
                if (toolCall && !toolCall.sent) {
                  controller.enqueue({
                    type: "tool-call",
                    toolCallId: (_a16 = toolCall.id) != null ? _a16 : generateId2(),
                    toolName: toolCall.function.name,
                    // Coerce invalid arguments to an empty JSON object
                    input: isParsableJson2(toolCall.function.arguments) ? toolCall.function.arguments : "{}"
                  });
                  toolCall.sent = true;
                }
              }
            }
            if (reasoningStarted) {
              controller.enqueue({
                type: "reasoning-end",
                id: reasoningId || generateId2()
              });
            }
            if (textStarted) {
              controller.enqueue({
                type: "text-end",
                id: textId || generateId2()
              });
            }
            const openrouterMetadata = {
              usage: openrouterUsage
            };
            if (provider !== void 0) {
              openrouterMetadata.provider = provider;
            }
            if (accumulatedReasoningDetails.length > 0) {
              openrouterMetadata.reasoning_details = accumulatedReasoningDetails;
            }
            controller.enqueue({
              type: "finish",
              finishReason,
              usage,
              providerMetadata: {
                openrouter: openrouterMetadata
              }
            });
          }
        })
      ),
      warnings: [],
      request: { body: args },
      response: { headers: responseHeaders }
    };
  }
};
function convertToOpenRouterCompletionPrompt({
  prompt,
  inputFormat,
  user = "user",
  assistant = "assistant"
}) {
  if (prompt.length === 1 && prompt[0] && prompt[0].role === "user" && prompt[0].content.length === 1 && prompt[0].content[0] && prompt[0].content[0].type === "text") {
    return { prompt: prompt[0].content[0].text };
  }
  let text = "";
  if (prompt[0] && prompt[0].role === "system") {
    text += `${prompt[0].content}

`;
    prompt = prompt.slice(1);
  }
  for (const { role, content } of prompt) {
    switch (role) {
      case "system": {
        throw new InvalidPromptError({
          message: `Unexpected system message in prompt: ${content}`,
          prompt
        });
      }
      case "user": {
        const userMessage = content.map((part) => {
          switch (part.type) {
            case "text": {
              return part.text;
            }
            case "file": {
              throw new UnsupportedFunctionalityError2({
                functionality: "file attachments"
              });
            }
            default: {
              return "";
            }
          }
        }).join("");
        text += `${user}:
${userMessage}

`;
        break;
      }
      case "assistant": {
        const assistantMessage = content.map(
          (part) => {
            switch (part.type) {
              case "text": {
                return part.text;
              }
              case "tool-call": {
                throw new UnsupportedFunctionalityError2({
                  functionality: "tool-call messages"
                });
              }
              case "tool-result": {
                throw new UnsupportedFunctionalityError2({
                  functionality: "tool-result messages"
                });
              }
              case "reasoning": {
                throw new UnsupportedFunctionalityError2({
                  functionality: "reasoning messages"
                });
              }
              case "file": {
                throw new UnsupportedFunctionalityError2({
                  functionality: "file attachments"
                });
              }
              default: {
                return "";
              }
            }
          }
        ).join("");
        text += `${assistant}:
${assistantMessage}

`;
        break;
      }
      case "tool": {
        throw new UnsupportedFunctionalityError2({
          functionality: "tool messages"
        });
      }
    }
  }
  text += `${assistant}:
`;
  return {
    prompt: text
  };
}
var OpenRouterCompletionChunkSchema = v4.z.union([
  v4.z.object({
    id: v4.z.string().optional(),
    model: v4.z.string().optional(),
    choices: v4.z.array(
      v4.z.object({
        text: v4.z.string(),
        reasoning: v4.z.string().nullish().optional(),
        reasoning_details: ReasoningDetailArraySchema.nullish(),
        finish_reason: v4.z.string().nullish(),
        index: v4.z.number().nullish(),
        logprobs: v4.z.object({
          tokens: v4.z.array(v4.z.string()),
          token_logprobs: v4.z.array(v4.z.number()),
          top_logprobs: v4.z.array(v4.z.record(v4.z.string(), v4.z.number())).nullable()
        }).passthrough().nullable().optional()
      }).passthrough()
    ),
    usage: v4.z.object({
      prompt_tokens: v4.z.number(),
      prompt_tokens_details: v4.z.object({
        cached_tokens: v4.z.number()
      }).passthrough().nullish(),
      completion_tokens: v4.z.number(),
      completion_tokens_details: v4.z.object({
        reasoning_tokens: v4.z.number()
      }).passthrough().nullish(),
      total_tokens: v4.z.number(),
      cost: v4.z.number().optional()
    }).passthrough().nullish()
  }).passthrough(),
  OpenRouterErrorResponseSchema
]);
var OpenRouterCompletionLanguageModel = class {
  constructor(modelId, settings, config) {
    this.specificationVersion = "v2";
    this.provider = "openrouter";
    this.supportedUrls = {
      "image/*": [
        /^data:image\/[a-zA-Z]+;base64,/,
        /^https?:\/\/.+\.(jpg|jpeg|png|gif|webp)$/i
      ],
      "text/*": [/^data:text\//, /^https?:\/\/.+$/],
      "application/*": [/^data:application\//, /^https?:\/\/.+$/]
    };
    this.defaultObjectGenerationMode = void 0;
    this.modelId = modelId;
    this.settings = settings;
    this.config = config;
  }
  getArgs({
    prompt,
    maxOutputTokens,
    temperature,
    topP,
    frequencyPenalty,
    presencePenalty,
    seed,
    responseFormat,
    topK,
    stopSequences,
    tools,
    toolChoice
  }) {
    const { prompt: completionPrompt } = convertToOpenRouterCompletionPrompt({
      prompt,
      inputFormat: "prompt"
    });
    if (tools == null ? void 0 : tools.length) {
      throw new UnsupportedFunctionalityError2({
        functionality: "tools"
      });
    }
    if (toolChoice) {
      throw new UnsupportedFunctionalityError2({
        functionality: "toolChoice"
      });
    }
    return __spreadValues(__spreadValues({
      // model id:
      model: this.modelId,
      models: this.settings.models,
      // model specific settings:
      logit_bias: this.settings.logitBias,
      logprobs: typeof this.settings.logprobs === "number" ? this.settings.logprobs : typeof this.settings.logprobs === "boolean" ? this.settings.logprobs ? 0 : void 0 : void 0,
      suffix: this.settings.suffix,
      user: this.settings.user,
      // standardized settings:
      max_tokens: maxOutputTokens,
      temperature,
      top_p: topP,
      frequency_penalty: frequencyPenalty,
      presence_penalty: presencePenalty,
      seed,
      stop: stopSequences,
      response_format: responseFormat,
      top_k: topK,
      // prompt:
      prompt: completionPrompt,
      // OpenRouter specific settings:
      include_reasoning: this.settings.includeReasoning,
      reasoning: this.settings.reasoning
    }, this.config.extraBody), this.settings.extraBody);
  }
  async doGenerate(options) {
    var _a15, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o;
    const providerOptions = options.providerOptions || {};
    const openrouterOptions = providerOptions.openrouter || {};
    const args = __spreadValues(__spreadValues({}, this.getArgs(options)), openrouterOptions);
    const { value: response, responseHeaders } = await postJsonToApi2({
      url: this.config.url({
        path: "/completions",
        modelId: this.modelId
      }),
      headers: combineHeaders2(this.config.headers(), options.headers),
      body: args,
      failedResponseHandler: openrouterFailedResponseHandler,
      successfulResponseHandler: createJsonResponseHandler2(
        OpenRouterCompletionChunkSchema
      ),
      abortSignal: options.abortSignal,
      fetch: this.config.fetch
    });
    if ("error" in response) {
      const errorData = response.error;
      throw new APICallError2({
        message: errorData.message,
        url: this.config.url({
          path: "/completions",
          modelId: this.modelId
        }),
        requestBodyValues: args,
        statusCode: 200,
        responseHeaders,
        data: errorData
      });
    }
    const choice = response.choices[0];
    if (!choice) {
      throw new NoContentGeneratedError({
        message: "No choice in OpenRouter completion response"
      });
    }
    return {
      content: [
        {
          type: "text",
          text: (_a15 = choice.text) != null ? _a15 : ""
        }
      ],
      finishReason: mapOpenRouterFinishReason(choice.finish_reason),
      usage: {
        inputTokens: (_c = (_b = response.usage) == null ? void 0 : _b.prompt_tokens) != null ? _c : 0,
        outputTokens: (_e = (_d = response.usage) == null ? void 0 : _d.completion_tokens) != null ? _e : 0,
        totalTokens: ((_g = (_f = response.usage) == null ? void 0 : _f.prompt_tokens) != null ? _g : 0) + ((_i = (_h = response.usage) == null ? void 0 : _h.completion_tokens) != null ? _i : 0),
        reasoningTokens: (_l = (_k = (_j = response.usage) == null ? void 0 : _j.completion_tokens_details) == null ? void 0 : _k.reasoning_tokens) != null ? _l : 0,
        cachedInputTokens: (_o = (_n = (_m = response.usage) == null ? void 0 : _m.prompt_tokens_details) == null ? void 0 : _n.cached_tokens) != null ? _o : 0
      },
      warnings: [],
      response: {
        headers: responseHeaders
      }
    };
  }
  async doStream(options) {
    const providerOptions = options.providerOptions || {};
    const openrouterOptions = providerOptions.openrouter || {};
    const args = __spreadValues(__spreadValues({}, this.getArgs(options)), openrouterOptions);
    const { value: response, responseHeaders } = await postJsonToApi2({
      url: this.config.url({
        path: "/completions",
        modelId: this.modelId
      }),
      headers: combineHeaders2(this.config.headers(), options.headers),
      body: __spreadProps(__spreadValues({}, args), {
        stream: true,
        // only include stream_options when in strict compatibility mode:
        stream_options: this.config.compatibility === "strict" ? { include_usage: true } : void 0
      }),
      failedResponseHandler: openrouterFailedResponseHandler,
      successfulResponseHandler: createEventSourceResponseHandler2(
        OpenRouterCompletionChunkSchema
      ),
      abortSignal: options.abortSignal,
      fetch: this.config.fetch
    });
    let finishReason = "other";
    const usage = {
      inputTokens: Number.NaN,
      outputTokens: Number.NaN,
      totalTokens: Number.NaN,
      reasoningTokens: Number.NaN,
      cachedInputTokens: Number.NaN
    };
    const openrouterUsage = {};
    return {
      stream: response.pipeThrough(
        new TransformStream({
          transform(chunk, controller) {
            var _a15, _b;
            if (!chunk.success) {
              finishReason = "error";
              controller.enqueue({ type: "error", error: chunk.error });
              return;
            }
            const value = chunk.value;
            if ("error" in value) {
              finishReason = "error";
              controller.enqueue({ type: "error", error: value.error });
              return;
            }
            if (value.usage != null) {
              usage.inputTokens = value.usage.prompt_tokens;
              usage.outputTokens = value.usage.completion_tokens;
              usage.totalTokens = value.usage.prompt_tokens + value.usage.completion_tokens;
              openrouterUsage.promptTokens = value.usage.prompt_tokens;
              if (value.usage.prompt_tokens_details) {
                const cachedInputTokens = (_a15 = value.usage.prompt_tokens_details.cached_tokens) != null ? _a15 : 0;
                usage.cachedInputTokens = cachedInputTokens;
                openrouterUsage.promptTokensDetails = {
                  cachedTokens: cachedInputTokens
                };
              }
              openrouterUsage.completionTokens = value.usage.completion_tokens;
              if (value.usage.completion_tokens_details) {
                const reasoningTokens = (_b = value.usage.completion_tokens_details.reasoning_tokens) != null ? _b : 0;
                usage.reasoningTokens = reasoningTokens;
                openrouterUsage.completionTokensDetails = {
                  reasoningTokens
                };
              }
              openrouterUsage.cost = value.usage.cost;
              openrouterUsage.totalTokens = value.usage.total_tokens;
            }
            const choice = value.choices[0];
            if ((choice == null ? void 0 : choice.finish_reason) != null) {
              finishReason = mapOpenRouterFinishReason(choice.finish_reason);
            }
            if ((choice == null ? void 0 : choice.text) != null) {
              controller.enqueue({
                type: "text-delta",
                delta: choice.text,
                id: generateId2()
              });
            }
          },
          flush(controller) {
            controller.enqueue({
              type: "finish",
              finishReason,
              usage,
              providerMetadata: {
                openrouter: {
                  usage: openrouterUsage
                }
              }
            });
          }
        })
      ),
      response: {
        headers: responseHeaders
      }
    };
  }
};
function removeUndefinedEntries2(record) {
  return Object.fromEntries(
    Object.entries(record).filter(([, value]) => value !== null)
  );
}
function withUserAgentSuffix2(headers, ...userAgentSuffixParts) {
  const cleanedHeaders = removeUndefinedEntries2(
    headers != null ? headers : {}
  );
  const currentUserAgentHeader = cleanedHeaders["user-agent"] || "";
  const newUserAgent = [currentUserAgentHeader, ...userAgentSuffixParts].filter(Boolean).join(" ");
  return __spreadProps(__spreadValues({}, cleanedHeaders), {
    "user-agent": newUserAgent
  });
}
var VERSION9 = "1.2.3";
function createOpenRouter(options = {}) {
  var _a15, _b, _c;
  const baseURL = (_b = withoutTrailingSlash2((_a15 = options.baseURL) != null ? _a15 : options.baseUrl)) != null ? _b : "https://openrouter.ai/api/v1";
  const compatibility = (_c = options.compatibility) != null ? _c : "compatible";
  const getHeaders = () => withUserAgentSuffix2(
    __spreadValues({
      Authorization: `Bearer ${loadApiKey2({
        apiKey: options.apiKey,
        environmentVariableName: "OPENROUTER_API_KEY",
        description: "OpenRouter"
      })}`
    }, options.headers),
    `ai-sdk/openrouter/${VERSION9}`
  );
  const createChatModel = (modelId, settings = {}) => new OpenRouterChatLanguageModel(modelId, settings, {
    provider: "openrouter.chat",
    url: ({ path }) => `${baseURL}${path}`,
    headers: getHeaders,
    compatibility,
    fetch: options.fetch,
    extraBody: options.extraBody
  });
  const createCompletionModel = (modelId, settings = {}) => new OpenRouterCompletionLanguageModel(modelId, settings, {
    provider: "openrouter.completion",
    url: ({ path }) => `${baseURL}${path}`,
    headers: getHeaders,
    compatibility,
    fetch: options.fetch,
    extraBody: options.extraBody
  });
  const createLanguageModel = (modelId, settings) => {
    if (new.target) {
      throw new Error(
        "The OpenRouter model function cannot be called with the new keyword."
      );
    }
    if (modelId === "openai/gpt-3.5-turbo-instruct") {
      return createCompletionModel(
        modelId,
        settings
      );
    }
    return createChatModel(modelId, settings);
  };
  const provider = (modelId, settings) => createLanguageModel(modelId, settings);
  provider.languageModel = createLanguageModel;
  provider.chat = createChatModel;
  provider.completion = createCompletionModel;
  return provider;
}
createOpenRouter({
  compatibility: "strict"
  // strict for OpenRouter API
});

// src/llm/model/gateway-resolver.ts
function parseModelRouterId(routerId, gatewayPrefix) {
  if (gatewayPrefix && !routerId.startsWith(`${gatewayPrefix}/`)) {
    throw new Error(`Expected ${gatewayPrefix}/ in model router ID ${routerId}`);
  }
  const idParts = routerId.split("/");
  if (gatewayPrefix === "azure-openai") {
    if (idParts.length < 2) {
      throw new Error(`Expected format azure-openai/deployment-name, but got ${routerId}`);
    }
    return {
      providerId: "azure-openai",
      modelId: idParts.slice(1).join("/")
      // Deployment name
    };
  }
  if (gatewayPrefix && idParts.length < 3) {
    throw new Error(
      `Expected atleast 3 id parts ${gatewayPrefix}/provider/model, but only saw ${idParts.length} in ${routerId}`
    );
  }
  const providerId = idParts.at(gatewayPrefix ? 1 : 0);
  const modelId = idParts.slice(gatewayPrefix ? 2 : 1).join(`/`);
  if (!routerId.includes(`/`) || !providerId || !modelId) {
    throw new Error(
      `Attempted to parse provider/model from ${routerId} but this ID doesn't appear to contain a provider`
    );
  }
  return {
    providerId,
    modelId
  };
}

// src/llm/model/gateways/constants.ts
var PROVIDERS_WITH_INSTALLED_PACKAGES = [
  "anthropic",
  "cerebras",
  "deepinfra",
  "deepseek",
  "google",
  "groq",
  "mistral",
  "openai",
  "openrouter",
  "perplexity",
  "togetherai",
  "xai"
];
var EXCLUDED_PROVIDERS = ["github-copilot"];

// src/llm/model/gateways/models-dev.ts
var PROVIDER_OVERRIDES = {
  mistral: {
    url: "https://api.mistral.ai/v1"
  },
  groq: {
    url: "https://api.groq.com/openai/v1"
  },
  vercel: {
    url: "https://ai-gateway.vercel.sh/v1",
    apiKeyEnvVar: "AI_GATEWAY_API_KEY"
  },
  // moonshotai uses Anthropic-compatible API, not OpenAI-compatible
  moonshotai: {
    url: "https://api.moonshot.ai/anthropic/v1",
    npm: "@ai-sdk/anthropic"
  },
  // moonshotai-cn (China version) also uses Anthropic-compatible API
  "moonshotai-cn": {
    url: "https://api.moonshot.cn/anthropic/v1",
    npm: "@ai-sdk/anthropic"
  }
};
var ModelsDevGateway = class extends chunkSH4PCZ3X_cjs.MastraModelGateway {
  id = "models.dev";
  name = "models.dev";
  providerConfigs = {};
  constructor(providerConfigs) {
    super();
    if (providerConfigs) this.providerConfigs = providerConfigs;
  }
  async fetchProviders() {
    const response = await fetch("https://models.dev/api.json");
    if (!response.ok) {
      throw new Error(`Failed to fetch from models.dev: ${response.statusText}`);
    }
    const data = await response.json();
    const providerConfigs = {};
    for (const [providerId, providerInfo] of Object.entries(data)) {
      if (EXCLUDED_PROVIDERS.includes(providerId)) continue;
      if (!providerInfo || typeof providerInfo !== "object" || !providerInfo.models) continue;
      const normalizedId = providerId;
      const isOpenAICompatible = providerInfo.npm === "@ai-sdk/openai-compatible" || providerInfo.npm === "@ai-sdk/gateway" || // Vercel AI Gateway is OpenAI-compatible
      normalizedId in PROVIDER_OVERRIDES;
      const hasInstalledPackage = PROVIDERS_WITH_INSTALLED_PACKAGES.includes(providerId);
      const hasApiAndEnv = providerInfo.api && providerInfo.env && providerInfo.env.length > 0;
      if (isOpenAICompatible || hasInstalledPackage || hasApiAndEnv) {
        const modelIds = Object.entries(providerInfo.models).filter(([, modelInfo]) => modelInfo?.status !== "deprecated").map(([modelId]) => modelId).sort();
        const url = PROVIDER_OVERRIDES[normalizedId]?.url || providerInfo.api;
        if (!hasInstalledPackage && !url) {
          continue;
        }
        const apiKeyEnvVar = providerInfo.env?.[0] || `${normalizedId.toUpperCase().replace(/-/g, "_")}_API_KEY`;
        const apiKeyHeader = !hasInstalledPackage ? PROVIDER_OVERRIDES[normalizedId]?.apiKeyHeader || "Authorization" : void 0;
        providerConfigs[normalizedId] = {
          url,
          apiKeyEnvVar,
          apiKeyHeader,
          name: providerInfo.name || providerId.charAt(0).toUpperCase() + providerId.slice(1),
          models: modelIds,
          docUrl: providerInfo.doc,
          // Include documentation URL if available
          gateway: `models.dev`,
          // Only store npm when it's a non-default SDK (not openai-compatible/gateway) to keep the registry small
          // Overrides take priority (e.g., moonshotai uses @ai-sdk/anthropic, not the openai-compatible listed in models.dev)
          npm: PROVIDER_OVERRIDES[normalizedId]?.npm || (providerInfo.npm && providerInfo.npm !== "@ai-sdk/openai-compatible" && providerInfo.npm !== "@ai-sdk/gateway" ? providerInfo.npm : void 0)
        };
      }
    }
    this.providerConfigs = providerConfigs;
    return providerConfigs;
  }
  buildUrl(routerId, envVars) {
    const { providerId } = parseModelRouterId(routerId);
    const config = this.providerConfigs[providerId];
    if (!config?.url) {
      return;
    }
    const baseUrlEnvVar = `${providerId.toUpperCase().replace(/-/g, "_")}_BASE_URL`;
    const customBaseUrl = envVars?.[baseUrlEnvVar] || process.env[baseUrlEnvVar];
    return customBaseUrl || config.url;
  }
  getApiKey(modelId) {
    const [provider, model] = modelId.split("/");
    if (!provider || !model) {
      throw new Error(`Could not identify provider from model id ${modelId}`);
    }
    const config = this.providerConfigs[provider];
    if (!config) {
      throw new Error(`Could not find config for provider ${provider} with model id ${modelId}`);
    }
    const apiKey = typeof config.apiKeyEnvVar === `string` ? process.env[config.apiKeyEnvVar] : void 0;
    if (!apiKey) {
      throw new Error(`Could not find API key process.env.${config.apiKeyEnvVar} for model id ${modelId}`);
    }
    return Promise.resolve(apiKey);
  }
  async resolveLanguageModel({
    modelId,
    providerId,
    apiKey,
    headers
  }) {
    const baseURL = this.buildUrl(`${providerId}/${modelId}`);
    switch (providerId) {
      case "openai":
        return chunkSH4PCZ3X_cjs.createOpenAI({ apiKey }).responses(modelId);
      case "gemini":
      case "google":
        return chunkSH4PCZ3X_cjs.createGoogleGenerativeAI({
          apiKey
        }).chat(modelId);
      case "anthropic":
        return chunkSH4PCZ3X_cjs.createAnthropic({ apiKey })(modelId);
      case "mistral":
        return createMistral({ apiKey })(modelId);
      case "groq":
        return createGroq({ apiKey })(modelId);
      case "openrouter":
        return createOpenRouter({ apiKey, headers })(modelId);
      case "xai":
        return createXai({
          apiKey
        })(modelId);
      case "deepseek":
        return createDeepSeek({
          apiKey
        })(modelId);
      case "perplexity":
        return createPerplexity({ apiKey })(modelId);
      case "cerebras":
        return createCerebras({ apiKey })(modelId);
      case "togetherai":
        return createTogetherAI({ apiKey })(modelId);
      case "deepinfra":
        return createDeepInfra({ apiKey })(modelId);
      case "moonshotai":
      case "moonshotai-cn": {
        if (!baseURL) throw new Error(`No API URL found for ${providerId}/${modelId}`);
        return chunkSH4PCZ3X_cjs.createAnthropic({ apiKey, baseURL })(modelId);
      }
      default: {
        const config = this.providerConfigs[providerId];
        const npm = config?.npm;
        if (npm === "@ai-sdk/anthropic") {
          if (!baseURL) throw new Error(`No API URL found for ${providerId}/${modelId}`);
          return chunkSH4PCZ3X_cjs.createAnthropic({ apiKey, baseURL })(modelId);
        }
        if (npm === "@ai-sdk/openai") {
          if (!baseURL) throw new Error(`No API URL found for ${providerId}/${modelId}`);
          return chunkSH4PCZ3X_cjs.createOpenAI({ apiKey, baseURL }).chat(modelId);
        }
        if (npm === "@ai-sdk/google") {
          if (!baseURL) throw new Error(`No API URL found for ${providerId}/${modelId}`);
          return chunkSH4PCZ3X_cjs.createGoogleGenerativeAI({ apiKey, baseURL }).chat(modelId);
        }
        if (npm === "@ai-sdk/mistral") {
          if (!baseURL) throw new Error(`No API URL found for ${providerId}/${modelId}`);
          return createMistral({ apiKey, baseURL })(modelId);
        }
        if (!baseURL) throw new Error(`No API URL found for ${providerId}/${modelId}`);
        return chunkSH4PCZ3X_cjs.createOpenAICompatible({ name: providerId, apiKey, baseURL, supportsStructuredOutputs: true }).chatModel(
          modelId
        );
      }
    }
  }
};

exports.ModelsDevGateway = ModelsDevGateway;
exports.parseModelRouterId = parseModelRouterId;
//# sourceMappingURL=chunk-XDD5V446.cjs.map
//# sourceMappingURL=chunk-XDD5V446.cjs.map