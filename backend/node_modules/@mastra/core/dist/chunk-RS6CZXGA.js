import { isZodArray, isZodObject, unwrapZodType, getZodTypeName } from './chunk-S53FKKVL.js';
import { RequestContext, MASTRA_RESOURCE_ID_KEY, MASTRA_THREAD_ID_KEY } from './chunk-CCLV5CAA.js';

// src/tools/validation.ts
var SENSITIVE_KEYS = /* @__PURE__ */ new Set([
  MASTRA_RESOURCE_ID_KEY,
  MASTRA_THREAD_ID_KEY,
  "apiKey",
  "api_key",
  "token",
  "secret",
  "password",
  "credential",
  "authorization"
]);
function redactSensitiveKeys(data) {
  const result = {};
  for (const [key, value] of Object.entries(data)) {
    if (SENSITIVE_KEYS.has(key) || key.toLowerCase().includes("secret") || key.toLowerCase().includes("password")) {
      result[key] = "[REDACTED]";
    } else {
      result[key] = value;
    }
  }
  return result;
}
function truncateForLogging(data, maxLength = 200) {
  try {
    const stringified = JSON.stringify(data, null, 2);
    if (stringified.length <= maxLength) {
      return stringified;
    }
    return stringified.slice(0, maxLength) + "... (truncated)";
  } catch {
    return "[Unable to serialize data]";
  }
}
function validateToolSuspendData(schema, suspendData, toolId) {
  if (!schema || !("safeParse" in schema)) {
    return { data: suspendData };
  }
  const validation = schema.safeParse(suspendData);
  if (validation.success) {
    return { data: validation.data };
  }
  const errorMessages = validation.error.issues.map((e) => `- ${e.path?.join(".") || "root"}: ${e.message}`).join("\n");
  const error = {
    error: true,
    message: `Tool suspension data validation failed${toolId ? ` for ${toolId}` : ""}. Please fix the following errors and try again:
${errorMessages}

Provided arguments: ${truncateForLogging(suspendData)}`,
    validationErrors: validation.error.format()
  };
  return { data: suspendData, error };
}
function normalizeNullishInput(schema, input) {
  if (input !== void 0 && input !== null) {
    return input;
  }
  if (isZodArray(schema)) {
    return [];
  }
  if (isZodObject(schema)) {
    return {};
  }
  return input;
}
function isPlainObject(value) {
  if (value === null || typeof value !== "object") {
    return false;
  }
  const proto = Object.getPrototypeOf(value);
  return proto === Object.prototype || proto === null;
}
function stripNullishValues(input) {
  if (input === null || input === void 0) {
    return void 0;
  }
  if (typeof input !== "object") {
    return input;
  }
  if (Array.isArray(input)) {
    return input.map((item) => item === null ? null : stripNullishValues(item));
  }
  if (!isPlainObject(input)) {
    return input;
  }
  const result = {};
  for (const [key, value] of Object.entries(input)) {
    if (value === null || value === void 0) {
      continue;
    }
    result[key] = stripNullishValues(value);
  }
  return result;
}
function convertUndefinedToNull(input) {
  if (input === void 0) {
    return null;
  }
  if (input === null || typeof input !== "object") {
    return input;
  }
  if (Array.isArray(input)) {
    return input.map(convertUndefinedToNull);
  }
  if (!isPlainObject(input)) {
    return input;
  }
  const result = {};
  for (const [key, value] of Object.entries(input)) {
    result[key] = convertUndefinedToNull(value);
  }
  return result;
}
function coerceStringifiedJsonValues(schema, input) {
  if (!isPlainObject(input)) {
    return input;
  }
  const unwrapped = unwrapZodType(schema);
  if (!isZodObject(unwrapped)) {
    return input;
  }
  const shape = unwrapped.shape;
  if (!shape || typeof shape !== "object") {
    return input;
  }
  let changed = false;
  const result = { ...input };
  for (const [key, value] of Object.entries(input)) {
    if (typeof value !== "string") {
      continue;
    }
    const fieldSchema = shape[key];
    if (!fieldSchema) {
      continue;
    }
    const baseFieldSchema = unwrapZodType(fieldSchema);
    if (getZodTypeName(baseFieldSchema) === "ZodString") {
      continue;
    }
    const trimmed = value.trim();
    if (isZodArray(baseFieldSchema) && trimmed.startsWith("[") || isZodObject(baseFieldSchema) && trimmed.startsWith("{")) {
      try {
        const parsed = JSON.parse(value);
        if (isZodArray(baseFieldSchema) && Array.isArray(parsed) || isZodObject(baseFieldSchema) && isPlainObject(parsed)) {
          result[key] = parsed;
          changed = true;
        }
      } catch {
      }
    }
  }
  return changed ? result : input;
}
function validateToolInput(schema, input, toolId) {
  if (!schema || !("safeParse" in schema)) {
    return { data: input };
  }
  let normalizedInput = normalizeNullishInput(schema, input);
  normalizedInput = convertUndefinedToNull(normalizedInput);
  const validation = schema.safeParse(normalizedInput);
  if (validation.success) {
    return { data: validation.data };
  }
  const coercedInput = coerceStringifiedJsonValues(schema, normalizedInput);
  if (coercedInput !== normalizedInput) {
    const coercedValidation = schema.safeParse(coercedInput);
    if (coercedValidation.success) {
      return { data: coercedValidation.data };
    }
  }
  const strippedInput = stripNullishValues(input);
  const normalizedStripped = normalizeNullishInput(schema, strippedInput);
  const retryValidation = schema.safeParse(normalizedStripped);
  if (retryValidation.success) {
    return { data: retryValidation.data };
  }
  const errorMessages = validation.error.issues.map((e) => `- ${e.path?.join(".") || "root"}: ${e.message}`).join("\n");
  const error = {
    error: true,
    message: `Tool input validation failed${toolId ? ` for ${toolId}` : ""}. Please fix the following errors and try again:
${errorMessages}

Provided arguments: ${truncateForLogging(input)}`,
    validationErrors: validation.error.format()
  };
  return { data: input, error };
}
function validateToolOutput(schema, output, toolId, suspendCalled) {
  if (!schema || !("safeParse" in schema) || suspendCalled) {
    return { data: output };
  }
  const validation = schema.safeParse(output);
  if (validation.success) {
    return { data: validation.data };
  }
  const errorMessages = validation.error.issues.map((e) => `- ${e.path?.join(".") || "root"}: ${e.message}`).join("\n");
  const error = {
    error: true,
    message: `Tool output validation failed${toolId ? ` for ${toolId}` : ""}. The tool returned invalid output:
${errorMessages}

Returned output: ${truncateForLogging(output)}`,
    validationErrors: validation.error.format()
  };
  return { data: output, error };
}
function validateRequestContext(schema, requestContext, identifier) {
  const contextValues = requestContext?.all ?? {};
  if (!schema || !("safeParse" in schema)) {
    return { data: contextValues };
  }
  const validation = schema.safeParse(contextValues);
  if (validation.success) {
    return { data: validation.data };
  }
  const errorMessages = validation.error.issues.map((e) => `- ${e.path?.join(".") || "root"}: ${e.message}`).join("\n");
  const redactedContextValues = redactSensitiveKeys(contextValues);
  const error = {
    error: true,
    message: `Request context validation failed${identifier ? ` for ${identifier}` : ""}. Please fix the following errors and try again:
${errorMessages}

Provided context: ${truncateForLogging(redactedContextValues)}`,
    validationErrors: validation.error.format()
  };
  return { data: contextValues, error };
}

// src/tools/tool.ts
var Tool = class {
  /** Unique identifier for the tool */
  id;
  /** Description of what the tool does */
  description;
  /** Schema for validating input parameters */
  inputSchema;
  /** Schema for validating output structure */
  outputSchema;
  /** Schema for suspend operation data */
  suspendSchema;
  /** Schema for resume operation data */
  resumeSchema;
  /**
   * Schema for validating request context values.
   * When provided, the request context will be validated against this schema before tool execution.
   */
  requestContextSchema;
  /**
   * Tool execution function
   * @param inputData - The raw, validated input data
   * @param context - Optional execution context with metadata
   * @returns Promise resolving to tool output or a ValidationError if input validation fails
   */
  execute;
  /** Parent Mastra instance for accessing shared resources */
  mastra;
  /**
   * Whether the tool requires explicit user approval before execution
   * @example
   * ```typescript
   * // For destructive operations
   * requireApproval: true
   * ```
   */
  requireApproval;
  /**
   * Provider-specific options passed to the model when this tool is used.
   * Keys are provider names (e.g., 'anthropic', 'openai'), values are provider-specific configs.
   * @example
   * ```typescript
   * providerOptions: {
   *   anthropic: {
   *     cacheControl: { type: 'ephemeral' }
   *   }
   * }
   * ```
   */
  providerOptions;
  /**
   * Optional MCP-specific properties including annotations and metadata.
   * Only relevant when the tool is being used in an MCP context.
   * @example
   * ```typescript
   * mcp: {
   *   annotations: {
   *     title: 'Weather Lookup',
   *     readOnlyHint: true,
   *     destructiveHint: false
   *   },
   *   _meta: {
   *     version: '1.0.0',
   *     author: 'team@example.com'
   *   }
   * }
   * ```
   */
  mcp;
  /**
   * Creates a new Tool instance with input validation wrapper.
   *
   * @param opts - Tool configuration and execute function
   * @example
   * ```typescript
   * const tool = new Tool({
   *   id: 'my-tool',
   *   description: 'Does something useful',
   *   inputSchema: z.object({ name: z.string() }),
   *   execute: async (inputData) => ({ greeting: `Hello ${inputData.name}` })
   * });
   * ```
   */
  constructor(opts) {
    this.id = opts.id;
    this.description = opts.description;
    this.inputSchema = opts.inputSchema;
    this.outputSchema = opts.outputSchema;
    this.suspendSchema = opts.suspendSchema;
    this.resumeSchema = opts.resumeSchema;
    this.requestContextSchema = opts.requestContextSchema;
    this.mastra = opts.mastra;
    this.requireApproval = opts.requireApproval || false;
    this.providerOptions = opts.providerOptions;
    this.mcp = opts.mcp;
    if (opts.execute) {
      const originalExecute = opts.execute;
      this.execute = async (inputData, context) => {
        const { data, error } = validateToolInput(this.inputSchema, inputData, this.id);
        if (error) {
          return error;
        }
        const { error: requestContextError } = validateRequestContext(
          this.requestContextSchema,
          context?.requestContext,
          this.id
        );
        if (requestContextError) {
          return requestContextError;
        }
        let suspendData = null;
        const baseContext = context ? {
          ...context,
          ...context.suspend ? {
            suspend: (args, suspendOptions) => {
              suspendData = args;
              return context.suspend?.(args, suspendOptions);
            }
          } : {}
        } : {};
        let organizedContext = baseContext;
        if (!context) {
          organizedContext = {
            requestContext: new RequestContext(),
            mastra: void 0
          };
        } else {
          const isAgentExecution = baseContext.toolCallId && baseContext.messages;
          const isWorkflowExecution = !isAgentExecution && (baseContext.workflow || baseContext.workflowId);
          if (isAgentExecution && !baseContext.agent) {
            const { toolCallId, messages, suspend, resumeData: resumeData2, threadId, resourceId, writableStream, ...rest } = baseContext;
            organizedContext = {
              ...rest,
              agent: {
                toolCallId,
                messages,
                suspend,
                resumeData: resumeData2,
                threadId,
                resourceId,
                writableStream
              },
              // Ensure requestContext is always present
              requestContext: rest.requestContext || new RequestContext()
            };
          } else if (isWorkflowExecution && !baseContext.workflow) {
            const { workflowId, runId, state, setState, suspend, resumeData: resumeData2, ...rest } = baseContext;
            organizedContext = {
              ...rest,
              workflow: {
                workflowId,
                runId,
                state,
                setState,
                suspend,
                resumeData: resumeData2
              },
              // Ensure requestContext is always present
              requestContext: rest.requestContext || new RequestContext()
            };
          } else {
            organizedContext = {
              ...baseContext,
              agent: baseContext.agent ? {
                ...baseContext.agent,
                suspend: (args, suspendOptions) => {
                  suspendData = args;
                  return baseContext.agent?.suspend?.(args, suspendOptions);
                }
              } : baseContext.agent,
              workflow: baseContext.workflow ? {
                ...baseContext.workflow,
                suspend: (args, suspendOptions) => {
                  suspendData = args;
                  return baseContext.workflow?.suspend?.(args, suspendOptions);
                }
              } : baseContext.workflow,
              requestContext: baseContext.requestContext || new RequestContext()
            };
          }
        }
        const resumeData = organizedContext.agent?.resumeData ?? organizedContext.workflow?.resumeData ?? organizedContext?.resumeData;
        if (resumeData) {
          const resumeValidation = validateToolInput(this.resumeSchema, resumeData, this.id);
          if (resumeValidation.error) {
            return resumeValidation.error;
          }
        }
        const output = await originalExecute(data, organizedContext);
        if (suspendData) {
          const suspendValidation = validateToolSuspendData(this.suspendSchema, suspendData, this.id);
          if (suspendValidation.error) {
            return suspendValidation.error;
          }
        }
        const skiptOutputValidation = !!(typeof output === "undefined" && suspendData);
        const outputValidation = validateToolOutput(this.outputSchema, output, this.id, skiptOutputValidation);
        if (outputValidation.error) {
          return outputValidation.error;
        }
        return outputValidation.data;
      };
    }
  }
};
function createTool(opts) {
  return new Tool(opts);
}

// src/tools/toolchecks.ts
function isVercelTool(tool) {
  return !!(tool && !(tool instanceof Tool) && ("parameters" in tool || "execute" in tool && typeof tool.execute === "function" && "inputSchema" in tool));
}

export { Tool, createTool, isVercelTool, validateToolInput, validateToolOutput, validateToolSuspendData };
//# sourceMappingURL=chunk-RS6CZXGA.js.map
//# sourceMappingURL=chunk-RS6CZXGA.js.map