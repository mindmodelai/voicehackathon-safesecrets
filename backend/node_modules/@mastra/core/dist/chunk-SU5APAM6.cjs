'use strict';

var chunkCYUP7QWT_cjs = require('./chunk-CYUP7QWT.cjs');
var chunkBFIOQFGF_cjs = require('./chunk-BFIOQFGF.cjs');
var zod = require('zod');

var createdAtField = zod.z.date().describe("Database record creation time");
var updatedAtField = zod.z.date().describe("Database record last update time");
var dbTimestamps = {
  createdAt: createdAtField,
  updatedAt: updatedAtField.nullable()
};
var paginationArgsSchema = zod.z.object({
  page: zod.z.coerce.number().int().min(0).optional().default(0).describe("Zero-indexed page number"),
  perPage: zod.z.coerce.number().int().min(1).max(100).optional().default(10).describe("Number of items per page")
}).describe("Pagination options for list queries");
var paginationInfoSchema = zod.z.object({
  total: zod.z.number().describe("Total number of items available"),
  page: zod.z.number().describe("Current page"),
  perPage: zod.z.union([zod.z.number(), zod.z.literal(false)]).describe("Number of items per page, or false if pagination is disabled"),
  hasMore: zod.z.boolean().describe("True if more pages are available")
});
var dateRangeSchema = zod.z.object({
  start: zod.z.coerce.date().optional().describe("Start of date range (inclusive by default)"),
  end: zod.z.coerce.date().optional().describe("End of date range (inclusive by default)"),
  startExclusive: zod.z.boolean().optional().describe("When true, excludes the start date from results (uses > instead of >=)"),
  endExclusive: zod.z.boolean().optional().describe("When true, excludes the end date from results (uses < instead of <=)")
}).describe("Date range filter for timestamps");
var sortDirectionSchema = zod.z.enum(["ASC", "DESC"]).describe("Sort direction: 'ASC' | 'DESC'");
var entityTypeField = zod.z.nativeEnum(chunkCYUP7QWT_cjs.EntityType).describe(`Entity type (e.g., 'agent' | 'processor' | 'tool' | 'workflow')`);
var entityIdField = zod.z.string().describe('ID of the entity (e.g., "weatherAgent", "orderWorkflow")');
var entityNameField = zod.z.string().describe("Name of the entity");
var userIdField = zod.z.string().describe("Human end-user who triggered execution");
var organizationIdField = zod.z.string().describe("Multi-tenant organization/account");
var resourceIdField = zod.z.string().describe("Broader resource context (Mastra memory compatibility)");
var runIdField = zod.z.string().describe("Unique execution run identifier");
var sessionIdField = zod.z.string().describe("Session identifier for grouping traces");
var threadIdField = zod.z.string().describe("Conversation thread identifier");
var requestIdField = zod.z.string().describe("HTTP request ID for log correlation");
var environmentField = zod.z.string().describe(`Environment (e.g., "production" | "staging" | "development")`);
var sourceField = zod.z.string().describe(`Source of execution (e.g., "local" | "cloud" | "ci")`);
var serviceNameField = zod.z.string().describe("Name of the service");

// src/evals/types.ts
var scoringSourceSchema = zod.z.enum(["LIVE", "TEST"]);
var scoringEntityTypeSchema = zod.z.enum(["AGENT", "WORKFLOW", ...Object.values(chunkCYUP7QWT_cjs.SpanType)]);
var scoringPromptsSchema = zod.z.object({
  description: zod.z.string(),
  prompt: zod.z.string()
});
var recordSchema = zod.z.record(zod.z.string(), zod.z.unknown());
var optionalRecordSchema = recordSchema.optional();
var scoringInputSchema = zod.z.object({
  runId: zod.z.string().optional(),
  input: zod.z.unknown().optional(),
  output: zod.z.unknown(),
  additionalContext: optionalRecordSchema,
  requestContext: optionalRecordSchema
  // Note: tracingContext is not serializable, so we don't include it in the schema
  // It's added at runtime when needed
});
var scoringHookInputSchema = zod.z.object({
  runId: zod.z.string().optional(),
  scorer: recordSchema,
  input: zod.z.unknown(),
  output: zod.z.unknown(),
  metadata: optionalRecordSchema,
  additionalContext: optionalRecordSchema,
  source: scoringSourceSchema,
  entity: recordSchema,
  entityType: scoringEntityTypeSchema,
  requestContext: optionalRecordSchema,
  structuredOutput: zod.z.boolean().optional(),
  traceId: zod.z.string().optional(),
  spanId: zod.z.string().optional(),
  resourceId: zod.z.string().optional(),
  threadId: zod.z.string().optional()
  // Note: tracingContext is not serializable, so we don't include it in the schema
});
var scoringExtractStepResultSchema = optionalRecordSchema;
var scoringValueSchema = zod.z.number();
var scoreResultSchema = zod.z.object({
  result: optionalRecordSchema,
  score: scoringValueSchema,
  prompt: zod.z.string().optional()
});
var scoringInputWithExtractStepResultSchema = scoringInputSchema.extend({
  runId: zod.z.string(),
  // Required in this context
  extractStepResult: optionalRecordSchema,
  extractPrompt: zod.z.string().optional()
});
var scoringInputWithExtractStepResultAndAnalyzeStepResultSchema = scoringInputWithExtractStepResultSchema.extend({
  score: zod.z.number(),
  analyzeStepResult: optionalRecordSchema,
  analyzePrompt: zod.z.string().optional()
});
var scoringInputWithExtractStepResultAndScoreAndReasonSchema = scoringInputWithExtractStepResultAndAnalyzeStepResultSchema.extend({
  reason: zod.z.string().optional(),
  reasonPrompt: zod.z.string().optional()
});
var scoreRowDataSchema = zod.z.object({
  id: zod.z.string(),
  scorerId: zod.z.string(),
  entityId: zod.z.string(),
  // From ScoringInputWithExtractStepResultAndScoreAndReason
  runId: zod.z.string(),
  input: zod.z.unknown().optional(),
  output: zod.z.unknown(),
  additionalContext: optionalRecordSchema,
  requestContext: optionalRecordSchema,
  extractStepResult: optionalRecordSchema,
  extractPrompt: zod.z.string().optional(),
  score: zod.z.number(),
  analyzeStepResult: optionalRecordSchema,
  analyzePrompt: zod.z.string().optional(),
  reason: zod.z.string().optional(),
  reasonPrompt: zod.z.string().optional(),
  // From ScoringHookInput
  scorer: recordSchema,
  metadata: optionalRecordSchema,
  source: scoringSourceSchema,
  entity: recordSchema,
  entityType: scoringEntityTypeSchema.optional(),
  structuredOutput: zod.z.boolean().optional(),
  traceId: zod.z.string().optional(),
  spanId: zod.z.string().optional(),
  resourceId: zod.z.string().optional(),
  threadId: zod.z.string().optional(),
  // Additional ScoreRowData fields
  preprocessStepResult: optionalRecordSchema,
  preprocessPrompt: zod.z.string().optional(),
  generateScorePrompt: zod.z.string().optional(),
  generateReasonPrompt: zod.z.string().optional(),
  // Timestamps
  ...dbTimestamps
});
var saveScorePayloadSchema = scoreRowDataSchema.omit({
  id: true,
  createdAt: true,
  updatedAt: true
});
var listScoresResponseSchema = zod.z.object({
  pagination: paginationInfoSchema,
  scores: zod.z.array(scoreRowDataSchema)
});

// src/storage/domains/observability/types.ts
var createOmitKeys = (shape) => Object.fromEntries(Object.keys(shape).map((k) => [k, true]));
var traceIdField = zod.z.string().describe("Unique trace identifier");
var spanIdField = zod.z.string().describe("Unique span identifier within a trace");
var spanNameField = zod.z.string().describe("Human-readable span name");
var parentSpanIdField = zod.z.string().describe("Parent span reference (null = root span)");
var spanTypeField = zod.z.nativeEnum(chunkCYUP7QWT_cjs.SpanType).describe("Span type (e.g., WORKFLOW_RUN, AGENT_RUN, TOOL_CALL, etc.)");
var attributesField = zod.z.record(zod.z.unknown()).describe("Span-type specific attributes (e.g., model, tokens, tools)");
var metadataField = zod.z.record(zod.z.unknown()).describe("User-defined metadata for custom filtering");
var tagsField = zod.z.array(zod.z.string()).describe("Labels for filtering traces (only on the root span)");
var scopeField = zod.z.record(zod.z.unknown()).describe('Arbitrary package/app version info (e.g., {"core": "1.0.0", "memory": "1.0.0", "gitSha": "abcd1234"})');
var linksField = zod.z.array(zod.z.unknown()).describe("References to related spans in other traces");
var inputField = zod.z.unknown().describe("Input data passed to the span");
var outputField = zod.z.unknown().describe("Output data returned from the span");
var errorField = zod.z.unknown().describe("Error info - presence indicates failure (status derived from this)");
var isEventField = zod.z.boolean().describe("Whether this is an event (point-in-time) vs a span (duration)");
var startedAtField = zod.z.date().describe("When the span started");
var endedAtField = zod.z.date().describe("When the span ended (null = running, status derived from this)");
var TraceStatus = /* @__PURE__ */ ((TraceStatus2) => {
  TraceStatus2["SUCCESS"] = "success";
  TraceStatus2["ERROR"] = "error";
  TraceStatus2["RUNNING"] = "running";
  return TraceStatus2;
})(TraceStatus || {});
var traceStatusField = zod.z.nativeEnum(TraceStatus).describe("Current status of the trace");
var hasChildErrorField = zod.z.preprocess((v) => {
  if (v === "true") return true;
  if (v === "false") return false;
  return v;
}, zod.z.boolean()).describe("True if any span in the trace encountered an error");
var sharedFields = {
  // Entity identification - first-class fields for filtering (e.g., agent, workflow, tool)
  entityType: entityTypeField.nullish(),
  entityId: entityIdField.nullish(),
  entityName: entityNameField.nullish(),
  // Identity & tenancy - for multi-tenant applications
  userId: userIdField.nullish(),
  organizationId: organizationIdField.nullish(),
  resourceId: resourceIdField.nullish(),
  // Correlation IDs - for linking related operations
  runId: runIdField.nullish(),
  sessionId: sessionIdField.nullish(),
  threadId: threadIdField.nullish(),
  requestId: requestIdField.nullish(),
  // Deployment context - these fields only exist on the root span
  environment: environmentField.nullish(),
  source: sourceField.nullish(),
  serviceName: serviceNameField.nullish(),
  scope: scopeField.nullish(),
  // Filterable data - user-defined metadata and tags (tags only on root span)
  metadata: metadataField.nullish(),
  tags: tagsField.nullish()
};
var spanIds = {
  traceId: traceIdField,
  spanId: spanIdField
};
var spanIdsSchema = zod.z.object({
  ...spanIds
});
var omitDbTimestamps = createOmitKeys(dbTimestamps);
var omitSpanIds = createOmitKeys(spanIds);
var spanRecordSchema = zod.z.object({
  // Required identifiers
  ...spanIds,
  name: spanNameField,
  spanType: spanTypeField,
  isEvent: isEventField,
  startedAt: startedAtField,
  // Shared fields
  parentSpanId: parentSpanIdField.nullish(),
  ...sharedFields,
  // Additional span-specific nullish fields
  attributes: attributesField.nullish(),
  links: linksField.nullish(),
  input: inputField.nullish(),
  output: outputField.nullish(),
  error: errorField.nullish(),
  endedAt: endedAtField.nullish(),
  // Database timestamps
  ...dbTimestamps
}).describe("Span record data");
function computeTraceStatus(span) {
  if (span.error != null) return "error" /* ERROR */;
  if (span.endedAt == null) return "running" /* RUNNING */;
  return "success" /* SUCCESS */;
}
var traceSpanSchema = spanRecordSchema.extend({
  status: traceStatusField
}).describe("Trace span with computed status (root spans only)");
function toTraceSpan(span) {
  return {
    ...span,
    status: computeTraceStatus(span)
  };
}
function toTraceSpans(spans) {
  return spans.map(toTraceSpan);
}
var createSpanRecordSchema = spanRecordSchema.omit(omitDbTimestamps);
var createSpanArgsSchema = zod.z.object({
  span: createSpanRecordSchema
}).describe("Arguments for creating a single span");
var batchCreateSpansArgsSchema = zod.z.object({
  records: zod.z.array(createSpanRecordSchema)
}).describe("Arguments for batch creating spans");
var getSpanArgsSchema = zod.z.object({
  traceId: traceIdField.min(1),
  spanId: spanIdField.min(1)
}).describe("Arguments for getting a single span");
var getSpanResponseSchema = zod.z.object({
  span: spanRecordSchema
});
var getRootSpanArgsSchema = zod.z.object({
  traceId: traceIdField.min(1)
}).describe("Arguments for getting a root span");
var getRootSpanResponseSchema = zod.z.object({
  span: spanRecordSchema
});
var getTraceArgsSchema = zod.z.object({
  traceId: traceIdField.min(1)
}).describe("Arguments for getting a single trace");
var getTraceResponseSchema = zod.z.object({
  traceId: traceIdField,
  spans: zod.z.array(spanRecordSchema)
});
var tracesFilterSchema = zod.z.object({
  // Date range filters
  startedAt: dateRangeSchema.optional().describe("Filter by span start time range"),
  endedAt: dateRangeSchema.optional().describe("Filter by span end time range"),
  // Span type filter
  spanType: spanTypeField.optional(),
  // Shared fields
  ...sharedFields,
  // Filter-specific derived status fields
  status: traceStatusField.optional(),
  hasChildError: hasChildErrorField.optional()
}).describe("Filters for querying traces");
var tracesOrderByFieldSchema = zod.z.enum(["startedAt", "endedAt"]).describe("Field to order by: 'startedAt' | 'endedAt'");
var tracesOrderBySchema = zod.z.object({
  field: tracesOrderByFieldSchema.default("startedAt").describe("Field to order by"),
  direction: sortDirectionSchema.default("DESC").describe("Sort direction")
}).describe("Order by configuration");
var listTracesArgsSchema = zod.z.object({
  filters: tracesFilterSchema.optional().describe("Optional filters to apply"),
  pagination: paginationArgsSchema.default({}).describe("Pagination settings"),
  orderBy: tracesOrderBySchema.default({}).describe("Ordering configuration (defaults to startedAt desc)")
}).describe("Arguments for listing traces");
var listTracesResponseSchema = zod.z.object({
  pagination: paginationInfoSchema,
  spans: zod.z.array(traceSpanSchema)
});
var updateSpanRecordSchema = createSpanRecordSchema.omit(omitSpanIds);
var updateSpanArgsSchema = zod.z.object({
  spanId: spanIdField,
  traceId: traceIdField,
  updates: updateSpanRecordSchema.partial()
}).describe("Arguments for updating a single span");
var batchUpdateSpansArgsSchema = zod.z.object({
  records: zod.z.array(
    zod.z.object({
      traceId: traceIdField,
      spanId: spanIdField,
      updates: updateSpanRecordSchema.partial()
    })
  )
}).describe("Arguments for batch updating spans");
var batchDeleteTracesArgsSchema = zod.z.object({
  traceIds: zod.z.array(traceIdField)
}).describe("Arguments for batch deleting traces");
var listScoresBySpanResponseSchema = zod.z.object({
  pagination: paginationInfoSchema,
  scores: zod.z.array(scoreRowDataSchema)
});
var scoreTracesRequestSchema = zod.z.object({
  scorerName: zod.z.string().min(1),
  targets: zod.z.array(
    zod.z.object({
      traceId: traceIdField,
      spanId: spanIdField.optional()
    })
  ).min(1)
});
var scoreTracesResponseSchema = zod.z.object({
  status: zod.z.string(),
  message: zod.z.string(),
  traceCount: zod.z.number()
});

// src/storage/types.ts
function unwrapSchema(schema) {
  let current = schema;
  let nullable = false;
  while (true) {
    const typeName = chunkBFIOQFGF_cjs.getZodTypeName(current);
    if (!typeName) break;
    if (typeName === "ZodNullable" || typeName === "ZodOptional") {
      nullable = true;
    }
    const inner = chunkBFIOQFGF_cjs.getZodInnerType(current, typeName);
    if (!inner) break;
    current = inner;
  }
  return { base: current, nullable };
}
function getZodChecks(schema) {
  const schemaAny = schema;
  if (schemaAny._zod?.def?.checks) {
    return schemaAny._zod.def.checks;
  }
  if (schemaAny._def?.checks) {
    return schemaAny._def.checks;
  }
  return [];
}
function zodToStorageType(schema) {
  const typeName = chunkBFIOQFGF_cjs.getZodTypeName(schema);
  if (typeName === "ZodString") {
    const checks = getZodChecks(schema);
    if (checks.some((c) => c.kind === "uuid")) {
      return "uuid";
    }
    return "text";
  }
  if (typeName === "ZodNativeEnum" || typeName === "ZodEnum") {
    return "text";
  }
  if (typeName === "ZodNumber") {
    const checks = getZodChecks(schema);
    return checks.some((c) => c.kind === "int") ? "integer" : "float";
  }
  if (typeName === "ZodBigInt") {
    return "bigint";
  }
  if (typeName === "ZodDate") {
    return "timestamp";
  }
  if (typeName === "ZodBoolean") {
    return "boolean";
  }
  return "jsonb";
}
function buildStorageSchema(zObject) {
  const shape = zObject.shape;
  const result = {};
  for (const [key, field] of Object.entries(shape)) {
    const { base, nullable } = unwrapSchema(field);
    result[key] = {
      type: zodToStorageType(base),
      nullable
    };
  }
  return result;
}

// src/storage/constants.ts
var TABLE_WORKFLOW_SNAPSHOT = "mastra_workflow_snapshot";
var TABLE_MESSAGES = "mastra_messages";
var TABLE_THREADS = "mastra_threads";
var TABLE_TRACES = "mastra_traces";
var TABLE_RESOURCES = "mastra_resources";
var TABLE_SCORERS = "mastra_scorers";
var TABLE_SPANS = "mastra_ai_spans";
var TABLE_AGENTS = "mastra_agents";
var TABLE_AGENT_VERSIONS = "mastra_agent_versions";
var TABLE_OBSERVATIONAL_MEMORY = "mastra_observational_memory";
var TABLE_PROMPT_BLOCKS = "mastra_prompt_blocks";
var TABLE_PROMPT_BLOCK_VERSIONS = "mastra_prompt_block_versions";
var TABLE_SCORER_DEFINITIONS = "mastra_scorer_definitions";
var TABLE_SCORER_DEFINITION_VERSIONS = "mastra_scorer_definition_versions";
var TABLE_MCP_CLIENTS = "mastra_mcp_clients";
var TABLE_MCP_CLIENT_VERSIONS = "mastra_mcp_client_versions";
var TABLE_DATASETS = "mastra_datasets";
var TABLE_DATASET_ITEMS = "mastra_dataset_items";
var TABLE_DATASET_VERSIONS = "mastra_dataset_versions";
var TABLE_EXPERIMENTS = "mastra_experiments";
var TABLE_EXPERIMENT_RESULTS = "mastra_experiment_results";
var SCORERS_SCHEMA = {
  id: { type: "text", nullable: false, primaryKey: true },
  scorerId: { type: "text" },
  traceId: { type: "text", nullable: true },
  spanId: { type: "text", nullable: true },
  runId: { type: "text" },
  scorer: { type: "jsonb" },
  preprocessStepResult: { type: "jsonb", nullable: true },
  extractStepResult: { type: "jsonb", nullable: true },
  analyzeStepResult: { type: "jsonb", nullable: true },
  score: { type: "float" },
  reason: { type: "text", nullable: true },
  metadata: { type: "jsonb", nullable: true },
  preprocessPrompt: { type: "text", nullable: true },
  extractPrompt: { type: "text", nullable: true },
  generateScorePrompt: { type: "text", nullable: true },
  generateReasonPrompt: { type: "text", nullable: true },
  analyzePrompt: { type: "text", nullable: true },
  // Deprecated
  reasonPrompt: { type: "text", nullable: true },
  input: { type: "jsonb" },
  output: { type: "jsonb" },
  // MESSAGE OUTPUT
  additionalContext: { type: "jsonb", nullable: true },
  // DATA FROM THE CONTEXT PARAM ON AN AGENT
  requestContext: { type: "jsonb", nullable: true },
  // THE EVALUATE Request Context FOR THE RUN
  /**
   * Things you can evaluate
   */
  entityType: { type: "text", nullable: true },
  // WORKFLOW, AGENT, TOOL, STEP, NETWORK
  entity: { type: "jsonb", nullable: true },
  // MINIMAL JSON DATA ABOUT WORKFLOW, AGENT, TOOL, STEP, NETWORK
  entityId: { type: "text", nullable: true },
  source: { type: "text" },
  resourceId: { type: "text", nullable: true },
  threadId: { type: "text", nullable: true },
  createdAt: { type: "timestamp" },
  updatedAt: { type: "timestamp" }
};
var SPAN_SCHEMA = buildStorageSchema(spanRecordSchema);
var OLD_SPAN_SCHEMA = {
  // Composite primary key of traceId and spanId
  traceId: { type: "text", nullable: false },
  spanId: { type: "text", nullable: false },
  parentSpanId: { type: "text", nullable: true },
  name: { type: "text", nullable: false },
  scope: { type: "jsonb", nullable: true },
  // Mastra package info {"core-version": "0.1.0"}
  spanType: { type: "text", nullable: false },
  // WORKFLOW_RUN, WORKFLOW_STEP, AGENT_RUN, AGENT_STEP, TOOL_RUN, TOOL_STEP, etc.
  attributes: { type: "jsonb", nullable: true },
  metadata: { type: "jsonb", nullable: true },
  links: { type: "jsonb", nullable: true },
  input: { type: "jsonb", nullable: true },
  output: { type: "jsonb", nullable: true },
  error: { type: "jsonb", nullable: true },
  startedAt: { type: "timestamp", nullable: false },
  // When the span started
  endedAt: { type: "timestamp", nullable: true },
  // When the span ended
  createdAt: { type: "timestamp", nullable: false },
  // The time the database record was created
  updatedAt: { type: "timestamp", nullable: true },
  // The time the database record was last updated
  isEvent: { type: "boolean", nullable: false }
};
var AGENTS_SCHEMA = {
  id: { type: "text", nullable: false, primaryKey: true },
  status: { type: "text", nullable: false },
  // 'draft' or 'published'
  activeVersionId: { type: "text", nullable: true },
  // FK to agent_versions.id
  authorId: { type: "text", nullable: true },
  // Author identifier for multi-tenant filtering
  metadata: { type: "jsonb", nullable: true },
  // Additional metadata for the agent
  createdAt: { type: "timestamp", nullable: false },
  updatedAt: { type: "timestamp", nullable: false }
};
var AGENT_VERSIONS_SCHEMA = {
  id: { type: "text", nullable: false, primaryKey: true },
  // UUID
  agentId: { type: "text", nullable: false },
  versionNumber: { type: "integer", nullable: false },
  // Agent config fields
  name: { type: "text", nullable: false },
  // Agent display name
  description: { type: "text", nullable: true },
  instructions: { type: "text", nullable: false },
  model: { type: "jsonb", nullable: false },
  tools: { type: "jsonb", nullable: true },
  defaultOptions: { type: "jsonb", nullable: true },
  workflows: { type: "jsonb", nullable: true },
  agents: { type: "jsonb", nullable: true },
  integrationTools: { type: "jsonb", nullable: true },
  inputProcessors: { type: "jsonb", nullable: true },
  outputProcessors: { type: "jsonb", nullable: true },
  memory: { type: "jsonb", nullable: true },
  scorers: { type: "jsonb", nullable: true },
  mcpClients: { type: "jsonb", nullable: true },
  requestContextSchema: { type: "jsonb", nullable: true },
  // Version metadata
  changedFields: { type: "jsonb", nullable: true },
  // Array of field names
  changeMessage: { type: "text", nullable: true },
  createdAt: { type: "timestamp", nullable: false }
};
var PROMPT_BLOCKS_SCHEMA = {
  id: { type: "text", nullable: false, primaryKey: true },
  status: { type: "text", nullable: false },
  // 'draft', 'published', or 'archived'
  activeVersionId: { type: "text", nullable: true },
  // FK to prompt_block_versions.id
  authorId: { type: "text", nullable: true },
  metadata: { type: "jsonb", nullable: true },
  createdAt: { type: "timestamp", nullable: false },
  updatedAt: { type: "timestamp", nullable: false }
};
var PROMPT_BLOCK_VERSIONS_SCHEMA = {
  id: { type: "text", nullable: false, primaryKey: true },
  blockId: { type: "text", nullable: false },
  versionNumber: { type: "integer", nullable: false },
  name: { type: "text", nullable: false },
  description: { type: "text", nullable: true },
  content: { type: "text", nullable: false },
  rules: { type: "jsonb", nullable: true },
  changedFields: { type: "jsonb", nullable: true },
  changeMessage: { type: "text", nullable: true },
  createdAt: { type: "timestamp", nullable: false }
};
var SCORER_DEFINITIONS_SCHEMA = {
  id: { type: "text", nullable: false, primaryKey: true },
  status: { type: "text", nullable: false },
  // 'draft', 'published', or 'archived'
  activeVersionId: { type: "text", nullable: true },
  // FK to scorer_definition_versions.id
  authorId: { type: "text", nullable: true },
  metadata: { type: "jsonb", nullable: true },
  createdAt: { type: "timestamp", nullable: false },
  updatedAt: { type: "timestamp", nullable: false }
};
var SCORER_DEFINITION_VERSIONS_SCHEMA = {
  id: { type: "text", nullable: false, primaryKey: true },
  scorerDefinitionId: { type: "text", nullable: false },
  versionNumber: { type: "integer", nullable: false },
  name: { type: "text", nullable: false },
  description: { type: "text", nullable: true },
  type: { type: "text", nullable: false },
  // 'llm-judge', 'bias', 'toxicity', etc.
  model: { type: "jsonb", nullable: true },
  instructions: { type: "text", nullable: true },
  scoreRange: { type: "jsonb", nullable: true },
  presetConfig: { type: "jsonb", nullable: true },
  defaultSampling: { type: "jsonb", nullable: true },
  changedFields: { type: "jsonb", nullable: true },
  changeMessage: { type: "text", nullable: true },
  createdAt: { type: "timestamp", nullable: false }
};
var MCP_CLIENTS_SCHEMA = {
  id: { type: "text", nullable: false, primaryKey: true },
  status: { type: "text", nullable: false },
  // 'draft', 'published', or 'archived'
  activeVersionId: { type: "text", nullable: true },
  // FK to mcp_client_versions.id
  authorId: { type: "text", nullable: true },
  metadata: { type: "jsonb", nullable: true },
  createdAt: { type: "timestamp", nullable: false },
  updatedAt: { type: "timestamp", nullable: false }
};
var MCP_CLIENT_VERSIONS_SCHEMA = {
  id: { type: "text", nullable: false, primaryKey: true },
  mcpClientId: { type: "text", nullable: false },
  versionNumber: { type: "integer", nullable: false },
  name: { type: "text", nullable: false },
  description: { type: "text", nullable: true },
  servers: { type: "jsonb", nullable: false },
  changedFields: { type: "jsonb", nullable: true },
  changeMessage: { type: "text", nullable: true },
  createdAt: { type: "timestamp", nullable: false }
};
var OBSERVATIONAL_MEMORY_SCHEMA = {
  id: { type: "text", nullable: false, primaryKey: true },
  lookupKey: { type: "text", nullable: false },
  // 'resource:{resourceId}' or 'thread:{threadId}'
  scope: { type: "text", nullable: false },
  // 'resource' or 'thread'
  resourceId: { type: "text", nullable: true },
  threadId: { type: "text", nullable: true },
  activeObservations: { type: "text", nullable: false },
  // JSON array of observations
  activeObservationsPendingUpdate: { type: "text", nullable: true },
  // JSON array, used during updates
  originType: { type: "text", nullable: false },
  // 'initialization', 'observation', or 'reflection'
  config: { type: "text", nullable: false },
  // JSON object
  generationCount: { type: "integer", nullable: false },
  lastObservedAt: { type: "timestamp", nullable: true },
  lastReflectionAt: { type: "timestamp", nullable: true },
  pendingMessageTokens: { type: "integer", nullable: false },
  // Token count
  totalTokensObserved: { type: "integer", nullable: false },
  // Running total of all observed tokens
  observationTokenCount: { type: "integer", nullable: false },
  // Current observation size in tokens
  isObserving: { type: "boolean", nullable: false },
  isReflecting: { type: "boolean", nullable: false },
  observedMessageIds: { type: "jsonb", nullable: true },
  // JSON array of message IDs already observed
  observedTimezone: { type: "text", nullable: true },
  // Timezone used for Observer date formatting (e.g., "America/Los_Angeles")
  // Async buffering columns
  bufferedObservations: { type: "text", nullable: true },
  // JSON string of buffered observation content
  bufferedObservationTokens: { type: "integer", nullable: true },
  // Token count of buffered observations
  bufferedMessageIds: { type: "jsonb", nullable: true },
  // JSON array of message IDs in the buffer
  bufferedReflection: { type: "text", nullable: true },
  // JSON string of buffered reflection content
  bufferedReflectionTokens: { type: "integer", nullable: true },
  // Token count of buffered reflection (post-compression)
  bufferedReflectionInputTokens: { type: "integer", nullable: true },
  // Token count of observations fed to reflector (pre-compression)
  reflectedObservationLineCount: { type: "integer", nullable: true },
  // Number of observation lines that were reflected on during async buffering
  bufferedObservationChunks: { type: "jsonb", nullable: true },
  // JSON array of BufferedObservationChunk objects
  isBufferingObservation: { type: "boolean", nullable: false },
  isBufferingReflection: { type: "boolean", nullable: false },
  lastBufferedAtTokens: { type: "integer", nullable: false },
  lastBufferedAtTime: { type: "timestamp", nullable: true },
  createdAt: { type: "timestamp", nullable: false },
  updatedAt: { type: "timestamp", nullable: false }
};
var DATASETS_SCHEMA = {
  id: { type: "text", nullable: false, primaryKey: true },
  name: { type: "text", nullable: false },
  description: { type: "text", nullable: true },
  metadata: { type: "jsonb", nullable: true },
  inputSchema: { type: "jsonb", nullable: true },
  groundTruthSchema: { type: "jsonb", nullable: true },
  version: { type: "integer", nullable: false },
  createdAt: { type: "timestamp", nullable: false },
  updatedAt: { type: "timestamp", nullable: false }
};
var DATASET_ITEMS_SCHEMA = {
  id: { type: "text", nullable: false },
  datasetId: { type: "text", nullable: false, references: { table: "mastra_datasets", column: "id" } },
  datasetVersion: { type: "integer", nullable: false },
  validTo: { type: "integer", nullable: true },
  isDeleted: { type: "boolean", nullable: false },
  input: { type: "jsonb", nullable: false },
  groundTruth: { type: "jsonb", nullable: true },
  metadata: { type: "jsonb", nullable: true },
  createdAt: { type: "timestamp", nullable: false },
  updatedAt: { type: "timestamp", nullable: false }
};
var DATASET_VERSIONS_SCHEMA = {
  id: { type: "text", nullable: false, primaryKey: true },
  datasetId: { type: "text", nullable: false, references: { table: "mastra_datasets", column: "id" } },
  version: { type: "integer", nullable: false },
  createdAt: { type: "timestamp", nullable: false }
};
var EXPERIMENTS_SCHEMA = {
  id: { type: "text", nullable: false, primaryKey: true },
  name: { type: "text", nullable: true },
  description: { type: "text", nullable: true },
  metadata: { type: "jsonb", nullable: true },
  datasetId: { type: "text", nullable: true, references: { table: "mastra_datasets", column: "id" } },
  datasetVersion: { type: "integer", nullable: true },
  targetType: { type: "text", nullable: false },
  targetId: { type: "text", nullable: false },
  status: { type: "text", nullable: false },
  totalItems: { type: "integer", nullable: false },
  succeededCount: { type: "integer", nullable: false },
  failedCount: { type: "integer", nullable: false },
  skippedCount: { type: "integer", nullable: false },
  startedAt: { type: "timestamp", nullable: true },
  completedAt: { type: "timestamp", nullable: true },
  createdAt: { type: "timestamp", nullable: false },
  updatedAt: { type: "timestamp", nullable: false }
};
var EXPERIMENT_RESULTS_SCHEMA = {
  id: { type: "text", nullable: false, primaryKey: true },
  experimentId: { type: "text", nullable: false, references: { table: "mastra_experiments", column: "id" } },
  itemId: { type: "text", nullable: false, references: { table: "mastra_dataset_items", column: "id" } },
  itemDatasetVersion: { type: "integer", nullable: true },
  input: { type: "jsonb", nullable: false },
  output: { type: "jsonb", nullable: true },
  groundTruth: { type: "jsonb", nullable: true },
  error: { type: "jsonb", nullable: true },
  startedAt: { type: "timestamp", nullable: false },
  completedAt: { type: "timestamp", nullable: false },
  retryCount: { type: "integer", nullable: false },
  traceId: { type: "text", nullable: true },
  createdAt: { type: "timestamp", nullable: false }
};
var TABLE_SCHEMAS = {
  [TABLE_WORKFLOW_SNAPSHOT]: {
    workflow_name: {
      type: "text"
    },
    run_id: {
      type: "text"
    },
    resourceId: { type: "text", nullable: true },
    snapshot: {
      type: "jsonb"
    },
    createdAt: {
      type: "timestamp"
    },
    updatedAt: {
      type: "timestamp"
    }
  },
  [TABLE_SCORERS]: SCORERS_SCHEMA,
  [TABLE_THREADS]: {
    id: { type: "text", nullable: false, primaryKey: true },
    resourceId: { type: "text", nullable: false },
    title: { type: "text", nullable: false },
    metadata: { type: "jsonb", nullable: true },
    createdAt: { type: "timestamp", nullable: false },
    updatedAt: { type: "timestamp", nullable: false }
  },
  [TABLE_MESSAGES]: {
    id: { type: "text", nullable: false, primaryKey: true },
    thread_id: { type: "text", nullable: false },
    content: { type: "text", nullable: false },
    role: { type: "text", nullable: false },
    type: { type: "text", nullable: false },
    createdAt: { type: "timestamp", nullable: false },
    resourceId: { type: "text", nullable: true }
  },
  [TABLE_SPANS]: SPAN_SCHEMA,
  [TABLE_TRACES]: {
    id: { type: "text", nullable: false, primaryKey: true },
    parentSpanId: { type: "text", nullable: true },
    name: { type: "text", nullable: false },
    traceId: { type: "text", nullable: false },
    scope: { type: "text", nullable: false },
    kind: { type: "integer", nullable: false },
    attributes: { type: "jsonb", nullable: true },
    status: { type: "jsonb", nullable: true },
    events: { type: "jsonb", nullable: true },
    links: { type: "jsonb", nullable: true },
    other: { type: "text", nullable: true },
    startTime: { type: "bigint", nullable: false },
    endTime: { type: "bigint", nullable: false },
    createdAt: { type: "timestamp", nullable: false }
  },
  [TABLE_RESOURCES]: {
    id: { type: "text", nullable: false, primaryKey: true },
    workingMemory: { type: "text", nullable: true },
    metadata: { type: "jsonb", nullable: true },
    createdAt: { type: "timestamp", nullable: false },
    updatedAt: { type: "timestamp", nullable: false }
  },
  [TABLE_AGENTS]: AGENTS_SCHEMA,
  [TABLE_AGENT_VERSIONS]: AGENT_VERSIONS_SCHEMA,
  [TABLE_PROMPT_BLOCKS]: PROMPT_BLOCKS_SCHEMA,
  [TABLE_PROMPT_BLOCK_VERSIONS]: PROMPT_BLOCK_VERSIONS_SCHEMA,
  [TABLE_SCORER_DEFINITIONS]: SCORER_DEFINITIONS_SCHEMA,
  [TABLE_SCORER_DEFINITION_VERSIONS]: SCORER_DEFINITION_VERSIONS_SCHEMA,
  [TABLE_MCP_CLIENTS]: MCP_CLIENTS_SCHEMA,
  [TABLE_MCP_CLIENT_VERSIONS]: MCP_CLIENT_VERSIONS_SCHEMA,
  [TABLE_DATASETS]: DATASETS_SCHEMA,
  [TABLE_DATASET_ITEMS]: DATASET_ITEMS_SCHEMA,
  [TABLE_DATASET_VERSIONS]: DATASET_VERSIONS_SCHEMA,
  [TABLE_EXPERIMENTS]: EXPERIMENTS_SCHEMA,
  [TABLE_EXPERIMENT_RESULTS]: EXPERIMENT_RESULTS_SCHEMA
};
var TABLE_CONFIGS = {
  [TABLE_DATASET_ITEMS]: { columns: DATASET_ITEMS_SCHEMA, compositePrimaryKey: ["id", "datasetVersion"] }
};
var OBSERVATIONAL_MEMORY_TABLE_SCHEMA = {
  [TABLE_OBSERVATIONAL_MEMORY]: OBSERVATIONAL_MEMORY_SCHEMA
};

exports.AGENTS_SCHEMA = AGENTS_SCHEMA;
exports.AGENT_VERSIONS_SCHEMA = AGENT_VERSIONS_SCHEMA;
exports.DATASETS_SCHEMA = DATASETS_SCHEMA;
exports.DATASET_ITEMS_SCHEMA = DATASET_ITEMS_SCHEMA;
exports.DATASET_VERSIONS_SCHEMA = DATASET_VERSIONS_SCHEMA;
exports.EXPERIMENTS_SCHEMA = EXPERIMENTS_SCHEMA;
exports.EXPERIMENT_RESULTS_SCHEMA = EXPERIMENT_RESULTS_SCHEMA;
exports.MCP_CLIENTS_SCHEMA = MCP_CLIENTS_SCHEMA;
exports.MCP_CLIENT_VERSIONS_SCHEMA = MCP_CLIENT_VERSIONS_SCHEMA;
exports.OBSERVATIONAL_MEMORY_SCHEMA = OBSERVATIONAL_MEMORY_SCHEMA;
exports.OBSERVATIONAL_MEMORY_TABLE_SCHEMA = OBSERVATIONAL_MEMORY_TABLE_SCHEMA;
exports.OLD_SPAN_SCHEMA = OLD_SPAN_SCHEMA;
exports.PROMPT_BLOCKS_SCHEMA = PROMPT_BLOCKS_SCHEMA;
exports.PROMPT_BLOCK_VERSIONS_SCHEMA = PROMPT_BLOCK_VERSIONS_SCHEMA;
exports.SCORERS_SCHEMA = SCORERS_SCHEMA;
exports.SCORER_DEFINITIONS_SCHEMA = SCORER_DEFINITIONS_SCHEMA;
exports.SCORER_DEFINITION_VERSIONS_SCHEMA = SCORER_DEFINITION_VERSIONS_SCHEMA;
exports.SPAN_SCHEMA = SPAN_SCHEMA;
exports.TABLE_AGENTS = TABLE_AGENTS;
exports.TABLE_AGENT_VERSIONS = TABLE_AGENT_VERSIONS;
exports.TABLE_CONFIGS = TABLE_CONFIGS;
exports.TABLE_DATASETS = TABLE_DATASETS;
exports.TABLE_DATASET_ITEMS = TABLE_DATASET_ITEMS;
exports.TABLE_DATASET_VERSIONS = TABLE_DATASET_VERSIONS;
exports.TABLE_EXPERIMENTS = TABLE_EXPERIMENTS;
exports.TABLE_EXPERIMENT_RESULTS = TABLE_EXPERIMENT_RESULTS;
exports.TABLE_MCP_CLIENTS = TABLE_MCP_CLIENTS;
exports.TABLE_MCP_CLIENT_VERSIONS = TABLE_MCP_CLIENT_VERSIONS;
exports.TABLE_MESSAGES = TABLE_MESSAGES;
exports.TABLE_OBSERVATIONAL_MEMORY = TABLE_OBSERVATIONAL_MEMORY;
exports.TABLE_PROMPT_BLOCKS = TABLE_PROMPT_BLOCKS;
exports.TABLE_PROMPT_BLOCK_VERSIONS = TABLE_PROMPT_BLOCK_VERSIONS;
exports.TABLE_RESOURCES = TABLE_RESOURCES;
exports.TABLE_SCHEMAS = TABLE_SCHEMAS;
exports.TABLE_SCORERS = TABLE_SCORERS;
exports.TABLE_SCORER_DEFINITIONS = TABLE_SCORER_DEFINITIONS;
exports.TABLE_SCORER_DEFINITION_VERSIONS = TABLE_SCORER_DEFINITION_VERSIONS;
exports.TABLE_SPANS = TABLE_SPANS;
exports.TABLE_THREADS = TABLE_THREADS;
exports.TABLE_TRACES = TABLE_TRACES;
exports.TABLE_WORKFLOW_SNAPSHOT = TABLE_WORKFLOW_SNAPSHOT;
exports.TraceStatus = TraceStatus;
exports.batchCreateSpansArgsSchema = batchCreateSpansArgsSchema;
exports.batchDeleteTracesArgsSchema = batchDeleteTracesArgsSchema;
exports.batchUpdateSpansArgsSchema = batchUpdateSpansArgsSchema;
exports.buildStorageSchema = buildStorageSchema;
exports.computeTraceStatus = computeTraceStatus;
exports.createSpanArgsSchema = createSpanArgsSchema;
exports.createSpanRecordSchema = createSpanRecordSchema;
exports.createdAtField = createdAtField;
exports.dateRangeSchema = dateRangeSchema;
exports.dbTimestamps = dbTimestamps;
exports.entityIdField = entityIdField;
exports.entityNameField = entityNameField;
exports.entityTypeField = entityTypeField;
exports.environmentField = environmentField;
exports.getRootSpanArgsSchema = getRootSpanArgsSchema;
exports.getRootSpanResponseSchema = getRootSpanResponseSchema;
exports.getSpanArgsSchema = getSpanArgsSchema;
exports.getSpanResponseSchema = getSpanResponseSchema;
exports.getTraceArgsSchema = getTraceArgsSchema;
exports.getTraceResponseSchema = getTraceResponseSchema;
exports.listScoresBySpanResponseSchema = listScoresBySpanResponseSchema;
exports.listScoresResponseSchema = listScoresResponseSchema;
exports.listTracesArgsSchema = listTracesArgsSchema;
exports.listTracesResponseSchema = listTracesResponseSchema;
exports.organizationIdField = organizationIdField;
exports.paginationArgsSchema = paginationArgsSchema;
exports.paginationInfoSchema = paginationInfoSchema;
exports.requestIdField = requestIdField;
exports.resourceIdField = resourceIdField;
exports.runIdField = runIdField;
exports.saveScorePayloadSchema = saveScorePayloadSchema;
exports.scoreResultSchema = scoreResultSchema;
exports.scoreRowDataSchema = scoreRowDataSchema;
exports.scoreTracesRequestSchema = scoreTracesRequestSchema;
exports.scoreTracesResponseSchema = scoreTracesResponseSchema;
exports.scoringEntityTypeSchema = scoringEntityTypeSchema;
exports.scoringExtractStepResultSchema = scoringExtractStepResultSchema;
exports.scoringHookInputSchema = scoringHookInputSchema;
exports.scoringInputSchema = scoringInputSchema;
exports.scoringInputWithExtractStepResultAndAnalyzeStepResultSchema = scoringInputWithExtractStepResultAndAnalyzeStepResultSchema;
exports.scoringInputWithExtractStepResultAndScoreAndReasonSchema = scoringInputWithExtractStepResultAndScoreAndReasonSchema;
exports.scoringInputWithExtractStepResultSchema = scoringInputWithExtractStepResultSchema;
exports.scoringPromptsSchema = scoringPromptsSchema;
exports.scoringSourceSchema = scoringSourceSchema;
exports.scoringValueSchema = scoringValueSchema;
exports.serviceNameField = serviceNameField;
exports.sessionIdField = sessionIdField;
exports.sortDirectionSchema = sortDirectionSchema;
exports.sourceField = sourceField;
exports.spanIdField = spanIdField;
exports.spanIds = spanIds;
exports.spanIdsSchema = spanIdsSchema;
exports.spanRecordSchema = spanRecordSchema;
exports.threadIdField = threadIdField;
exports.toTraceSpan = toTraceSpan;
exports.toTraceSpans = toTraceSpans;
exports.traceIdField = traceIdField;
exports.traceSpanSchema = traceSpanSchema;
exports.tracesFilterSchema = tracesFilterSchema;
exports.tracesOrderByFieldSchema = tracesOrderByFieldSchema;
exports.tracesOrderBySchema = tracesOrderBySchema;
exports.updateSpanArgsSchema = updateSpanArgsSchema;
exports.updateSpanRecordSchema = updateSpanRecordSchema;
exports.updatedAtField = updatedAtField;
exports.userIdField = userIdField;
//# sourceMappingURL=chunk-SU5APAM6.cjs.map
//# sourceMappingURL=chunk-SU5APAM6.cjs.map