{"version":3,"sources":["../src/zod-to-json.ts"],"names":["z","zodToJsonSchemaOriginal"],"mappings":"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","file":"chunk-VC7YNDY2.cjs","sourcesContent":["import type { JSONSchema7 } from 'json-schema';\nimport { z } from 'zod';\nimport type { ZodSchema as ZodSchemaV3 } from 'zod/v3';\nimport type { Targets } from 'zod-to-json-schema';\nimport zodToJsonSchemaOriginal from 'zod-to-json-schema';\n\n// Symbol to mark schemas as already patched (for idempotency)\nconst PATCHED = Symbol('__mastra_patched__');\n\n/**\n * Recursively patch Zod v4 record schemas that are missing valueType.\n * This fixes a bug in Zod v4 where z.record(valueSchema) doesn't set def.valueType.\n * The single-arg form should set valueType but instead only sets keyType.\n */\nfunction patchRecordSchemas(schema: any): any {\n  if (!schema || typeof schema !== 'object') return schema;\n\n  // Skip if already patched (idempotency check)\n  if ((schema as any)[PATCHED]) return schema;\n  (schema as any)[PATCHED] = true;\n\n  // Check the _zod.def location (v4 structure)\n  const def = schema._zod?.def;\n\n  // Fix record schemas with missing valueType\n  if (def?.type === 'record' && def.keyType && !def.valueType) {\n    // The bug: z.record(valueSchema) puts the value in keyType instead of valueType\n    // Fix: move it to valueType and set keyType to string (the default)\n    def.valueType = def.keyType;\n    def.keyType = (z as any).string();\n  }\n\n  // Recursively patch nested schemas\n  if (!def) return schema;\n\n  if (def.type === 'object' && def.shape) {\n    const shape = typeof def.shape === 'function' ? def.shape() : def.shape;\n    for (const key of Object.keys(shape)) {\n      patchRecordSchemas(shape[key]);\n    }\n  }\n\n  if (def.type === 'array' && def.element) {\n    patchRecordSchemas(def.element);\n  }\n\n  if (def.type === 'union' && def.options) {\n    def.options.forEach(patchRecordSchemas);\n  }\n\n  if (def.type === 'record') {\n    if (def.keyType) patchRecordSchemas(def.keyType);\n    if (def.valueType) patchRecordSchemas(def.valueType);\n  }\n\n  // Handle intersection types\n  if (def.type === 'intersection') {\n    if (def.left) patchRecordSchemas(def.left);\n    if (def.right) patchRecordSchemas(def.right);\n  }\n\n  // Handle lazy types - patch the schema returned by the getter\n  if (def.type === 'lazy') {\n    // For lazy schemas, we need to patch the schema when it's accessed\n    // Store the original getter and wrap it\n    if (def.getter && typeof def.getter === 'function') {\n      const originalGetter = def.getter;\n      def.getter = function () {\n        const innerSchema = originalGetter();\n        if (innerSchema) {\n          patchRecordSchemas(innerSchema);\n        }\n        return innerSchema;\n      };\n    }\n  }\n\n  // Handle wrapper types that have innerType\n  // This covers: optional, nullable, default, catch, nullish, and any other wrappers\n  if (def.innerType) {\n    patchRecordSchemas(def.innerType);\n  }\n\n  return schema;\n}\n\n/**\n * Recursively fixes anyOf patterns that some providers (like OpenAI) don't accept.\n * Converts anyOf: [{type: X}, {type: \"null\"}] to type: [X, \"null\"]\n * Also fixes empty {} property schemas by converting to a union of primitive types.\n */\nfunction fixAnyOfNullable(schema: JSONSchema7): JSONSchema7 {\n  if (typeof schema !== 'object' || schema === null) {\n    return schema;\n  }\n\n  const result = { ...schema };\n\n  // Fix anyOf pattern: [{type: X}, {type: \"null\"}] or [{type: \"null\"}, {type: X}]\n  if (result.anyOf && Array.isArray(result.anyOf) && result.anyOf.length === 2) {\n    const nullSchema = result.anyOf.find((s: any) => typeof s === 'object' && s !== null && s.type === 'null');\n    const otherSchema = result.anyOf.find((s: any) => typeof s === 'object' && s !== null && s.type !== 'null');\n\n    if (nullSchema && otherSchema && typeof otherSchema === 'object' && otherSchema.type) {\n      // Convert anyOf to type array format\n      // Normalize sibling fields (like properties/items) before returning\n      const { anyOf, ...rest } = result;\n      const fixedRest = fixAnyOfNullable(rest as JSONSchema7);\n      const fixedOther = fixAnyOfNullable(otherSchema as JSONSchema7);\n      return {\n        ...fixedRest,\n        ...fixedOther,\n        type: (Array.isArray(fixedOther.type)\n          ? [...fixedOther.type, 'null']\n          : [fixedOther.type, 'null']) as JSONSchema7['type'],\n      };\n    }\n  }\n\n  // Fix empty property schemas {} - OpenAI requires a type key\n  if (result.properties && typeof result.properties === 'object' && !Array.isArray(result.properties)) {\n    result.properties = Object.fromEntries(\n      Object.entries(result.properties).map(([key, value]) => {\n        const propSchema = value as JSONSchema7;\n\n        // If property is an empty object {}, convert to allow primitive types\n        // Note: We exclude 'object' (requires additionalProperties) and 'array' (requires items) for OpenAI\n        if (\n          typeof propSchema === 'object' &&\n          propSchema !== null &&\n          !Array.isArray(propSchema) &&\n          Object.keys(propSchema).length === 0\n        ) {\n          return [key, { type: ['string', 'number', 'boolean', 'null'] as JSONSchema7['type'] }];\n        }\n\n        // Recursively fix nested schemas\n        return [key, fixAnyOfNullable(propSchema)];\n      }),\n    );\n  }\n\n  // Recursively fix items in arrays\n  if (result.items) {\n    if (Array.isArray(result.items)) {\n      result.items = result.items.map(item => fixAnyOfNullable(item as JSONSchema7));\n    } else {\n      result.items = fixAnyOfNullable(result.items as JSONSchema7);\n    }\n  }\n\n  // Recursively fix anyOf/oneOf/allOf schemas\n  if (result.anyOf && Array.isArray(result.anyOf)) {\n    result.anyOf = result.anyOf.map(s => fixAnyOfNullable(s as JSONSchema7));\n  }\n  if (result.oneOf && Array.isArray(result.oneOf)) {\n    result.oneOf = result.oneOf.map(s => fixAnyOfNullable(s as JSONSchema7));\n  }\n  if (result.allOf && Array.isArray(result.allOf)) {\n    result.allOf = result.allOf.map(s => fixAnyOfNullable(s as JSONSchema7));\n  }\n\n  return result;\n}\n\n// export function zotToJsonSchema(zodSchema: ZodSchemaV3 | ZodSchemaV4, target: Targets = 'jsonSchema7', strategy: 'none' | 'seen' | 'root' | 'relative' = 'relative'): JSONSchema7 {\n//   const target = 'draft-07' as StandardJSONSchemaV1.Target;\n//   const standardSchema = toStandardSchema(zodSchema);\n//   const jsonSchema = standardSchemaToJSONSchema(standardSchema, {\n//     target,\n//   });\n\n//   traverse(jsonSchema, {\n//     cb: {\n//       pre: (schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema) => {\n//         this.preProcessJSONNode(schema, parentSchema);\n//       },\n//       post: (schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema) => {\n//         this.postProcessJSONNode(schema, parentSchema);\n//       },\n//     },\n//   });\n\n// }\n\nexport function zodToJsonSchema(\n  zodSchema: any,\n  target: Targets = 'jsonSchema7',\n  strategy: 'none' | 'seen' | 'root' | 'relative' = 'relative',\n): JSONSchema7 {\n  const fn = 'toJSONSchema';\n\n  if (fn in z) {\n    // Zod v4 path - patch record schemas before converting\n    patchRecordSchemas(zodSchema);\n\n    const jsonSchema = (z as any)[fn](zodSchema, {\n      unrepresentable: 'any',\n      override: (ctx: any) => {\n        // Handle both Zod v4 structures: _def directly or nested in _zod\n        const def = ctx.zodSchema?._def || ctx.zodSchema?._zod?.def;\n        // Check for date type using both possible property names\n        if (def && (def.typeName === 'ZodDate' || def.type === 'date')) {\n          ctx.jsonSchema.type = 'string';\n          ctx.jsonSchema.format = 'date-time';\n        }\n      },\n    }) satisfies JSONSchema7;\n\n    // Fix anyOf patterns for nullable fields - required for OpenAI compatibility\n    return fixAnyOfNullable(jsonSchema);\n  } else {\n    // Zod v3 path - use the original converter\n    return zodToJsonSchemaOriginal(zodSchema as ZodSchemaV3, {\n      $refStrategy: strategy,\n      target,\n    }) as JSONSchema7;\n  }\n}\n"]}