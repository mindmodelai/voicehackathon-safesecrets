{"version":3,"sources":["../../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/lib/compile/codegen/code.ts","../../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/lib/compile/codegen/scope.ts","../../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/lib/compile/codegen/index.ts","../../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/lib/compile/util.ts","../../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/lib/compile/names.ts","../../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/lib/compile/errors.ts","../../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/lib/compile/validate/boolSchema.ts","../../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/lib/compile/rules.ts","../../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/lib/compile/validate/applicability.ts","../../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/lib/compile/validate/dataType.ts","../../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/lib/compile/validate/defaults.ts","../../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/lib/vocabularies/code.ts","../../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/lib/compile/validate/keyword.ts","../../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/lib/compile/validate/subschema.ts","../../../node_modules/.pnpm/fast-deep-equal@3.1.3/node_modules/fast-deep-equal/index.js","../../../node_modules/.pnpm/json-schema-traverse@1.0.0/node_modules/json-schema-traverse/index.js","../../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/lib/compile/resolve.ts","../../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/lib/compile/validate/index.ts","../../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/lib/runtime/validation_error.ts","../../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/lib/compile/ref_error.ts","../../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/lib/compile/index.ts","../../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/refs/data.json","../../../node_modules/.pnpm/fast-uri@3.1.0/node_modules/fast-uri/lib/utils.js","../../../node_modules/.pnpm/fast-uri@3.1.0/node_modules/fast-uri/lib/schemes.js","../../../node_modules/.pnpm/fast-uri@3.1.0/node_modules/fast-uri/index.js","../../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/lib/runtime/uri.ts","../../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/lib/core.ts","../../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/lib/vocabularies/core/id.ts","../../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/lib/vocabularies/core/ref.ts","../../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/lib/vocabularies/core/index.ts","../../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/lib/vocabularies/validation/limitNumber.ts","../../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/lib/vocabularies/validation/multipleOf.ts","../../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/lib/runtime/ucs2length.ts","../../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/lib/vocabularies/validation/limitLength.ts","../../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/lib/vocabularies/validation/pattern.ts","../../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/lib/vocabularies/validation/limitProperties.ts","../../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/lib/vocabularies/validation/required.ts","../../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/lib/vocabularies/validation/limitItems.ts","../../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/lib/runtime/equal.ts","../../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/lib/vocabularies/validation/uniqueItems.ts","../../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/lib/vocabularies/validation/const.ts","../../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/lib/vocabularies/validation/enum.ts","../../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/lib/vocabularies/validation/index.ts","../../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/lib/vocabularies/applicator/additionalItems.ts","../../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/lib/vocabularies/applicator/items.ts","../../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/lib/vocabularies/applicator/prefixItems.ts","../../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/lib/vocabularies/applicator/items2020.ts","../../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/lib/vocabularies/applicator/contains.ts","../../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/lib/vocabularies/applicator/dependencies.ts","../../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/lib/vocabularies/applicator/propertyNames.ts","../../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/lib/vocabularies/applicator/additionalProperties.ts","../../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/lib/vocabularies/applicator/properties.ts","../../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/lib/vocabularies/applicator/patternProperties.ts","../../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/lib/vocabularies/applicator/not.ts","../../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/lib/vocabularies/applicator/anyOf.ts","../../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/lib/vocabularies/applicator/oneOf.ts","../../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/lib/vocabularies/applicator/allOf.ts","../../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/lib/vocabularies/applicator/if.ts","../../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/lib/vocabularies/applicator/thenElse.ts","../../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/lib/vocabularies/applicator/index.ts","../../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/lib/vocabularies/format/format.ts","../../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/lib/vocabularies/format/index.ts","../../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/lib/vocabularies/metadata.ts","../../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/lib/vocabularies/draft7.ts","../../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/lib/vocabularies/discriminator/types.ts","../../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/lib/vocabularies/discriminator/index.ts","../../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/dist/refs/json-schema-draft-07.json","../../../node_modules/.pnpm/ajv@8.17.1/node_modules/ajv/lib/ajv.ts","../src/standard-schema/adapters/ai-sdk.ts","../src/standard-schema/adapters/json-schema.ts","../src/standard-schema/adapters/zod-v3.ts","../src/standard-schema/standard-schema.ts"],"names":["exports","UsedValueState","Type","DataType","_a","traverse","Ajv","DiscrError","VENDOR","issues","toStandardSchema"],"mappings":"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","file":"chunk-DGOXVQNP.js","sourcesContent":["// eslint-disable-next-line @typescript-eslint/no-extraneous-class\nexport abstract class _CodeOrName {\n  abstract readonly str: string\n  abstract readonly names: UsedNames\n  abstract toString(): string\n  abstract emptyStr(): boolean\n}\n\nexport const IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i\n\nexport class Name extends _CodeOrName {\n  readonly str: string\n  constructor(s: string) {\n    super()\n    if (!IDENTIFIER.test(s)) throw new Error(\"CodeGen: name must be a valid identifier\")\n    this.str = s\n  }\n\n  toString(): string {\n    return this.str\n  }\n\n  emptyStr(): boolean {\n    return false\n  }\n\n  get names(): UsedNames {\n    return {[this.str]: 1}\n  }\n}\n\nexport class _Code extends _CodeOrName {\n  readonly _items: readonly CodeItem[]\n  private _str?: string\n  private _names?: UsedNames\n\n  constructor(code: string | readonly CodeItem[]) {\n    super()\n    this._items = typeof code === \"string\" ? [code] : code\n  }\n\n  toString(): string {\n    return this.str\n  }\n\n  emptyStr(): boolean {\n    if (this._items.length > 1) return false\n    const item = this._items[0]\n    return item === \"\" || item === '\"\"'\n  }\n\n  get str(): string {\n    return (this._str ??= this._items.reduce((s: string, c: CodeItem) => `${s}${c}`, \"\"))\n  }\n\n  get names(): UsedNames {\n    return (this._names ??= this._items.reduce((names: UsedNames, c) => {\n      if (c instanceof Name) names[c.str] = (names[c.str] || 0) + 1\n      return names\n    }, {}))\n  }\n}\n\nexport type CodeItem = Name | string | number | boolean | null\n\nexport type UsedNames = Record<string, number | undefined>\n\nexport type Code = _Code | Name\n\nexport type SafeExpr = Code | number | boolean | null\n\nexport const nil = new _Code(\"\")\n\ntype CodeArg = SafeExpr | string | undefined\n\nexport function _(strs: TemplateStringsArray, ...args: CodeArg[]): _Code {\n  const code: CodeItem[] = [strs[0]]\n  let i = 0\n  while (i < args.length) {\n    addCodeArg(code, args[i])\n    code.push(strs[++i])\n  }\n  return new _Code(code)\n}\n\nconst plus = new _Code(\"+\")\n\nexport function str(strs: TemplateStringsArray, ...args: (CodeArg | string[])[]): _Code {\n  const expr: CodeItem[] = [safeStringify(strs[0])]\n  let i = 0\n  while (i < args.length) {\n    expr.push(plus)\n    addCodeArg(expr, args[i])\n    expr.push(plus, safeStringify(strs[++i]))\n  }\n  optimize(expr)\n  return new _Code(expr)\n}\n\nexport function addCodeArg(code: CodeItem[], arg: CodeArg | string[]): void {\n  if (arg instanceof _Code) code.push(...arg._items)\n  else if (arg instanceof Name) code.push(arg)\n  else code.push(interpolate(arg))\n}\n\nfunction optimize(expr: CodeItem[]): void {\n  let i = 1\n  while (i < expr.length - 1) {\n    if (expr[i] === plus) {\n      const res = mergeExprItems(expr[i - 1], expr[i + 1])\n      if (res !== undefined) {\n        expr.splice(i - 1, 3, res)\n        continue\n      }\n      expr[i++] = \"+\"\n    }\n    i++\n  }\n}\n\nfunction mergeExprItems(a: CodeItem, b: CodeItem): CodeItem | undefined {\n  if (b === '\"\"') return a\n  if (a === '\"\"') return b\n  if (typeof a == \"string\") {\n    if (b instanceof Name || a[a.length - 1] !== '\"') return\n    if (typeof b != \"string\") return `${a.slice(0, -1)}${b}\"`\n    if (b[0] === '\"') return a.slice(0, -1) + b.slice(1)\n    return\n  }\n  if (typeof b == \"string\" && b[0] === '\"' && !(a instanceof Name)) return `\"${a}${b.slice(1)}`\n  return\n}\n\nexport function strConcat(c1: Code, c2: Code): Code {\n  return c2.emptyStr() ? c1 : c1.emptyStr() ? c2 : str`${c1}${c2}`\n}\n\n// TODO do not allow arrays here\nfunction interpolate(x?: string | string[] | number | boolean | null): SafeExpr | string {\n  return typeof x == \"number\" || typeof x == \"boolean\" || x === null\n    ? x\n    : safeStringify(Array.isArray(x) ? x.join(\",\") : x)\n}\n\nexport function stringify(x: unknown): Code {\n  return new _Code(safeStringify(x))\n}\n\nexport function safeStringify(x: unknown): string {\n  return JSON.stringify(x)\n    .replace(/\\u2028/g, \"\\\\u2028\")\n    .replace(/\\u2029/g, \"\\\\u2029\")\n}\n\nexport function getProperty(key: Code | string | number): Code {\n  return typeof key == \"string\" && IDENTIFIER.test(key) ? new _Code(`.${key}`) : _`[${key}]`\n}\n\n//Does best effort to format the name properly\nexport function getEsmExportName(key: Code | string | number): Code {\n  if (typeof key == \"string\" && IDENTIFIER.test(key)) {\n    return new _Code(`${key}`)\n  }\n  throw new Error(`CodeGen: invalid export name: ${key}, use explicit $id name mapping`)\n}\n\nexport function regexpCode(rx: RegExp): Code {\n  return new _Code(rx.toString())\n}\n","import {_, nil, Code, Name} from \"./code\"\n\ninterface NameGroup {\n  prefix: string\n  index: number\n}\n\nexport interface NameValue {\n  ref: ValueReference // this is the reference to any value that can be referred to from generated code via `globals` var in the closure\n  key?: unknown // any key to identify a global to avoid duplicates, if not passed ref is used\n  code?: Code // this is the code creating the value needed for standalone code wit_out closure - can be a primitive value, function or import (`require`)\n}\n\nexport type ValueReference = unknown // possibly make CodeGen parameterized type on this type\n\nclass ValueError extends Error {\n  readonly value?: NameValue\n  constructor(name: ValueScopeName) {\n    super(`CodeGen: \"code\" for ${name} not defined`)\n    this.value = name.value\n  }\n}\n\ninterface ScopeOptions {\n  prefixes?: Set<string>\n  parent?: Scope\n}\n\ninterface ValueScopeOptions extends ScopeOptions {\n  scope: ScopeStore\n  es5?: boolean\n  lines?: boolean\n}\n\nexport type ScopeStore = Record<string, ValueReference[] | undefined>\n\ntype ScopeValues = {\n  [Prefix in string]?: Map<unknown, ValueScopeName>\n}\n\nexport type ScopeValueSets = {\n  [Prefix in string]?: Set<ValueScopeName>\n}\n\nexport enum UsedValueState {\n  Started,\n  Completed,\n}\n\nexport type UsedScopeValues = {\n  [Prefix in string]?: Map<ValueScopeName, UsedValueState | undefined>\n}\n\nexport const varKinds = {\n  const: new Name(\"const\"),\n  let: new Name(\"let\"),\n  var: new Name(\"var\"),\n}\n\nexport class Scope {\n  protected readonly _names: {[Prefix in string]?: NameGroup} = {}\n  protected readonly _prefixes?: Set<string>\n  protected readonly _parent?: Scope\n\n  constructor({prefixes, parent}: ScopeOptions = {}) {\n    this._prefixes = prefixes\n    this._parent = parent\n  }\n\n  toName(nameOrPrefix: Name | string): Name {\n    return nameOrPrefix instanceof Name ? nameOrPrefix : this.name(nameOrPrefix)\n  }\n\n  name(prefix: string): Name {\n    return new Name(this._newName(prefix))\n  }\n\n  protected _newName(prefix: string): string {\n    const ng = this._names[prefix] || this._nameGroup(prefix)\n    return `${prefix}${ng.index++}`\n  }\n\n  private _nameGroup(prefix: string): NameGroup {\n    if (this._parent?._prefixes?.has(prefix) || (this._prefixes && !this._prefixes.has(prefix))) {\n      throw new Error(`CodeGen: prefix \"${prefix}\" is not allowed in this scope`)\n    }\n    return (this._names[prefix] = {prefix, index: 0})\n  }\n}\n\ninterface ScopePath {\n  property: string\n  itemIndex: number\n}\n\nexport class ValueScopeName extends Name {\n  readonly prefix: string\n  value?: NameValue\n  scopePath?: Code\n\n  constructor(prefix: string, nameStr: string) {\n    super(nameStr)\n    this.prefix = prefix\n  }\n\n  setValue(value: NameValue, {property, itemIndex}: ScopePath): void {\n    this.value = value\n    this.scopePath = _`.${new Name(property)}[${itemIndex}]`\n  }\n}\n\ninterface VSOptions extends ValueScopeOptions {\n  _n: Code\n}\n\nconst line = _`\\n`\n\nexport class ValueScope extends Scope {\n  protected readonly _values: ScopeValues = {}\n  protected readonly _scope: ScopeStore\n  readonly opts: VSOptions\n\n  constructor(opts: ValueScopeOptions) {\n    super(opts)\n    this._scope = opts.scope\n    this.opts = {...opts, _n: opts.lines ? line : nil}\n  }\n\n  get(): ScopeStore {\n    return this._scope\n  }\n\n  name(prefix: string): ValueScopeName {\n    return new ValueScopeName(prefix, this._newName(prefix))\n  }\n\n  value(nameOrPrefix: ValueScopeName | string, value: NameValue): ValueScopeName {\n    if (value.ref === undefined) throw new Error(\"CodeGen: ref must be passed in value\")\n    const name = this.toName(nameOrPrefix) as ValueScopeName\n    const {prefix} = name\n    const valueKey = value.key ?? value.ref\n    let vs = this._values[prefix]\n    if (vs) {\n      const _name = vs.get(valueKey)\n      if (_name) return _name\n    } else {\n      vs = this._values[prefix] = new Map()\n    }\n    vs.set(valueKey, name)\n\n    const s = this._scope[prefix] || (this._scope[prefix] = [])\n    const itemIndex = s.length\n    s[itemIndex] = value.ref\n    name.setValue(value, {property: prefix, itemIndex})\n    return name\n  }\n\n  getValue(prefix: string, keyOrRef: unknown): ValueScopeName | undefined {\n    const vs = this._values[prefix]\n    if (!vs) return\n    return vs.get(keyOrRef)\n  }\n\n  scopeRefs(scopeName: Name, values: ScopeValues | ScopeValueSets = this._values): Code {\n    return this._reduceValues(values, (name: ValueScopeName) => {\n      if (name.scopePath === undefined) throw new Error(`CodeGen: name \"${name}\" has no value`)\n      return _`${scopeName}${name.scopePath}`\n    })\n  }\n\n  scopeCode(\n    values: ScopeValues | ScopeValueSets = this._values,\n    usedValues?: UsedScopeValues,\n    getCode?: (n: ValueScopeName) => Code | undefined\n  ): Code {\n    return this._reduceValues(\n      values,\n      (name: ValueScopeName) => {\n        if (name.value === undefined) throw new Error(`CodeGen: name \"${name}\" has no value`)\n        return name.value.code\n      },\n      usedValues,\n      getCode\n    )\n  }\n\n  private _reduceValues(\n    values: ScopeValues | ScopeValueSets,\n    valueCode: (n: ValueScopeName) => Code | undefined,\n    usedValues: UsedScopeValues = {},\n    getCode?: (n: ValueScopeName) => Code | undefined\n  ): Code {\n    let code: Code = nil\n    for (const prefix in values) {\n      const vs = values[prefix]\n      if (!vs) continue\n      const nameSet = (usedValues[prefix] = usedValues[prefix] || new Map())\n      vs.forEach((name: ValueScopeName) => {\n        if (nameSet.has(name)) return\n        nameSet.set(name, UsedValueState.Started)\n        let c = valueCode(name)\n        if (c) {\n          const def = this.opts.es5 ? varKinds.var : varKinds.const\n          code = _`${code}${def} ${name} = ${c};${this.opts._n}`\n        } else if ((c = getCode?.(name))) {\n          code = _`${code}${c}${this.opts._n}`\n        } else {\n          throw new ValueError(name)\n        }\n        nameSet.set(name, UsedValueState.Completed)\n      })\n    }\n    return code\n  }\n}\n","import type {ScopeValueSets, NameValue, ValueScope, ValueScopeName} from \"./scope\"\nimport {_, nil, _Code, Code, Name, UsedNames, CodeItem, addCodeArg, _CodeOrName} from \"./code\"\nimport {Scope, varKinds} from \"./scope\"\n\nexport {_, str, strConcat, nil, getProperty, stringify, regexpCode, Name, Code} from \"./code\"\nexport {Scope, ScopeStore, ValueScope, ValueScopeName, ScopeValueSets, varKinds} from \"./scope\"\n\n// type for expressions that can be safely inserted in code without quotes\nexport type SafeExpr = Code | number | boolean | null\n\n// type that is either Code of function that adds code to CodeGen instance using its methods\nexport type Block = Code | (() => void)\n\nexport const operators = {\n  GT: new _Code(\">\"),\n  GTE: new _Code(\">=\"),\n  LT: new _Code(\"<\"),\n  LTE: new _Code(\"<=\"),\n  EQ: new _Code(\"===\"),\n  NEQ: new _Code(\"!==\"),\n  NOT: new _Code(\"!\"),\n  OR: new _Code(\"||\"),\n  AND: new _Code(\"&&\"),\n  ADD: new _Code(\"+\"),\n}\n\nabstract class Node {\n  abstract readonly names: UsedNames\n\n  optimizeNodes(): this | ChildNode | ChildNode[] | undefined {\n    return this\n  }\n\n  optimizeNames(_names: UsedNames, _constants: Constants): this | undefined {\n    return this\n  }\n\n  // get count(): number {\n  //   return 1\n  // }\n}\n\nclass Def extends Node {\n  constructor(\n    private readonly varKind: Name,\n    private readonly name: Name,\n    private rhs?: SafeExpr\n  ) {\n    super()\n  }\n\n  render({es5, _n}: CGOptions): string {\n    const varKind = es5 ? varKinds.var : this.varKind\n    const rhs = this.rhs === undefined ? \"\" : ` = ${this.rhs}`\n    return `${varKind} ${this.name}${rhs};` + _n\n  }\n\n  optimizeNames(names: UsedNames, constants: Constants): this | undefined {\n    if (!names[this.name.str]) return\n    if (this.rhs) this.rhs = optimizeExpr(this.rhs, names, constants)\n    return this\n  }\n\n  get names(): UsedNames {\n    return this.rhs instanceof _CodeOrName ? this.rhs.names : {}\n  }\n}\n\nclass Assign extends Node {\n  constructor(\n    readonly lhs: Code,\n    public rhs: SafeExpr,\n    private readonly sideEffects?: boolean\n  ) {\n    super()\n  }\n\n  render({_n}: CGOptions): string {\n    return `${this.lhs} = ${this.rhs};` + _n\n  }\n\n  optimizeNames(names: UsedNames, constants: Constants): this | undefined {\n    if (this.lhs instanceof Name && !names[this.lhs.str] && !this.sideEffects) return\n    this.rhs = optimizeExpr(this.rhs, names, constants)\n    return this\n  }\n\n  get names(): UsedNames {\n    const names = this.lhs instanceof Name ? {} : {...this.lhs.names}\n    return addExprNames(names, this.rhs)\n  }\n}\n\nclass AssignOp extends Assign {\n  constructor(\n    lhs: Code,\n    private readonly op: Code,\n    rhs: SafeExpr,\n    sideEffects?: boolean\n  ) {\n    super(lhs, rhs, sideEffects)\n  }\n\n  render({_n}: CGOptions): string {\n    return `${this.lhs} ${this.op}= ${this.rhs};` + _n\n  }\n}\n\nclass Label extends Node {\n  readonly names: UsedNames = {}\n  constructor(readonly label: Name) {\n    super()\n  }\n\n  render({_n}: CGOptions): string {\n    return `${this.label}:` + _n\n  }\n}\n\nclass Break extends Node {\n  readonly names: UsedNames = {}\n  constructor(readonly label?: Code) {\n    super()\n  }\n\n  render({_n}: CGOptions): string {\n    const label = this.label ? ` ${this.label}` : \"\"\n    return `break${label};` + _n\n  }\n}\n\nclass Throw extends Node {\n  constructor(readonly error: Code) {\n    super()\n  }\n\n  render({_n}: CGOptions): string {\n    return `throw ${this.error};` + _n\n  }\n\n  get names(): UsedNames {\n    return this.error.names\n  }\n}\n\nclass AnyCode extends Node {\n  constructor(private code: SafeExpr) {\n    super()\n  }\n\n  render({_n}: CGOptions): string {\n    return `${this.code};` + _n\n  }\n\n  optimizeNodes(): this | undefined {\n    return `${this.code}` ? this : undefined\n  }\n\n  optimizeNames(names: UsedNames, constants: Constants): this {\n    this.code = optimizeExpr(this.code, names, constants)\n    return this\n  }\n\n  get names(): UsedNames {\n    return this.code instanceof _CodeOrName ? this.code.names : {}\n  }\n}\n\nabstract class ParentNode extends Node {\n  constructor(readonly nodes: ChildNode[] = []) {\n    super()\n  }\n\n  render(opts: CGOptions): string {\n    return this.nodes.reduce((code, n) => code + n.render(opts), \"\")\n  }\n\n  optimizeNodes(): this | ChildNode | ChildNode[] | undefined {\n    const {nodes} = this\n    let i = nodes.length\n    while (i--) {\n      const n = nodes[i].optimizeNodes()\n      if (Array.isArray(n)) nodes.splice(i, 1, ...n)\n      else if (n) nodes[i] = n\n      else nodes.splice(i, 1)\n    }\n    return nodes.length > 0 ? this : undefined\n  }\n\n  optimizeNames(names: UsedNames, constants: Constants): this | undefined {\n    const {nodes} = this\n    let i = nodes.length\n    while (i--) {\n      // iterating backwards improves 1-pass optimization\n      const n = nodes[i]\n      if (n.optimizeNames(names, constants)) continue\n      subtractNames(names, n.names)\n      nodes.splice(i, 1)\n    }\n    return nodes.length > 0 ? this : undefined\n  }\n\n  get names(): UsedNames {\n    return this.nodes.reduce((names: UsedNames, n) => addNames(names, n.names), {})\n  }\n\n  // get count(): number {\n  //   return this.nodes.reduce((c, n) => c + n.count, 1)\n  // }\n}\n\nabstract class BlockNode extends ParentNode {\n  render(opts: CGOptions): string {\n    return \"{\" + opts._n + super.render(opts) + \"}\" + opts._n\n  }\n}\n\nclass Root extends ParentNode {}\n\nclass Else extends BlockNode {\n  static readonly kind = \"else\"\n}\n\nclass If extends BlockNode {\n  static readonly kind = \"if\"\n  else?: If | Else\n  constructor(\n    private condition: Code | boolean,\n    nodes?: ChildNode[]\n  ) {\n    super(nodes)\n  }\n\n  render(opts: CGOptions): string {\n    let code = `if(${this.condition})` + super.render(opts)\n    if (this.else) code += \"else \" + this.else.render(opts)\n    return code\n  }\n\n  optimizeNodes(): If | ChildNode[] | undefined {\n    super.optimizeNodes()\n    const cond = this.condition\n    if (cond === true) return this.nodes // else is ignored here\n    let e = this.else\n    if (e) {\n      const ns = e.optimizeNodes()\n      e = this.else = Array.isArray(ns) ? new Else(ns) : (ns as Else | undefined)\n    }\n    if (e) {\n      if (cond === false) return e instanceof If ? e : e.nodes\n      if (this.nodes.length) return this\n      return new If(not(cond), e instanceof If ? [e] : e.nodes)\n    }\n    if (cond === false || !this.nodes.length) return undefined\n    return this\n  }\n\n  optimizeNames(names: UsedNames, constants: Constants): this | undefined {\n    this.else = this.else?.optimizeNames(names, constants)\n    if (!(super.optimizeNames(names, constants) || this.else)) return\n    this.condition = optimizeExpr(this.condition, names, constants)\n    return this\n  }\n\n  get names(): UsedNames {\n    const names = super.names\n    addExprNames(names, this.condition)\n    if (this.else) addNames(names, this.else.names)\n    return names\n  }\n\n  // get count(): number {\n  //   return super.count + (this.else?.count || 0)\n  // }\n}\n\nabstract class For extends BlockNode {\n  static readonly kind = \"for\"\n}\n\nclass ForLoop extends For {\n  constructor(private iteration: Code) {\n    super()\n  }\n\n  render(opts: CGOptions): string {\n    return `for(${this.iteration})` + super.render(opts)\n  }\n\n  optimizeNames(names: UsedNames, constants: Constants): this | undefined {\n    if (!super.optimizeNames(names, constants)) return\n    this.iteration = optimizeExpr(this.iteration, names, constants)\n    return this\n  }\n\n  get names(): UsedNames {\n    return addNames(super.names, this.iteration.names)\n  }\n}\n\nclass ForRange extends For {\n  constructor(\n    private readonly varKind: Name,\n    private readonly name: Name,\n    private readonly from: SafeExpr,\n    private readonly to: SafeExpr\n  ) {\n    super()\n  }\n\n  render(opts: CGOptions): string {\n    const varKind = opts.es5 ? varKinds.var : this.varKind\n    const {name, from, to} = this\n    return `for(${varKind} ${name}=${from}; ${name}<${to}; ${name}++)` + super.render(opts)\n  }\n\n  get names(): UsedNames {\n    const names = addExprNames(super.names, this.from)\n    return addExprNames(names, this.to)\n  }\n}\n\nclass ForIter extends For {\n  constructor(\n    private readonly loop: \"of\" | \"in\",\n    private readonly varKind: Name,\n    private readonly name: Name,\n    private iterable: Code\n  ) {\n    super()\n  }\n\n  render(opts: CGOptions): string {\n    return `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` + super.render(opts)\n  }\n\n  optimizeNames(names: UsedNames, constants: Constants): this | undefined {\n    if (!super.optimizeNames(names, constants)) return\n    this.iterable = optimizeExpr(this.iterable, names, constants)\n    return this\n  }\n\n  get names(): UsedNames {\n    return addNames(super.names, this.iterable.names)\n  }\n}\n\nclass Func extends BlockNode {\n  static readonly kind = \"func\"\n  constructor(\n    public name: Name,\n    public args: Code,\n    public async?: boolean\n  ) {\n    super()\n  }\n\n  render(opts: CGOptions): string {\n    const _async = this.async ? \"async \" : \"\"\n    return `${_async}function ${this.name}(${this.args})` + super.render(opts)\n  }\n}\n\nclass Return extends ParentNode {\n  static readonly kind = \"return\"\n\n  render(opts: CGOptions): string {\n    return \"return \" + super.render(opts)\n  }\n}\n\nclass Try extends BlockNode {\n  catch?: Catch\n  finally?: Finally\n\n  render(opts: CGOptions): string {\n    let code = \"try\" + super.render(opts)\n    if (this.catch) code += this.catch.render(opts)\n    if (this.finally) code += this.finally.render(opts)\n    return code\n  }\n\n  optimizeNodes(): this {\n    super.optimizeNodes()\n    this.catch?.optimizeNodes() as Catch | undefined\n    this.finally?.optimizeNodes() as Finally | undefined\n    return this\n  }\n\n  optimizeNames(names: UsedNames, constants: Constants): this {\n    super.optimizeNames(names, constants)\n    this.catch?.optimizeNames(names, constants)\n    this.finally?.optimizeNames(names, constants)\n    return this\n  }\n\n  get names(): UsedNames {\n    const names = super.names\n    if (this.catch) addNames(names, this.catch.names)\n    if (this.finally) addNames(names, this.finally.names)\n    return names\n  }\n\n  // get count(): number {\n  //   return super.count + (this.catch?.count || 0) + (this.finally?.count || 0)\n  // }\n}\n\nclass Catch extends BlockNode {\n  static readonly kind = \"catch\"\n  constructor(readonly error: Name) {\n    super()\n  }\n\n  render(opts: CGOptions): string {\n    return `catch(${this.error})` + super.render(opts)\n  }\n}\n\nclass Finally extends BlockNode {\n  static readonly kind = \"finally\"\n  render(opts: CGOptions): string {\n    return \"finally\" + super.render(opts)\n  }\n}\n\ntype StartBlockNode = If | For | Func | Return | Try\n\ntype LeafNode = Def | Assign | Label | Break | Throw | AnyCode\n\ntype ChildNode = StartBlockNode | LeafNode\n\ntype EndBlockNodeType =\n  | typeof If\n  | typeof Else\n  | typeof For\n  | typeof Func\n  | typeof Return\n  | typeof Catch\n  | typeof Finally\n\ntype Constants = Record<string, SafeExpr | undefined>\n\nexport interface CodeGenOptions {\n  es5?: boolean\n  lines?: boolean\n  ownProperties?: boolean\n}\n\ninterface CGOptions extends CodeGenOptions {\n  _n: \"\\n\" | \"\"\n}\n\nexport class CodeGen {\n  readonly _scope: Scope\n  readonly _extScope: ValueScope\n  readonly _values: ScopeValueSets = {}\n  private readonly _nodes: ParentNode[]\n  private readonly _blockStarts: number[] = []\n  private readonly _constants: Constants = {}\n  private readonly opts: CGOptions\n\n  constructor(extScope: ValueScope, opts: CodeGenOptions = {}) {\n    this.opts = {...opts, _n: opts.lines ? \"\\n\" : \"\"}\n    this._extScope = extScope\n    this._scope = new Scope({parent: extScope})\n    this._nodes = [new Root()]\n  }\n\n  toString(): string {\n    return this._root.render(this.opts)\n  }\n\n  // returns unique name in the internal scope\n  name(prefix: string): Name {\n    return this._scope.name(prefix)\n  }\n\n  // reserves unique name in the external scope\n  scopeName(prefix: string): ValueScopeName {\n    return this._extScope.name(prefix)\n  }\n\n  // reserves unique name in the external scope and assigns value to it\n  scopeValue(prefixOrName: ValueScopeName | string, value: NameValue): Name {\n    const name = this._extScope.value(prefixOrName, value)\n    const vs = this._values[name.prefix] || (this._values[name.prefix] = new Set())\n    vs.add(name)\n    return name\n  }\n\n  getScopeValue(prefix: string, keyOrRef: unknown): ValueScopeName | undefined {\n    return this._extScope.getValue(prefix, keyOrRef)\n  }\n\n  // return code that assigns values in the external scope to the names that are used internally\n  // (same names that were returned by gen.scopeName or gen.scopeValue)\n  scopeRefs(scopeName: Name): Code {\n    return this._extScope.scopeRefs(scopeName, this._values)\n  }\n\n  scopeCode(): Code {\n    return this._extScope.scopeCode(this._values)\n  }\n\n  private _def(\n    varKind: Name,\n    nameOrPrefix: Name | string,\n    rhs?: SafeExpr,\n    constant?: boolean\n  ): Name {\n    const name = this._scope.toName(nameOrPrefix)\n    if (rhs !== undefined && constant) this._constants[name.str] = rhs\n    this._leafNode(new Def(varKind, name, rhs))\n    return name\n  }\n\n  // `const` declaration (`var` in es5 mode)\n  const(nameOrPrefix: Name | string, rhs: SafeExpr, _constant?: boolean): Name {\n    return this._def(varKinds.const, nameOrPrefix, rhs, _constant)\n  }\n\n  // `let` declaration with optional assignment (`var` in es5 mode)\n  let(nameOrPrefix: Name | string, rhs?: SafeExpr, _constant?: boolean): Name {\n    return this._def(varKinds.let, nameOrPrefix, rhs, _constant)\n  }\n\n  // `var` declaration with optional assignment\n  var(nameOrPrefix: Name | string, rhs?: SafeExpr, _constant?: boolean): Name {\n    return this._def(varKinds.var, nameOrPrefix, rhs, _constant)\n  }\n\n  // assignment code\n  assign(lhs: Code, rhs: SafeExpr, sideEffects?: boolean): CodeGen {\n    return this._leafNode(new Assign(lhs, rhs, sideEffects))\n  }\n\n  // `+=` code\n  add(lhs: Code, rhs: SafeExpr): CodeGen {\n    return this._leafNode(new AssignOp(lhs, operators.ADD, rhs))\n  }\n\n  // appends passed SafeExpr to code or executes Block\n  code(c: Block | SafeExpr): CodeGen {\n    if (typeof c == \"function\") c()\n    else if (c !== nil) this._leafNode(new AnyCode(c))\n    return this\n  }\n\n  // returns code for object literal for the passed argument list of key-value pairs\n  object(...keyValues: [Name | string, SafeExpr | string][]): _Code {\n    const code: CodeItem[] = [\"{\"]\n    for (const [key, value] of keyValues) {\n      if (code.length > 1) code.push(\",\")\n      code.push(key)\n      if (key !== value || this.opts.es5) {\n        code.push(\":\")\n        addCodeArg(code, value)\n      }\n    }\n    code.push(\"}\")\n    return new _Code(code)\n  }\n\n  // `if` clause (or statement if `thenBody` and, optionally, `elseBody` are passed)\n  if(condition: Code | boolean, thenBody?: Block, elseBody?: Block): CodeGen {\n    this._blockNode(new If(condition))\n\n    if (thenBody && elseBody) {\n      this.code(thenBody).else().code(elseBody).endIf()\n    } else if (thenBody) {\n      this.code(thenBody).endIf()\n    } else if (elseBody) {\n      throw new Error('CodeGen: \"else\" body without \"then\" body')\n    }\n    return this\n  }\n\n  // `else if` clause - invalid without `if` or after `else` clauses\n  elseIf(condition: Code | boolean): CodeGen {\n    return this._elseNode(new If(condition))\n  }\n\n  // `else` clause - only valid after `if` or `else if` clauses\n  else(): CodeGen {\n    return this._elseNode(new Else())\n  }\n\n  // end `if` statement (needed if gen.if was used only with condition)\n  endIf(): CodeGen {\n    return this._endBlockNode(If, Else)\n  }\n\n  private _for(node: For, forBody?: Block): CodeGen {\n    this._blockNode(node)\n    if (forBody) this.code(forBody).endFor()\n    return this\n  }\n\n  // a generic `for` clause (or statement if `forBody` is passed)\n  for(iteration: Code, forBody?: Block): CodeGen {\n    return this._for(new ForLoop(iteration), forBody)\n  }\n\n  // `for` statement for a range of values\n  forRange(\n    nameOrPrefix: Name | string,\n    from: SafeExpr,\n    to: SafeExpr,\n    forBody: (index: Name) => void,\n    varKind: Code = this.opts.es5 ? varKinds.var : varKinds.let\n  ): CodeGen {\n    const name = this._scope.toName(nameOrPrefix)\n    return this._for(new ForRange(varKind, name, from, to), () => forBody(name))\n  }\n\n  // `for-of` statement (in es5 mode replace with a normal for loop)\n  forOf(\n    nameOrPrefix: Name | string,\n    iterable: Code,\n    forBody: (item: Name) => void,\n    varKind: Code = varKinds.const\n  ): CodeGen {\n    const name = this._scope.toName(nameOrPrefix)\n    if (this.opts.es5) {\n      const arr = iterable instanceof Name ? iterable : this.var(\"_arr\", iterable)\n      return this.forRange(\"_i\", 0, _`${arr}.length`, (i) => {\n        this.var(name, _`${arr}[${i}]`)\n        forBody(name)\n      })\n    }\n    return this._for(new ForIter(\"of\", varKind, name, iterable), () => forBody(name))\n  }\n\n  // `for-in` statement.\n  // With option `ownProperties` replaced with a `for-of` loop for object keys\n  forIn(\n    nameOrPrefix: Name | string,\n    obj: Code,\n    forBody: (item: Name) => void,\n    varKind: Code = this.opts.es5 ? varKinds.var : varKinds.const\n  ): CodeGen {\n    if (this.opts.ownProperties) {\n      return this.forOf(nameOrPrefix, _`Object.keys(${obj})`, forBody)\n    }\n    const name = this._scope.toName(nameOrPrefix)\n    return this._for(new ForIter(\"in\", varKind, name, obj), () => forBody(name))\n  }\n\n  // end `for` loop\n  endFor(): CodeGen {\n    return this._endBlockNode(For)\n  }\n\n  // `label` statement\n  label(label: Name): CodeGen {\n    return this._leafNode(new Label(label))\n  }\n\n  // `break` statement\n  break(label?: Code): CodeGen {\n    return this._leafNode(new Break(label))\n  }\n\n  // `return` statement\n  return(value: Block | SafeExpr): CodeGen {\n    const node = new Return()\n    this._blockNode(node)\n    this.code(value)\n    if (node.nodes.length !== 1) throw new Error('CodeGen: \"return\" should have one node')\n    return this._endBlockNode(Return)\n  }\n\n  // `try` statement\n  try(tryBody: Block, catchCode?: (e: Name) => void, finallyCode?: Block): CodeGen {\n    if (!catchCode && !finallyCode) throw new Error('CodeGen: \"try\" without \"catch\" and \"finally\"')\n    const node = new Try()\n    this._blockNode(node)\n    this.code(tryBody)\n    if (catchCode) {\n      const error = this.name(\"e\")\n      this._currNode = node.catch = new Catch(error)\n      catchCode(error)\n    }\n    if (finallyCode) {\n      this._currNode = node.finally = new Finally()\n      this.code(finallyCode)\n    }\n    return this._endBlockNode(Catch, Finally)\n  }\n\n  // `throw` statement\n  throw(error: Code): CodeGen {\n    return this._leafNode(new Throw(error))\n  }\n\n  // start self-balancing block\n  block(body?: Block, nodeCount?: number): CodeGen {\n    this._blockStarts.push(this._nodes.length)\n    if (body) this.code(body).endBlock(nodeCount)\n    return this\n  }\n\n  // end the current self-balancing block\n  endBlock(nodeCount?: number): CodeGen {\n    const len = this._blockStarts.pop()\n    if (len === undefined) throw new Error(\"CodeGen: not in self-balancing block\")\n    const toClose = this._nodes.length - len\n    if (toClose < 0 || (nodeCount !== undefined && toClose !== nodeCount)) {\n      throw new Error(`CodeGen: wrong number of nodes: ${toClose} vs ${nodeCount} expected`)\n    }\n    this._nodes.length = len\n    return this\n  }\n\n  // `function` heading (or definition if funcBody is passed)\n  func(name: Name, args: Code = nil, async?: boolean, funcBody?: Block): CodeGen {\n    this._blockNode(new Func(name, args, async))\n    if (funcBody) this.code(funcBody).endFunc()\n    return this\n  }\n\n  // end function definition\n  endFunc(): CodeGen {\n    return this._endBlockNode(Func)\n  }\n\n  optimize(n = 1): void {\n    while (n-- > 0) {\n      this._root.optimizeNodes()\n      this._root.optimizeNames(this._root.names, this._constants)\n    }\n  }\n\n  private _leafNode(node: LeafNode): CodeGen {\n    this._currNode.nodes.push(node)\n    return this\n  }\n\n  private _blockNode(node: StartBlockNode): void {\n    this._currNode.nodes.push(node)\n    this._nodes.push(node)\n  }\n\n  private _endBlockNode(N1: EndBlockNodeType, N2?: EndBlockNodeType): CodeGen {\n    const n = this._currNode\n    if (n instanceof N1 || (N2 && n instanceof N2)) {\n      this._nodes.pop()\n      return this\n    }\n    throw new Error(`CodeGen: not in block \"${N2 ? `${N1.kind}/${N2.kind}` : N1.kind}\"`)\n  }\n\n  private _elseNode(node: If | Else): CodeGen {\n    const n = this._currNode\n    if (!(n instanceof If)) {\n      throw new Error('CodeGen: \"else\" without \"if\"')\n    }\n    this._currNode = n.else = node\n    return this\n  }\n\n  private get _root(): Root {\n    return this._nodes[0] as Root\n  }\n\n  private get _currNode(): ParentNode {\n    const ns = this._nodes\n    return ns[ns.length - 1]\n  }\n\n  private set _currNode(node: ParentNode) {\n    const ns = this._nodes\n    ns[ns.length - 1] = node\n  }\n\n  // get nodeCount(): number {\n  //   return this._root.count\n  // }\n}\n\nfunction addNames(names: UsedNames, from: UsedNames): UsedNames {\n  for (const n in from) names[n] = (names[n] || 0) + (from[n] || 0)\n  return names\n}\n\nfunction addExprNames(names: UsedNames, from: SafeExpr): UsedNames {\n  return from instanceof _CodeOrName ? addNames(names, from.names) : names\n}\n\nfunction optimizeExpr<T extends SafeExpr | Code>(expr: T, names: UsedNames, constants: Constants): T\nfunction optimizeExpr(expr: SafeExpr, names: UsedNames, constants: Constants): SafeExpr {\n  if (expr instanceof Name) return replaceName(expr)\n  if (!canOptimize(expr)) return expr\n  return new _Code(\n    expr._items.reduce((items: CodeItem[], c: SafeExpr | string) => {\n      if (c instanceof Name) c = replaceName(c)\n      if (c instanceof _Code) items.push(...c._items)\n      else items.push(c)\n      return items\n    }, [])\n  )\n\n  function replaceName(n: Name): SafeExpr {\n    const c = constants[n.str]\n    if (c === undefined || names[n.str] !== 1) return n\n    delete names[n.str]\n    return c\n  }\n\n  function canOptimize(e: SafeExpr): e is _Code {\n    return (\n      e instanceof _Code &&\n      e._items.some(\n        (c) => c instanceof Name && names[c.str] === 1 && constants[c.str] !== undefined\n      )\n    )\n  }\n}\n\nfunction subtractNames(names: UsedNames, from: UsedNames): void {\n  for (const n in from) names[n] = (names[n] || 0) - (from[n] || 0)\n}\n\nexport function not<T extends Code | SafeExpr>(x: T): T\nexport function not(x: Code | SafeExpr): Code | SafeExpr {\n  return typeof x == \"boolean\" || typeof x == \"number\" || x === null ? !x : _`!${par(x)}`\n}\n\nconst andCode = mappend(operators.AND)\n\n// boolean AND (&&) expression with the passed arguments\nexport function and(...args: Code[]): Code {\n  return args.reduce(andCode)\n}\n\nconst orCode = mappend(operators.OR)\n\n// boolean OR (||) expression with the passed arguments\nexport function or(...args: Code[]): Code {\n  return args.reduce(orCode)\n}\n\ntype MAppend = (x: Code, y: Code) => Code\n\nfunction mappend(op: Code): MAppend {\n  return (x, y) => (x === nil ? y : y === nil ? x : _`${par(x)} ${op} ${par(y)}`)\n}\n\nfunction par(x: Code): Code {\n  return x instanceof Name ? x : _`(${x})`\n}\n","import type {AnySchema, EvaluatedProperties, EvaluatedItems} from \"../types\"\nimport type {SchemaCxt, SchemaObjCxt} from \".\"\nimport {_, getProperty, Code, Name, CodeGen} from \"./codegen\"\nimport {_Code} from \"./codegen/code\"\nimport type {Rule, ValidationRules} from \"./rules\"\n\n// TODO refactor to use Set\nexport function toHash<T extends string = string>(arr: T[]): {[K in T]?: true} {\n  const hash: {[K in T]?: true} = {}\n  for (const item of arr) hash[item] = true\n  return hash\n}\n\nexport function alwaysValidSchema(it: SchemaCxt, schema: AnySchema): boolean | void {\n  if (typeof schema == \"boolean\") return schema\n  if (Object.keys(schema).length === 0) return true\n  checkUnknownRules(it, schema)\n  return !schemaHasRules(schema, it.self.RULES.all)\n}\n\nexport function checkUnknownRules(it: SchemaCxt, schema: AnySchema = it.schema): void {\n  const {opts, self} = it\n  if (!opts.strictSchema) return\n  if (typeof schema === \"boolean\") return\n  const rules = self.RULES.keywords\n  for (const key in schema) {\n    if (!rules[key]) checkStrictMode(it, `unknown keyword: \"${key}\"`)\n  }\n}\n\nexport function schemaHasRules(\n  schema: AnySchema,\n  rules: {[Key in string]?: boolean | Rule}\n): boolean {\n  if (typeof schema == \"boolean\") return !schema\n  for (const key in schema) if (rules[key]) return true\n  return false\n}\n\nexport function schemaHasRulesButRef(schema: AnySchema, RULES: ValidationRules): boolean {\n  if (typeof schema == \"boolean\") return !schema\n  for (const key in schema) if (key !== \"$ref\" && RULES.all[key]) return true\n  return false\n}\n\nexport function schemaRefOrVal(\n  {topSchemaRef, schemaPath}: SchemaObjCxt,\n  schema: unknown,\n  keyword: string,\n  $data?: string | false\n): Code | number | boolean {\n  if (!$data) {\n    if (typeof schema == \"number\" || typeof schema == \"boolean\") return schema\n    if (typeof schema == \"string\") return _`${schema}`\n  }\n  return _`${topSchemaRef}${schemaPath}${getProperty(keyword)}`\n}\n\nexport function unescapeFragment(str: string): string {\n  return unescapeJsonPointer(decodeURIComponent(str))\n}\n\nexport function escapeFragment(str: string | number): string {\n  return encodeURIComponent(escapeJsonPointer(str))\n}\n\nexport function escapeJsonPointer(str: string | number): string {\n  if (typeof str == \"number\") return `${str}`\n  return str.replace(/~/g, \"~0\").replace(/\\//g, \"~1\")\n}\n\nexport function unescapeJsonPointer(str: string): string {\n  return str.replace(/~1/g, \"/\").replace(/~0/g, \"~\")\n}\n\nexport function eachItem<T>(xs: T | T[], f: (x: T) => void): void {\n  if (Array.isArray(xs)) {\n    for (const x of xs) f(x)\n  } else {\n    f(xs)\n  }\n}\n\ntype SomeEvaluated = EvaluatedProperties | EvaluatedItems\n\ntype MergeEvaluatedFunc<T extends SomeEvaluated> = (\n  gen: CodeGen,\n  from: Name | T,\n  to: Name | Exclude<T, true> | undefined,\n  toName?: typeof Name\n) => Name | T\n\ninterface MakeMergeFuncArgs<T extends SomeEvaluated> {\n  mergeNames: (gen: CodeGen, from: Name, to: Name) => void\n  mergeToName: (gen: CodeGen, from: T, to: Name) => void\n  mergeValues: (from: T, to: Exclude<T, true>) => T\n  resultToName: (gen: CodeGen, res?: T) => Name\n}\n\nfunction makeMergeEvaluated<T extends SomeEvaluated>({\n  mergeNames,\n  mergeToName,\n  mergeValues,\n  resultToName,\n}: MakeMergeFuncArgs<T>): MergeEvaluatedFunc<T> {\n  return (gen, from, to, toName) => {\n    const res =\n      to === undefined\n        ? from\n        : to instanceof Name\n        ? (from instanceof Name ? mergeNames(gen, from, to) : mergeToName(gen, from, to), to)\n        : from instanceof Name\n        ? (mergeToName(gen, to, from), from)\n        : mergeValues(from, to)\n    return toName === Name && !(res instanceof Name) ? resultToName(gen, res) : res\n  }\n}\n\ninterface MergeEvaluated {\n  props: MergeEvaluatedFunc<EvaluatedProperties>\n  items: MergeEvaluatedFunc<EvaluatedItems>\n}\n\nexport const mergeEvaluated: MergeEvaluated = {\n  props: makeMergeEvaluated({\n    mergeNames: (gen, from, to) =>\n      gen.if(_`${to} !== true && ${from} !== undefined`, () => {\n        gen.if(\n          _`${from} === true`,\n          () => gen.assign(to, true),\n          () => gen.assign(to, _`${to} || {}`).code(_`Object.assign(${to}, ${from})`)\n        )\n      }),\n    mergeToName: (gen, from, to) =>\n      gen.if(_`${to} !== true`, () => {\n        if (from === true) {\n          gen.assign(to, true)\n        } else {\n          gen.assign(to, _`${to} || {}`)\n          setEvaluated(gen, to, from)\n        }\n      }),\n    mergeValues: (from, to) => (from === true ? true : {...from, ...to}),\n    resultToName: evaluatedPropsToName,\n  }),\n  items: makeMergeEvaluated({\n    mergeNames: (gen, from, to) =>\n      gen.if(_`${to} !== true && ${from} !== undefined`, () =>\n        gen.assign(to, _`${from} === true ? true : ${to} > ${from} ? ${to} : ${from}`)\n      ),\n    mergeToName: (gen, from, to) =>\n      gen.if(_`${to} !== true`, () =>\n        gen.assign(to, from === true ? true : _`${to} > ${from} ? ${to} : ${from}`)\n      ),\n    mergeValues: (from, to) => (from === true ? true : Math.max(from, to)),\n    resultToName: (gen, items) => gen.var(\"items\", items),\n  }),\n}\n\nexport function evaluatedPropsToName(gen: CodeGen, ps?: EvaluatedProperties): Name {\n  if (ps === true) return gen.var(\"props\", true)\n  const props = gen.var(\"props\", _`{}`)\n  if (ps !== undefined) setEvaluated(gen, props, ps)\n  return props\n}\n\nexport function setEvaluated(gen: CodeGen, props: Name, ps: {[K in string]?: true}): void {\n  Object.keys(ps).forEach((p) => gen.assign(_`${props}${getProperty(p)}`, true))\n}\n\nconst snippets: {[S in string]?: _Code} = {}\n\nexport function useFunc(gen: CodeGen, f: {code: string}): Name {\n  return gen.scopeValue(\"func\", {\n    ref: f,\n    code: snippets[f.code] || (snippets[f.code] = new _Code(f.code)),\n  })\n}\n\nexport enum Type {\n  Num,\n  Str,\n}\n\nexport function getErrorPath(\n  dataProp: Name | string | number,\n  dataPropType?: Type,\n  jsPropertySyntax?: boolean\n): Code | string {\n  // let path\n  if (dataProp instanceof Name) {\n    const isNumber = dataPropType === Type.Num\n    return jsPropertySyntax\n      ? isNumber\n        ? _`\"[\" + ${dataProp} + \"]\"`\n        : _`\"['\" + ${dataProp} + \"']\"`\n      : isNumber\n      ? _`\"/\" + ${dataProp}`\n      : _`\"/\" + ${dataProp}.replace(/~/g, \"~0\").replace(/\\\\//g, \"~1\")` // TODO maybe use global escapePointer\n  }\n  return jsPropertySyntax ? getProperty(dataProp).toString() : \"/\" + escapeJsonPointer(dataProp)\n}\n\nexport function checkStrictMode(\n  it: SchemaCxt,\n  msg: string,\n  mode: boolean | \"log\" = it.opts.strictSchema\n): void {\n  if (!mode) return\n  msg = `strict mode: ${msg}`\n  if (mode === true) throw new Error(msg)\n  it.self.logger.warn(msg)\n}\n","import {Name} from \"./codegen\"\n\nconst names = {\n  // validation function arguments\n  data: new Name(\"data\"), // data passed to validation function\n  // args passed from referencing schema\n  valCxt: new Name(\"valCxt\"), // validation/data context - should not be used directly, it is destructured to the names below\n  instancePath: new Name(\"instancePath\"),\n  parentData: new Name(\"parentData\"),\n  parentDataProperty: new Name(\"parentDataProperty\"),\n  rootData: new Name(\"rootData\"), // root data - same as the data passed to the first/top validation function\n  dynamicAnchors: new Name(\"dynamicAnchors\"), // used to support recursiveRef and dynamicRef\n  // function scoped variables\n  vErrors: new Name(\"vErrors\"), // null or array of validation errors\n  errors: new Name(\"errors\"), // counter of validation errors\n  this: new Name(\"this\"),\n  // \"globals\"\n  self: new Name(\"self\"),\n  scope: new Name(\"scope\"),\n  // JTD serialize/parse name for JSON string and position\n  json: new Name(\"json\"),\n  jsonPos: new Name(\"jsonPos\"),\n  jsonLen: new Name(\"jsonLen\"),\n  jsonPart: new Name(\"jsonPart\"),\n}\n\nexport default names\n","import type {KeywordErrorCxt, KeywordErrorDefinition} from \"../types\"\nimport type {SchemaCxt} from \"./index\"\nimport {CodeGen, _, str, strConcat, Code, Name} from \"./codegen\"\nimport {SafeExpr} from \"./codegen/code\"\nimport {getErrorPath, Type} from \"./util\"\nimport N from \"./names\"\n\nexport const keywordError: KeywordErrorDefinition = {\n  message: ({keyword}) => str`must pass \"${keyword}\" keyword validation`,\n}\n\nexport const keyword$DataError: KeywordErrorDefinition = {\n  message: ({keyword, schemaType}) =>\n    schemaType\n      ? str`\"${keyword}\" keyword must be ${schemaType} ($data)`\n      : str`\"${keyword}\" keyword is invalid ($data)`,\n}\n\nexport interface ErrorPaths {\n  instancePath?: Code\n  schemaPath?: string\n  parentSchema?: boolean\n}\n\nexport function reportError(\n  cxt: KeywordErrorCxt,\n  error: KeywordErrorDefinition = keywordError,\n  errorPaths?: ErrorPaths,\n  overrideAllErrors?: boolean\n): void {\n  const {it} = cxt\n  const {gen, compositeRule, allErrors} = it\n  const errObj = errorObjectCode(cxt, error, errorPaths)\n  if (overrideAllErrors ?? (compositeRule || allErrors)) {\n    addError(gen, errObj)\n  } else {\n    returnErrors(it, _`[${errObj}]`)\n  }\n}\n\nexport function reportExtraError(\n  cxt: KeywordErrorCxt,\n  error: KeywordErrorDefinition = keywordError,\n  errorPaths?: ErrorPaths\n): void {\n  const {it} = cxt\n  const {gen, compositeRule, allErrors} = it\n  const errObj = errorObjectCode(cxt, error, errorPaths)\n  addError(gen, errObj)\n  if (!(compositeRule || allErrors)) {\n    returnErrors(it, N.vErrors)\n  }\n}\n\nexport function resetErrorsCount(gen: CodeGen, errsCount: Name): void {\n  gen.assign(N.errors, errsCount)\n  gen.if(_`${N.vErrors} !== null`, () =>\n    gen.if(\n      errsCount,\n      () => gen.assign(_`${N.vErrors}.length`, errsCount),\n      () => gen.assign(N.vErrors, null)\n    )\n  )\n}\n\nexport function extendErrors({\n  gen,\n  keyword,\n  schemaValue,\n  data,\n  errsCount,\n  it,\n}: KeywordErrorCxt): void {\n  /* istanbul ignore if */\n  if (errsCount === undefined) throw new Error(\"ajv implementation error\")\n  const err = gen.name(\"err\")\n  gen.forRange(\"i\", errsCount, N.errors, (i) => {\n    gen.const(err, _`${N.vErrors}[${i}]`)\n    gen.if(_`${err}.instancePath === undefined`, () =>\n      gen.assign(_`${err}.instancePath`, strConcat(N.instancePath, it.errorPath))\n    )\n    gen.assign(_`${err}.schemaPath`, str`${it.errSchemaPath}/${keyword}`)\n    if (it.opts.verbose) {\n      gen.assign(_`${err}.schema`, schemaValue)\n      gen.assign(_`${err}.data`, data)\n    }\n  })\n}\n\nfunction addError(gen: CodeGen, errObj: Code): void {\n  const err = gen.const(\"err\", errObj)\n  gen.if(\n    _`${N.vErrors} === null`,\n    () => gen.assign(N.vErrors, _`[${err}]`),\n    _`${N.vErrors}.push(${err})`\n  )\n  gen.code(_`${N.errors}++`)\n}\n\nfunction returnErrors(it: SchemaCxt, errs: Code): void {\n  const {gen, validateName, schemaEnv} = it\n  if (schemaEnv.$async) {\n    gen.throw(_`new ${it.ValidationError as Name}(${errs})`)\n  } else {\n    gen.assign(_`${validateName}.errors`, errs)\n    gen.return(false)\n  }\n}\n\nconst E = {\n  keyword: new Name(\"keyword\"),\n  schemaPath: new Name(\"schemaPath\"), // also used in JTD errors\n  params: new Name(\"params\"),\n  propertyName: new Name(\"propertyName\"),\n  message: new Name(\"message\"),\n  schema: new Name(\"schema\"),\n  parentSchema: new Name(\"parentSchema\"),\n}\n\nfunction errorObjectCode(\n  cxt: KeywordErrorCxt,\n  error: KeywordErrorDefinition,\n  errorPaths?: ErrorPaths\n): Code {\n  const {createErrors} = cxt.it\n  if (createErrors === false) return _`{}`\n  return errorObject(cxt, error, errorPaths)\n}\n\nfunction errorObject(\n  cxt: KeywordErrorCxt,\n  error: KeywordErrorDefinition,\n  errorPaths: ErrorPaths = {}\n): Code {\n  const {gen, it} = cxt\n  const keyValues: [Name, SafeExpr | string][] = [\n    errorInstancePath(it, errorPaths),\n    errorSchemaPath(cxt, errorPaths),\n  ]\n  extraErrorProps(cxt, error, keyValues)\n  return gen.object(...keyValues)\n}\n\nfunction errorInstancePath({errorPath}: SchemaCxt, {instancePath}: ErrorPaths): [Name, Code] {\n  const instPath = instancePath\n    ? str`${errorPath}${getErrorPath(instancePath, Type.Str)}`\n    : errorPath\n  return [N.instancePath, strConcat(N.instancePath, instPath)]\n}\n\nfunction errorSchemaPath(\n  {keyword, it: {errSchemaPath}}: KeywordErrorCxt,\n  {schemaPath, parentSchema}: ErrorPaths\n): [Name, string | Code] {\n  let schPath = parentSchema ? errSchemaPath : str`${errSchemaPath}/${keyword}`\n  if (schemaPath) {\n    schPath = str`${schPath}${getErrorPath(schemaPath, Type.Str)}`\n  }\n  return [E.schemaPath, schPath]\n}\n\nfunction extraErrorProps(\n  cxt: KeywordErrorCxt,\n  {params, message}: KeywordErrorDefinition,\n  keyValues: [Name, SafeExpr | string][]\n): void {\n  const {keyword, data, schemaValue, it} = cxt\n  const {opts, propertyName, topSchemaRef, schemaPath} = it\n  keyValues.push(\n    [E.keyword, keyword],\n    [E.params, typeof params == \"function\" ? params(cxt) : params || _`{}`]\n  )\n  if (opts.messages) {\n    keyValues.push([E.message, typeof message == \"function\" ? message(cxt) : message])\n  }\n  if (opts.verbose) {\n    keyValues.push(\n      [E.schema, schemaValue],\n      [E.parentSchema, _`${topSchemaRef}${schemaPath}`],\n      [N.data, data]\n    )\n  }\n  if (propertyName) keyValues.push([E.propertyName, propertyName])\n}\n","import type {KeywordErrorDefinition, KeywordErrorCxt} from \"../../types\"\nimport type {SchemaCxt} from \"..\"\nimport {reportError} from \"../errors\"\nimport {_, Name} from \"../codegen\"\nimport N from \"../names\"\n\nconst boolError: KeywordErrorDefinition = {\n  message: \"boolean schema is false\",\n}\n\nexport function topBoolOrEmptySchema(it: SchemaCxt): void {\n  const {gen, schema, validateName} = it\n  if (schema === false) {\n    falseSchemaError(it, false)\n  } else if (typeof schema == \"object\" && schema.$async === true) {\n    gen.return(N.data)\n  } else {\n    gen.assign(_`${validateName}.errors`, null)\n    gen.return(true)\n  }\n}\n\nexport function boolOrEmptySchema(it: SchemaCxt, valid: Name): void {\n  const {gen, schema} = it\n  if (schema === false) {\n    gen.var(valid, false) // TODO var\n    falseSchemaError(it)\n  } else {\n    gen.var(valid, true) // TODO var\n  }\n}\n\nfunction falseSchemaError(it: SchemaCxt, overrideAllErrors?: boolean): void {\n  const {gen, data} = it\n  // TODO maybe some other interface should be used for non-keyword validation errors...\n  const cxt: KeywordErrorCxt = {\n    gen,\n    keyword: \"false schema\",\n    data,\n    schema: false,\n    schemaCode: false,\n    schemaValue: false,\n    params: {},\n    it,\n  }\n  reportError(cxt, boolError, undefined, overrideAllErrors)\n}\n","import type {AddedKeywordDefinition} from \"../types\"\n\nconst _jsonTypes = [\"string\", \"number\", \"integer\", \"boolean\", \"null\", \"object\", \"array\"] as const\n\nexport type JSONType = (typeof _jsonTypes)[number]\n\nconst jsonTypes: Set<string> = new Set(_jsonTypes)\n\nexport function isJSONType(x: unknown): x is JSONType {\n  return typeof x == \"string\" && jsonTypes.has(x)\n}\n\ntype ValidationTypes = {\n  [K in JSONType]: boolean | RuleGroup | undefined\n}\n\nexport interface ValidationRules {\n  rules: RuleGroup[]\n  post: RuleGroup\n  all: {[Key in string]?: boolean | Rule} // rules that have to be validated\n  keywords: {[Key in string]?: boolean} // all known keywords (superset of \"all\")\n  types: ValidationTypes\n}\n\nexport interface RuleGroup {\n  type?: JSONType\n  rules: Rule[]\n}\n\n// This interface wraps KeywordDefinition because definition can have multiple keywords\nexport interface Rule {\n  keyword: string\n  definition: AddedKeywordDefinition\n}\n\nexport function getRules(): ValidationRules {\n  const groups: Record<\"number\" | \"string\" | \"array\" | \"object\", RuleGroup> = {\n    number: {type: \"number\", rules: []},\n    string: {type: \"string\", rules: []},\n    array: {type: \"array\", rules: []},\n    object: {type: \"object\", rules: []},\n  }\n  return {\n    types: {...groups, integer: true, boolean: true, null: true},\n    rules: [{rules: []}, groups.number, groups.string, groups.array, groups.object],\n    post: {rules: []},\n    all: {},\n    keywords: {},\n  }\n}\n","import type {AnySchemaObject} from \"../../types\"\nimport type {SchemaObjCxt} from \"..\"\nimport type {JSONType, RuleGroup, Rule} from \"../rules\"\n\nexport function schemaHasRulesForType(\n  {schema, self}: SchemaObjCxt,\n  type: JSONType\n): boolean | undefined {\n  const group = self.RULES.types[type]\n  return group && group !== true && shouldUseGroup(schema, group)\n}\n\nexport function shouldUseGroup(schema: AnySchemaObject, group: RuleGroup): boolean {\n  return group.rules.some((rule) => shouldUseRule(schema, rule))\n}\n\nexport function shouldUseRule(schema: AnySchemaObject, rule: Rule): boolean | undefined {\n  return (\n    schema[rule.keyword] !== undefined ||\n    rule.definition.implements?.some((kwd) => schema[kwd] !== undefined)\n  )\n}\n","import type {\n  KeywordErrorDefinition,\n  KeywordErrorCxt,\n  ErrorObject,\n  AnySchemaObject,\n} from \"../../types\"\nimport type {SchemaObjCxt} from \"..\"\nimport {isJSONType, JSONType} from \"../rules\"\nimport {schemaHasRulesForType} from \"./applicability\"\nimport {reportError} from \"../errors\"\nimport {_, nil, and, not, operators, Code, Name} from \"../codegen\"\nimport {toHash, schemaRefOrVal} from \"../util\"\n\nexport enum DataType {\n  Correct,\n  Wrong,\n}\n\nexport function getSchemaTypes(schema: AnySchemaObject): JSONType[] {\n  const types = getJSONTypes(schema.type)\n  const hasNull = types.includes(\"null\")\n  if (hasNull) {\n    if (schema.nullable === false) throw new Error(\"type: null contradicts nullable: false\")\n  } else {\n    if (!types.length && schema.nullable !== undefined) {\n      throw new Error('\"nullable\" cannot be used without \"type\"')\n    }\n    if (schema.nullable === true) types.push(\"null\")\n  }\n  return types\n}\n\n// eslint-disable-next-line @typescript-eslint/no-redundant-type-constituents\nexport function getJSONTypes(ts: unknown | unknown[]): JSONType[] {\n  const types: unknown[] = Array.isArray(ts) ? ts : ts ? [ts] : []\n  if (types.every(isJSONType)) return types\n  throw new Error(\"type must be JSONType or JSONType[]: \" + types.join(\",\"))\n}\n\nexport function coerceAndCheckDataType(it: SchemaObjCxt, types: JSONType[]): boolean {\n  const {gen, data, opts} = it\n  const coerceTo = coerceToTypes(types, opts.coerceTypes)\n  const checkTypes =\n    types.length > 0 &&\n    !(coerceTo.length === 0 && types.length === 1 && schemaHasRulesForType(it, types[0]))\n  if (checkTypes) {\n    const wrongType = checkDataTypes(types, data, opts.strictNumbers, DataType.Wrong)\n    gen.if(wrongType, () => {\n      if (coerceTo.length) coerceData(it, types, coerceTo)\n      else reportTypeError(it)\n    })\n  }\n  return checkTypes\n}\n\nconst COERCIBLE: Set<JSONType> = new Set([\"string\", \"number\", \"integer\", \"boolean\", \"null\"])\nfunction coerceToTypes(types: JSONType[], coerceTypes?: boolean | \"array\"): JSONType[] {\n  return coerceTypes\n    ? types.filter((t) => COERCIBLE.has(t) || (coerceTypes === \"array\" && t === \"array\"))\n    : []\n}\n\nfunction coerceData(it: SchemaObjCxt, types: JSONType[], coerceTo: JSONType[]): void {\n  const {gen, data, opts} = it\n  const dataType = gen.let(\"dataType\", _`typeof ${data}`)\n  const coerced = gen.let(\"coerced\", _`undefined`)\n  if (opts.coerceTypes === \"array\") {\n    gen.if(_`${dataType} == 'object' && Array.isArray(${data}) && ${data}.length == 1`, () =>\n      gen\n        .assign(data, _`${data}[0]`)\n        .assign(dataType, _`typeof ${data}`)\n        .if(checkDataTypes(types, data, opts.strictNumbers), () => gen.assign(coerced, data))\n    )\n  }\n  gen.if(_`${coerced} !== undefined`)\n  for (const t of coerceTo) {\n    if (COERCIBLE.has(t) || (t === \"array\" && opts.coerceTypes === \"array\")) {\n      coerceSpecificType(t)\n    }\n  }\n  gen.else()\n  reportTypeError(it)\n  gen.endIf()\n\n  gen.if(_`${coerced} !== undefined`, () => {\n    gen.assign(data, coerced)\n    assignParentData(it, coerced)\n  })\n\n  function coerceSpecificType(t: string): void {\n    switch (t) {\n      case \"string\":\n        gen\n          .elseIf(_`${dataType} == \"number\" || ${dataType} == \"boolean\"`)\n          .assign(coerced, _`\"\" + ${data}`)\n          .elseIf(_`${data} === null`)\n          .assign(coerced, _`\"\"`)\n        return\n      case \"number\":\n        gen\n          .elseIf(\n            _`${dataType} == \"boolean\" || ${data} === null\n              || (${dataType} == \"string\" && ${data} && ${data} == +${data})`\n          )\n          .assign(coerced, _`+${data}`)\n        return\n      case \"integer\":\n        gen\n          .elseIf(\n            _`${dataType} === \"boolean\" || ${data} === null\n              || (${dataType} === \"string\" && ${data} && ${data} == +${data} && !(${data} % 1))`\n          )\n          .assign(coerced, _`+${data}`)\n        return\n      case \"boolean\":\n        gen\n          .elseIf(_`${data} === \"false\" || ${data} === 0 || ${data} === null`)\n          .assign(coerced, false)\n          .elseIf(_`${data} === \"true\" || ${data} === 1`)\n          .assign(coerced, true)\n        return\n      case \"null\":\n        gen.elseIf(_`${data} === \"\" || ${data} === 0 || ${data} === false`)\n        gen.assign(coerced, null)\n        return\n\n      case \"array\":\n        gen\n          .elseIf(\n            _`${dataType} === \"string\" || ${dataType} === \"number\"\n              || ${dataType} === \"boolean\" || ${data} === null`\n          )\n          .assign(coerced, _`[${data}]`)\n    }\n  }\n}\n\nfunction assignParentData({gen, parentData, parentDataProperty}: SchemaObjCxt, expr: Name): void {\n  // TODO use gen.property\n  gen.if(_`${parentData} !== undefined`, () =>\n    gen.assign(_`${parentData}[${parentDataProperty}]`, expr)\n  )\n}\n\nexport function checkDataType(\n  dataType: JSONType,\n  data: Name,\n  strictNums?: boolean | \"log\",\n  correct = DataType.Correct\n): Code {\n  const EQ = correct === DataType.Correct ? operators.EQ : operators.NEQ\n  let cond: Code\n  switch (dataType) {\n    case \"null\":\n      return _`${data} ${EQ} null`\n    case \"array\":\n      cond = _`Array.isArray(${data})`\n      break\n    case \"object\":\n      cond = _`${data} && typeof ${data} == \"object\" && !Array.isArray(${data})`\n      break\n    case \"integer\":\n      cond = numCond(_`!(${data} % 1) && !isNaN(${data})`)\n      break\n    case \"number\":\n      cond = numCond()\n      break\n    default:\n      return _`typeof ${data} ${EQ} ${dataType}`\n  }\n  return correct === DataType.Correct ? cond : not(cond)\n\n  function numCond(_cond: Code = nil): Code {\n    return and(_`typeof ${data} == \"number\"`, _cond, strictNums ? _`isFinite(${data})` : nil)\n  }\n}\n\nexport function checkDataTypes(\n  dataTypes: JSONType[],\n  data: Name,\n  strictNums?: boolean | \"log\",\n  correct?: DataType\n): Code {\n  if (dataTypes.length === 1) {\n    return checkDataType(dataTypes[0], data, strictNums, correct)\n  }\n  let cond: Code\n  const types = toHash(dataTypes)\n  if (types.array && types.object) {\n    const notObj = _`typeof ${data} != \"object\"`\n    cond = types.null ? notObj : _`!${data} || ${notObj}`\n    delete types.null\n    delete types.array\n    delete types.object\n  } else {\n    cond = nil\n  }\n  if (types.number) delete types.integer\n  for (const t in types) cond = and(cond, checkDataType(t as JSONType, data, strictNums, correct))\n  return cond\n}\n\nexport type TypeError = ErrorObject<\"type\", {type: string}>\n\nconst typeError: KeywordErrorDefinition = {\n  message: ({schema}) => `must be ${schema}`,\n  params: ({schema, schemaValue}) =>\n    typeof schema == \"string\" ? _`{type: ${schema}}` : _`{type: ${schemaValue}}`,\n}\n\nexport function reportTypeError(it: SchemaObjCxt): void {\n  const cxt = getTypeErrorContext(it)\n  reportError(cxt, typeError)\n}\n\nfunction getTypeErrorContext(it: SchemaObjCxt): KeywordErrorCxt {\n  const {gen, data, schema} = it\n  const schemaCode = schemaRefOrVal(it, schema, \"type\")\n  return {\n    gen,\n    keyword: \"type\",\n    data,\n    schema: schema.type,\n    schemaCode,\n    schemaValue: schemaCode,\n    parentSchema: schema,\n    params: {},\n    it,\n  }\n}\n","import type {SchemaObjCxt} from \"..\"\nimport {_, getProperty, stringify} from \"../codegen\"\nimport {checkStrictMode} from \"../util\"\n\nexport function assignDefaults(it: SchemaObjCxt, ty?: string): void {\n  const {properties, items} = it.schema\n  if (ty === \"object\" && properties) {\n    for (const key in properties) {\n      assignDefault(it, key, properties[key].default)\n    }\n  } else if (ty === \"array\" && Array.isArray(items)) {\n    items.forEach((sch, i: number) => assignDefault(it, i, sch.default))\n  }\n}\n\nfunction assignDefault(it: SchemaObjCxt, prop: string | number, defaultValue: unknown): void {\n  const {gen, compositeRule, data, opts} = it\n  if (defaultValue === undefined) return\n  const childData = _`${data}${getProperty(prop)}`\n  if (compositeRule) {\n    checkStrictMode(it, `default is ignored for: ${childData}`)\n    return\n  }\n\n  let condition = _`${childData} === undefined`\n  if (opts.useDefaults === \"empty\") {\n    condition = _`${condition} || ${childData} === null || ${childData} === \"\"`\n  }\n  // `${childData} === undefined` +\n  // (opts.useDefaults === \"empty\" ? ` || ${childData} === null || ${childData} === \"\"` : \"\")\n  gen.if(condition, _`${childData} = ${stringify(defaultValue)}`)\n}\n","import type {AnySchema, SchemaMap} from \"../types\"\nimport type {SchemaCxt} from \"../compile\"\nimport type {KeywordCxt} from \"../compile/validate\"\nimport {CodeGen, _, and, or, not, nil, strConcat, getProperty, Code, Name} from \"../compile/codegen\"\nimport {alwaysValidSchema, Type} from \"../compile/util\"\nimport N from \"../compile/names\"\nimport {useFunc} from \"../compile/util\"\nexport function checkReportMissingProp(cxt: KeywordCxt, prop: string): void {\n  const {gen, data, it} = cxt\n  gen.if(noPropertyInData(gen, data, prop, it.opts.ownProperties), () => {\n    cxt.setParams({missingProperty: _`${prop}`}, true)\n    cxt.error()\n  })\n}\n\nexport function checkMissingProp(\n  {gen, data, it: {opts}}: KeywordCxt,\n  properties: string[],\n  missing: Name\n): Code {\n  return or(\n    ...properties.map((prop) =>\n      and(noPropertyInData(gen, data, prop, opts.ownProperties), _`${missing} = ${prop}`)\n    )\n  )\n}\n\nexport function reportMissingProp(cxt: KeywordCxt, missing: Name): void {\n  cxt.setParams({missingProperty: missing}, true)\n  cxt.error()\n}\n\nexport function hasPropFunc(gen: CodeGen): Name {\n  return gen.scopeValue(\"func\", {\n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    ref: Object.prototype.hasOwnProperty,\n    code: _`Object.prototype.hasOwnProperty`,\n  })\n}\n\nexport function isOwnProperty(gen: CodeGen, data: Name, property: Name | string): Code {\n  return _`${hasPropFunc(gen)}.call(${data}, ${property})`\n}\n\nexport function propertyInData(\n  gen: CodeGen,\n  data: Name,\n  property: Name | string,\n  ownProperties?: boolean\n): Code {\n  const cond = _`${data}${getProperty(property)} !== undefined`\n  return ownProperties ? _`${cond} && ${isOwnProperty(gen, data, property)}` : cond\n}\n\nexport function noPropertyInData(\n  gen: CodeGen,\n  data: Name,\n  property: Name | string,\n  ownProperties?: boolean\n): Code {\n  const cond = _`${data}${getProperty(property)} === undefined`\n  return ownProperties ? or(cond, not(isOwnProperty(gen, data, property))) : cond\n}\n\nexport function allSchemaProperties(schemaMap?: SchemaMap): string[] {\n  return schemaMap ? Object.keys(schemaMap).filter((p) => p !== \"__proto__\") : []\n}\n\nexport function schemaProperties(it: SchemaCxt, schemaMap: SchemaMap): string[] {\n  return allSchemaProperties(schemaMap).filter(\n    (p) => !alwaysValidSchema(it, schemaMap[p] as AnySchema)\n  )\n}\n\nexport function callValidateCode(\n  {schemaCode, data, it: {gen, topSchemaRef, schemaPath, errorPath}, it}: KeywordCxt,\n  func: Code,\n  context: Code,\n  passSchema?: boolean\n): Code {\n  const dataAndSchema = passSchema ? _`${schemaCode}, ${data}, ${topSchemaRef}${schemaPath}` : data\n  const valCxt: [Name, Code | number][] = [\n    [N.instancePath, strConcat(N.instancePath, errorPath)],\n    [N.parentData, it.parentData],\n    [N.parentDataProperty, it.parentDataProperty],\n    [N.rootData, N.rootData],\n  ]\n  if (it.opts.dynamicRef) valCxt.push([N.dynamicAnchors, N.dynamicAnchors])\n  const args = _`${dataAndSchema}, ${gen.object(...valCxt)}`\n  return context !== nil ? _`${func}.call(${context}, ${args})` : _`${func}(${args})`\n}\n\nconst newRegExp = _`new RegExp`\n\nexport function usePattern({gen, it: {opts}}: KeywordCxt, pattern: string): Name {\n  const u = opts.unicodeRegExp ? \"u\" : \"\"\n  const {regExp} = opts.code\n  const rx = regExp(pattern, u)\n\n  return gen.scopeValue(\"pattern\", {\n    key: rx.toString(),\n    ref: rx,\n    code: _`${regExp.code === \"new RegExp\" ? newRegExp : useFunc(gen, regExp)}(${pattern}, ${u})`,\n  })\n}\n\nexport function validateArray(cxt: KeywordCxt): Name {\n  const {gen, data, keyword, it} = cxt\n  const valid = gen.name(\"valid\")\n  if (it.allErrors) {\n    const validArr = gen.let(\"valid\", true)\n    validateItems(() => gen.assign(validArr, false))\n    return validArr\n  }\n  gen.var(valid, true)\n  validateItems(() => gen.break())\n  return valid\n\n  function validateItems(notValid: () => void): void {\n    const len = gen.const(\"len\", _`${data}.length`)\n    gen.forRange(\"i\", 0, len, (i) => {\n      cxt.subschema(\n        {\n          keyword,\n          dataProp: i,\n          dataPropType: Type.Num,\n        },\n        valid\n      )\n      gen.if(not(valid), notValid)\n    })\n  }\n}\n\nexport function validateUnion(cxt: KeywordCxt): void {\n  const {gen, schema, keyword, it} = cxt\n  /* istanbul ignore if */\n  if (!Array.isArray(schema)) throw new Error(\"ajv implementation error\")\n  const alwaysValid = schema.some((sch: AnySchema) => alwaysValidSchema(it, sch))\n  if (alwaysValid && !it.opts.unevaluated) return\n\n  const valid = gen.let(\"valid\", false)\n  const schValid = gen.name(\"_valid\")\n\n  gen.block(() =>\n    schema.forEach((_sch: AnySchema, i: number) => {\n      const schCxt = cxt.subschema(\n        {\n          keyword,\n          schemaProp: i,\n          compositeRule: true,\n        },\n        schValid\n      )\n      gen.assign(valid, _`${valid} || ${schValid}`)\n      const merged = cxt.mergeValidEvaluated(schCxt, schValid)\n      // can short-circuit if `unevaluatedProperties/Items` not supported (opts.unevaluated !== true)\n      // or if all properties and items were evaluated (it.props === true && it.items === true)\n      if (!merged) gen.if(not(valid))\n    })\n  )\n\n  cxt.result(\n    valid,\n    () => cxt.reset(),\n    () => cxt.error(true)\n  )\n}\n","import type {KeywordCxt} from \".\"\nimport type {\n  AnySchema,\n  SchemaValidateFunction,\n  AnyValidateFunction,\n  AddedKeywordDefinition,\n  MacroKeywordDefinition,\n  FuncKeywordDefinition,\n} from \"../../types\"\nimport type {SchemaObjCxt} from \"..\"\nimport {_, nil, not, stringify, Code, Name, CodeGen} from \"../codegen\"\nimport N from \"../names\"\nimport type {JSONType} from \"../rules\"\nimport {callValidateCode} from \"../../vocabularies/code\"\nimport {extendErrors} from \"../errors\"\n\ntype KeywordCompilationResult = AnySchema | SchemaValidateFunction | AnyValidateFunction\n\nexport function macroKeywordCode(cxt: KeywordCxt, def: MacroKeywordDefinition): void {\n  const {gen, keyword, schema, parentSchema, it} = cxt\n  const macroSchema = def.macro.call(it.self, schema, parentSchema, it)\n  const schemaRef = useKeyword(gen, keyword, macroSchema)\n  if (it.opts.validateSchema !== false) it.self.validateSchema(macroSchema, true)\n\n  const valid = gen.name(\"valid\")\n  cxt.subschema(\n    {\n      schema: macroSchema,\n      schemaPath: nil,\n      errSchemaPath: `${it.errSchemaPath}/${keyword}`,\n      topSchemaRef: schemaRef,\n      compositeRule: true,\n    },\n    valid\n  )\n  cxt.pass(valid, () => cxt.error(true))\n}\n\nexport function funcKeywordCode(cxt: KeywordCxt, def: FuncKeywordDefinition): void {\n  const {gen, keyword, schema, parentSchema, $data, it} = cxt\n  checkAsyncKeyword(it, def)\n  const validate =\n    !$data && def.compile ? def.compile.call(it.self, schema, parentSchema, it) : def.validate\n  const validateRef = useKeyword(gen, keyword, validate)\n  const valid = gen.let(\"valid\")\n  cxt.block$data(valid, validateKeyword)\n  cxt.ok(def.valid ?? valid)\n\n  function validateKeyword(): void {\n    if (def.errors === false) {\n      assignValid()\n      if (def.modifying) modifyData(cxt)\n      reportErrs(() => cxt.error())\n    } else {\n      const ruleErrs = def.async ? validateAsync() : validateSync()\n      if (def.modifying) modifyData(cxt)\n      reportErrs(() => addErrs(cxt, ruleErrs))\n    }\n  }\n\n  function validateAsync(): Name {\n    const ruleErrs = gen.let(\"ruleErrs\", null)\n    gen.try(\n      () => assignValid(_`await `),\n      (e) =>\n        gen.assign(valid, false).if(\n          _`${e} instanceof ${it.ValidationError as Name}`,\n          () => gen.assign(ruleErrs, _`${e}.errors`),\n          () => gen.throw(e)\n        )\n    )\n    return ruleErrs\n  }\n\n  function validateSync(): Code {\n    const validateErrs = _`${validateRef}.errors`\n    gen.assign(validateErrs, null)\n    assignValid(nil)\n    return validateErrs\n  }\n\n  function assignValid(_await: Code = def.async ? _`await ` : nil): void {\n    const passCxt = it.opts.passContext ? N.this : N.self\n    const passSchema = !((\"compile\" in def && !$data) || def.schema === false)\n    gen.assign(\n      valid,\n      _`${_await}${callValidateCode(cxt, validateRef, passCxt, passSchema)}`,\n      def.modifying\n    )\n  }\n\n  function reportErrs(errors: () => void): void {\n    gen.if(not(def.valid ?? valid), errors)\n  }\n}\n\nfunction modifyData(cxt: KeywordCxt): void {\n  const {gen, data, it} = cxt\n  gen.if(it.parentData, () => gen.assign(data, _`${it.parentData}[${it.parentDataProperty}]`))\n}\n\nfunction addErrs(cxt: KeywordCxt, errs: Code): void {\n  const {gen} = cxt\n  gen.if(\n    _`Array.isArray(${errs})`,\n    () => {\n      gen\n        .assign(N.vErrors, _`${N.vErrors} === null ? ${errs} : ${N.vErrors}.concat(${errs})`)\n        .assign(N.errors, _`${N.vErrors}.length`)\n      extendErrors(cxt)\n    },\n    () => cxt.error()\n  )\n}\n\nfunction checkAsyncKeyword({schemaEnv}: SchemaObjCxt, def: FuncKeywordDefinition): void {\n  if (def.async && !schemaEnv.$async) throw new Error(\"async keyword in sync schema\")\n}\n\nfunction useKeyword(gen: CodeGen, keyword: string, result?: KeywordCompilationResult): Name {\n  if (result === undefined) throw new Error(`keyword \"${keyword}\" failed to compile`)\n  return gen.scopeValue(\n    \"keyword\",\n    typeof result == \"function\" ? {ref: result} : {ref: result, code: stringify(result)}\n  )\n}\n\nexport function validSchemaType(\n  schema: unknown,\n  schemaType: JSONType[],\n  allowUndefined = false\n): boolean {\n  // TODO add tests\n  return (\n    !schemaType.length ||\n    schemaType.some((st) =>\n      st === \"array\"\n        ? Array.isArray(schema)\n        : st === \"object\"\n        ? schema && typeof schema == \"object\" && !Array.isArray(schema)\n        : typeof schema == st || (allowUndefined && typeof schema == \"undefined\")\n    )\n  )\n}\n\nexport function validateKeywordUsage(\n  {schema, opts, self, errSchemaPath}: SchemaObjCxt,\n  def: AddedKeywordDefinition,\n  keyword: string\n): void {\n  /* istanbul ignore if */\n  if (Array.isArray(def.keyword) ? !def.keyword.includes(keyword) : def.keyword !== keyword) {\n    throw new Error(\"ajv implementation error\")\n  }\n\n  const deps = def.dependencies\n  if (deps?.some((kwd) => !Object.prototype.hasOwnProperty.call(schema, kwd))) {\n    throw new Error(`parent schema must have dependencies of ${keyword}: ${deps.join(\",\")}`)\n  }\n\n  if (def.validateSchema) {\n    const valid = def.validateSchema(schema[keyword])\n    if (!valid) {\n      const msg =\n        `keyword \"${keyword}\" value is invalid at path \"${errSchemaPath}\": ` +\n        self.errorsText(def.validateSchema.errors)\n      if (opts.validateSchema === \"log\") self.logger.error(msg)\n      else throw new Error(msg)\n    }\n  }\n}\n","import type {AnySchema} from \"../../types\"\nimport type {SchemaObjCxt} from \"..\"\nimport {_, str, getProperty, Code, Name} from \"../codegen\"\nimport {escapeFragment, getErrorPath, Type} from \"../util\"\nimport type {JSONType} from \"../rules\"\n\nexport interface SubschemaContext {\n  // TODO use Optional? align with SchemCxt property types\n  schema: AnySchema\n  schemaPath: Code\n  errSchemaPath: string\n  topSchemaRef?: Code\n  errorPath?: Code\n  dataLevel?: number\n  dataTypes?: JSONType[]\n  data?: Name\n  parentData?: Name\n  parentDataProperty?: Code | number\n  dataNames?: Name[]\n  dataPathArr?: (Code | number)[]\n  propertyName?: Name\n  jtdDiscriminator?: string\n  jtdMetadata?: boolean\n  compositeRule?: true\n  createErrors?: boolean\n  allErrors?: boolean\n}\n\nexport type SubschemaArgs = Partial<{\n  keyword: string\n  schemaProp: string | number\n  schema: AnySchema\n  schemaPath: Code\n  errSchemaPath: string\n  topSchemaRef: Code\n  data: Name | Code\n  dataProp: Code | string | number\n  dataTypes: JSONType[]\n  definedProperties: Set<string>\n  propertyName: Name\n  dataPropType: Type\n  jtdDiscriminator: string\n  jtdMetadata: boolean\n  compositeRule: true\n  createErrors: boolean\n  allErrors: boolean\n}>\n\nexport function getSubschema(\n  it: SchemaObjCxt,\n  {keyword, schemaProp, schema, schemaPath, errSchemaPath, topSchemaRef}: SubschemaArgs\n): SubschemaContext {\n  if (keyword !== undefined && schema !== undefined) {\n    throw new Error('both \"keyword\" and \"schema\" passed, only one allowed')\n  }\n\n  if (keyword !== undefined) {\n    const sch = it.schema[keyword]\n    return schemaProp === undefined\n      ? {\n          schema: sch,\n          schemaPath: _`${it.schemaPath}${getProperty(keyword)}`,\n          errSchemaPath: `${it.errSchemaPath}/${keyword}`,\n        }\n      : {\n          schema: sch[schemaProp],\n          schemaPath: _`${it.schemaPath}${getProperty(keyword)}${getProperty(schemaProp)}`,\n          errSchemaPath: `${it.errSchemaPath}/${keyword}/${escapeFragment(schemaProp)}`,\n        }\n  }\n\n  if (schema !== undefined) {\n    if (schemaPath === undefined || errSchemaPath === undefined || topSchemaRef === undefined) {\n      throw new Error('\"schemaPath\", \"errSchemaPath\" and \"topSchemaRef\" are required with \"schema\"')\n    }\n    return {\n      schema,\n      schemaPath,\n      topSchemaRef,\n      errSchemaPath,\n    }\n  }\n\n  throw new Error('either \"keyword\" or \"schema\" must be passed')\n}\n\nexport function extendSubschemaData(\n  subschema: SubschemaContext,\n  it: SchemaObjCxt,\n  {dataProp, dataPropType: dpType, data, dataTypes, propertyName}: SubschemaArgs\n): void {\n  if (data !== undefined && dataProp !== undefined) {\n    throw new Error('both \"data\" and \"dataProp\" passed, only one allowed')\n  }\n\n  const {gen} = it\n\n  if (dataProp !== undefined) {\n    const {errorPath, dataPathArr, opts} = it\n    const nextData = gen.let(\"data\", _`${it.data}${getProperty(dataProp)}`, true)\n    dataContextProps(nextData)\n    subschema.errorPath = str`${errorPath}${getErrorPath(dataProp, dpType, opts.jsPropertySyntax)}`\n    subschema.parentDataProperty = _`${dataProp}`\n    subschema.dataPathArr = [...dataPathArr, subschema.parentDataProperty]\n  }\n\n  if (data !== undefined) {\n    const nextData = data instanceof Name ? data : gen.let(\"data\", data, true) // replaceable if used once?\n    dataContextProps(nextData)\n    if (propertyName !== undefined) subschema.propertyName = propertyName\n    // TODO something is possibly wrong here with not changing parentDataProperty and not appending dataPathArr\n  }\n\n  if (dataTypes) subschema.dataTypes = dataTypes\n\n  function dataContextProps(_nextData: Name): void {\n    subschema.data = _nextData\n    subschema.dataLevel = it.dataLevel + 1\n    subschema.dataTypes = []\n    it.definedProperties = new Set<string>()\n    subschema.parentData = it.data\n    subschema.dataNames = [...it.dataNames, _nextData]\n  }\n}\n\nexport function extendSubschemaMode(\n  subschema: SubschemaContext,\n  {jtdDiscriminator, jtdMetadata, compositeRule, createErrors, allErrors}: SubschemaArgs\n): void {\n  if (compositeRule !== undefined) subschema.compositeRule = compositeRule\n  if (createErrors !== undefined) subschema.createErrors = createErrors\n  if (allErrors !== undefined) subschema.allErrors = allErrors\n  subschema.jtdDiscriminator = jtdDiscriminator // not inherited\n  subschema.jtdMetadata = jtdMetadata // not inherited\n}\n","'use strict';\n\n// do not edit .js files directly - edit src/index.jst\n\n\n\nmodule.exports = function equal(a, b) {\n  if (a === b) return true;\n\n  if (a && b && typeof a == 'object' && typeof b == 'object') {\n    if (a.constructor !== b.constructor) return false;\n\n    var length, i, keys;\n    if (Array.isArray(a)) {\n      length = a.length;\n      if (length != b.length) return false;\n      for (i = length; i-- !== 0;)\n        if (!equal(a[i], b[i])) return false;\n      return true;\n    }\n\n\n\n    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;\n    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();\n    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();\n\n    keys = Object.keys(a);\n    length = keys.length;\n    if (length !== Object.keys(b).length) return false;\n\n    for (i = length; i-- !== 0;)\n      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;\n\n    for (i = length; i-- !== 0;) {\n      var key = keys[i];\n\n      if (!equal(a[key], b[key])) return false;\n    }\n\n    return true;\n  }\n\n  // true if both NaN, false otherwise\n  return a!==a && b!==b;\n};\n","'use strict';\n\nvar traverse = module.exports = function (schema, opts, cb) {\n  // Legacy support for v0.3.1 and earlier.\n  if (typeof opts == 'function') {\n    cb = opts;\n    opts = {};\n  }\n\n  cb = opts.cb || cb;\n  var pre = (typeof cb == 'function') ? cb : cb.pre || function() {};\n  var post = cb.post || function() {};\n\n  _traverse(opts, pre, post, schema, '', schema);\n};\n\n\ntraverse.keywords = {\n  additionalItems: true,\n  items: true,\n  contains: true,\n  additionalProperties: true,\n  propertyNames: true,\n  not: true,\n  if: true,\n  then: true,\n  else: true\n};\n\ntraverse.arrayKeywords = {\n  items: true,\n  allOf: true,\n  anyOf: true,\n  oneOf: true\n};\n\ntraverse.propsKeywords = {\n  $defs: true,\n  definitions: true,\n  properties: true,\n  patternProperties: true,\n  dependencies: true\n};\n\ntraverse.skipKeywords = {\n  default: true,\n  enum: true,\n  const: true,\n  required: true,\n  maximum: true,\n  minimum: true,\n  exclusiveMaximum: true,\n  exclusiveMinimum: true,\n  multipleOf: true,\n  maxLength: true,\n  minLength: true,\n  pattern: true,\n  format: true,\n  maxItems: true,\n  minItems: true,\n  uniqueItems: true,\n  maxProperties: true,\n  minProperties: true\n};\n\n\nfunction _traverse(opts, pre, post, schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {\n  if (schema && typeof schema == 'object' && !Array.isArray(schema)) {\n    pre(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);\n    for (var key in schema) {\n      var sch = schema[key];\n      if (Array.isArray(sch)) {\n        if (key in traverse.arrayKeywords) {\n          for (var i=0; i<sch.length; i++)\n            _traverse(opts, pre, post, sch[i], jsonPtr + '/' + key + '/' + i, rootSchema, jsonPtr, key, schema, i);\n        }\n      } else if (key in traverse.propsKeywords) {\n        if (sch && typeof sch == 'object') {\n          for (var prop in sch)\n            _traverse(opts, pre, post, sch[prop], jsonPtr + '/' + key + '/' + escapeJsonPtr(prop), rootSchema, jsonPtr, key, schema, prop);\n        }\n      } else if (key in traverse.keywords || (opts.allKeys && !(key in traverse.skipKeywords))) {\n        _traverse(opts, pre, post, sch, jsonPtr + '/' + key, rootSchema, jsonPtr, key, schema);\n      }\n    }\n    post(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);\n  }\n}\n\n\nfunction escapeJsonPtr(str) {\n  return str.replace(/~/g, '~0').replace(/\\//g, '~1');\n}\n","import type {AnySchema, AnySchemaObject, UriResolver} from \"../types\"\nimport type Ajv from \"../ajv\"\nimport type {URIComponent} from \"fast-uri\"\nimport {eachItem} from \"./util\"\nimport * as equal from \"fast-deep-equal\"\nimport * as traverse from \"json-schema-traverse\"\n\n// the hash of local references inside the schema (created by getSchemaRefs), used for inline resolution\nexport type LocalRefs = {[Ref in string]?: AnySchemaObject}\n\n// TODO refactor to use keyword definitions\nconst SIMPLE_INLINED = new Set([\n  \"type\",\n  \"format\",\n  \"pattern\",\n  \"maxLength\",\n  \"minLength\",\n  \"maxProperties\",\n  \"minProperties\",\n  \"maxItems\",\n  \"minItems\",\n  \"maximum\",\n  \"minimum\",\n  \"uniqueItems\",\n  \"multipleOf\",\n  \"required\",\n  \"enum\",\n  \"const\",\n])\n\nexport function inlineRef(schema: AnySchema, limit: boolean | number = true): boolean {\n  if (typeof schema == \"boolean\") return true\n  if (limit === true) return !hasRef(schema)\n  if (!limit) return false\n  return countKeys(schema) <= limit\n}\n\nconst REF_KEYWORDS = new Set([\n  \"$ref\",\n  \"$recursiveRef\",\n  \"$recursiveAnchor\",\n  \"$dynamicRef\",\n  \"$dynamicAnchor\",\n])\n\nfunction hasRef(schema: AnySchemaObject): boolean {\n  for (const key in schema) {\n    if (REF_KEYWORDS.has(key)) return true\n    const sch = schema[key]\n    if (Array.isArray(sch) && sch.some(hasRef)) return true\n    if (typeof sch == \"object\" && hasRef(sch)) return true\n  }\n  return false\n}\n\nfunction countKeys(schema: AnySchemaObject): number {\n  let count = 0\n  for (const key in schema) {\n    if (key === \"$ref\") return Infinity\n    count++\n    if (SIMPLE_INLINED.has(key)) continue\n    if (typeof schema[key] == \"object\") {\n      eachItem(schema[key], (sch) => (count += countKeys(sch)))\n    }\n    if (count === Infinity) return Infinity\n  }\n  return count\n}\n\nexport function getFullPath(resolver: UriResolver, id = \"\", normalize?: boolean): string {\n  if (normalize !== false) id = normalizeId(id)\n  const p = resolver.parse(id)\n  return _getFullPath(resolver, p)\n}\n\nexport function _getFullPath(resolver: UriResolver, p: URIComponent): string {\n  const serialized = resolver.serialize(p)\n  return serialized.split(\"#\")[0] + \"#\"\n}\n\nconst TRAILING_SLASH_HASH = /#\\/?$/\nexport function normalizeId(id: string | undefined): string {\n  return id ? id.replace(TRAILING_SLASH_HASH, \"\") : \"\"\n}\n\nexport function resolveUrl(resolver: UriResolver, baseId: string, id: string): string {\n  id = normalizeId(id)\n  return resolver.resolve(baseId, id)\n}\n\nconst ANCHOR = /^[a-z_][-a-z0-9._]*$/i\n\nexport function getSchemaRefs(this: Ajv, schema: AnySchema, baseId: string): LocalRefs {\n  if (typeof schema == \"boolean\") return {}\n  const {schemaId, uriResolver} = this.opts\n  const schId = normalizeId(schema[schemaId] || baseId)\n  const baseIds: {[JsonPtr in string]?: string} = {\"\": schId}\n  const pathPrefix = getFullPath(uriResolver, schId, false)\n  const localRefs: LocalRefs = {}\n  const schemaRefs: Set<string> = new Set()\n\n  traverse(schema, {allKeys: true}, (sch, jsonPtr, _, parentJsonPtr) => {\n    if (parentJsonPtr === undefined) return\n    const fullPath = pathPrefix + jsonPtr\n    let innerBaseId = baseIds[parentJsonPtr]\n    if (typeof sch[schemaId] == \"string\") innerBaseId = addRef.call(this, sch[schemaId])\n    addAnchor.call(this, sch.$anchor)\n    addAnchor.call(this, sch.$dynamicAnchor)\n    baseIds[jsonPtr] = innerBaseId\n\n    function addRef(this: Ajv, ref: string): string {\n      // eslint-disable-next-line @typescript-eslint/unbound-method\n      const _resolve = this.opts.uriResolver.resolve\n      ref = normalizeId(innerBaseId ? _resolve(innerBaseId, ref) : ref)\n      if (schemaRefs.has(ref)) throw ambiguos(ref)\n      schemaRefs.add(ref)\n      let schOrRef = this.refs[ref]\n      if (typeof schOrRef == \"string\") schOrRef = this.refs[schOrRef]\n      if (typeof schOrRef == \"object\") {\n        checkAmbiguosRef(sch, schOrRef.schema, ref)\n      } else if (ref !== normalizeId(fullPath)) {\n        if (ref[0] === \"#\") {\n          checkAmbiguosRef(sch, localRefs[ref], ref)\n          localRefs[ref] = sch\n        } else {\n          this.refs[ref] = fullPath\n        }\n      }\n      return ref\n    }\n\n    function addAnchor(this: Ajv, anchor: unknown): void {\n      if (typeof anchor == \"string\") {\n        if (!ANCHOR.test(anchor)) throw new Error(`invalid anchor \"${anchor}\"`)\n        addRef.call(this, `#${anchor}`)\n      }\n    }\n  })\n\n  return localRefs\n\n  function checkAmbiguosRef(sch1: AnySchema, sch2: AnySchema | undefined, ref: string): void {\n    if (sch2 !== undefined && !equal(sch1, sch2)) throw ambiguos(ref)\n  }\n\n  function ambiguos(ref: string): Error {\n    return new Error(`reference \"${ref}\" resolves to more than one schema`)\n  }\n}\n","import type {\n  AddedKeywordDefinition,\n  AnySchema,\n  AnySchemaObject,\n  KeywordErrorCxt,\n  KeywordCxtParams,\n} from \"../../types\"\nimport type {SchemaCxt, SchemaObjCxt} from \"..\"\nimport type {InstanceOptions} from \"../../core\"\nimport {boolOrEmptySchema, topBoolOrEmptySchema} from \"./boolSchema\"\nimport {coerceAndCheckDataType, getSchemaTypes} from \"./dataType\"\nimport {shouldUseGroup, shouldUseRule} from \"./applicability\"\nimport {checkDataType, checkDataTypes, reportTypeError, DataType} from \"./dataType\"\nimport {assignDefaults} from \"./defaults\"\nimport {funcKeywordCode, macroKeywordCode, validateKeywordUsage, validSchemaType} from \"./keyword\"\nimport {getSubschema, extendSubschemaData, SubschemaArgs, extendSubschemaMode} from \"./subschema\"\nimport {_, nil, str, or, not, getProperty, Block, Code, Name, CodeGen} from \"../codegen\"\nimport N from \"../names\"\nimport {resolveUrl} from \"../resolve\"\nimport {\n  schemaRefOrVal,\n  schemaHasRulesButRef,\n  checkUnknownRules,\n  checkStrictMode,\n  unescapeJsonPointer,\n  mergeEvaluated,\n} from \"../util\"\nimport type {JSONType, Rule, RuleGroup} from \"../rules\"\nimport {\n  ErrorPaths,\n  reportError,\n  reportExtraError,\n  resetErrorsCount,\n  keyword$DataError,\n} from \"../errors\"\n\n// schema compilation - generates validation function, subschemaCode (below) is used for subschemas\nexport function validateFunctionCode(it: SchemaCxt): void {\n  if (isSchemaObj(it)) {\n    checkKeywords(it)\n    if (schemaCxtHasRules(it)) {\n      topSchemaObjCode(it)\n      return\n    }\n  }\n  validateFunction(it, () => topBoolOrEmptySchema(it))\n}\n\nfunction validateFunction(\n  {gen, validateName, schema, schemaEnv, opts}: SchemaCxt,\n  body: Block\n): void {\n  if (opts.code.es5) {\n    gen.func(validateName, _`${N.data}, ${N.valCxt}`, schemaEnv.$async, () => {\n      gen.code(_`\"use strict\"; ${funcSourceUrl(schema, opts)}`)\n      destructureValCxtES5(gen, opts)\n      gen.code(body)\n    })\n  } else {\n    gen.func(validateName, _`${N.data}, ${destructureValCxt(opts)}`, schemaEnv.$async, () =>\n      gen.code(funcSourceUrl(schema, opts)).code(body)\n    )\n  }\n}\n\nfunction destructureValCxt(opts: InstanceOptions): Code {\n  return _`{${N.instancePath}=\"\", ${N.parentData}, ${N.parentDataProperty}, ${N.rootData}=${\n    N.data\n  }${opts.dynamicRef ? _`, ${N.dynamicAnchors}={}` : nil}}={}`\n}\n\nfunction destructureValCxtES5(gen: CodeGen, opts: InstanceOptions): void {\n  gen.if(\n    N.valCxt,\n    () => {\n      gen.var(N.instancePath, _`${N.valCxt}.${N.instancePath}`)\n      gen.var(N.parentData, _`${N.valCxt}.${N.parentData}`)\n      gen.var(N.parentDataProperty, _`${N.valCxt}.${N.parentDataProperty}`)\n      gen.var(N.rootData, _`${N.valCxt}.${N.rootData}`)\n      if (opts.dynamicRef) gen.var(N.dynamicAnchors, _`${N.valCxt}.${N.dynamicAnchors}`)\n    },\n    () => {\n      gen.var(N.instancePath, _`\"\"`)\n      gen.var(N.parentData, _`undefined`)\n      gen.var(N.parentDataProperty, _`undefined`)\n      gen.var(N.rootData, N.data)\n      if (opts.dynamicRef) gen.var(N.dynamicAnchors, _`{}`)\n    }\n  )\n}\n\nfunction topSchemaObjCode(it: SchemaObjCxt): void {\n  const {schema, opts, gen} = it\n  validateFunction(it, () => {\n    if (opts.$comment && schema.$comment) commentKeyword(it)\n    checkNoDefault(it)\n    gen.let(N.vErrors, null)\n    gen.let(N.errors, 0)\n    if (opts.unevaluated) resetEvaluated(it)\n    typeAndKeywords(it)\n    returnResults(it)\n  })\n  return\n}\n\nfunction resetEvaluated(it: SchemaObjCxt): void {\n  // TODO maybe some hook to execute it in the end to check whether props/items are Name, as in assignEvaluated\n  const {gen, validateName} = it\n  it.evaluated = gen.const(\"evaluated\", _`${validateName}.evaluated`)\n  gen.if(_`${it.evaluated}.dynamicProps`, () => gen.assign(_`${it.evaluated}.props`, _`undefined`))\n  gen.if(_`${it.evaluated}.dynamicItems`, () => gen.assign(_`${it.evaluated}.items`, _`undefined`))\n}\n\nfunction funcSourceUrl(schema: AnySchema, opts: InstanceOptions): Code {\n  const schId = typeof schema == \"object\" && schema[opts.schemaId]\n  return schId && (opts.code.source || opts.code.process) ? _`/*# sourceURL=${schId} */` : nil\n}\n\n// schema compilation - this function is used recursively to generate code for sub-schemas\nfunction subschemaCode(it: SchemaCxt, valid: Name): void {\n  if (isSchemaObj(it)) {\n    checkKeywords(it)\n    if (schemaCxtHasRules(it)) {\n      subSchemaObjCode(it, valid)\n      return\n    }\n  }\n  boolOrEmptySchema(it, valid)\n}\n\nfunction schemaCxtHasRules({schema, self}: SchemaCxt): boolean {\n  if (typeof schema == \"boolean\") return !schema\n  for (const key in schema) if (self.RULES.all[key]) return true\n  return false\n}\n\nfunction isSchemaObj(it: SchemaCxt): it is SchemaObjCxt {\n  return typeof it.schema != \"boolean\"\n}\n\nfunction subSchemaObjCode(it: SchemaObjCxt, valid: Name): void {\n  const {schema, gen, opts} = it\n  if (opts.$comment && schema.$comment) commentKeyword(it)\n  updateContext(it)\n  checkAsyncSchema(it)\n  const errsCount = gen.const(\"_errs\", N.errors)\n  typeAndKeywords(it, errsCount)\n  // TODO var\n  gen.var(valid, _`${errsCount} === ${N.errors}`)\n}\n\nfunction checkKeywords(it: SchemaObjCxt): void {\n  checkUnknownRules(it)\n  checkRefsAndKeywords(it)\n}\n\nfunction typeAndKeywords(it: SchemaObjCxt, errsCount?: Name): void {\n  if (it.opts.jtd) return schemaKeywords(it, [], false, errsCount)\n  const types = getSchemaTypes(it.schema)\n  const checkedTypes = coerceAndCheckDataType(it, types)\n  schemaKeywords(it, types, !checkedTypes, errsCount)\n}\n\nfunction checkRefsAndKeywords(it: SchemaObjCxt): void {\n  const {schema, errSchemaPath, opts, self} = it\n  if (schema.$ref && opts.ignoreKeywordsWithRef && schemaHasRulesButRef(schema, self.RULES)) {\n    self.logger.warn(`$ref: keywords ignored in schema at path \"${errSchemaPath}\"`)\n  }\n}\n\nfunction checkNoDefault(it: SchemaObjCxt): void {\n  const {schema, opts} = it\n  if (schema.default !== undefined && opts.useDefaults && opts.strictSchema) {\n    checkStrictMode(it, \"default is ignored in the schema root\")\n  }\n}\n\nfunction updateContext(it: SchemaObjCxt): void {\n  const schId = it.schema[it.opts.schemaId]\n  if (schId) it.baseId = resolveUrl(it.opts.uriResolver, it.baseId, schId)\n}\n\nfunction checkAsyncSchema(it: SchemaObjCxt): void {\n  if (it.schema.$async && !it.schemaEnv.$async) throw new Error(\"async schema in sync schema\")\n}\n\nfunction commentKeyword({gen, schemaEnv, schema, errSchemaPath, opts}: SchemaObjCxt): void {\n  const msg = schema.$comment\n  if (opts.$comment === true) {\n    gen.code(_`${N.self}.logger.log(${msg})`)\n  } else if (typeof opts.$comment == \"function\") {\n    const schemaPath = str`${errSchemaPath}/$comment`\n    const rootName = gen.scopeValue(\"root\", {ref: schemaEnv.root})\n    gen.code(_`${N.self}.opts.$comment(${msg}, ${schemaPath}, ${rootName}.schema)`)\n  }\n}\n\nfunction returnResults(it: SchemaCxt): void {\n  const {gen, schemaEnv, validateName, ValidationError, opts} = it\n  if (schemaEnv.$async) {\n    // TODO assign unevaluated\n    gen.if(\n      _`${N.errors} === 0`,\n      () => gen.return(N.data),\n      () => gen.throw(_`new ${ValidationError as Name}(${N.vErrors})`)\n    )\n  } else {\n    gen.assign(_`${validateName}.errors`, N.vErrors)\n    if (opts.unevaluated) assignEvaluated(it)\n    gen.return(_`${N.errors} === 0`)\n  }\n}\n\nfunction assignEvaluated({gen, evaluated, props, items}: SchemaCxt): void {\n  if (props instanceof Name) gen.assign(_`${evaluated}.props`, props)\n  if (items instanceof Name) gen.assign(_`${evaluated}.items`, items)\n}\n\nfunction schemaKeywords(\n  it: SchemaObjCxt,\n  types: JSONType[],\n  typeErrors: boolean,\n  errsCount?: Name\n): void {\n  const {gen, schema, data, allErrors, opts, self} = it\n  const {RULES} = self\n  if (schema.$ref && (opts.ignoreKeywordsWithRef || !schemaHasRulesButRef(schema, RULES))) {\n    gen.block(() => keywordCode(it, \"$ref\", (RULES.all.$ref as Rule).definition)) // TODO typecast\n    return\n  }\n  if (!opts.jtd) checkStrictTypes(it, types)\n  gen.block(() => {\n    for (const group of RULES.rules) groupKeywords(group)\n    groupKeywords(RULES.post)\n  })\n\n  function groupKeywords(group: RuleGroup): void {\n    if (!shouldUseGroup(schema, group)) return\n    if (group.type) {\n      gen.if(checkDataType(group.type, data, opts.strictNumbers))\n      iterateKeywords(it, group)\n      if (types.length === 1 && types[0] === group.type && typeErrors) {\n        gen.else()\n        reportTypeError(it)\n      }\n      gen.endIf()\n    } else {\n      iterateKeywords(it, group)\n    }\n    // TODO make it \"ok\" call?\n    if (!allErrors) gen.if(_`${N.errors} === ${errsCount || 0}`)\n  }\n}\n\nfunction iterateKeywords(it: SchemaObjCxt, group: RuleGroup): void {\n  const {\n    gen,\n    schema,\n    opts: {useDefaults},\n  } = it\n  if (useDefaults) assignDefaults(it, group.type)\n  gen.block(() => {\n    for (const rule of group.rules) {\n      if (shouldUseRule(schema, rule)) {\n        keywordCode(it, rule.keyword, rule.definition, group.type)\n      }\n    }\n  })\n}\n\nfunction checkStrictTypes(it: SchemaObjCxt, types: JSONType[]): void {\n  if (it.schemaEnv.meta || !it.opts.strictTypes) return\n  checkContextTypes(it, types)\n  if (!it.opts.allowUnionTypes) checkMultipleTypes(it, types)\n  checkKeywordTypes(it, it.dataTypes)\n}\n\nfunction checkContextTypes(it: SchemaObjCxt, types: JSONType[]): void {\n  if (!types.length) return\n  if (!it.dataTypes.length) {\n    it.dataTypes = types\n    return\n  }\n  types.forEach((t) => {\n    if (!includesType(it.dataTypes, t)) {\n      strictTypesError(it, `type \"${t}\" not allowed by context \"${it.dataTypes.join(\",\")}\"`)\n    }\n  })\n  narrowSchemaTypes(it, types)\n}\n\nfunction checkMultipleTypes(it: SchemaObjCxt, ts: JSONType[]): void {\n  if (ts.length > 1 && !(ts.length === 2 && ts.includes(\"null\"))) {\n    strictTypesError(it, \"use allowUnionTypes to allow union type keyword\")\n  }\n}\n\nfunction checkKeywordTypes(it: SchemaObjCxt, ts: JSONType[]): void {\n  const rules = it.self.RULES.all\n  for (const keyword in rules) {\n    const rule = rules[keyword]\n    if (typeof rule == \"object\" && shouldUseRule(it.schema, rule)) {\n      const {type} = rule.definition\n      if (type.length && !type.some((t) => hasApplicableType(ts, t))) {\n        strictTypesError(it, `missing type \"${type.join(\",\")}\" for keyword \"${keyword}\"`)\n      }\n    }\n  }\n}\n\nfunction hasApplicableType(schTs: JSONType[], kwdT: JSONType): boolean {\n  return schTs.includes(kwdT) || (kwdT === \"number\" && schTs.includes(\"integer\"))\n}\n\nfunction includesType(ts: JSONType[], t: JSONType): boolean {\n  return ts.includes(t) || (t === \"integer\" && ts.includes(\"number\"))\n}\n\nfunction narrowSchemaTypes(it: SchemaObjCxt, withTypes: JSONType[]): void {\n  const ts: JSONType[] = []\n  for (const t of it.dataTypes) {\n    if (includesType(withTypes, t)) ts.push(t)\n    else if (withTypes.includes(\"integer\") && t === \"number\") ts.push(\"integer\")\n  }\n  it.dataTypes = ts\n}\n\nfunction strictTypesError(it: SchemaObjCxt, msg: string): void {\n  const schemaPath = it.schemaEnv.baseId + it.errSchemaPath\n  msg += ` at \"${schemaPath}\" (strictTypes)`\n  checkStrictMode(it, msg, it.opts.strictTypes)\n}\n\nexport class KeywordCxt implements KeywordErrorCxt {\n  readonly gen: CodeGen\n  readonly allErrors?: boolean\n  readonly keyword: string\n  readonly data: Name // Name referencing the current level of the data instance\n  readonly $data?: string | false\n  schema: any // keyword value in the schema\n  readonly schemaValue: Code | number | boolean // Code reference to keyword schema value or primitive value\n  readonly schemaCode: Code | number | boolean // Code reference to resolved schema value (different if schema is $data)\n  readonly schemaType: JSONType[] // allowed type(s) of keyword value in the schema\n  readonly parentSchema: AnySchemaObject\n  readonly errsCount?: Name // Name reference to the number of validation errors collected before this keyword,\n  // requires option trackErrors in keyword definition\n  params: KeywordCxtParams // object to pass parameters to error messages from keyword code\n  readonly it: SchemaObjCxt // schema compilation context (schema is guaranteed to be an object, not boolean)\n  readonly def: AddedKeywordDefinition\n\n  constructor(it: SchemaObjCxt, def: AddedKeywordDefinition, keyword: string) {\n    validateKeywordUsage(it, def, keyword)\n    this.gen = it.gen\n    this.allErrors = it.allErrors\n    this.keyword = keyword\n    this.data = it.data\n    this.schema = it.schema[keyword]\n    this.$data = def.$data && it.opts.$data && this.schema && this.schema.$data\n    this.schemaValue = schemaRefOrVal(it, this.schema, keyword, this.$data)\n    this.schemaType = def.schemaType\n    this.parentSchema = it.schema\n    this.params = {}\n    this.it = it\n    this.def = def\n\n    if (this.$data) {\n      this.schemaCode = it.gen.const(\"vSchema\", getData(this.$data, it))\n    } else {\n      this.schemaCode = this.schemaValue\n      if (!validSchemaType(this.schema, def.schemaType, def.allowUndefined)) {\n        throw new Error(`${keyword} value must be ${JSON.stringify(def.schemaType)}`)\n      }\n    }\n\n    if (\"code\" in def ? def.trackErrors : def.errors !== false) {\n      this.errsCount = it.gen.const(\"_errs\", N.errors)\n    }\n  }\n\n  result(condition: Code, successAction?: () => void, failAction?: () => void): void {\n    this.failResult(not(condition), successAction, failAction)\n  }\n\n  failResult(condition: Code, successAction?: () => void, failAction?: () => void): void {\n    this.gen.if(condition)\n    if (failAction) failAction()\n    else this.error()\n    if (successAction) {\n      this.gen.else()\n      successAction()\n      if (this.allErrors) this.gen.endIf()\n    } else {\n      if (this.allErrors) this.gen.endIf()\n      else this.gen.else()\n    }\n  }\n\n  pass(condition: Code, failAction?: () => void): void {\n    this.failResult(not(condition), undefined, failAction)\n  }\n\n  fail(condition?: Code): void {\n    if (condition === undefined) {\n      this.error()\n      if (!this.allErrors) this.gen.if(false) // this branch will be removed by gen.optimize\n      return\n    }\n    this.gen.if(condition)\n    this.error()\n    if (this.allErrors) this.gen.endIf()\n    else this.gen.else()\n  }\n\n  fail$data(condition: Code): void {\n    if (!this.$data) return this.fail(condition)\n    const {schemaCode} = this\n    this.fail(_`${schemaCode} !== undefined && (${or(this.invalid$data(), condition)})`)\n  }\n\n  error(append?: boolean, errorParams?: KeywordCxtParams, errorPaths?: ErrorPaths): void {\n    if (errorParams) {\n      this.setParams(errorParams)\n      this._error(append, errorPaths)\n      this.setParams({})\n      return\n    }\n    this._error(append, errorPaths)\n  }\n\n  private _error(append?: boolean, errorPaths?: ErrorPaths): void {\n    ;(append ? reportExtraError : reportError)(this, this.def.error, errorPaths)\n  }\n\n  $dataError(): void {\n    reportError(this, this.def.$dataError || keyword$DataError)\n  }\n\n  reset(): void {\n    if (this.errsCount === undefined) throw new Error('add \"trackErrors\" to keyword definition')\n    resetErrorsCount(this.gen, this.errsCount)\n  }\n\n  ok(cond: Code | boolean): void {\n    if (!this.allErrors) this.gen.if(cond)\n  }\n\n  setParams(obj: KeywordCxtParams, assign?: true): void {\n    if (assign) Object.assign(this.params, obj)\n    else this.params = obj\n  }\n\n  block$data(valid: Name, codeBlock: () => void, $dataValid: Code = nil): void {\n    this.gen.block(() => {\n      this.check$data(valid, $dataValid)\n      codeBlock()\n    })\n  }\n\n  check$data(valid: Name = nil, $dataValid: Code = nil): void {\n    if (!this.$data) return\n    const {gen, schemaCode, schemaType, def} = this\n    gen.if(or(_`${schemaCode} === undefined`, $dataValid))\n    if (valid !== nil) gen.assign(valid, true)\n    if (schemaType.length || def.validateSchema) {\n      gen.elseIf(this.invalid$data())\n      this.$dataError()\n      if (valid !== nil) gen.assign(valid, false)\n    }\n    gen.else()\n  }\n\n  invalid$data(): Code {\n    const {gen, schemaCode, schemaType, def, it} = this\n    return or(wrong$DataType(), invalid$DataSchema())\n\n    function wrong$DataType(): Code {\n      if (schemaType.length) {\n        /* istanbul ignore if */\n        if (!(schemaCode instanceof Name)) throw new Error(\"ajv implementation error\")\n        const st = Array.isArray(schemaType) ? schemaType : [schemaType]\n        return _`${checkDataTypes(st, schemaCode, it.opts.strictNumbers, DataType.Wrong)}`\n      }\n      return nil\n    }\n\n    function invalid$DataSchema(): Code {\n      if (def.validateSchema) {\n        const validateSchemaRef = gen.scopeValue(\"validate$data\", {ref: def.validateSchema}) // TODO value.code for standalone\n        return _`!${validateSchemaRef}(${schemaCode})`\n      }\n      return nil\n    }\n  }\n\n  subschema(appl: SubschemaArgs, valid: Name): SchemaCxt {\n    const subschema = getSubschema(this.it, appl)\n    extendSubschemaData(subschema, this.it, appl)\n    extendSubschemaMode(subschema, appl)\n    const nextContext = {...this.it, ...subschema, items: undefined, props: undefined}\n    subschemaCode(nextContext, valid)\n    return nextContext\n  }\n\n  mergeEvaluated(schemaCxt: SchemaCxt, toName?: typeof Name): void {\n    const {it, gen} = this\n    if (!it.opts.unevaluated) return\n    if (it.props !== true && schemaCxt.props !== undefined) {\n      it.props = mergeEvaluated.props(gen, schemaCxt.props, it.props, toName)\n    }\n    if (it.items !== true && schemaCxt.items !== undefined) {\n      it.items = mergeEvaluated.items(gen, schemaCxt.items, it.items, toName)\n    }\n  }\n\n  mergeValidEvaluated(schemaCxt: SchemaCxt, valid: Name): boolean | void {\n    const {it, gen} = this\n    if (it.opts.unevaluated && (it.props !== true || it.items !== true)) {\n      gen.if(valid, () => this.mergeEvaluated(schemaCxt, Name))\n      return true\n    }\n  }\n}\n\nfunction keywordCode(\n  it: SchemaObjCxt,\n  keyword: string,\n  def: AddedKeywordDefinition,\n  ruleType?: JSONType\n): void {\n  const cxt = new KeywordCxt(it, def, keyword)\n  if (\"code\" in def) {\n    def.code(cxt, ruleType)\n  } else if (cxt.$data && def.validate) {\n    funcKeywordCode(cxt, def)\n  } else if (\"macro\" in def) {\n    macroKeywordCode(cxt, def)\n  } else if (def.compile || def.validate) {\n    funcKeywordCode(cxt, def)\n  }\n}\n\nconst JSON_POINTER = /^\\/(?:[^~]|~0|~1)*$/\nconst RELATIVE_JSON_POINTER = /^([0-9]+)(#|\\/(?:[^~]|~0|~1)*)?$/\nexport function getData(\n  $data: string,\n  {dataLevel, dataNames, dataPathArr}: SchemaCxt\n): Code | number {\n  let jsonPointer\n  let data: Code\n  if ($data === \"\") return N.rootData\n  if ($data[0] === \"/\") {\n    if (!JSON_POINTER.test($data)) throw new Error(`Invalid JSON-pointer: ${$data}`)\n    jsonPointer = $data\n    data = N.rootData\n  } else {\n    const matches = RELATIVE_JSON_POINTER.exec($data)\n    if (!matches) throw new Error(`Invalid JSON-pointer: ${$data}`)\n    const up: number = +matches[1]\n    jsonPointer = matches[2]\n    if (jsonPointer === \"#\") {\n      if (up >= dataLevel) throw new Error(errorMsg(\"property/index\", up))\n      return dataPathArr[dataLevel - up]\n    }\n    if (up > dataLevel) throw new Error(errorMsg(\"data\", up))\n    data = dataNames[dataLevel - up]\n    if (!jsonPointer) return data\n  }\n\n  let expr = data\n  const segments = jsonPointer.split(\"/\")\n  for (const segment of segments) {\n    if (segment) {\n      data = _`${data}${getProperty(unescapeJsonPointer(segment))}`\n      expr = _`${expr} && ${data}`\n    }\n  }\n  return expr\n\n  function errorMsg(pointerType: string, up: number): string {\n    return `Cannot access ${pointerType} ${up} levels up, current level is ${dataLevel}`\n  }\n}\n","import type {ErrorObject} from \"../types\"\n\nexport default class ValidationError extends Error {\n  readonly errors: Partial<ErrorObject>[]\n  readonly ajv: true\n  readonly validation: true\n\n  constructor(errors: Partial<ErrorObject>[]) {\n    super(\"validation failed\")\n    this.errors = errors\n    this.ajv = this.validation = true\n  }\n}\n","import {resolveUrl, normalizeId, getFullPath} from \"./resolve\"\nimport type {UriResolver} from \"../types\"\n\nexport default class MissingRefError extends Error {\n  readonly missingRef: string\n  readonly missingSchema: string\n\n  constructor(resolver: UriResolver, baseId: string, ref: string, msg?: string) {\n    super(msg || `can't resolve reference ${ref} from id ${baseId}`)\n    this.missingRef = resolveUrl(resolver, baseId, ref)\n    this.missingSchema = normalizeId(getFullPath(resolver, this.missingRef))\n  }\n}\n","import type {\n  AnySchema,\n  AnySchemaObject,\n  AnyValidateFunction,\n  AsyncValidateFunction,\n  EvaluatedProperties,\n  EvaluatedItems,\n} from \"../types\"\nimport type Ajv from \"../core\"\nimport type {InstanceOptions} from \"../core\"\nimport {CodeGen, _, nil, stringify, Name, Code, ValueScopeName} from \"./codegen\"\nimport ValidationError from \"../runtime/validation_error\"\nimport N from \"./names\"\nimport {LocalRefs, getFullPath, _getFullPath, inlineRef, normalizeId, resolveUrl} from \"./resolve\"\nimport {schemaHasRulesButRef, unescapeFragment} from \"./util\"\nimport {validateFunctionCode} from \"./validate\"\nimport {URIComponent} from \"fast-uri\"\nimport {JSONType} from \"./rules\"\n\nexport type SchemaRefs = {\n  [Ref in string]?: SchemaEnv | AnySchema\n}\n\nexport interface SchemaCxt {\n  readonly gen: CodeGen\n  readonly allErrors?: boolean // validation mode - whether to collect all errors or break on error\n  readonly data: Name // Name with reference to the current part of data instance\n  readonly parentData: Name // should be used in keywords modifying data\n  readonly parentDataProperty: Code | number // should be used in keywords modifying data\n  readonly dataNames: Name[]\n  readonly dataPathArr: (Code | number)[]\n  readonly dataLevel: number // the level of the currently validated data,\n  // it can be used to access both the property names and the data on all levels from the top.\n  dataTypes: JSONType[] // data types applied to the current part of data instance\n  definedProperties: Set<string> // set of properties to keep track of for required checks\n  readonly topSchemaRef: Code\n  readonly validateName: Name\n  evaluated?: Name\n  readonly ValidationError?: Name\n  readonly schema: AnySchema // current schema object - equal to parentSchema passed via KeywordCxt\n  readonly schemaEnv: SchemaEnv\n  readonly rootId: string\n  baseId: string // the current schema base URI that should be used as the base for resolving URIs in references (\\$ref)\n  readonly schemaPath: Code // the run-time expression that evaluates to the property name of the current schema\n  readonly errSchemaPath: string // this is actual string, should not be changed to Code\n  readonly errorPath: Code\n  readonly propertyName?: Name\n  readonly compositeRule?: boolean // true indicates that the current schema is inside the compound keyword,\n  // where failing some rule doesn't mean validation failure (`anyOf`, `oneOf`, `not`, `if`).\n  // This flag is used to determine whether you can return validation result immediately after any error in case the option `allErrors` is not `true.\n  // You only need to use it if you have many steps in your keywords and potentially can define multiple errors.\n  props?: EvaluatedProperties | Name // properties evaluated by this schema - used by parent schema or assigned to validation function\n  items?: EvaluatedItems | Name // last item evaluated by this schema - used by parent schema or assigned to validation function\n  jtdDiscriminator?: string\n  jtdMetadata?: boolean\n  readonly createErrors?: boolean\n  readonly opts: InstanceOptions // Ajv instance option.\n  readonly self: Ajv // current Ajv instance\n}\n\nexport interface SchemaObjCxt extends SchemaCxt {\n  readonly schema: AnySchemaObject\n}\ninterface SchemaEnvArgs {\n  readonly schema: AnySchema\n  readonly schemaId?: \"$id\" | \"id\"\n  readonly root?: SchemaEnv\n  readonly baseId?: string\n  readonly schemaPath?: string\n  readonly localRefs?: LocalRefs\n  readonly meta?: boolean\n}\n\nexport class SchemaEnv implements SchemaEnvArgs {\n  readonly schema: AnySchema\n  readonly schemaId?: \"$id\" | \"id\"\n  readonly root: SchemaEnv\n  baseId: string // TODO possibly, it should be readonly\n  schemaPath?: string\n  localRefs?: LocalRefs\n  readonly meta?: boolean\n  readonly $async?: boolean // true if the current schema is asynchronous.\n  readonly refs: SchemaRefs = {}\n  readonly dynamicAnchors: {[Ref in string]?: true} = {}\n  validate?: AnyValidateFunction\n  validateName?: ValueScopeName\n  serialize?: (data: unknown) => string\n  serializeName?: ValueScopeName\n  parse?: (data: string) => unknown\n  parseName?: ValueScopeName\n\n  constructor(env: SchemaEnvArgs) {\n    let schema: AnySchemaObject | undefined\n    if (typeof env.schema == \"object\") schema = env.schema\n    this.schema = env.schema\n    this.schemaId = env.schemaId\n    this.root = env.root || this\n    this.baseId = env.baseId ?? normalizeId(schema?.[env.schemaId || \"$id\"])\n    this.schemaPath = env.schemaPath\n    this.localRefs = env.localRefs\n    this.meta = env.meta\n    this.$async = schema?.$async\n    this.refs = {}\n  }\n}\n\n// let codeSize = 0\n// let nodeCount = 0\n\n// Compiles schema in SchemaEnv\nexport function compileSchema(this: Ajv, sch: SchemaEnv): SchemaEnv {\n  // TODO refactor - remove compilations\n  const _sch = getCompilingSchema.call(this, sch)\n  if (_sch) return _sch\n  const rootId = getFullPath(this.opts.uriResolver, sch.root.baseId) // TODO if getFullPath removed 1 tests fails\n  const {es5, lines} = this.opts.code\n  const {ownProperties} = this.opts\n  const gen = new CodeGen(this.scope, {es5, lines, ownProperties})\n  let _ValidationError\n  if (sch.$async) {\n    _ValidationError = gen.scopeValue(\"Error\", {\n      ref: ValidationError,\n      code: _`require(\"ajv/dist/runtime/validation_error\").default`,\n    })\n  }\n\n  const validateName = gen.scopeName(\"validate\")\n  sch.validateName = validateName\n\n  const schemaCxt: SchemaCxt = {\n    gen,\n    allErrors: this.opts.allErrors,\n    data: N.data,\n    parentData: N.parentData,\n    parentDataProperty: N.parentDataProperty,\n    dataNames: [N.data],\n    dataPathArr: [nil], // TODO can its length be used as dataLevel if nil is removed?\n    dataLevel: 0,\n    dataTypes: [],\n    definedProperties: new Set<string>(),\n    topSchemaRef: gen.scopeValue(\n      \"schema\",\n      this.opts.code.source === true\n        ? {ref: sch.schema, code: stringify(sch.schema)}\n        : {ref: sch.schema}\n    ),\n    validateName,\n    ValidationError: _ValidationError,\n    schema: sch.schema,\n    schemaEnv: sch,\n    rootId,\n    baseId: sch.baseId || rootId,\n    schemaPath: nil,\n    errSchemaPath: sch.schemaPath || (this.opts.jtd ? \"\" : \"#\"),\n    errorPath: _`\"\"`,\n    opts: this.opts,\n    self: this,\n  }\n\n  let sourceCode: string | undefined\n  try {\n    this._compilations.add(sch)\n    validateFunctionCode(schemaCxt)\n    gen.optimize(this.opts.code.optimize)\n    // gen.optimize(1)\n    const validateCode = gen.toString()\n    sourceCode = `${gen.scopeRefs(N.scope)}return ${validateCode}`\n    // console.log((codeSize += sourceCode.length), (nodeCount += gen.nodeCount))\n    if (this.opts.code.process) sourceCode = this.opts.code.process(sourceCode, sch)\n    // console.log(\"\\n\\n\\n *** \\n\", sourceCode)\n    const makeValidate = new Function(`${N.self}`, `${N.scope}`, sourceCode)\n    const validate: AnyValidateFunction = makeValidate(this, this.scope.get())\n    this.scope.value(validateName, {ref: validate})\n\n    validate.errors = null\n    validate.schema = sch.schema\n    validate.schemaEnv = sch\n    if (sch.$async) (validate as AsyncValidateFunction).$async = true\n    if (this.opts.code.source === true) {\n      validate.source = {validateName, validateCode, scopeValues: gen._values}\n    }\n    if (this.opts.unevaluated) {\n      const {props, items} = schemaCxt\n      validate.evaluated = {\n        props: props instanceof Name ? undefined : props,\n        items: items instanceof Name ? undefined : items,\n        dynamicProps: props instanceof Name,\n        dynamicItems: items instanceof Name,\n      }\n      if (validate.source) validate.source.evaluated = stringify(validate.evaluated)\n    }\n    sch.validate = validate\n    return sch\n  } catch (e) {\n    delete sch.validate\n    delete sch.validateName\n    if (sourceCode) this.logger.error(\"Error compiling schema, function code:\", sourceCode)\n    // console.log(\"\\n\\n\\n *** \\n\", sourceCode, this.opts)\n    throw e\n  } finally {\n    this._compilations.delete(sch)\n  }\n}\n\nexport function resolveRef(\n  this: Ajv,\n  root: SchemaEnv,\n  baseId: string,\n  ref: string\n): AnySchema | SchemaEnv | undefined {\n  ref = resolveUrl(this.opts.uriResolver, baseId, ref)\n  const schOrFunc = root.refs[ref]\n  if (schOrFunc) return schOrFunc\n\n  let _sch = resolve.call(this, root, ref)\n  if (_sch === undefined) {\n    const schema = root.localRefs?.[ref] // TODO maybe localRefs should hold SchemaEnv\n    const {schemaId} = this.opts\n    if (schema) _sch = new SchemaEnv({schema, schemaId, root, baseId})\n  }\n\n  if (_sch === undefined) return\n  return (root.refs[ref] = inlineOrCompile.call(this, _sch))\n}\n\nfunction inlineOrCompile(this: Ajv, sch: SchemaEnv): AnySchema | SchemaEnv {\n  if (inlineRef(sch.schema, this.opts.inlineRefs)) return sch.schema\n  return sch.validate ? sch : compileSchema.call(this, sch)\n}\n\n// Index of schema compilation in the currently compiled list\nexport function getCompilingSchema(this: Ajv, schEnv: SchemaEnv): SchemaEnv | void {\n  for (const sch of this._compilations) {\n    if (sameSchemaEnv(sch, schEnv)) return sch\n  }\n}\n\nfunction sameSchemaEnv(s1: SchemaEnv, s2: SchemaEnv): boolean {\n  return s1.schema === s2.schema && s1.root === s2.root && s1.baseId === s2.baseId\n}\n\n// resolve and compile the references ($ref)\n// TODO returns AnySchemaObject (if the schema can be inlined) or validation function\nfunction resolve(\n  this: Ajv,\n  root: SchemaEnv, // information about the root schema for the current schema\n  ref: string // reference to resolve\n): SchemaEnv | undefined {\n  let sch\n  while (typeof (sch = this.refs[ref]) == \"string\") ref = sch\n  return sch || this.schemas[ref] || resolveSchema.call(this, root, ref)\n}\n\n// Resolve schema, its root and baseId\nexport function resolveSchema(\n  this: Ajv,\n  root: SchemaEnv, // root object with properties schema, refs TODO below SchemaEnv is assigned to it\n  ref: string // reference to resolve\n): SchemaEnv | undefined {\n  const p = this.opts.uriResolver.parse(ref)\n  const refPath = _getFullPath(this.opts.uriResolver, p)\n  let baseId = getFullPath(this.opts.uriResolver, root.baseId, undefined)\n  // TODO `Object.keys(root.schema).length > 0` should not be needed - but removing breaks 2 tests\n  if (Object.keys(root.schema).length > 0 && refPath === baseId) {\n    return getJsonPointer.call(this, p, root)\n  }\n\n  const id = normalizeId(refPath)\n  const schOrRef = this.refs[id] || this.schemas[id]\n  if (typeof schOrRef == \"string\") {\n    const sch = resolveSchema.call(this, root, schOrRef)\n    if (typeof sch?.schema !== \"object\") return\n    return getJsonPointer.call(this, p, sch)\n  }\n\n  if (typeof schOrRef?.schema !== \"object\") return\n  if (!schOrRef.validate) compileSchema.call(this, schOrRef)\n  if (id === normalizeId(ref)) {\n    const {schema} = schOrRef\n    const {schemaId} = this.opts\n    const schId = schema[schemaId]\n    if (schId) baseId = resolveUrl(this.opts.uriResolver, baseId, schId)\n    return new SchemaEnv({schema, schemaId, root, baseId})\n  }\n  return getJsonPointer.call(this, p, schOrRef)\n}\n\nconst PREVENT_SCOPE_CHANGE = new Set([\n  \"properties\",\n  \"patternProperties\",\n  \"enum\",\n  \"dependencies\",\n  \"definitions\",\n])\n\nfunction getJsonPointer(\n  this: Ajv,\n  parsedRef: URIComponent,\n  {baseId, schema, root}: SchemaEnv\n): SchemaEnv | undefined {\n  if (parsedRef.fragment?.[0] !== \"/\") return\n  for (const part of parsedRef.fragment.slice(1).split(\"/\")) {\n    if (typeof schema === \"boolean\") return\n    const partSchema = schema[unescapeFragment(part)]\n    if (partSchema === undefined) return\n    schema = partSchema\n    // TODO PREVENT_SCOPE_CHANGE could be defined in keyword def?\n    const schId = typeof schema === \"object\" && schema[this.opts.schemaId]\n    if (!PREVENT_SCOPE_CHANGE.has(part) && schId) {\n      baseId = resolveUrl(this.opts.uriResolver, baseId, schId)\n    }\n  }\n  let env: SchemaEnv | undefined\n  if (typeof schema != \"boolean\" && schema.$ref && !schemaHasRulesButRef(schema, this.RULES)) {\n    const $ref = resolveUrl(this.opts.uriResolver, baseId, schema.$ref)\n    env = resolveSchema.call(this, root, $ref)\n  }\n  // even though resolution failed we need to return SchemaEnv to throw exception\n  // so that compileAsync loads missing schema.\n  const {schemaId} = this.opts\n  env = env || new SchemaEnv({schema, schemaId, root, baseId})\n  if (env.schema !== env.root.schema) return env\n  return undefined\n}\n","{\n  \"$id\": \"https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#\",\n  \"description\": \"Meta-schema for $data reference (JSON AnySchema extension proposal)\",\n  \"type\": \"object\",\n  \"required\": [\"$data\"],\n  \"properties\": {\n    \"$data\": {\n      \"type\": \"string\",\n      \"anyOf\": [{\"format\": \"relative-json-pointer\"}, {\"format\": \"json-pointer\"}]\n    }\n  },\n  \"additionalProperties\": false\n}\n","'use strict'\n\n/** @type {(value: string) => boolean} */\nconst isUUID = RegExp.prototype.test.bind(/^[\\da-f]{8}-[\\da-f]{4}-[\\da-f]{4}-[\\da-f]{4}-[\\da-f]{12}$/iu)\n\n/** @type {(value: string) => boolean} */\nconst isIPv4 = RegExp.prototype.test.bind(/^(?:(?:25[0-5]|2[0-4]\\d|1\\d{2}|[1-9]\\d|\\d)\\.){3}(?:25[0-5]|2[0-4]\\d|1\\d{2}|[1-9]\\d|\\d)$/u)\n\n/**\n * @param {Array<string>} input\n * @returns {string}\n */\nfunction stringArrayToHexStripped (input) {\n  let acc = ''\n  let code = 0\n  let i = 0\n\n  for (i = 0; i < input.length; i++) {\n    code = input[i].charCodeAt(0)\n    if (code === 48) {\n      continue\n    }\n    if (!((code >= 48 && code <= 57) || (code >= 65 && code <= 70) || (code >= 97 && code <= 102))) {\n      return ''\n    }\n    acc += input[i]\n    break\n  }\n\n  for (i += 1; i < input.length; i++) {\n    code = input[i].charCodeAt(0)\n    if (!((code >= 48 && code <= 57) || (code >= 65 && code <= 70) || (code >= 97 && code <= 102))) {\n      return ''\n    }\n    acc += input[i]\n  }\n  return acc\n}\n\n/**\n * @typedef {Object} GetIPV6Result\n * @property {boolean} error - Indicates if there was an error parsing the IPv6 address.\n * @property {string} address - The parsed IPv6 address.\n * @property {string} [zone] - The zone identifier, if present.\n */\n\n/**\n * @param {string} value\n * @returns {boolean}\n */\nconst nonSimpleDomain = RegExp.prototype.test.bind(/[^!\"$&'()*+,\\-.;=_`a-z{}~]/u)\n\n/**\n * @param {Array<string>} buffer\n * @returns {boolean}\n */\nfunction consumeIsZone (buffer) {\n  buffer.length = 0\n  return true\n}\n\n/**\n * @param {Array<string>} buffer\n * @param {Array<string>} address\n * @param {GetIPV6Result} output\n * @returns {boolean}\n */\nfunction consumeHextets (buffer, address, output) {\n  if (buffer.length) {\n    const hex = stringArrayToHexStripped(buffer)\n    if (hex !== '') {\n      address.push(hex)\n    } else {\n      output.error = true\n      return false\n    }\n    buffer.length = 0\n  }\n  return true\n}\n\n/**\n * @param {string} input\n * @returns {GetIPV6Result}\n */\nfunction getIPV6 (input) {\n  let tokenCount = 0\n  const output = { error: false, address: '', zone: '' }\n  /** @type {Array<string>} */\n  const address = []\n  /** @type {Array<string>} */\n  const buffer = []\n  let endipv6Encountered = false\n  let endIpv6 = false\n\n  let consume = consumeHextets\n\n  for (let i = 0; i < input.length; i++) {\n    const cursor = input[i]\n    if (cursor === '[' || cursor === ']') { continue }\n    if (cursor === ':') {\n      if (endipv6Encountered === true) {\n        endIpv6 = true\n      }\n      if (!consume(buffer, address, output)) { break }\n      if (++tokenCount > 7) {\n        // not valid\n        output.error = true\n        break\n      }\n      if (i > 0 && input[i - 1] === ':') {\n        endipv6Encountered = true\n      }\n      address.push(':')\n      continue\n    } else if (cursor === '%') {\n      if (!consume(buffer, address, output)) { break }\n      // switch to zone detection\n      consume = consumeIsZone\n    } else {\n      buffer.push(cursor)\n      continue\n    }\n  }\n  if (buffer.length) {\n    if (consume === consumeIsZone) {\n      output.zone = buffer.join('')\n    } else if (endIpv6) {\n      address.push(buffer.join(''))\n    } else {\n      address.push(stringArrayToHexStripped(buffer))\n    }\n  }\n  output.address = address.join('')\n  return output\n}\n\n/**\n * @typedef {Object} NormalizeIPv6Result\n * @property {string} host - The normalized host.\n * @property {string} [escapedHost] - The escaped host.\n * @property {boolean} isIPV6 - Indicates if the host is an IPv6 address.\n */\n\n/**\n * @param {string} host\n * @returns {NormalizeIPv6Result}\n */\nfunction normalizeIPv6 (host) {\n  if (findToken(host, ':') < 2) { return { host, isIPV6: false } }\n  const ipv6 = getIPV6(host)\n\n  if (!ipv6.error) {\n    let newHost = ipv6.address\n    let escapedHost = ipv6.address\n    if (ipv6.zone) {\n      newHost += '%' + ipv6.zone\n      escapedHost += '%25' + ipv6.zone\n    }\n    return { host: newHost, isIPV6: true, escapedHost }\n  } else {\n    return { host, isIPV6: false }\n  }\n}\n\n/**\n * @param {string} str\n * @param {string} token\n * @returns {number}\n */\nfunction findToken (str, token) {\n  let ind = 0\n  for (let i = 0; i < str.length; i++) {\n    if (str[i] === token) ind++\n  }\n  return ind\n}\n\n/**\n * @param {string} path\n * @returns {string}\n *\n * @see https://datatracker.ietf.org/doc/html/rfc3986#section-5.2.4\n */\nfunction removeDotSegments (path) {\n  let input = path\n  const output = []\n  let nextSlash = -1\n  let len = 0\n\n  // eslint-disable-next-line no-cond-assign\n  while (len = input.length) {\n    if (len === 1) {\n      if (input === '.') {\n        break\n      } else if (input === '/') {\n        output.push('/')\n        break\n      } else {\n        output.push(input)\n        break\n      }\n    } else if (len === 2) {\n      if (input[0] === '.') {\n        if (input[1] === '.') {\n          break\n        } else if (input[1] === '/') {\n          input = input.slice(2)\n          continue\n        }\n      } else if (input[0] === '/') {\n        if (input[1] === '.' || input[1] === '/') {\n          output.push('/')\n          break\n        }\n      }\n    } else if (len === 3) {\n      if (input === '/..') {\n        if (output.length !== 0) {\n          output.pop()\n        }\n        output.push('/')\n        break\n      }\n    }\n    if (input[0] === '.') {\n      if (input[1] === '.') {\n        if (input[2] === '/') {\n          input = input.slice(3)\n          continue\n        }\n      } else if (input[1] === '/') {\n        input = input.slice(2)\n        continue\n      }\n    } else if (input[0] === '/') {\n      if (input[1] === '.') {\n        if (input[2] === '/') {\n          input = input.slice(2)\n          continue\n        } else if (input[2] === '.') {\n          if (input[3] === '/') {\n            input = input.slice(3)\n            if (output.length !== 0) {\n              output.pop()\n            }\n            continue\n          }\n        }\n      }\n    }\n\n    // Rule 2E: Move normal path segment to output\n    if ((nextSlash = input.indexOf('/', 1)) === -1) {\n      output.push(input)\n      break\n    } else {\n      output.push(input.slice(0, nextSlash))\n      input = input.slice(nextSlash)\n    }\n  }\n\n  return output.join('')\n}\n\n/**\n * @param {import('../types/index').URIComponent} component\n * @param {boolean} esc\n * @returns {import('../types/index').URIComponent}\n */\nfunction normalizeComponentEncoding (component, esc) {\n  const func = esc !== true ? escape : unescape\n  if (component.scheme !== undefined) {\n    component.scheme = func(component.scheme)\n  }\n  if (component.userinfo !== undefined) {\n    component.userinfo = func(component.userinfo)\n  }\n  if (component.host !== undefined) {\n    component.host = func(component.host)\n  }\n  if (component.path !== undefined) {\n    component.path = func(component.path)\n  }\n  if (component.query !== undefined) {\n    component.query = func(component.query)\n  }\n  if (component.fragment !== undefined) {\n    component.fragment = func(component.fragment)\n  }\n  return component\n}\n\n/**\n * @param {import('../types/index').URIComponent} component\n * @returns {string|undefined}\n */\nfunction recomposeAuthority (component) {\n  const uriTokens = []\n\n  if (component.userinfo !== undefined) {\n    uriTokens.push(component.userinfo)\n    uriTokens.push('@')\n  }\n\n  if (component.host !== undefined) {\n    let host = unescape(component.host)\n    if (!isIPv4(host)) {\n      const ipV6res = normalizeIPv6(host)\n      if (ipV6res.isIPV6 === true) {\n        host = `[${ipV6res.escapedHost}]`\n      } else {\n        host = component.host\n      }\n    }\n    uriTokens.push(host)\n  }\n\n  if (typeof component.port === 'number' || typeof component.port === 'string') {\n    uriTokens.push(':')\n    uriTokens.push(String(component.port))\n  }\n\n  return uriTokens.length ? uriTokens.join('') : undefined\n};\n\nmodule.exports = {\n  nonSimpleDomain,\n  recomposeAuthority,\n  normalizeComponentEncoding,\n  removeDotSegments,\n  isIPv4,\n  isUUID,\n  normalizeIPv6,\n  stringArrayToHexStripped\n}\n","'use strict'\n\nconst { isUUID } = require('./utils')\nconst URN_REG = /([\\da-z][\\d\\-a-z]{0,31}):((?:[\\w!$'()*+,\\-.:;=@]|%[\\da-f]{2})+)/iu\n\nconst supportedSchemeNames = /** @type {const} */ (['http', 'https', 'ws',\n  'wss', 'urn', 'urn:uuid'])\n\n/** @typedef {supportedSchemeNames[number]} SchemeName */\n\n/**\n * @param {string} name\n * @returns {name is SchemeName}\n */\nfunction isValidSchemeName (name) {\n  return supportedSchemeNames.indexOf(/** @type {*} */ (name)) !== -1\n}\n\n/**\n * @callback SchemeFn\n * @param {import('../types/index').URIComponent} component\n * @param {import('../types/index').Options} options\n * @returns {import('../types/index').URIComponent}\n */\n\n/**\n * @typedef {Object} SchemeHandler\n * @property {SchemeName} scheme - The scheme name.\n * @property {boolean} [domainHost] - Indicates if the scheme supports domain hosts.\n * @property {SchemeFn} parse - Function to parse the URI component for this scheme.\n * @property {SchemeFn} serialize - Function to serialize the URI component for this scheme.\n * @property {boolean} [skipNormalize] - Indicates if normalization should be skipped for this scheme.\n * @property {boolean} [absolutePath] - Indicates if the scheme uses absolute paths.\n * @property {boolean} [unicodeSupport] - Indicates if the scheme supports Unicode.\n */\n\n/**\n * @param {import('../types/index').URIComponent} wsComponent\n * @returns {boolean}\n */\nfunction wsIsSecure (wsComponent) {\n  if (wsComponent.secure === true) {\n    return true\n  } else if (wsComponent.secure === false) {\n    return false\n  } else if (wsComponent.scheme) {\n    return (\n      wsComponent.scheme.length === 3 &&\n      (wsComponent.scheme[0] === 'w' || wsComponent.scheme[0] === 'W') &&\n      (wsComponent.scheme[1] === 's' || wsComponent.scheme[1] === 'S') &&\n      (wsComponent.scheme[2] === 's' || wsComponent.scheme[2] === 'S')\n    )\n  } else {\n    return false\n  }\n}\n\n/** @type {SchemeFn} */\nfunction httpParse (component) {\n  if (!component.host) {\n    component.error = component.error || 'HTTP URIs must have a host.'\n  }\n\n  return component\n}\n\n/** @type {SchemeFn} */\nfunction httpSerialize (component) {\n  const secure = String(component.scheme).toLowerCase() === 'https'\n\n  // normalize the default port\n  if (component.port === (secure ? 443 : 80) || component.port === '') {\n    component.port = undefined\n  }\n\n  // normalize the empty path\n  if (!component.path) {\n    component.path = '/'\n  }\n\n  // NOTE: We do not parse query strings for HTTP URIs\n  // as WWW Form Url Encoded query strings are part of the HTML4+ spec,\n  // and not the HTTP spec.\n\n  return component\n}\n\n/** @type {SchemeFn} */\nfunction wsParse (wsComponent) {\n// indicate if the secure flag is set\n  wsComponent.secure = wsIsSecure(wsComponent)\n\n  // construct resouce name\n  wsComponent.resourceName = (wsComponent.path || '/') + (wsComponent.query ? '?' + wsComponent.query : '')\n  wsComponent.path = undefined\n  wsComponent.query = undefined\n\n  return wsComponent\n}\n\n/** @type {SchemeFn} */\nfunction wsSerialize (wsComponent) {\n// normalize the default port\n  if (wsComponent.port === (wsIsSecure(wsComponent) ? 443 : 80) || wsComponent.port === '') {\n    wsComponent.port = undefined\n  }\n\n  // ensure scheme matches secure flag\n  if (typeof wsComponent.secure === 'boolean') {\n    wsComponent.scheme = (wsComponent.secure ? 'wss' : 'ws')\n    wsComponent.secure = undefined\n  }\n\n  // reconstruct path from resource name\n  if (wsComponent.resourceName) {\n    const [path, query] = wsComponent.resourceName.split('?')\n    wsComponent.path = (path && path !== '/' ? path : undefined)\n    wsComponent.query = query\n    wsComponent.resourceName = undefined\n  }\n\n  // forbid fragment component\n  wsComponent.fragment = undefined\n\n  return wsComponent\n}\n\n/** @type {SchemeFn} */\nfunction urnParse (urnComponent, options) {\n  if (!urnComponent.path) {\n    urnComponent.error = 'URN can not be parsed'\n    return urnComponent\n  }\n  const matches = urnComponent.path.match(URN_REG)\n  if (matches) {\n    const scheme = options.scheme || urnComponent.scheme || 'urn'\n    urnComponent.nid = matches[1].toLowerCase()\n    urnComponent.nss = matches[2]\n    const urnScheme = `${scheme}:${options.nid || urnComponent.nid}`\n    const schemeHandler = getSchemeHandler(urnScheme)\n    urnComponent.path = undefined\n\n    if (schemeHandler) {\n      urnComponent = schemeHandler.parse(urnComponent, options)\n    }\n  } else {\n    urnComponent.error = urnComponent.error || 'URN can not be parsed.'\n  }\n\n  return urnComponent\n}\n\n/** @type {SchemeFn} */\nfunction urnSerialize (urnComponent, options) {\n  if (urnComponent.nid === undefined) {\n    throw new Error('URN without nid cannot be serialized')\n  }\n  const scheme = options.scheme || urnComponent.scheme || 'urn'\n  const nid = urnComponent.nid.toLowerCase()\n  const urnScheme = `${scheme}:${options.nid || nid}`\n  const schemeHandler = getSchemeHandler(urnScheme)\n\n  if (schemeHandler) {\n    urnComponent = schemeHandler.serialize(urnComponent, options)\n  }\n\n  const uriComponent = urnComponent\n  const nss = urnComponent.nss\n  uriComponent.path = `${nid || options.nid}:${nss}`\n\n  options.skipEscape = true\n  return uriComponent\n}\n\n/** @type {SchemeFn} */\nfunction urnuuidParse (urnComponent, options) {\n  const uuidComponent = urnComponent\n  uuidComponent.uuid = uuidComponent.nss\n  uuidComponent.nss = undefined\n\n  if (!options.tolerant && (!uuidComponent.uuid || !isUUID(uuidComponent.uuid))) {\n    uuidComponent.error = uuidComponent.error || 'UUID is not valid.'\n  }\n\n  return uuidComponent\n}\n\n/** @type {SchemeFn} */\nfunction urnuuidSerialize (uuidComponent) {\n  const urnComponent = uuidComponent\n  // normalize UUID\n  urnComponent.nss = (uuidComponent.uuid || '').toLowerCase()\n  return urnComponent\n}\n\nconst http = /** @type {SchemeHandler} */ ({\n  scheme: 'http',\n  domainHost: true,\n  parse: httpParse,\n  serialize: httpSerialize\n})\n\nconst https = /** @type {SchemeHandler} */ ({\n  scheme: 'https',\n  domainHost: http.domainHost,\n  parse: httpParse,\n  serialize: httpSerialize\n})\n\nconst ws = /** @type {SchemeHandler} */ ({\n  scheme: 'ws',\n  domainHost: true,\n  parse: wsParse,\n  serialize: wsSerialize\n})\n\nconst wss = /** @type {SchemeHandler} */ ({\n  scheme: 'wss',\n  domainHost: ws.domainHost,\n  parse: ws.parse,\n  serialize: ws.serialize\n})\n\nconst urn = /** @type {SchemeHandler} */ ({\n  scheme: 'urn',\n  parse: urnParse,\n  serialize: urnSerialize,\n  skipNormalize: true\n})\n\nconst urnuuid = /** @type {SchemeHandler} */ ({\n  scheme: 'urn:uuid',\n  parse: urnuuidParse,\n  serialize: urnuuidSerialize,\n  skipNormalize: true\n})\n\nconst SCHEMES = /** @type {Record<SchemeName, SchemeHandler>} */ ({\n  http,\n  https,\n  ws,\n  wss,\n  urn,\n  'urn:uuid': urnuuid\n})\n\nObject.setPrototypeOf(SCHEMES, null)\n\n/**\n * @param {string|undefined} scheme\n * @returns {SchemeHandler|undefined}\n */\nfunction getSchemeHandler (scheme) {\n  return (\n    scheme && (\n      SCHEMES[/** @type {SchemeName} */ (scheme)] ||\n      SCHEMES[/** @type {SchemeName} */(scheme.toLowerCase())])\n  ) ||\n    undefined\n}\n\nmodule.exports = {\n  wsIsSecure,\n  SCHEMES,\n  isValidSchemeName,\n  getSchemeHandler,\n}\n","'use strict'\n\nconst { normalizeIPv6, removeDotSegments, recomposeAuthority, normalizeComponentEncoding, isIPv4, nonSimpleDomain } = require('./lib/utils')\nconst { SCHEMES, getSchemeHandler } = require('./lib/schemes')\n\n/**\n * @template {import('./types/index').URIComponent|string} T\n * @param {T} uri\n * @param {import('./types/index').Options} [options]\n * @returns {T}\n */\nfunction normalize (uri, options) {\n  if (typeof uri === 'string') {\n    uri = /** @type {T} */ (serialize(parse(uri, options), options))\n  } else if (typeof uri === 'object') {\n    uri = /** @type {T} */ (parse(serialize(uri, options), options))\n  }\n  return uri\n}\n\n/**\n * @param {string} baseURI\n * @param {string} relativeURI\n * @param {import('./types/index').Options} [options]\n * @returns {string}\n */\nfunction resolve (baseURI, relativeURI, options) {\n  const schemelessOptions = options ? Object.assign({ scheme: 'null' }, options) : { scheme: 'null' }\n  const resolved = resolveComponent(parse(baseURI, schemelessOptions), parse(relativeURI, schemelessOptions), schemelessOptions, true)\n  schemelessOptions.skipEscape = true\n  return serialize(resolved, schemelessOptions)\n}\n\n/**\n * @param {import ('./types/index').URIComponent} base\n * @param {import ('./types/index').URIComponent} relative\n * @param {import('./types/index').Options} [options]\n * @param {boolean} [skipNormalization=false]\n * @returns {import ('./types/index').URIComponent}\n */\nfunction resolveComponent (base, relative, options, skipNormalization) {\n  /** @type {import('./types/index').URIComponent} */\n  const target = {}\n  if (!skipNormalization) {\n    base = parse(serialize(base, options), options) // normalize base component\n    relative = parse(serialize(relative, options), options) // normalize relative component\n  }\n  options = options || {}\n\n  if (!options.tolerant && relative.scheme) {\n    target.scheme = relative.scheme\n    // target.authority = relative.authority;\n    target.userinfo = relative.userinfo\n    target.host = relative.host\n    target.port = relative.port\n    target.path = removeDotSegments(relative.path || '')\n    target.query = relative.query\n  } else {\n    if (relative.userinfo !== undefined || relative.host !== undefined || relative.port !== undefined) {\n      // target.authority = relative.authority;\n      target.userinfo = relative.userinfo\n      target.host = relative.host\n      target.port = relative.port\n      target.path = removeDotSegments(relative.path || '')\n      target.query = relative.query\n    } else {\n      if (!relative.path) {\n        target.path = base.path\n        if (relative.query !== undefined) {\n          target.query = relative.query\n        } else {\n          target.query = base.query\n        }\n      } else {\n        if (relative.path[0] === '/') {\n          target.path = removeDotSegments(relative.path)\n        } else {\n          if ((base.userinfo !== undefined || base.host !== undefined || base.port !== undefined) && !base.path) {\n            target.path = '/' + relative.path\n          } else if (!base.path) {\n            target.path = relative.path\n          } else {\n            target.path = base.path.slice(0, base.path.lastIndexOf('/') + 1) + relative.path\n          }\n          target.path = removeDotSegments(target.path)\n        }\n        target.query = relative.query\n      }\n      // target.authority = base.authority;\n      target.userinfo = base.userinfo\n      target.host = base.host\n      target.port = base.port\n    }\n    target.scheme = base.scheme\n  }\n\n  target.fragment = relative.fragment\n\n  return target\n}\n\n/**\n * @param {import ('./types/index').URIComponent|string} uriA\n * @param {import ('./types/index').URIComponent|string} uriB\n * @param {import ('./types/index').Options} options\n * @returns {boolean}\n */\nfunction equal (uriA, uriB, options) {\n  if (typeof uriA === 'string') {\n    uriA = unescape(uriA)\n    uriA = serialize(normalizeComponentEncoding(parse(uriA, options), true), { ...options, skipEscape: true })\n  } else if (typeof uriA === 'object') {\n    uriA = serialize(normalizeComponentEncoding(uriA, true), { ...options, skipEscape: true })\n  }\n\n  if (typeof uriB === 'string') {\n    uriB = unescape(uriB)\n    uriB = serialize(normalizeComponentEncoding(parse(uriB, options), true), { ...options, skipEscape: true })\n  } else if (typeof uriB === 'object') {\n    uriB = serialize(normalizeComponentEncoding(uriB, true), { ...options, skipEscape: true })\n  }\n\n  return uriA.toLowerCase() === uriB.toLowerCase()\n}\n\n/**\n * @param {Readonly<import('./types/index').URIComponent>} cmpts\n * @param {import('./types/index').Options} [opts]\n * @returns {string}\n */\nfunction serialize (cmpts, opts) {\n  const component = {\n    host: cmpts.host,\n    scheme: cmpts.scheme,\n    userinfo: cmpts.userinfo,\n    port: cmpts.port,\n    path: cmpts.path,\n    query: cmpts.query,\n    nid: cmpts.nid,\n    nss: cmpts.nss,\n    uuid: cmpts.uuid,\n    fragment: cmpts.fragment,\n    reference: cmpts.reference,\n    resourceName: cmpts.resourceName,\n    secure: cmpts.secure,\n    error: ''\n  }\n  const options = Object.assign({}, opts)\n  const uriTokens = []\n\n  // find scheme handler\n  const schemeHandler = getSchemeHandler(options.scheme || component.scheme)\n\n  // perform scheme specific serialization\n  if (schemeHandler && schemeHandler.serialize) schemeHandler.serialize(component, options)\n\n  if (component.path !== undefined) {\n    if (!options.skipEscape) {\n      component.path = escape(component.path)\n\n      if (component.scheme !== undefined) {\n        component.path = component.path.split('%3A').join(':')\n      }\n    } else {\n      component.path = unescape(component.path)\n    }\n  }\n\n  if (options.reference !== 'suffix' && component.scheme) {\n    uriTokens.push(component.scheme, ':')\n  }\n\n  const authority = recomposeAuthority(component)\n  if (authority !== undefined) {\n    if (options.reference !== 'suffix') {\n      uriTokens.push('//')\n    }\n\n    uriTokens.push(authority)\n\n    if (component.path && component.path[0] !== '/') {\n      uriTokens.push('/')\n    }\n  }\n  if (component.path !== undefined) {\n    let s = component.path\n\n    if (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) {\n      s = removeDotSegments(s)\n    }\n\n    if (\n      authority === undefined &&\n      s[0] === '/' &&\n      s[1] === '/'\n    ) {\n      // don't allow the path to start with \"//\"\n      s = '/%2F' + s.slice(2)\n    }\n\n    uriTokens.push(s)\n  }\n\n  if (component.query !== undefined) {\n    uriTokens.push('?', component.query)\n  }\n\n  if (component.fragment !== undefined) {\n    uriTokens.push('#', component.fragment)\n  }\n  return uriTokens.join('')\n}\n\nconst URI_PARSE = /^(?:([^#/:?]+):)?(?:\\/\\/((?:([^#/?@]*)@)?(\\[[^#/?\\]]+\\]|[^#/:?]*)(?::(\\d*))?))?([^#?]*)(?:\\?([^#]*))?(?:#((?:.|[\\n\\r])*))?/u\n\n/**\n * @param {string} uri\n * @param {import('./types/index').Options} [opts]\n * @returns\n */\nfunction parse (uri, opts) {\n  const options = Object.assign({}, opts)\n  /** @type {import('./types/index').URIComponent} */\n  const parsed = {\n    scheme: undefined,\n    userinfo: undefined,\n    host: '',\n    port: undefined,\n    path: '',\n    query: undefined,\n    fragment: undefined\n  }\n\n  let isIP = false\n  if (options.reference === 'suffix') {\n    if (options.scheme) {\n      uri = options.scheme + ':' + uri\n    } else {\n      uri = '//' + uri\n    }\n  }\n\n  const matches = uri.match(URI_PARSE)\n\n  if (matches) {\n    // store each component\n    parsed.scheme = matches[1]\n    parsed.userinfo = matches[3]\n    parsed.host = matches[4]\n    parsed.port = parseInt(matches[5], 10)\n    parsed.path = matches[6] || ''\n    parsed.query = matches[7]\n    parsed.fragment = matches[8]\n\n    // fix port number\n    if (isNaN(parsed.port)) {\n      parsed.port = matches[5]\n    }\n    if (parsed.host) {\n      const ipv4result = isIPv4(parsed.host)\n      if (ipv4result === false) {\n        const ipv6result = normalizeIPv6(parsed.host)\n        parsed.host = ipv6result.host.toLowerCase()\n        isIP = ipv6result.isIPV6\n      } else {\n        isIP = true\n      }\n    }\n    if (parsed.scheme === undefined && parsed.userinfo === undefined && parsed.host === undefined && parsed.port === undefined && parsed.query === undefined && !parsed.path) {\n      parsed.reference = 'same-document'\n    } else if (parsed.scheme === undefined) {\n      parsed.reference = 'relative'\n    } else if (parsed.fragment === undefined) {\n      parsed.reference = 'absolute'\n    } else {\n      parsed.reference = 'uri'\n    }\n\n    // check for reference errors\n    if (options.reference && options.reference !== 'suffix' && options.reference !== parsed.reference) {\n      parsed.error = parsed.error || 'URI is not a ' + options.reference + ' reference.'\n    }\n\n    // find scheme handler\n    const schemeHandler = getSchemeHandler(options.scheme || parsed.scheme)\n\n    // check if scheme can't handle IRIs\n    if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {\n      // if host component is a domain name\n      if (parsed.host && (options.domainHost || (schemeHandler && schemeHandler.domainHost)) && isIP === false && nonSimpleDomain(parsed.host)) {\n        // convert Unicode IDN -> ASCII IDN\n        try {\n          parsed.host = URL.domainToASCII(parsed.host.toLowerCase())\n        } catch (e) {\n          parsed.error = parsed.error || \"Host's domain name can not be converted to ASCII: \" + e\n        }\n      }\n      // convert IRI -> URI\n    }\n\n    if (!schemeHandler || (schemeHandler && !schemeHandler.skipNormalize)) {\n      if (uri.indexOf('%') !== -1) {\n        if (parsed.scheme !== undefined) {\n          parsed.scheme = unescape(parsed.scheme)\n        }\n        if (parsed.host !== undefined) {\n          parsed.host = unescape(parsed.host)\n        }\n      }\n      if (parsed.path) {\n        parsed.path = escape(unescape(parsed.path))\n      }\n      if (parsed.fragment) {\n        parsed.fragment = encodeURI(decodeURIComponent(parsed.fragment))\n      }\n    }\n\n    // perform scheme specific parsing\n    if (schemeHandler && schemeHandler.parse) {\n      schemeHandler.parse(parsed, options)\n    }\n  } else {\n    parsed.error = parsed.error || 'URI can not be parsed.'\n  }\n  return parsed\n}\n\nconst fastUri = {\n  SCHEMES,\n  normalize,\n  resolve,\n  resolveComponent,\n  equal,\n  serialize,\n  parse\n}\n\nmodule.exports = fastUri\nmodule.exports.default = fastUri\nmodule.exports.fastUri = fastUri\n","import * as uri from \"fast-uri\"\n\ntype URI = typeof uri & {code: string}\n;(uri as URI).code = 'require(\"ajv/dist/runtime/uri\").default'\n\nexport default uri as URI\n","export {\n  Format,\n  FormatDefinition,\n  AsyncFormatDefinition,\n  KeywordDefinition,\n  KeywordErrorDefinition,\n  CodeKeywordDefinition,\n  MacroKeywordDefinition,\n  FuncKeywordDefinition,\n  Vocabulary,\n  Schema,\n  SchemaObject,\n  AnySchemaObject,\n  AsyncSchema,\n  AnySchema,\n  ValidateFunction,\n  AsyncValidateFunction,\n  AnyValidateFunction,\n  ErrorObject,\n  ErrorNoParams,\n} from \"./types\"\n\nexport {SchemaCxt, SchemaObjCxt} from \"./compile\"\nexport interface Plugin<Opts> {\n  (ajv: Ajv, options?: Opts): Ajv\n  [prop: string]: any\n}\n\nexport {KeywordCxt} from \"./compile/validate\"\nexport {DefinedError} from \"./vocabularies/errors\"\nexport {JSONType} from \"./compile/rules\"\nexport {JSONSchemaType} from \"./types/json-schema\"\nexport {JTDSchemaType, SomeJTDSchemaType, JTDDataType} from \"./types/jtd-schema\"\nexport {_, str, stringify, nil, Name, Code, CodeGen, CodeGenOptions} from \"./compile/codegen\"\n\nimport type {\n  Schema,\n  AnySchema,\n  AnySchemaObject,\n  SchemaObject,\n  AsyncSchema,\n  Vocabulary,\n  KeywordDefinition,\n  AddedKeywordDefinition,\n  AnyValidateFunction,\n  ValidateFunction,\n  AsyncValidateFunction,\n  ErrorObject,\n  Format,\n  AddedFormat,\n  RegExpEngine,\n  UriResolver,\n} from \"./types\"\nimport type {JSONSchemaType} from \"./types/json-schema\"\nimport type {JTDSchemaType, SomeJTDSchemaType, JTDDataType} from \"./types/jtd-schema\"\nimport ValidationError from \"./runtime/validation_error\"\nimport MissingRefError from \"./compile/ref_error\"\nimport {getRules, ValidationRules, Rule, RuleGroup, JSONType} from \"./compile/rules\"\nimport {SchemaEnv, compileSchema, resolveSchema} from \"./compile\"\nimport {Code, ValueScope} from \"./compile/codegen\"\nimport {normalizeId, getSchemaRefs} from \"./compile/resolve\"\nimport {getJSONTypes} from \"./compile/validate/dataType\"\nimport {eachItem} from \"./compile/util\"\nimport * as $dataRefSchema from \"./refs/data.json\"\n\nimport DefaultUriResolver from \"./runtime/uri\"\n\nconst defaultRegExp: RegExpEngine = (str, flags) => new RegExp(str, flags)\ndefaultRegExp.code = \"new RegExp\"\n\nconst META_IGNORE_OPTIONS: (keyof Options)[] = [\"removeAdditional\", \"useDefaults\", \"coerceTypes\"]\nconst EXT_SCOPE_NAMES = new Set([\n  \"validate\",\n  \"serialize\",\n  \"parse\",\n  \"wrapper\",\n  \"root\",\n  \"schema\",\n  \"keyword\",\n  \"pattern\",\n  \"formats\",\n  \"validate$data\",\n  \"func\",\n  \"obj\",\n  \"Error\",\n])\n\nexport type Options = CurrentOptions & DeprecatedOptions\n\nexport interface CurrentOptions {\n  // strict mode options (NEW)\n  strict?: boolean | \"log\"\n  strictSchema?: boolean | \"log\"\n  strictNumbers?: boolean | \"log\"\n  strictTypes?: boolean | \"log\"\n  strictTuples?: boolean | \"log\"\n  strictRequired?: boolean | \"log\"\n  allowMatchingProperties?: boolean // disables a strict mode restriction\n  allowUnionTypes?: boolean\n  validateFormats?: boolean\n  // validation and reporting options:\n  $data?: boolean\n  allErrors?: boolean\n  verbose?: boolean\n  discriminator?: boolean\n  unicodeRegExp?: boolean\n  timestamp?: \"string\" | \"date\" // JTD only\n  parseDate?: boolean // JTD only\n  allowDate?: boolean // JTD only\n  $comment?:\n    | true\n    | ((comment: string, schemaPath?: string, rootSchema?: AnySchemaObject) => unknown)\n  formats?: {[Name in string]?: Format}\n  keywords?: Vocabulary\n  schemas?: AnySchema[] | {[Key in string]?: AnySchema}\n  logger?: Logger | false\n  loadSchema?: (uri: string) => Promise<AnySchemaObject>\n  // options to modify validated data:\n  removeAdditional?: boolean | \"all\" | \"failing\"\n  useDefaults?: boolean | \"empty\"\n  coerceTypes?: boolean | \"array\"\n  // advanced options:\n  next?: boolean // NEW\n  unevaluated?: boolean // NEW\n  dynamicRef?: boolean // NEW\n  schemaId?: \"id\" | \"$id\"\n  jtd?: boolean // NEW\n  meta?: SchemaObject | boolean\n  defaultMeta?: string | AnySchemaObject\n  validateSchema?: boolean | \"log\"\n  addUsedSchema?: boolean\n  inlineRefs?: boolean | number\n  passContext?: boolean\n  loopRequired?: number\n  loopEnum?: number // NEW\n  ownProperties?: boolean\n  multipleOfPrecision?: number\n  int32range?: boolean // JTD only\n  messages?: boolean\n  code?: CodeOptions // NEW\n  uriResolver?: UriResolver\n}\n\nexport interface CodeOptions {\n  es5?: boolean\n  esm?: boolean\n  lines?: boolean\n  optimize?: boolean | number\n  formats?: Code // code to require (or construct) map of available formats - for standalone code\n  source?: boolean\n  process?: (code: string, schema?: SchemaEnv) => string\n  regExp?: RegExpEngine\n}\n\ninterface InstanceCodeOptions extends CodeOptions {\n  regExp: RegExpEngine\n  optimize: number\n}\n\ninterface DeprecatedOptions {\n  /** @deprecated */\n  ignoreKeywordsWithRef?: boolean\n  /** @deprecated */\n  jsPropertySyntax?: boolean // added instead of jsonPointers\n  /** @deprecated */\n  unicode?: boolean\n}\n\ninterface RemovedOptions {\n  format?: boolean\n  errorDataPath?: \"object\" | \"property\"\n  nullable?: boolean // \"nullable\" keyword is supported by default\n  jsonPointers?: boolean\n  extendRefs?: true | \"ignore\" | \"fail\"\n  missingRefs?: true | \"ignore\" | \"fail\"\n  processCode?: (code: string, schema?: SchemaEnv) => string\n  sourceCode?: boolean\n  strictDefaults?: boolean\n  strictKeywords?: boolean\n  uniqueItems?: boolean\n  unknownFormats?: true | string[] | \"ignore\"\n  cache?: any\n  serialize?: (schema: AnySchema) => unknown\n  ajvErrors?: boolean\n}\n\ntype OptionsInfo<T extends RemovedOptions | DeprecatedOptions> = {\n  [K in keyof T]-?: string | undefined\n}\n\nconst removedOptions: OptionsInfo<RemovedOptions> = {\n  errorDataPath: \"\",\n  format: \"`validateFormats: false` can be used instead.\",\n  nullable: '\"nullable\" keyword is supported by default.',\n  jsonPointers: \"Deprecated jsPropertySyntax can be used instead.\",\n  extendRefs: \"Deprecated ignoreKeywordsWithRef can be used instead.\",\n  missingRefs: \"Pass empty schema with $id that should be ignored to ajv.addSchema.\",\n  processCode: \"Use option `code: {process: (code, schemaEnv: object) => string}`\",\n  sourceCode: \"Use option `code: {source: true}`\",\n  strictDefaults: \"It is default now, see option `strict`.\",\n  strictKeywords: \"It is default now, see option `strict`.\",\n  uniqueItems: '\"uniqueItems\" keyword is always validated.',\n  unknownFormats: \"Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).\",\n  cache: \"Map is used as cache, schema object as key.\",\n  serialize: \"Map is used as cache, schema object as key.\",\n  ajvErrors: \"It is default now.\",\n}\n\nconst deprecatedOptions: OptionsInfo<DeprecatedOptions> = {\n  ignoreKeywordsWithRef: \"\",\n  jsPropertySyntax: \"\",\n  unicode: '\"minLength\"/\"maxLength\" account for unicode characters by default.',\n}\n\ntype RequiredInstanceOptions = {\n  [K in\n    | \"strictSchema\"\n    | \"strictNumbers\"\n    | \"strictTypes\"\n    | \"strictTuples\"\n    | \"strictRequired\"\n    | \"inlineRefs\"\n    | \"loopRequired\"\n    | \"loopEnum\"\n    | \"meta\"\n    | \"messages\"\n    | \"schemaId\"\n    | \"addUsedSchema\"\n    | \"validateSchema\"\n    | \"validateFormats\"\n    | \"int32range\"\n    | \"unicodeRegExp\"\n    | \"uriResolver\"]: NonNullable<Options[K]>\n} & {code: InstanceCodeOptions}\n\nexport type InstanceOptions = Options & RequiredInstanceOptions\n\nconst MAX_EXPRESSION = 200\n\n// eslint-disable-next-line complexity\nfunction requiredOptions(o: Options): RequiredInstanceOptions {\n  const s = o.strict\n  const _optz = o.code?.optimize\n  const optimize = _optz === true || _optz === undefined ? 1 : _optz || 0\n  const regExp = o.code?.regExp ?? defaultRegExp\n  const uriResolver = o.uriResolver ?? DefaultUriResolver\n  return {\n    strictSchema: o.strictSchema ?? s ?? true,\n    strictNumbers: o.strictNumbers ?? s ?? true,\n    strictTypes: o.strictTypes ?? s ?? \"log\",\n    strictTuples: o.strictTuples ?? s ?? \"log\",\n    strictRequired: o.strictRequired ?? s ?? false,\n    code: o.code ? {...o.code, optimize, regExp} : {optimize, regExp},\n    loopRequired: o.loopRequired ?? MAX_EXPRESSION,\n    loopEnum: o.loopEnum ?? MAX_EXPRESSION,\n    meta: o.meta ?? true,\n    messages: o.messages ?? true,\n    inlineRefs: o.inlineRefs ?? true,\n    schemaId: o.schemaId ?? \"$id\",\n    addUsedSchema: o.addUsedSchema ?? true,\n    validateSchema: o.validateSchema ?? true,\n    validateFormats: o.validateFormats ?? true,\n    unicodeRegExp: o.unicodeRegExp ?? true,\n    int32range: o.int32range ?? true,\n    uriResolver: uriResolver,\n  }\n}\n\nexport interface Logger {\n  log(...args: unknown[]): unknown\n  warn(...args: unknown[]): unknown\n  error(...args: unknown[]): unknown\n}\n\nexport default class Ajv {\n  opts: InstanceOptions\n  errors?: ErrorObject[] | null // errors from the last validation\n  logger: Logger\n  // shared external scope values for compiled functions\n  readonly scope: ValueScope\n  readonly schemas: {[Key in string]?: SchemaEnv} = {}\n  readonly refs: {[Ref in string]?: SchemaEnv | string} = {}\n  readonly formats: {[Name in string]?: AddedFormat} = {}\n  readonly RULES: ValidationRules\n  readonly _compilations: Set<SchemaEnv> = new Set()\n  private readonly _loading: {[Ref in string]?: Promise<AnySchemaObject>} = {}\n  private readonly _cache: Map<AnySchema, SchemaEnv> = new Map()\n  private readonly _metaOpts: InstanceOptions\n\n  static ValidationError = ValidationError\n  static MissingRefError = MissingRefError\n\n  constructor(opts: Options = {}) {\n    opts = this.opts = {...opts, ...requiredOptions(opts)}\n    const {es5, lines} = this.opts.code\n\n    this.scope = new ValueScope({scope: {}, prefixes: EXT_SCOPE_NAMES, es5, lines})\n    this.logger = getLogger(opts.logger)\n    const formatOpt = opts.validateFormats\n    opts.validateFormats = false\n\n    this.RULES = getRules()\n    checkOptions.call(this, removedOptions, opts, \"NOT SUPPORTED\")\n    checkOptions.call(this, deprecatedOptions, opts, \"DEPRECATED\", \"warn\")\n    this._metaOpts = getMetaSchemaOptions.call(this)\n\n    if (opts.formats) addInitialFormats.call(this)\n    this._addVocabularies()\n    this._addDefaultMetaSchema()\n    if (opts.keywords) addInitialKeywords.call(this, opts.keywords)\n    if (typeof opts.meta == \"object\") this.addMetaSchema(opts.meta)\n    addInitialSchemas.call(this)\n    opts.validateFormats = formatOpt\n  }\n\n  _addVocabularies(): void {\n    this.addKeyword(\"$async\")\n  }\n\n  _addDefaultMetaSchema(): void {\n    const {$data, meta, schemaId} = this.opts\n    let _dataRefSchema: SchemaObject = $dataRefSchema\n    if (schemaId === \"id\") {\n      _dataRefSchema = {...$dataRefSchema}\n      _dataRefSchema.id = _dataRefSchema.$id\n      delete _dataRefSchema.$id\n    }\n    if (meta && $data) this.addMetaSchema(_dataRefSchema, _dataRefSchema[schemaId], false)\n  }\n\n  defaultMeta(): string | AnySchemaObject | undefined {\n    const {meta, schemaId} = this.opts\n    return (this.opts.defaultMeta = typeof meta == \"object\" ? meta[schemaId] || meta : undefined)\n  }\n\n  // Validate data using schema\n  // AnySchema will be compiled and cached using schema itself as a key for Map\n  validate(schema: Schema | string, data: unknown): boolean\n  validate(schemaKeyRef: AnySchema | string, data: unknown): boolean | Promise<unknown>\n  validate<T>(schema: Schema | JSONSchemaType<T> | string, data: unknown): data is T\n  // Separated for type inference to work\n  // eslint-disable-next-line @typescript-eslint/unified-signatures\n  validate<T>(schema: JTDSchemaType<T>, data: unknown): data is T\n  // This overload is only intended for typescript inference, the first\n  // argument prevents manual type annotation from matching this overload\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  validate<N extends never, T extends SomeJTDSchemaType>(\n    schema: T,\n    data: unknown\n  ): data is JTDDataType<T>\n  // eslint-disable-next-line @typescript-eslint/no-redundant-type-constituents\n  validate<T>(schema: AsyncSchema, data: unknown | T): Promise<T>\n  validate<T>(schemaKeyRef: AnySchema | string, data: unknown): data is T | Promise<T>\n  validate<T>(\n    schemaKeyRef: AnySchema | string, // key, ref or schema object\n    // eslint-disable-next-line @typescript-eslint/no-redundant-type-constituents\n    data: unknown | T // to be validated\n  ): boolean | Promise<T> {\n    let v: AnyValidateFunction | undefined\n    if (typeof schemaKeyRef == \"string\") {\n      v = this.getSchema<T>(schemaKeyRef)\n      if (!v) throw new Error(`no schema with key or ref \"${schemaKeyRef}\"`)\n    } else {\n      v = this.compile<T>(schemaKeyRef)\n    }\n\n    const valid = v(data)\n    if (!(\"$async\" in v)) this.errors = v.errors\n    return valid\n  }\n\n  // Create validation function for passed schema\n  // _meta: true if schema is a meta-schema. Used internally to compile meta schemas of user-defined keywords.\n  compile<T = unknown>(schema: Schema | JSONSchemaType<T>, _meta?: boolean): ValidateFunction<T>\n  // Separated for type inference to work\n  // eslint-disable-next-line @typescript-eslint/unified-signatures\n  compile<T = unknown>(schema: JTDSchemaType<T>, _meta?: boolean): ValidateFunction<T>\n  // This overload is only intended for typescript inference, the first\n  // argument prevents manual type annotation from matching this overload\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  compile<N extends never, T extends SomeJTDSchemaType>(\n    schema: T,\n    _meta?: boolean\n  ): ValidateFunction<JTDDataType<T>>\n  compile<T = unknown>(schema: AsyncSchema, _meta?: boolean): AsyncValidateFunction<T>\n  compile<T = unknown>(schema: AnySchema, _meta?: boolean): AnyValidateFunction<T>\n  compile<T = unknown>(schema: AnySchema, _meta?: boolean): AnyValidateFunction<T> {\n    const sch = this._addSchema(schema, _meta)\n    return (sch.validate || this._compileSchemaEnv(sch)) as AnyValidateFunction<T>\n  }\n\n  // Creates validating function for passed schema with asynchronous loading of missing schemas.\n  // `loadSchema` option should be a function that accepts schema uri and returns promise that resolves with the schema.\n  // TODO allow passing schema URI\n  // meta - optional true to compile meta-schema\n  compileAsync<T = unknown>(\n    schema: SchemaObject | JSONSchemaType<T>,\n    _meta?: boolean\n  ): Promise<ValidateFunction<T>>\n  // Separated for type inference to work\n  // eslint-disable-next-line @typescript-eslint/unified-signatures\n  compileAsync<T = unknown>(schema: JTDSchemaType<T>, _meta?: boolean): Promise<ValidateFunction<T>>\n  compileAsync<T = unknown>(schema: AsyncSchema, meta?: boolean): Promise<AsyncValidateFunction<T>>\n  // eslint-disable-next-line @typescript-eslint/unified-signatures\n  compileAsync<T = unknown>(\n    schema: AnySchemaObject,\n    meta?: boolean\n  ): Promise<AnyValidateFunction<T>>\n  compileAsync<T = unknown>(\n    schema: AnySchemaObject,\n    meta?: boolean\n  ): Promise<AnyValidateFunction<T>> {\n    if (typeof this.opts.loadSchema != \"function\") {\n      throw new Error(\"options.loadSchema should be a function\")\n    }\n    const {loadSchema} = this.opts\n    return runCompileAsync.call(this, schema, meta)\n\n    async function runCompileAsync(\n      this: Ajv,\n      _schema: AnySchemaObject,\n      _meta?: boolean\n    ): Promise<AnyValidateFunction> {\n      await loadMetaSchema.call(this, _schema.$schema)\n      const sch = this._addSchema(_schema, _meta)\n      return sch.validate || _compileAsync.call(this, sch)\n    }\n\n    async function loadMetaSchema(this: Ajv, $ref?: string): Promise<void> {\n      if ($ref && !this.getSchema($ref)) {\n        await runCompileAsync.call(this, {$ref}, true)\n      }\n    }\n\n    async function _compileAsync(this: Ajv, sch: SchemaEnv): Promise<AnyValidateFunction> {\n      try {\n        return this._compileSchemaEnv(sch)\n      } catch (e) {\n        if (!(e instanceof MissingRefError)) throw e\n        checkLoaded.call(this, e)\n        await loadMissingSchema.call(this, e.missingSchema)\n        return _compileAsync.call(this, sch)\n      }\n    }\n\n    function checkLoaded(this: Ajv, {missingSchema: ref, missingRef}: MissingRefError): void {\n      if (this.refs[ref]) {\n        throw new Error(`AnySchema ${ref} is loaded but ${missingRef} cannot be resolved`)\n      }\n    }\n\n    async function loadMissingSchema(this: Ajv, ref: string): Promise<void> {\n      const _schema = await _loadSchema.call(this, ref)\n      if (!this.refs[ref]) await loadMetaSchema.call(this, _schema.$schema)\n      if (!this.refs[ref]) this.addSchema(_schema, ref, meta)\n    }\n\n    async function _loadSchema(this: Ajv, ref: string): Promise<AnySchemaObject> {\n      const p = this._loading[ref]\n      if (p) return p\n      try {\n        return await (this._loading[ref] = loadSchema(ref))\n      } finally {\n        delete this._loading[ref]\n      }\n    }\n  }\n\n  // Adds schema to the instance\n  addSchema(\n    schema: AnySchema | AnySchema[], // If array is passed, `key` will be ignored\n    key?: string, // Optional schema key. Can be passed to `validate` method instead of schema object or id/ref. One schema per instance can have empty `id` and `key`.\n    _meta?: boolean, // true if schema is a meta-schema. Used internally, addMetaSchema should be used instead.\n    _validateSchema = this.opts.validateSchema // false to skip schema validation. Used internally, option validateSchema should be used instead.\n  ): Ajv {\n    if (Array.isArray(schema)) {\n      for (const sch of schema) this.addSchema(sch, undefined, _meta, _validateSchema)\n      return this\n    }\n    let id: string | undefined\n    if (typeof schema === \"object\") {\n      const {schemaId} = this.opts\n      id = schema[schemaId]\n      if (id !== undefined && typeof id != \"string\") {\n        throw new Error(`schema ${schemaId} must be string`)\n      }\n    }\n    key = normalizeId(key || id)\n    this._checkUnique(key)\n    this.schemas[key] = this._addSchema(schema, _meta, key, _validateSchema, true)\n    return this\n  }\n\n  // Add schema that will be used to validate other schemas\n  // options in META_IGNORE_OPTIONS are alway set to false\n  addMetaSchema(\n    schema: AnySchemaObject,\n    key?: string, // schema key\n    _validateSchema = this.opts.validateSchema // false to skip schema validation, can be used to override validateSchema option for meta-schema\n  ): Ajv {\n    this.addSchema(schema, key, true, _validateSchema)\n    return this\n  }\n\n  //  Validate schema against its meta-schema\n  validateSchema(schema: AnySchema, throwOrLogError?: boolean): boolean | Promise<unknown> {\n    if (typeof schema == \"boolean\") return true\n    let $schema: string | AnySchemaObject | undefined\n    $schema = schema.$schema\n    if ($schema !== undefined && typeof $schema != \"string\") {\n      throw new Error(\"$schema must be a string\")\n    }\n    $schema = $schema || this.opts.defaultMeta || this.defaultMeta()\n    if (!$schema) {\n      this.logger.warn(\"meta-schema not available\")\n      this.errors = null\n      return true\n    }\n    const valid = this.validate($schema, schema)\n    if (!valid && throwOrLogError) {\n      const message = \"schema is invalid: \" + this.errorsText()\n      if (this.opts.validateSchema === \"log\") this.logger.error(message)\n      else throw new Error(message)\n    }\n    return valid\n  }\n\n  // Get compiled schema by `key` or `ref`.\n  // (`key` that was passed to `addSchema` or full schema reference - `schema.$id` or resolved id)\n  getSchema<T = unknown>(keyRef: string): AnyValidateFunction<T> | undefined {\n    let sch\n    while (typeof (sch = getSchEnv.call(this, keyRef)) == \"string\") keyRef = sch\n    if (sch === undefined) {\n      const {schemaId} = this.opts\n      const root = new SchemaEnv({schema: {}, schemaId})\n      sch = resolveSchema.call(this, root, keyRef)\n      if (!sch) return\n      this.refs[keyRef] = sch\n    }\n    return (sch.validate || this._compileSchemaEnv(sch)) as AnyValidateFunction<T> | undefined\n  }\n\n  // Remove cached schema(s).\n  // If no parameter is passed all schemas but meta-schemas are removed.\n  // If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.\n  // Even if schema is referenced by other schemas it still can be removed as other schemas have local references.\n  removeSchema(schemaKeyRef?: AnySchema | string | RegExp): Ajv {\n    if (schemaKeyRef instanceof RegExp) {\n      this._removeAllSchemas(this.schemas, schemaKeyRef)\n      this._removeAllSchemas(this.refs, schemaKeyRef)\n      return this\n    }\n    switch (typeof schemaKeyRef) {\n      case \"undefined\":\n        this._removeAllSchemas(this.schemas)\n        this._removeAllSchemas(this.refs)\n        this._cache.clear()\n        return this\n      case \"string\": {\n        const sch = getSchEnv.call(this, schemaKeyRef)\n        if (typeof sch == \"object\") this._cache.delete(sch.schema)\n        delete this.schemas[schemaKeyRef]\n        delete this.refs[schemaKeyRef]\n        return this\n      }\n      case \"object\": {\n        const cacheKey = schemaKeyRef\n        this._cache.delete(cacheKey)\n        let id = schemaKeyRef[this.opts.schemaId]\n        if (id) {\n          id = normalizeId(id)\n          delete this.schemas[id]\n          delete this.refs[id]\n        }\n        return this\n      }\n      default:\n        throw new Error(\"ajv.removeSchema: invalid parameter\")\n    }\n  }\n\n  // add \"vocabulary\" - a collection of keywords\n  addVocabulary(definitions: Vocabulary): Ajv {\n    for (const def of definitions) this.addKeyword(def)\n    return this\n  }\n\n  addKeyword(\n    kwdOrDef: string | KeywordDefinition,\n    def?: KeywordDefinition // deprecated\n  ): Ajv {\n    let keyword: string | string[]\n    if (typeof kwdOrDef == \"string\") {\n      keyword = kwdOrDef\n      if (typeof def == \"object\") {\n        this.logger.warn(\"these parameters are deprecated, see docs for addKeyword\")\n        def.keyword = keyword\n      }\n    } else if (typeof kwdOrDef == \"object\" && def === undefined) {\n      def = kwdOrDef\n      keyword = def.keyword\n      if (Array.isArray(keyword) && !keyword.length) {\n        throw new Error(\"addKeywords: keyword must be string or non-empty array\")\n      }\n    } else {\n      throw new Error(\"invalid addKeywords parameters\")\n    }\n\n    checkKeyword.call(this, keyword, def)\n    if (!def) {\n      eachItem(keyword, (kwd) => addRule.call(this, kwd))\n      return this\n    }\n    keywordMetaschema.call(this, def)\n    const definition: AddedKeywordDefinition = {\n      ...def,\n      type: getJSONTypes(def.type),\n      schemaType: getJSONTypes(def.schemaType),\n    }\n    eachItem(\n      keyword,\n      definition.type.length === 0\n        ? (k) => addRule.call(this, k, definition)\n        : (k) => definition.type.forEach((t) => addRule.call(this, k, definition, t))\n    )\n    return this\n  }\n\n  getKeyword(keyword: string): AddedKeywordDefinition | boolean {\n    const rule = this.RULES.all[keyword]\n    return typeof rule == \"object\" ? rule.definition : !!rule\n  }\n\n  // Remove keyword\n  removeKeyword(keyword: string): Ajv {\n    // TODO return type should be Ajv\n    const {RULES} = this\n    delete RULES.keywords[keyword]\n    delete RULES.all[keyword]\n    for (const group of RULES.rules) {\n      const i = group.rules.findIndex((rule) => rule.keyword === keyword)\n      if (i >= 0) group.rules.splice(i, 1)\n    }\n    return this\n  }\n\n  // Add format\n  addFormat(name: string, format: Format): Ajv {\n    if (typeof format == \"string\") format = new RegExp(format)\n    this.formats[name] = format\n    return this\n  }\n\n  errorsText(\n    errors: ErrorObject[] | null | undefined = this.errors, // optional array of validation errors\n    {separator = \", \", dataVar = \"data\"}: ErrorsTextOptions = {} // optional options with properties `separator` and `dataVar`\n  ): string {\n    if (!errors || errors.length === 0) return \"No errors\"\n    return errors\n      .map((e) => `${dataVar}${e.instancePath} ${e.message}`)\n      .reduce((text, msg) => text + separator + msg)\n  }\n\n  $dataMetaSchema(metaSchema: AnySchemaObject, keywordsJsonPointers: string[]): AnySchemaObject {\n    const rules = this.RULES.all\n    metaSchema = JSON.parse(JSON.stringify(metaSchema))\n    for (const jsonPointer of keywordsJsonPointers) {\n      const segments = jsonPointer.split(\"/\").slice(1) // first segment is an empty string\n      let keywords = metaSchema\n      for (const seg of segments) keywords = keywords[seg] as AnySchemaObject\n\n      for (const key in rules) {\n        const rule = rules[key]\n        if (typeof rule != \"object\") continue\n        const {$data} = rule.definition\n        const schema = keywords[key] as AnySchemaObject | undefined\n        if ($data && schema) keywords[key] = schemaOrData(schema)\n      }\n    }\n\n    return metaSchema\n  }\n\n  private _removeAllSchemas(schemas: {[Ref in string]?: SchemaEnv | string}, regex?: RegExp): void {\n    for (const keyRef in schemas) {\n      const sch = schemas[keyRef]\n      if (!regex || regex.test(keyRef)) {\n        if (typeof sch == \"string\") {\n          delete schemas[keyRef]\n        } else if (sch && !sch.meta) {\n          this._cache.delete(sch.schema)\n          delete schemas[keyRef]\n        }\n      }\n    }\n  }\n\n  _addSchema(\n    schema: AnySchema,\n    meta?: boolean,\n    baseId?: string,\n    validateSchema = this.opts.validateSchema,\n    addSchema = this.opts.addUsedSchema\n  ): SchemaEnv {\n    let id: string | undefined\n    const {schemaId} = this.opts\n    if (typeof schema == \"object\") {\n      id = schema[schemaId]\n    } else {\n      if (this.opts.jtd) throw new Error(\"schema must be object\")\n      else if (typeof schema != \"boolean\") throw new Error(\"schema must be object or boolean\")\n    }\n    let sch = this._cache.get(schema)\n    if (sch !== undefined) return sch\n\n    baseId = normalizeId(id || baseId)\n    const localRefs = getSchemaRefs.call(this, schema, baseId)\n    sch = new SchemaEnv({schema, schemaId, meta, baseId, localRefs})\n    this._cache.set(sch.schema, sch)\n    if (addSchema && !baseId.startsWith(\"#\")) {\n      // TODO atm it is allowed to overwrite schemas without id (instead of not adding them)\n      if (baseId) this._checkUnique(baseId)\n      this.refs[baseId] = sch\n    }\n    if (validateSchema) this.validateSchema(schema, true)\n    return sch\n  }\n\n  private _checkUnique(id: string): void {\n    if (this.schemas[id] || this.refs[id]) {\n      throw new Error(`schema with key or id \"${id}\" already exists`)\n    }\n  }\n\n  private _compileSchemaEnv(sch: SchemaEnv): AnyValidateFunction {\n    if (sch.meta) this._compileMetaSchema(sch)\n    else compileSchema.call(this, sch)\n\n    /* istanbul ignore if */\n    if (!sch.validate) throw new Error(\"ajv implementation error\")\n    return sch.validate\n  }\n\n  private _compileMetaSchema(sch: SchemaEnv): void {\n    const currentOpts = this.opts\n    this.opts = this._metaOpts\n    try {\n      compileSchema.call(this, sch)\n    } finally {\n      this.opts = currentOpts\n    }\n  }\n}\n\nexport interface ErrorsTextOptions {\n  separator?: string\n  dataVar?: string\n}\n\nfunction checkOptions(\n  this: Ajv,\n  checkOpts: OptionsInfo<RemovedOptions | DeprecatedOptions>,\n  options: Options & RemovedOptions,\n  msg: string,\n  log: \"warn\" | \"error\" = \"error\"\n): void {\n  for (const key in checkOpts) {\n    const opt = key as keyof typeof checkOpts\n    if (opt in options) this.logger[log](`${msg}: option ${key}. ${checkOpts[opt]}`)\n  }\n}\n\nfunction getSchEnv(this: Ajv, keyRef: string): SchemaEnv | string | undefined {\n  keyRef = normalizeId(keyRef) // TODO tests fail without this line\n  return this.schemas[keyRef] || this.refs[keyRef]\n}\n\nfunction addInitialSchemas(this: Ajv): void {\n  const optsSchemas = this.opts.schemas\n  if (!optsSchemas) return\n  if (Array.isArray(optsSchemas)) this.addSchema(optsSchemas)\n  else for (const key in optsSchemas) this.addSchema(optsSchemas[key] as AnySchema, key)\n}\n\nfunction addInitialFormats(this: Ajv): void {\n  for (const name in this.opts.formats) {\n    const format = this.opts.formats[name]\n    if (format) this.addFormat(name, format)\n  }\n}\n\nfunction addInitialKeywords(\n  this: Ajv,\n  defs: Vocabulary | {[K in string]?: KeywordDefinition}\n): void {\n  if (Array.isArray(defs)) {\n    this.addVocabulary(defs)\n    return\n  }\n  this.logger.warn(\"keywords option as map is deprecated, pass array\")\n  for (const keyword in defs) {\n    const def = defs[keyword] as KeywordDefinition\n    if (!def.keyword) def.keyword = keyword\n    this.addKeyword(def)\n  }\n}\n\nfunction getMetaSchemaOptions(this: Ajv): InstanceOptions {\n  const metaOpts = {...this.opts}\n  for (const opt of META_IGNORE_OPTIONS) delete metaOpts[opt]\n  return metaOpts\n}\n\nconst noLogs = {log() {}, warn() {}, error() {}}\n\nfunction getLogger(logger?: Partial<Logger> | false): Logger {\n  if (logger === false) return noLogs\n  if (logger === undefined) return console\n  if (logger.log && logger.warn && logger.error) return logger as Logger\n  throw new Error(\"logger must implement log, warn and error methods\")\n}\n\nconst KEYWORD_NAME = /^[a-z_$][a-z0-9_$:-]*$/i\n\nfunction checkKeyword(this: Ajv, keyword: string | string[], def?: KeywordDefinition): void {\n  const {RULES} = this\n  eachItem(keyword, (kwd) => {\n    if (RULES.keywords[kwd]) throw new Error(`Keyword ${kwd} is already defined`)\n    if (!KEYWORD_NAME.test(kwd)) throw new Error(`Keyword ${kwd} has invalid name`)\n  })\n  if (!def) return\n  if (def.$data && !(\"code\" in def || \"validate\" in def)) {\n    throw new Error('$data keyword must have \"code\" or \"validate\" function')\n  }\n}\n\nfunction addRule(\n  this: Ajv,\n  keyword: string,\n  definition?: AddedKeywordDefinition,\n  dataType?: JSONType\n): void {\n  const post = definition?.post\n  if (dataType && post) throw new Error('keyword with \"post\" flag cannot have \"type\"')\n  const {RULES} = this\n  let ruleGroup = post ? RULES.post : RULES.rules.find(({type: t}) => t === dataType)\n  if (!ruleGroup) {\n    ruleGroup = {type: dataType, rules: []}\n    RULES.rules.push(ruleGroup)\n  }\n  RULES.keywords[keyword] = true\n  if (!definition) return\n\n  const rule: Rule = {\n    keyword,\n    definition: {\n      ...definition,\n      type: getJSONTypes(definition.type),\n      schemaType: getJSONTypes(definition.schemaType),\n    },\n  }\n  if (definition.before) addBeforeRule.call(this, ruleGroup, rule, definition.before)\n  else ruleGroup.rules.push(rule)\n  RULES.all[keyword] = rule\n  definition.implements?.forEach((kwd) => this.addKeyword(kwd))\n}\n\nfunction addBeforeRule(this: Ajv, ruleGroup: RuleGroup, rule: Rule, before: string): void {\n  const i = ruleGroup.rules.findIndex((_rule) => _rule.keyword === before)\n  if (i >= 0) {\n    ruleGroup.rules.splice(i, 0, rule)\n  } else {\n    ruleGroup.rules.push(rule)\n    this.logger.warn(`rule ${before} is not defined`)\n  }\n}\n\nfunction keywordMetaschema(this: Ajv, def: KeywordDefinition): void {\n  let {metaSchema} = def\n  if (metaSchema === undefined) return\n  if (def.$data && this.opts.$data) metaSchema = schemaOrData(metaSchema)\n  def.validateSchema = this.compile(metaSchema, true)\n}\n\nconst $dataRef = {\n  $ref: \"https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#\",\n}\n\nfunction schemaOrData(schema: AnySchema): AnySchemaObject {\n  return {anyOf: [schema, $dataRef]}\n}\n","import type {CodeKeywordDefinition} from \"../../types\"\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"id\",\n  code() {\n    throw new Error('NOT SUPPORTED: keyword \"id\", use \"$id\" for schema ID')\n  },\n}\n\nexport default def\n","import type {CodeKeywordDefinition, AnySchema} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport MissingRefError from \"../../compile/ref_error\"\nimport {callValidateCode} from \"../code\"\nimport {_, nil, stringify, Code, Name} from \"../../compile/codegen\"\nimport N from \"../../compile/names\"\nimport {SchemaEnv, resolveRef} from \"../../compile\"\nimport {mergeEvaluated} from \"../../compile/util\"\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"$ref\",\n  schemaType: \"string\",\n  code(cxt: KeywordCxt): void {\n    const {gen, schema: $ref, it} = cxt\n    const {baseId, schemaEnv: env, validateName, opts, self} = it\n    const {root} = env\n    if (($ref === \"#\" || $ref === \"#/\") && baseId === root.baseId) return callRootRef()\n    const schOrEnv = resolveRef.call(self, root, baseId, $ref)\n    if (schOrEnv === undefined) throw new MissingRefError(it.opts.uriResolver, baseId, $ref)\n    if (schOrEnv instanceof SchemaEnv) return callValidate(schOrEnv)\n    return inlineRefSchema(schOrEnv)\n\n    function callRootRef(): void {\n      if (env === root) return callRef(cxt, validateName, env, env.$async)\n      const rootName = gen.scopeValue(\"root\", {ref: root})\n      return callRef(cxt, _`${rootName}.validate`, root, root.$async)\n    }\n\n    function callValidate(sch: SchemaEnv): void {\n      const v = getValidate(cxt, sch)\n      callRef(cxt, v, sch, sch.$async)\n    }\n\n    function inlineRefSchema(sch: AnySchema): void {\n      const schName = gen.scopeValue(\n        \"schema\",\n        opts.code.source === true ? {ref: sch, code: stringify(sch)} : {ref: sch}\n      )\n      const valid = gen.name(\"valid\")\n      const schCxt = cxt.subschema(\n        {\n          schema: sch,\n          dataTypes: [],\n          schemaPath: nil,\n          topSchemaRef: schName,\n          errSchemaPath: $ref,\n        },\n        valid\n      )\n      cxt.mergeEvaluated(schCxt)\n      cxt.ok(valid)\n    }\n  },\n}\n\nexport function getValidate(cxt: KeywordCxt, sch: SchemaEnv): Code {\n  const {gen} = cxt\n  return sch.validate\n    ? gen.scopeValue(\"validate\", {ref: sch.validate})\n    : _`${gen.scopeValue(\"wrapper\", {ref: sch})}.validate`\n}\n\nexport function callRef(cxt: KeywordCxt, v: Code, sch?: SchemaEnv, $async?: boolean): void {\n  const {gen, it} = cxt\n  const {allErrors, schemaEnv: env, opts} = it\n  const passCxt = opts.passContext ? N.this : nil\n  if ($async) callAsyncRef()\n  else callSyncRef()\n\n  function callAsyncRef(): void {\n    if (!env.$async) throw new Error(\"async schema referenced by sync schema\")\n    const valid = gen.let(\"valid\")\n    gen.try(\n      () => {\n        gen.code(_`await ${callValidateCode(cxt, v, passCxt)}`)\n        addEvaluatedFrom(v) // TODO will not work with async, it has to be returned with the result\n        if (!allErrors) gen.assign(valid, true)\n      },\n      (e) => {\n        gen.if(_`!(${e} instanceof ${it.ValidationError as Name})`, () => gen.throw(e))\n        addErrorsFrom(e)\n        if (!allErrors) gen.assign(valid, false)\n      }\n    )\n    cxt.ok(valid)\n  }\n\n  function callSyncRef(): void {\n    cxt.result(\n      callValidateCode(cxt, v, passCxt),\n      () => addEvaluatedFrom(v),\n      () => addErrorsFrom(v)\n    )\n  }\n\n  function addErrorsFrom(source: Code): void {\n    const errs = _`${source}.errors`\n    gen.assign(N.vErrors, _`${N.vErrors} === null ? ${errs} : ${N.vErrors}.concat(${errs})`) // TODO tagged\n    gen.assign(N.errors, _`${N.vErrors}.length`)\n  }\n\n  function addEvaluatedFrom(source: Code): void {\n    if (!it.opts.unevaluated) return\n    const schEvaluated = sch?.validate?.evaluated\n    // TODO refactor\n    if (it.props !== true) {\n      if (schEvaluated && !schEvaluated.dynamicProps) {\n        if (schEvaluated.props !== undefined) {\n          it.props = mergeEvaluated.props(gen, schEvaluated.props, it.props)\n        }\n      } else {\n        const props = gen.var(\"props\", _`${source}.evaluated.props`)\n        it.props = mergeEvaluated.props(gen, props, it.props, Name)\n      }\n    }\n    if (it.items !== true) {\n      if (schEvaluated && !schEvaluated.dynamicItems) {\n        if (schEvaluated.items !== undefined) {\n          it.items = mergeEvaluated.items(gen, schEvaluated.items, it.items)\n        }\n      } else {\n        const items = gen.var(\"items\", _`${source}.evaluated.items`)\n        it.items = mergeEvaluated.items(gen, items, it.items, Name)\n      }\n    }\n  }\n}\n\nexport default def\n","import type {Vocabulary} from \"../../types\"\nimport idKeyword from \"./id\"\nimport refKeyword from \"./ref\"\n\nconst core: Vocabulary = [\n  \"$schema\",\n  \"$id\",\n  \"$defs\",\n  \"$vocabulary\",\n  {keyword: \"$comment\"},\n  \"definitions\",\n  idKeyword,\n  refKeyword,\n]\n\nexport default core\n","import type {CodeKeywordDefinition, ErrorObject, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str, operators, Code} from \"../../compile/codegen\"\n\nconst ops = operators\n\ntype Kwd = \"maximum\" | \"minimum\" | \"exclusiveMaximum\" | \"exclusiveMinimum\"\n\ntype Comparison = \"<=\" | \">=\" | \"<\" | \">\"\n\nconst KWDs: {[K in Kwd]: {okStr: Comparison; ok: Code; fail: Code}} = {\n  maximum: {okStr: \"<=\", ok: ops.LTE, fail: ops.GT},\n  minimum: {okStr: \">=\", ok: ops.GTE, fail: ops.LT},\n  exclusiveMaximum: {okStr: \"<\", ok: ops.LT, fail: ops.GTE},\n  exclusiveMinimum: {okStr: \">\", ok: ops.GT, fail: ops.LTE},\n}\n\nexport type LimitNumberError = ErrorObject<\n  Kwd,\n  {limit: number; comparison: Comparison},\n  number | {$data: string}\n>\n\nconst error: KeywordErrorDefinition = {\n  message: ({keyword, schemaCode}) => str`must be ${KWDs[keyword as Kwd].okStr} ${schemaCode}`,\n  params: ({keyword, schemaCode}) =>\n    _`{comparison: ${KWDs[keyword as Kwd].okStr}, limit: ${schemaCode}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: Object.keys(KWDs),\n  type: \"number\",\n  schemaType: \"number\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {keyword, data, schemaCode} = cxt\n    cxt.fail$data(_`${data} ${KWDs[keyword as Kwd].fail} ${schemaCode} || isNaN(${data})`)\n  },\n}\n\nexport default def\n","import type {CodeKeywordDefinition, ErrorObject, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str} from \"../../compile/codegen\"\n\nexport type MultipleOfError = ErrorObject<\n  \"multipleOf\",\n  {multipleOf: number},\n  number | {$data: string}\n>\n\nconst error: KeywordErrorDefinition = {\n  message: ({schemaCode}) => str`must be multiple of ${schemaCode}`,\n  params: ({schemaCode}) => _`{multipleOf: ${schemaCode}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"multipleOf\",\n  type: \"number\",\n  schemaType: \"number\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {gen, data, schemaCode, it} = cxt\n    // const bdt = bad$DataType(schemaCode, <string>def.schemaType, $data)\n    const prec = it.opts.multipleOfPrecision\n    const res = gen.let(\"res\")\n    const invalid = prec\n      ? _`Math.abs(Math.round(${res}) - ${res}) > 1e-${prec}`\n      : _`${res} !== parseInt(${res})`\n    cxt.fail$data(_`(${schemaCode} === 0 || (${res} = ${data}/${schemaCode}, ${invalid}))`)\n  },\n}\n\nexport default def\n","// https://mathiasbynens.be/notes/javascript-encoding\n// https://github.com/bestiejs/punycode.js - punycode.ucs2.decode\nexport default function ucs2length(str: string): number {\n  const len = str.length\n  let length = 0\n  let pos = 0\n  let value: number\n  while (pos < len) {\n    length++\n    value = str.charCodeAt(pos++)\n    if (value >= 0xd800 && value <= 0xdbff && pos < len) {\n      // high surrogate, and there is a next character\n      value = str.charCodeAt(pos)\n      if ((value & 0xfc00) === 0xdc00) pos++ // low surrogate\n    }\n  }\n  return length\n}\n\nucs2length.code = 'require(\"ajv/dist/runtime/ucs2length\").default'\n","import type {CodeKeywordDefinition, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str, operators} from \"../../compile/codegen\"\nimport {useFunc} from \"../../compile/util\"\nimport ucs2length from \"../../runtime/ucs2length\"\n\nconst error: KeywordErrorDefinition = {\n  message({keyword, schemaCode}) {\n    const comp = keyword === \"maxLength\" ? \"more\" : \"fewer\"\n    return str`must NOT have ${comp} than ${schemaCode} characters`\n  },\n  params: ({schemaCode}) => _`{limit: ${schemaCode}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: [\"maxLength\", \"minLength\"],\n  type: \"string\",\n  schemaType: \"number\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {keyword, data, schemaCode, it} = cxt\n    const op = keyword === \"maxLength\" ? operators.GT : operators.LT\n    const len =\n      it.opts.unicode === false ? _`${data}.length` : _`${useFunc(cxt.gen, ucs2length)}(${data})`\n    cxt.fail$data(_`${len} ${op} ${schemaCode}`)\n  },\n}\n\nexport default def\n","import type {CodeKeywordDefinition, ErrorObject, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {usePattern} from \"../code\"\nimport {_, str} from \"../../compile/codegen\"\n\nexport type PatternError = ErrorObject<\"pattern\", {pattern: string}, string | {$data: string}>\n\nconst error: KeywordErrorDefinition = {\n  message: ({schemaCode}) => str`must match pattern \"${schemaCode}\"`,\n  params: ({schemaCode}) => _`{pattern: ${schemaCode}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"pattern\",\n  type: \"string\",\n  schemaType: \"string\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {data, $data, schema, schemaCode, it} = cxt\n    // TODO regexp should be wrapped in try/catchs\n    const u = it.opts.unicodeRegExp ? \"u\" : \"\"\n    const regExp = $data ? _`(new RegExp(${schemaCode}, ${u}))` : usePattern(cxt, schema)\n    cxt.fail$data(_`!${regExp}.test(${data})`)\n  },\n}\n\nexport default def\n","import type {CodeKeywordDefinition, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str, operators} from \"../../compile/codegen\"\n\nconst error: KeywordErrorDefinition = {\n  message({keyword, schemaCode}) {\n    const comp = keyword === \"maxProperties\" ? \"more\" : \"fewer\"\n    return str`must NOT have ${comp} than ${schemaCode} properties`\n  },\n  params: ({schemaCode}) => _`{limit: ${schemaCode}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: [\"maxProperties\", \"minProperties\"],\n  type: \"object\",\n  schemaType: \"number\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {keyword, data, schemaCode} = cxt\n    const op = keyword === \"maxProperties\" ? operators.GT : operators.LT\n    cxt.fail$data(_`Object.keys(${data}).length ${op} ${schemaCode}`)\n  },\n}\n\nexport default def\n","import type {CodeKeywordDefinition, ErrorObject, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {\n  checkReportMissingProp,\n  checkMissingProp,\n  reportMissingProp,\n  propertyInData,\n  noPropertyInData,\n} from \"../code\"\nimport {_, str, nil, not, Name, Code} from \"../../compile/codegen\"\nimport {checkStrictMode} from \"../../compile/util\"\n\nexport type RequiredError = ErrorObject<\n  \"required\",\n  {missingProperty: string},\n  string[] | {$data: string}\n>\n\nconst error: KeywordErrorDefinition = {\n  message: ({params: {missingProperty}}) => str`must have required property '${missingProperty}'`,\n  params: ({params: {missingProperty}}) => _`{missingProperty: ${missingProperty}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"required\",\n  type: \"object\",\n  schemaType: \"array\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {gen, schema, schemaCode, data, $data, it} = cxt\n    const {opts} = it\n    if (!$data && schema.length === 0) return\n    const useLoop = schema.length >= opts.loopRequired\n    if (it.allErrors) allErrorsMode()\n    else exitOnErrorMode()\n\n    if (opts.strictRequired) {\n      const props = cxt.parentSchema.properties\n      const {definedProperties} = cxt.it\n      for (const requiredKey of schema) {\n        if (props?.[requiredKey] === undefined && !definedProperties.has(requiredKey)) {\n          const schemaPath = it.schemaEnv.baseId + it.errSchemaPath\n          const msg = `required property \"${requiredKey}\" is not defined at \"${schemaPath}\" (strictRequired)`\n          checkStrictMode(it, msg, it.opts.strictRequired)\n        }\n      }\n    }\n\n    function allErrorsMode(): void {\n      if (useLoop || $data) {\n        cxt.block$data(nil, loopAllRequired)\n      } else {\n        for (const prop of schema) {\n          checkReportMissingProp(cxt, prop)\n        }\n      }\n    }\n\n    function exitOnErrorMode(): void {\n      const missing = gen.let(\"missing\")\n      if (useLoop || $data) {\n        const valid = gen.let(\"valid\", true)\n        cxt.block$data(valid, () => loopUntilMissing(missing, valid))\n        cxt.ok(valid)\n      } else {\n        gen.if(checkMissingProp(cxt, schema, missing))\n        reportMissingProp(cxt, missing)\n        gen.else()\n      }\n    }\n\n    function loopAllRequired(): void {\n      gen.forOf(\"prop\", schemaCode as Code, (prop) => {\n        cxt.setParams({missingProperty: prop})\n        gen.if(noPropertyInData(gen, data, prop, opts.ownProperties), () => cxt.error())\n      })\n    }\n\n    function loopUntilMissing(missing: Name, valid: Name): void {\n      cxt.setParams({missingProperty: missing})\n      gen.forOf(\n        missing,\n        schemaCode as Code,\n        () => {\n          gen.assign(valid, propertyInData(gen, data, missing, opts.ownProperties))\n          gen.if(not(valid), () => {\n            cxt.error()\n            gen.break()\n          })\n        },\n        nil\n      )\n    }\n  },\n}\n\nexport default def\n","import type {CodeKeywordDefinition, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str, operators} from \"../../compile/codegen\"\n\nconst error: KeywordErrorDefinition = {\n  message({keyword, schemaCode}) {\n    const comp = keyword === \"maxItems\" ? \"more\" : \"fewer\"\n    return str`must NOT have ${comp} than ${schemaCode} items`\n  },\n  params: ({schemaCode}) => _`{limit: ${schemaCode}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: [\"maxItems\", \"minItems\"],\n  type: \"array\",\n  schemaType: \"number\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {keyword, data, schemaCode} = cxt\n    const op = keyword === \"maxItems\" ? operators.GT : operators.LT\n    cxt.fail$data(_`${data}.length ${op} ${schemaCode}`)\n  },\n}\n\nexport default def\n","// https://github.com/ajv-validator/ajv/issues/889\nimport * as equal from \"fast-deep-equal\"\n\ntype Equal = typeof equal & {code: string}\n;(equal as Equal).code = 'require(\"ajv/dist/runtime/equal\").default'\n\nexport default equal as Equal\n","import type {CodeKeywordDefinition, ErrorObject, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {checkDataTypes, getSchemaTypes, DataType} from \"../../compile/validate/dataType\"\nimport {_, str, Name} from \"../../compile/codegen\"\nimport {useFunc} from \"../../compile/util\"\nimport equal from \"../../runtime/equal\"\n\nexport type UniqueItemsError = ErrorObject<\n  \"uniqueItems\",\n  {i: number; j: number},\n  boolean | {$data: string}\n>\n\nconst error: KeywordErrorDefinition = {\n  message: ({params: {i, j}}) =>\n    str`must NOT have duplicate items (items ## ${j} and ${i} are identical)`,\n  params: ({params: {i, j}}) => _`{i: ${i}, j: ${j}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"uniqueItems\",\n  type: \"array\",\n  schemaType: \"boolean\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {gen, data, $data, schema, parentSchema, schemaCode, it} = cxt\n    if (!$data && !schema) return\n    const valid = gen.let(\"valid\")\n    const itemTypes = parentSchema.items ? getSchemaTypes(parentSchema.items) : []\n    cxt.block$data(valid, validateUniqueItems, _`${schemaCode} === false`)\n    cxt.ok(valid)\n\n    function validateUniqueItems(): void {\n      const i = gen.let(\"i\", _`${data}.length`)\n      const j = gen.let(\"j\")\n      cxt.setParams({i, j})\n      gen.assign(valid, true)\n      gen.if(_`${i} > 1`, () => (canOptimize() ? loopN : loopN2)(i, j))\n    }\n\n    function canOptimize(): boolean {\n      return itemTypes.length > 0 && !itemTypes.some((t) => t === \"object\" || t === \"array\")\n    }\n\n    function loopN(i: Name, j: Name): void {\n      const item = gen.name(\"item\")\n      const wrongType = checkDataTypes(itemTypes, item, it.opts.strictNumbers, DataType.Wrong)\n      const indices = gen.const(\"indices\", _`{}`)\n      gen.for(_`;${i}--;`, () => {\n        gen.let(item, _`${data}[${i}]`)\n        gen.if(wrongType, _`continue`)\n        if (itemTypes.length > 1) gen.if(_`typeof ${item} == \"string\"`, _`${item} += \"_\"`)\n        gen\n          .if(_`typeof ${indices}[${item}] == \"number\"`, () => {\n            gen.assign(j, _`${indices}[${item}]`)\n            cxt.error()\n            gen.assign(valid, false).break()\n          })\n          .code(_`${indices}[${item}] = ${i}`)\n      })\n    }\n\n    function loopN2(i: Name, j: Name): void {\n      const eql = useFunc(gen, equal)\n      const outer = gen.name(\"outer\")\n      gen.label(outer).for(_`;${i}--;`, () =>\n        gen.for(_`${j} = ${i}; ${j}--;`, () =>\n          gen.if(_`${eql}(${data}[${i}], ${data}[${j}])`, () => {\n            cxt.error()\n            gen.assign(valid, false).break(outer)\n          })\n        )\n      )\n    }\n  },\n}\n\nexport default def\n","import type {CodeKeywordDefinition, ErrorObject, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_} from \"../../compile/codegen\"\nimport {useFunc} from \"../../compile/util\"\nimport equal from \"../../runtime/equal\"\n\nexport type ConstError = ErrorObject<\"const\", {allowedValue: any}>\n\nconst error: KeywordErrorDefinition = {\n  message: \"must be equal to constant\",\n  params: ({schemaCode}) => _`{allowedValue: ${schemaCode}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"const\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {gen, data, $data, schemaCode, schema} = cxt\n    if ($data || (schema && typeof schema == \"object\")) {\n      cxt.fail$data(_`!${useFunc(gen, equal)}(${data}, ${schemaCode})`)\n    } else {\n      cxt.fail(_`${schema} !== ${data}`)\n    }\n  },\n}\n\nexport default def\n","import type {CodeKeywordDefinition, ErrorObject, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, or, Name, Code} from \"../../compile/codegen\"\nimport {useFunc} from \"../../compile/util\"\nimport equal from \"../../runtime/equal\"\n\nexport type EnumError = ErrorObject<\"enum\", {allowedValues: any[]}, any[] | {$data: string}>\n\nconst error: KeywordErrorDefinition = {\n  message: \"must be equal to one of the allowed values\",\n  params: ({schemaCode}) => _`{allowedValues: ${schemaCode}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"enum\",\n  schemaType: \"array\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {gen, data, $data, schema, schemaCode, it} = cxt\n    if (!$data && schema.length === 0) throw new Error(\"enum must have non-empty array\")\n    const useLoop = schema.length >= it.opts.loopEnum\n    let eql: Name | undefined\n    const getEql = (): Name => (eql ??= useFunc(gen, equal))\n\n    let valid: Code\n    if (useLoop || $data) {\n      valid = gen.let(\"valid\")\n      cxt.block$data(valid, loopEnum)\n    } else {\n      /* istanbul ignore if */\n      if (!Array.isArray(schema)) throw new Error(\"ajv implementation error\")\n      const vSchema = gen.const(\"vSchema\", schemaCode)\n      valid = or(...schema.map((_x: unknown, i: number) => equalCode(vSchema, i)))\n    }\n    cxt.pass(valid)\n\n    function loopEnum(): void {\n      gen.assign(valid, false)\n      gen.forOf(\"v\", schemaCode as Code, (v) =>\n        gen.if(_`${getEql()}(${data}, ${v})`, () => gen.assign(valid, true).break())\n      )\n    }\n\n    function equalCode(vSchema: Name, i: number): Code {\n      const sch = schema[i]\n      return typeof sch === \"object\" && sch !== null\n        ? _`${getEql()}(${data}, ${vSchema}[${i}])`\n        : _`${data} === ${sch}`\n    }\n  },\n}\n\nexport default def\n","import type {ErrorObject, Vocabulary} from \"../../types\"\nimport limitNumber, {LimitNumberError} from \"./limitNumber\"\nimport multipleOf, {MultipleOfError} from \"./multipleOf\"\nimport limitLength from \"./limitLength\"\nimport pattern, {PatternError} from \"./pattern\"\nimport limitProperties from \"./limitProperties\"\nimport required, {RequiredError} from \"./required\"\nimport limitItems from \"./limitItems\"\nimport uniqueItems, {UniqueItemsError} from \"./uniqueItems\"\nimport constKeyword, {ConstError} from \"./const\"\nimport enumKeyword, {EnumError} from \"./enum\"\n\nconst validation: Vocabulary = [\n  // number\n  limitNumber,\n  multipleOf,\n  // string\n  limitLength,\n  pattern,\n  // object\n  limitProperties,\n  required,\n  // array\n  limitItems,\n  uniqueItems,\n  // any\n  {keyword: \"type\", schemaType: [\"string\", \"array\"]},\n  {keyword: \"nullable\", schemaType: \"boolean\"},\n  constKeyword,\n  enumKeyword,\n]\n\nexport default validation\n\ntype LimitError = ErrorObject<\n  \"maxItems\" | \"minItems\" | \"minProperties\" | \"maxProperties\" | \"minLength\" | \"maxLength\",\n  {limit: number},\n  number | {$data: string}\n>\n\nexport type ValidationKeywordError =\n  | LimitError\n  | LimitNumberError\n  | MultipleOfError\n  | PatternError\n  | RequiredError\n  | UniqueItemsError\n  | ConstError\n  | EnumError\n","import type {\n  CodeKeywordDefinition,\n  ErrorObject,\n  KeywordErrorDefinition,\n  AnySchema,\n} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str, not, Name} from \"../../compile/codegen\"\nimport {alwaysValidSchema, checkStrictMode, Type} from \"../../compile/util\"\n\nexport type AdditionalItemsError = ErrorObject<\"additionalItems\", {limit: number}, AnySchema>\n\nconst error: KeywordErrorDefinition = {\n  message: ({params: {len}}) => str`must NOT have more than ${len} items`,\n  params: ({params: {len}}) => _`{limit: ${len}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"additionalItems\" as const,\n  type: \"array\",\n  schemaType: [\"boolean\", \"object\"],\n  before: \"uniqueItems\",\n  error,\n  code(cxt: KeywordCxt) {\n    const {parentSchema, it} = cxt\n    const {items} = parentSchema\n    if (!Array.isArray(items)) {\n      checkStrictMode(it, '\"additionalItems\" is ignored when \"items\" is not an array of schemas')\n      return\n    }\n    validateAdditionalItems(cxt, items)\n  },\n}\n\nexport function validateAdditionalItems(cxt: KeywordCxt, items: AnySchema[]): void {\n  const {gen, schema, data, keyword, it} = cxt\n  it.items = true\n  const len = gen.const(\"len\", _`${data}.length`)\n  if (schema === false) {\n    cxt.setParams({len: items.length})\n    cxt.pass(_`${len} <= ${items.length}`)\n  } else if (typeof schema == \"object\" && !alwaysValidSchema(it, schema)) {\n    const valid = gen.var(\"valid\", _`${len} <= ${items.length}`) // TODO var\n    gen.if(not(valid), () => validateItems(valid))\n    cxt.ok(valid)\n  }\n\n  function validateItems(valid: Name): void {\n    gen.forRange(\"i\", items.length, len, (i) => {\n      cxt.subschema({keyword, dataProp: i, dataPropType: Type.Num}, valid)\n      if (!it.allErrors) gen.if(not(valid), () => gen.break())\n    })\n  }\n}\n\nexport default def\n","import type {CodeKeywordDefinition, AnySchema, AnySchemaObject} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_} from \"../../compile/codegen\"\nimport {alwaysValidSchema, mergeEvaluated, checkStrictMode} from \"../../compile/util\"\nimport {validateArray} from \"../code\"\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"items\",\n  type: \"array\",\n  schemaType: [\"object\", \"array\", \"boolean\"],\n  before: \"uniqueItems\",\n  code(cxt: KeywordCxt) {\n    const {schema, it} = cxt\n    if (Array.isArray(schema)) return validateTuple(cxt, \"additionalItems\", schema)\n    it.items = true\n    if (alwaysValidSchema(it, schema)) return\n    cxt.ok(validateArray(cxt))\n  },\n}\n\nexport function validateTuple(\n  cxt: KeywordCxt,\n  extraItems: string,\n  schArr: AnySchema[] = cxt.schema\n): void {\n  const {gen, parentSchema, data, keyword, it} = cxt\n  checkStrictTuple(parentSchema)\n  if (it.opts.unevaluated && schArr.length && it.items !== true) {\n    it.items = mergeEvaluated.items(gen, schArr.length, it.items)\n  }\n  const valid = gen.name(\"valid\")\n  const len = gen.const(\"len\", _`${data}.length`)\n  schArr.forEach((sch: AnySchema, i: number) => {\n    if (alwaysValidSchema(it, sch)) return\n    gen.if(_`${len} > ${i}`, () =>\n      cxt.subschema(\n        {\n          keyword,\n          schemaProp: i,\n          dataProp: i,\n        },\n        valid\n      )\n    )\n    cxt.ok(valid)\n  })\n\n  function checkStrictTuple(sch: AnySchemaObject): void {\n    const {opts, errSchemaPath} = it\n    const l = schArr.length\n    const fullTuple = l === sch.minItems && (l === sch.maxItems || sch[extraItems] === false)\n    if (opts.strictTuples && !fullTuple) {\n      const msg = `\"${keyword}\" is ${l}-tuple, but minItems or maxItems/${extraItems} are not specified or different at path \"${errSchemaPath}\"`\n      checkStrictMode(it, msg, opts.strictTuples)\n    }\n  }\n}\n\nexport default def\n","import type {CodeKeywordDefinition} from \"../../types\"\nimport {validateTuple} from \"./items\"\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"prefixItems\",\n  type: \"array\",\n  schemaType: [\"array\"],\n  before: \"uniqueItems\",\n  code: (cxt) => validateTuple(cxt, \"items\"),\n}\n\nexport default def\n","import type {\n  CodeKeywordDefinition,\n  KeywordErrorDefinition,\n  ErrorObject,\n  AnySchema,\n} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str} from \"../../compile/codegen\"\nimport {alwaysValidSchema} from \"../../compile/util\"\nimport {validateArray} from \"../code\"\nimport {validateAdditionalItems} from \"./additionalItems\"\n\nexport type ItemsError = ErrorObject<\"items\", {limit: number}, AnySchema>\n\nconst error: KeywordErrorDefinition = {\n  message: ({params: {len}}) => str`must NOT have more than ${len} items`,\n  params: ({params: {len}}) => _`{limit: ${len}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"items\",\n  type: \"array\",\n  schemaType: [\"object\", \"boolean\"],\n  before: \"uniqueItems\",\n  error,\n  code(cxt: KeywordCxt) {\n    const {schema, parentSchema, it} = cxt\n    const {prefixItems} = parentSchema\n    it.items = true\n    if (alwaysValidSchema(it, schema)) return\n    if (prefixItems) validateAdditionalItems(cxt, prefixItems)\n    else cxt.ok(validateArray(cxt))\n  },\n}\n\nexport default def\n","import type {\n  CodeKeywordDefinition,\n  KeywordErrorDefinition,\n  ErrorObject,\n  AnySchema,\n} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str, Name} from \"../../compile/codegen\"\nimport {alwaysValidSchema, checkStrictMode, Type} from \"../../compile/util\"\n\nexport type ContainsError = ErrorObject<\n  \"contains\",\n  {minContains: number; maxContains?: number},\n  AnySchema\n>\n\nconst error: KeywordErrorDefinition = {\n  message: ({params: {min, max}}) =>\n    max === undefined\n      ? str`must contain at least ${min} valid item(s)`\n      : str`must contain at least ${min} and no more than ${max} valid item(s)`,\n  params: ({params: {min, max}}) =>\n    max === undefined ? _`{minContains: ${min}}` : _`{minContains: ${min}, maxContains: ${max}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"contains\",\n  type: \"array\",\n  schemaType: [\"object\", \"boolean\"],\n  before: \"uniqueItems\",\n  trackErrors: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {gen, schema, parentSchema, data, it} = cxt\n    let min: number\n    let max: number | undefined\n    const {minContains, maxContains} = parentSchema\n    if (it.opts.next) {\n      min = minContains === undefined ? 1 : minContains\n      max = maxContains\n    } else {\n      min = 1\n    }\n    const len = gen.const(\"len\", _`${data}.length`)\n    cxt.setParams({min, max})\n    if (max === undefined && min === 0) {\n      checkStrictMode(it, `\"minContains\" == 0 without \"maxContains\": \"contains\" keyword ignored`)\n      return\n    }\n    if (max !== undefined && min > max) {\n      checkStrictMode(it, `\"minContains\" > \"maxContains\" is always invalid`)\n      cxt.fail()\n      return\n    }\n    if (alwaysValidSchema(it, schema)) {\n      let cond = _`${len} >= ${min}`\n      if (max !== undefined) cond = _`${cond} && ${len} <= ${max}`\n      cxt.pass(cond)\n      return\n    }\n\n    it.items = true\n    const valid = gen.name(\"valid\")\n    if (max === undefined && min === 1) {\n      validateItems(valid, () => gen.if(valid, () => gen.break()))\n    } else if (min === 0) {\n      gen.let(valid, true)\n      if (max !== undefined) gen.if(_`${data}.length > 0`, validateItemsWithCount)\n    } else {\n      gen.let(valid, false)\n      validateItemsWithCount()\n    }\n    cxt.result(valid, () => cxt.reset())\n\n    function validateItemsWithCount(): void {\n      const schValid = gen.name(\"_valid\")\n      const count = gen.let(\"count\", 0)\n      validateItems(schValid, () => gen.if(schValid, () => checkLimits(count)))\n    }\n\n    function validateItems(_valid: Name, block: () => void): void {\n      gen.forRange(\"i\", 0, len, (i) => {\n        cxt.subschema(\n          {\n            keyword: \"contains\",\n            dataProp: i,\n            dataPropType: Type.Num,\n            compositeRule: true,\n          },\n          _valid\n        )\n        block()\n      })\n    }\n\n    function checkLimits(count: Name): void {\n      gen.code(_`${count}++`)\n      if (max === undefined) {\n        gen.if(_`${count} >= ${min}`, () => gen.assign(valid, true).break())\n      } else {\n        gen.if(_`${count} > ${max}`, () => gen.assign(valid, false).break())\n        if (min === 1) gen.assign(valid, true)\n        else gen.if(_`${count} >= ${min}`, () => gen.assign(valid, true))\n      }\n    }\n  },\n}\n\nexport default def\n","import type {\n  CodeKeywordDefinition,\n  ErrorObject,\n  KeywordErrorDefinition,\n  SchemaMap,\n  AnySchema,\n} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str} from \"../../compile/codegen\"\nimport {alwaysValidSchema} from \"../../compile/util\"\nimport {checkReportMissingProp, checkMissingProp, reportMissingProp, propertyInData} from \"../code\"\n\nexport type PropertyDependencies = {[K in string]?: string[]}\n\nexport interface DependenciesErrorParams {\n  property: string\n  missingProperty: string\n  depsCount: number\n  deps: string // TODO change to string[]\n}\n\ntype SchemaDependencies = SchemaMap\n\nexport type DependenciesError = ErrorObject<\n  \"dependencies\",\n  DependenciesErrorParams,\n  {[K in string]?: string[] | AnySchema}\n>\n\nexport const error: KeywordErrorDefinition = {\n  message: ({params: {property, depsCount, deps}}) => {\n    const property_ies = depsCount === 1 ? \"property\" : \"properties\"\n    return str`must have ${property_ies} ${deps} when property ${property} is present`\n  },\n  params: ({params: {property, depsCount, deps, missingProperty}}) =>\n    _`{property: ${property},\n    missingProperty: ${missingProperty},\n    depsCount: ${depsCount},\n    deps: ${deps}}`, // TODO change to reference\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"dependencies\",\n  type: \"object\",\n  schemaType: \"object\",\n  error,\n  code(cxt: KeywordCxt) {\n    const [propDeps, schDeps] = splitDependencies(cxt)\n    validatePropertyDeps(cxt, propDeps)\n    validateSchemaDeps(cxt, schDeps)\n  },\n}\n\nfunction splitDependencies({schema}: KeywordCxt): [PropertyDependencies, SchemaDependencies] {\n  const propertyDeps: PropertyDependencies = {}\n  const schemaDeps: SchemaDependencies = {}\n  for (const key in schema) {\n    if (key === \"__proto__\") continue\n    const deps = Array.isArray(schema[key]) ? propertyDeps : schemaDeps\n    deps[key] = schema[key]\n  }\n  return [propertyDeps, schemaDeps]\n}\n\nexport function validatePropertyDeps(\n  cxt: KeywordCxt,\n  propertyDeps: {[K in string]?: string[]} = cxt.schema\n): void {\n  const {gen, data, it} = cxt\n  if (Object.keys(propertyDeps).length === 0) return\n  const missing = gen.let(\"missing\")\n  for (const prop in propertyDeps) {\n    const deps = propertyDeps[prop] as string[]\n    if (deps.length === 0) continue\n    const hasProperty = propertyInData(gen, data, prop, it.opts.ownProperties)\n    cxt.setParams({\n      property: prop,\n      depsCount: deps.length,\n      deps: deps.join(\", \"),\n    })\n    if (it.allErrors) {\n      gen.if(hasProperty, () => {\n        for (const depProp of deps) {\n          checkReportMissingProp(cxt, depProp)\n        }\n      })\n    } else {\n      gen.if(_`${hasProperty} && (${checkMissingProp(cxt, deps, missing)})`)\n      reportMissingProp(cxt, missing)\n      gen.else()\n    }\n  }\n}\n\nexport function validateSchemaDeps(cxt: KeywordCxt, schemaDeps: SchemaMap = cxt.schema): void {\n  const {gen, data, keyword, it} = cxt\n  const valid = gen.name(\"valid\")\n  for (const prop in schemaDeps) {\n    if (alwaysValidSchema(it, schemaDeps[prop] as AnySchema)) continue\n    gen.if(\n      propertyInData(gen, data, prop, it.opts.ownProperties),\n      () => {\n        const schCxt = cxt.subschema({keyword, schemaProp: prop}, valid)\n        cxt.mergeValidEvaluated(schCxt, valid)\n      },\n      () => gen.var(valid, true) // TODO var\n    )\n    cxt.ok(valid)\n  }\n}\n\nexport default def\n","import type {\n  CodeKeywordDefinition,\n  ErrorObject,\n  KeywordErrorDefinition,\n  AnySchema,\n} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, not} from \"../../compile/codegen\"\nimport {alwaysValidSchema} from \"../../compile/util\"\n\nexport type PropertyNamesError = ErrorObject<\"propertyNames\", {propertyName: string}, AnySchema>\n\nconst error: KeywordErrorDefinition = {\n  message: \"property name must be valid\",\n  params: ({params}) => _`{propertyName: ${params.propertyName}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"propertyNames\",\n  type: \"object\",\n  schemaType: [\"object\", \"boolean\"],\n  error,\n  code(cxt: KeywordCxt) {\n    const {gen, schema, data, it} = cxt\n    if (alwaysValidSchema(it, schema)) return\n    const valid = gen.name(\"valid\")\n\n    gen.forIn(\"key\", data, (key) => {\n      cxt.setParams({propertyName: key})\n      cxt.subschema(\n        {\n          keyword: \"propertyNames\",\n          data: key,\n          dataTypes: [\"string\"],\n          propertyName: key,\n          compositeRule: true,\n        },\n        valid\n      )\n      gen.if(not(valid), () => {\n        cxt.error(true)\n        if (!it.allErrors) gen.break()\n      })\n    })\n\n    cxt.ok(valid)\n  },\n}\n\nexport default def\n","import type {\n  CodeKeywordDefinition,\n  AddedKeywordDefinition,\n  ErrorObject,\n  KeywordErrorDefinition,\n  AnySchema,\n} from \"../../types\"\nimport {allSchemaProperties, usePattern, isOwnProperty} from \"../code\"\nimport {_, nil, or, not, Code, Name} from \"../../compile/codegen\"\nimport N from \"../../compile/names\"\nimport type {SubschemaArgs} from \"../../compile/validate/subschema\"\nimport {alwaysValidSchema, schemaRefOrVal, Type} from \"../../compile/util\"\n\nexport type AdditionalPropertiesError = ErrorObject<\n  \"additionalProperties\",\n  {additionalProperty: string},\n  AnySchema\n>\n\nconst error: KeywordErrorDefinition = {\n  message: \"must NOT have additional properties\",\n  params: ({params}) => _`{additionalProperty: ${params.additionalProperty}}`,\n}\n\nconst def: CodeKeywordDefinition & AddedKeywordDefinition = {\n  keyword: \"additionalProperties\",\n  type: [\"object\"],\n  schemaType: [\"boolean\", \"object\"],\n  allowUndefined: true,\n  trackErrors: true,\n  error,\n  code(cxt) {\n    const {gen, schema, parentSchema, data, errsCount, it} = cxt\n    /* istanbul ignore if */\n    if (!errsCount) throw new Error(\"ajv implementation error\")\n    const {allErrors, opts} = it\n    it.props = true\n    if (opts.removeAdditional !== \"all\" && alwaysValidSchema(it, schema)) return\n    const props = allSchemaProperties(parentSchema.properties)\n    const patProps = allSchemaProperties(parentSchema.patternProperties)\n    checkAdditionalProperties()\n    cxt.ok(_`${errsCount} === ${N.errors}`)\n\n    function checkAdditionalProperties(): void {\n      gen.forIn(\"key\", data, (key: Name) => {\n        if (!props.length && !patProps.length) additionalPropertyCode(key)\n        else gen.if(isAdditional(key), () => additionalPropertyCode(key))\n      })\n    }\n\n    function isAdditional(key: Name): Code {\n      let definedProp: Code\n      if (props.length > 8) {\n        // TODO maybe an option instead of hard-coded 8?\n        const propsSchema = schemaRefOrVal(it, parentSchema.properties, \"properties\")\n        definedProp = isOwnProperty(gen, propsSchema as Code, key)\n      } else if (props.length) {\n        definedProp = or(...props.map((p) => _`${key} === ${p}`))\n      } else {\n        definedProp = nil\n      }\n      if (patProps.length) {\n        definedProp = or(definedProp, ...patProps.map((p) => _`${usePattern(cxt, p)}.test(${key})`))\n      }\n      return not(definedProp)\n    }\n\n    function deleteAdditional(key: Name): void {\n      gen.code(_`delete ${data}[${key}]`)\n    }\n\n    function additionalPropertyCode(key: Name): void {\n      if (opts.removeAdditional === \"all\" || (opts.removeAdditional && schema === false)) {\n        deleteAdditional(key)\n        return\n      }\n\n      if (schema === false) {\n        cxt.setParams({additionalProperty: key})\n        cxt.error()\n        if (!allErrors) gen.break()\n        return\n      }\n\n      if (typeof schema == \"object\" && !alwaysValidSchema(it, schema)) {\n        const valid = gen.name(\"valid\")\n        if (opts.removeAdditional === \"failing\") {\n          applyAdditionalSchema(key, valid, false)\n          gen.if(not(valid), () => {\n            cxt.reset()\n            deleteAdditional(key)\n          })\n        } else {\n          applyAdditionalSchema(key, valid)\n          if (!allErrors) gen.if(not(valid), () => gen.break())\n        }\n      }\n    }\n\n    function applyAdditionalSchema(key: Name, valid: Name, errors?: false): void {\n      const subschema: SubschemaArgs = {\n        keyword: \"additionalProperties\",\n        dataProp: key,\n        dataPropType: Type.Str,\n      }\n      if (errors === false) {\n        Object.assign(subschema, {\n          compositeRule: true,\n          createErrors: false,\n          allErrors: false,\n        })\n      }\n      cxt.subschema(subschema, valid)\n    }\n  },\n}\n\nexport default def\n","import type {CodeKeywordDefinition} from \"../../types\"\nimport {KeywordCxt} from \"../../compile/validate\"\nimport {propertyInData, allSchemaProperties} from \"../code\"\nimport {alwaysValidSchema, toHash, mergeEvaluated} from \"../../compile/util\"\nimport apDef from \"./additionalProperties\"\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"properties\",\n  type: \"object\",\n  schemaType: \"object\",\n  code(cxt: KeywordCxt) {\n    const {gen, schema, parentSchema, data, it} = cxt\n    if (it.opts.removeAdditional === \"all\" && parentSchema.additionalProperties === undefined) {\n      apDef.code(new KeywordCxt(it, apDef, \"additionalProperties\"))\n    }\n    const allProps = allSchemaProperties(schema)\n    for (const prop of allProps) {\n      it.definedProperties.add(prop)\n    }\n    if (it.opts.unevaluated && allProps.length && it.props !== true) {\n      it.props = mergeEvaluated.props(gen, toHash(allProps), it.props)\n    }\n    const properties = allProps.filter((p) => !alwaysValidSchema(it, schema[p]))\n    if (properties.length === 0) return\n    const valid = gen.name(\"valid\")\n\n    for (const prop of properties) {\n      if (hasDefault(prop)) {\n        applyPropertySchema(prop)\n      } else {\n        gen.if(propertyInData(gen, data, prop, it.opts.ownProperties))\n        applyPropertySchema(prop)\n        if (!it.allErrors) gen.else().var(valid, true)\n        gen.endIf()\n      }\n      cxt.it.definedProperties.add(prop)\n      cxt.ok(valid)\n    }\n\n    function hasDefault(prop: string): boolean | undefined {\n      return it.opts.useDefaults && !it.compositeRule && schema[prop].default !== undefined\n    }\n\n    function applyPropertySchema(prop: string): void {\n      cxt.subschema(\n        {\n          keyword: \"properties\",\n          schemaProp: prop,\n          dataProp: prop,\n        },\n        valid\n      )\n    }\n  },\n}\n\nexport default def\n","import type {CodeKeywordDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {allSchemaProperties, usePattern} from \"../code\"\nimport {_, not, Name} from \"../../compile/codegen\"\nimport {alwaysValidSchema, checkStrictMode} from \"../../compile/util\"\nimport {evaluatedPropsToName, Type} from \"../../compile/util\"\nimport {AnySchema} from \"../../types\"\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"patternProperties\",\n  type: \"object\",\n  schemaType: \"object\",\n  code(cxt: KeywordCxt) {\n    const {gen, schema, data, parentSchema, it} = cxt\n    const {opts} = it\n    const patterns = allSchemaProperties(schema)\n    const alwaysValidPatterns = patterns.filter((p) =>\n      alwaysValidSchema(it, schema[p] as AnySchema)\n    )\n\n    if (\n      patterns.length === 0 ||\n      (alwaysValidPatterns.length === patterns.length &&\n        (!it.opts.unevaluated || it.props === true))\n    ) {\n      return\n    }\n\n    const checkProperties =\n      opts.strictSchema && !opts.allowMatchingProperties && parentSchema.properties\n    const valid = gen.name(\"valid\")\n    if (it.props !== true && !(it.props instanceof Name)) {\n      it.props = evaluatedPropsToName(gen, it.props)\n    }\n    const {props} = it\n    validatePatternProperties()\n\n    function validatePatternProperties(): void {\n      for (const pat of patterns) {\n        if (checkProperties) checkMatchingProperties(pat)\n        if (it.allErrors) {\n          validateProperties(pat)\n        } else {\n          gen.var(valid, true) // TODO var\n          validateProperties(pat)\n          gen.if(valid)\n        }\n      }\n    }\n\n    function checkMatchingProperties(pat: string): void {\n      for (const prop in checkProperties) {\n        if (new RegExp(pat).test(prop)) {\n          checkStrictMode(\n            it,\n            `property ${prop} matches pattern ${pat} (use allowMatchingProperties)`\n          )\n        }\n      }\n    }\n\n    function validateProperties(pat: string): void {\n      gen.forIn(\"key\", data, (key) => {\n        gen.if(_`${usePattern(cxt, pat)}.test(${key})`, () => {\n          const alwaysValid = alwaysValidPatterns.includes(pat)\n          if (!alwaysValid) {\n            cxt.subschema(\n              {\n                keyword: \"patternProperties\",\n                schemaProp: pat,\n                dataProp: key,\n                dataPropType: Type.Str,\n              },\n              valid\n            )\n          }\n\n          if (it.opts.unevaluated && props !== true) {\n            gen.assign(_`${props}[${key}]`, true)\n          } else if (!alwaysValid && !it.allErrors) {\n            // can short-circuit if `unevaluatedProperties` is not supported (opts.next === false)\n            // or if all properties were evaluated (props === true)\n            gen.if(not(valid), () => gen.break())\n          }\n        })\n      })\n    }\n  },\n}\n\nexport default def\n","import type {CodeKeywordDefinition, ErrorNoParams, AnySchema} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {alwaysValidSchema} from \"../../compile/util\"\n\nexport type NotKeywordError = ErrorNoParams<\"not\", AnySchema>\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"not\",\n  schemaType: [\"object\", \"boolean\"],\n  trackErrors: true,\n  code(cxt: KeywordCxt) {\n    const {gen, schema, it} = cxt\n    if (alwaysValidSchema(it, schema)) {\n      cxt.fail()\n      return\n    }\n\n    const valid = gen.name(\"valid\")\n    cxt.subschema(\n      {\n        keyword: \"not\",\n        compositeRule: true,\n        createErrors: false,\n        allErrors: false,\n      },\n      valid\n    )\n\n    cxt.failResult(\n      valid,\n      () => cxt.reset(),\n      () => cxt.error()\n    )\n  },\n  error: {message: \"must NOT be valid\"},\n}\n\nexport default def\n","import type {CodeKeywordDefinition, ErrorNoParams, AnySchema} from \"../../types\"\nimport {validateUnion} from \"../code\"\n\nexport type AnyOfError = ErrorNoParams<\"anyOf\", AnySchema[]>\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"anyOf\",\n  schemaType: \"array\",\n  trackErrors: true,\n  code: validateUnion,\n  error: {message: \"must match a schema in anyOf\"},\n}\n\nexport default def\n","import type {\n  CodeKeywordDefinition,\n  ErrorObject,\n  KeywordErrorDefinition,\n  AnySchema,\n} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, Name} from \"../../compile/codegen\"\nimport {alwaysValidSchema} from \"../../compile/util\"\nimport {SchemaCxt} from \"../../compile\"\n\nexport type OneOfError = ErrorObject<\n  \"oneOf\",\n  {passingSchemas: [number, number] | null},\n  AnySchema[]\n>\n\nconst error: KeywordErrorDefinition = {\n  message: \"must match exactly one schema in oneOf\",\n  params: ({params}) => _`{passingSchemas: ${params.passing}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"oneOf\",\n  schemaType: \"array\",\n  trackErrors: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {gen, schema, parentSchema, it} = cxt\n    /* istanbul ignore if */\n    if (!Array.isArray(schema)) throw new Error(\"ajv implementation error\")\n    if (it.opts.discriminator && parentSchema.discriminator) return\n    const schArr: AnySchema[] = schema\n    const valid = gen.let(\"valid\", false)\n    const passing = gen.let(\"passing\", null)\n    const schValid = gen.name(\"_valid\")\n    cxt.setParams({passing})\n    // TODO possibly fail straight away (with warning or exception) if there are two empty always valid schemas\n\n    gen.block(validateOneOf)\n\n    cxt.result(\n      valid,\n      () => cxt.reset(),\n      () => cxt.error(true)\n    )\n\n    function validateOneOf(): void {\n      schArr.forEach((sch: AnySchema, i: number) => {\n        let schCxt: SchemaCxt | undefined\n        if (alwaysValidSchema(it, sch)) {\n          gen.var(schValid, true)\n        } else {\n          schCxt = cxt.subschema(\n            {\n              keyword: \"oneOf\",\n              schemaProp: i,\n              compositeRule: true,\n            },\n            schValid\n          )\n        }\n\n        if (i > 0) {\n          gen\n            .if(_`${schValid} && ${valid}`)\n            .assign(valid, false)\n            .assign(passing, _`[${passing}, ${i}]`)\n            .else()\n        }\n\n        gen.if(schValid, () => {\n          gen.assign(valid, true)\n          gen.assign(passing, i)\n          if (schCxt) cxt.mergeEvaluated(schCxt, Name)\n        })\n      })\n    }\n  },\n}\n\nexport default def\n","import type {CodeKeywordDefinition, AnySchema} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {alwaysValidSchema} from \"../../compile/util\"\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"allOf\",\n  schemaType: \"array\",\n  code(cxt: KeywordCxt) {\n    const {gen, schema, it} = cxt\n    /* istanbul ignore if */\n    if (!Array.isArray(schema)) throw new Error(\"ajv implementation error\")\n    const valid = gen.name(\"valid\")\n    schema.forEach((sch: AnySchema, i: number) => {\n      if (alwaysValidSchema(it, sch)) return\n      const schCxt = cxt.subschema({keyword: \"allOf\", schemaProp: i}, valid)\n      cxt.ok(valid)\n      cxt.mergeEvaluated(schCxt)\n    })\n  },\n}\n\nexport default def\n","import type {\n  CodeKeywordDefinition,\n  ErrorObject,\n  KeywordErrorDefinition,\n  AnySchema,\n} from \"../../types\"\nimport type {SchemaObjCxt} from \"../../compile\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str, not, Name} from \"../../compile/codegen\"\nimport {alwaysValidSchema, checkStrictMode} from \"../../compile/util\"\n\nexport type IfKeywordError = ErrorObject<\"if\", {failingKeyword: string}, AnySchema>\n\nconst error: KeywordErrorDefinition = {\n  message: ({params}) => str`must match \"${params.ifClause}\" schema`,\n  params: ({params}) => _`{failingKeyword: ${params.ifClause}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"if\",\n  schemaType: [\"object\", \"boolean\"],\n  trackErrors: true,\n  error,\n  code(cxt: KeywordCxt) {\n    const {gen, parentSchema, it} = cxt\n    if (parentSchema.then === undefined && parentSchema.else === undefined) {\n      checkStrictMode(it, '\"if\" without \"then\" and \"else\" is ignored')\n    }\n    const hasThen = hasSchema(it, \"then\")\n    const hasElse = hasSchema(it, \"else\")\n    if (!hasThen && !hasElse) return\n\n    const valid = gen.let(\"valid\", true)\n    const schValid = gen.name(\"_valid\")\n    validateIf()\n    cxt.reset()\n\n    if (hasThen && hasElse) {\n      const ifClause = gen.let(\"ifClause\")\n      cxt.setParams({ifClause})\n      gen.if(schValid, validateClause(\"then\", ifClause), validateClause(\"else\", ifClause))\n    } else if (hasThen) {\n      gen.if(schValid, validateClause(\"then\"))\n    } else {\n      gen.if(not(schValid), validateClause(\"else\"))\n    }\n\n    cxt.pass(valid, () => cxt.error(true))\n\n    function validateIf(): void {\n      const schCxt = cxt.subschema(\n        {\n          keyword: \"if\",\n          compositeRule: true,\n          createErrors: false,\n          allErrors: false,\n        },\n        schValid\n      )\n      cxt.mergeEvaluated(schCxt)\n    }\n\n    function validateClause(keyword: string, ifClause?: Name): () => void {\n      return () => {\n        const schCxt = cxt.subschema({keyword}, schValid)\n        gen.assign(valid, schValid)\n        cxt.mergeValidEvaluated(schCxt, valid)\n        if (ifClause) gen.assign(ifClause, _`${keyword}`)\n        else cxt.setParams({ifClause: keyword})\n      }\n    }\n  },\n}\n\nfunction hasSchema(it: SchemaObjCxt, keyword: string): boolean {\n  const schema = it.schema[keyword]\n  return schema !== undefined && !alwaysValidSchema(it, schema)\n}\n\nexport default def\n","import type {CodeKeywordDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {checkStrictMode} from \"../../compile/util\"\n\nconst def: CodeKeywordDefinition = {\n  keyword: [\"then\", \"else\"],\n  schemaType: [\"object\", \"boolean\"],\n  code({keyword, parentSchema, it}: KeywordCxt) {\n    if (parentSchema.if === undefined) checkStrictMode(it, `\"${keyword}\" without \"if\" is ignored`)\n  },\n}\n\nexport default def\n","import type {ErrorNoParams, Vocabulary} from \"../../types\"\nimport additionalItems, {AdditionalItemsError} from \"./additionalItems\"\nimport prefixItems from \"./prefixItems\"\nimport items from \"./items\"\nimport items2020, {ItemsError} from \"./items2020\"\nimport contains, {ContainsError} from \"./contains\"\nimport dependencies, {DependenciesError} from \"./dependencies\"\nimport propertyNames, {PropertyNamesError} from \"./propertyNames\"\nimport additionalProperties, {AdditionalPropertiesError} from \"./additionalProperties\"\nimport properties from \"./properties\"\nimport patternProperties from \"./patternProperties\"\nimport notKeyword, {NotKeywordError} from \"./not\"\nimport anyOf, {AnyOfError} from \"./anyOf\"\nimport oneOf, {OneOfError} from \"./oneOf\"\nimport allOf from \"./allOf\"\nimport ifKeyword, {IfKeywordError} from \"./if\"\nimport thenElse from \"./thenElse\"\n\nexport default function getApplicator(draft2020 = false): Vocabulary {\n  const applicator = [\n    // any\n    notKeyword,\n    anyOf,\n    oneOf,\n    allOf,\n    ifKeyword,\n    thenElse,\n    // object\n    propertyNames,\n    additionalProperties,\n    dependencies,\n    properties,\n    patternProperties,\n  ]\n  // array\n  if (draft2020) applicator.push(prefixItems, items2020)\n  else applicator.push(additionalItems, items)\n  applicator.push(contains)\n  return applicator\n}\n\nexport type ApplicatorKeywordError =\n  | ErrorNoParams<\"false schema\">\n  | AdditionalItemsError\n  | ItemsError\n  | ContainsError\n  | AdditionalPropertiesError\n  | DependenciesError\n  | IfKeywordError\n  | AnyOfError\n  | OneOfError\n  | NotKeywordError\n  | PropertyNamesError\n","import type {\n  AddedFormat,\n  FormatValidator,\n  AsyncFormatValidator,\n  CodeKeywordDefinition,\n  KeywordErrorDefinition,\n  ErrorObject,\n} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, str, nil, or, Code, getProperty, regexpCode} from \"../../compile/codegen\"\n\ntype FormatValidate =\n  | FormatValidator<string>\n  | FormatValidator<number>\n  | AsyncFormatValidator<string>\n  | AsyncFormatValidator<number>\n  | RegExp\n  | string\n  | true\n\nexport type FormatError = ErrorObject<\"format\", {format: string}, string | {$data: string}>\n\nconst error: KeywordErrorDefinition = {\n  message: ({schemaCode}) => str`must match format \"${schemaCode}\"`,\n  params: ({schemaCode}) => _`{format: ${schemaCode}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"format\",\n  type: [\"number\", \"string\"],\n  schemaType: \"string\",\n  $data: true,\n  error,\n  code(cxt: KeywordCxt, ruleType?: string) {\n    const {gen, data, $data, schema, schemaCode, it} = cxt\n    const {opts, errSchemaPath, schemaEnv, self} = it\n    if (!opts.validateFormats) return\n\n    if ($data) validate$DataFormat()\n    else validateFormat()\n\n    function validate$DataFormat(): void {\n      const fmts = gen.scopeValue(\"formats\", {\n        ref: self.formats,\n        code: opts.code.formats,\n      })\n      const fDef = gen.const(\"fDef\", _`${fmts}[${schemaCode}]`)\n      const fType = gen.let(\"fType\")\n      const format = gen.let(\"format\")\n      // TODO simplify\n      gen.if(\n        _`typeof ${fDef} == \"object\" && !(${fDef} instanceof RegExp)`,\n        () => gen.assign(fType, _`${fDef}.type || \"string\"`).assign(format, _`${fDef}.validate`),\n        () => gen.assign(fType, _`\"string\"`).assign(format, fDef)\n      )\n      cxt.fail$data(or(unknownFmt(), invalidFmt()))\n\n      function unknownFmt(): Code {\n        if (opts.strictSchema === false) return nil\n        return _`${schemaCode} && !${format}`\n      }\n\n      function invalidFmt(): Code {\n        const callFormat = schemaEnv.$async\n          ? _`(${fDef}.async ? await ${format}(${data}) : ${format}(${data}))`\n          : _`${format}(${data})`\n        const validData = _`(typeof ${format} == \"function\" ? ${callFormat} : ${format}.test(${data}))`\n        return _`${format} && ${format} !== true && ${fType} === ${ruleType} && !${validData}`\n      }\n    }\n\n    function validateFormat(): void {\n      const formatDef: AddedFormat | undefined = self.formats[schema]\n      if (!formatDef) {\n        unknownFormat()\n        return\n      }\n      if (formatDef === true) return\n      const [fmtType, format, fmtRef] = getFormat(formatDef)\n      if (fmtType === ruleType) cxt.pass(validCondition())\n\n      function unknownFormat(): void {\n        if (opts.strictSchema === false) {\n          self.logger.warn(unknownMsg())\n          return\n        }\n        throw new Error(unknownMsg())\n\n        function unknownMsg(): string {\n          return `unknown format \"${schema as string}\" ignored in schema at path \"${errSchemaPath}\"`\n        }\n      }\n\n      function getFormat(fmtDef: AddedFormat): [string, FormatValidate, Code] {\n        const code =\n          fmtDef instanceof RegExp\n            ? regexpCode(fmtDef)\n            : opts.code.formats\n            ? _`${opts.code.formats}${getProperty(schema)}`\n            : undefined\n        const fmt = gen.scopeValue(\"formats\", {key: schema, ref: fmtDef, code})\n        if (typeof fmtDef == \"object\" && !(fmtDef instanceof RegExp)) {\n          return [fmtDef.type || \"string\", fmtDef.validate, _`${fmt}.validate`]\n        }\n\n        return [\"string\", fmtDef, fmt]\n      }\n\n      function validCondition(): Code {\n        if (typeof formatDef == \"object\" && !(formatDef instanceof RegExp) && formatDef.async) {\n          if (!schemaEnv.$async) throw new Error(\"async format in sync schema\")\n          return _`await ${fmtRef}(${data})`\n        }\n        return typeof format == \"function\" ? _`${fmtRef}(${data})` : _`${fmtRef}.test(${data})`\n      }\n    }\n  },\n}\n\nexport default def\n","import type {Vocabulary} from \"../../types\"\nimport formatKeyword from \"./format\"\n\nconst format: Vocabulary = [formatKeyword]\n\nexport default format\n","import type {Vocabulary} from \"../types\"\n\nexport const metadataVocabulary: Vocabulary = [\n  \"title\",\n  \"description\",\n  \"default\",\n  \"deprecated\",\n  \"readOnly\",\n  \"writeOnly\",\n  \"examples\",\n]\n\nexport const contentVocabulary: Vocabulary = [\n  \"contentMediaType\",\n  \"contentEncoding\",\n  \"contentSchema\",\n]\n","import type {Vocabulary} from \"../types\"\nimport coreVocabulary from \"./core\"\nimport validationVocabulary from \"./validation\"\nimport getApplicatorVocabulary from \"./applicator\"\nimport formatVocabulary from \"./format\"\nimport {metadataVocabulary, contentVocabulary} from \"./metadata\"\n\nconst draft7Vocabularies: Vocabulary[] = [\n  coreVocabulary,\n  validationVocabulary,\n  getApplicatorVocabulary(),\n  formatVocabulary,\n  metadataVocabulary,\n  contentVocabulary,\n]\n\nexport default draft7Vocabularies\n","import type {ErrorObject} from \"../../types\"\n\nexport enum DiscrError {\n  Tag = \"tag\",\n  Mapping = \"mapping\",\n}\n\nexport type DiscrErrorObj<E extends DiscrError> = ErrorObject<\n  \"discriminator\",\n  {error: E; tag: string; tagValue: unknown},\n  string\n>\n","import type {CodeKeywordDefinition, AnySchemaObject, KeywordErrorDefinition} from \"../../types\"\nimport type {KeywordCxt} from \"../../compile/validate\"\nimport {_, getProperty, Name} from \"../../compile/codegen\"\nimport {DiscrError, DiscrErrorObj} from \"../discriminator/types\"\nimport {resolveRef, SchemaEnv} from \"../../compile\"\nimport MissingRefError from \"../../compile/ref_error\"\nimport {schemaHasRulesButRef} from \"../../compile/util\"\n\nexport type DiscriminatorError = DiscrErrorObj<DiscrError.Tag> | DiscrErrorObj<DiscrError.Mapping>\n\nconst error: KeywordErrorDefinition = {\n  message: ({params: {discrError, tagName}}) =>\n    discrError === DiscrError.Tag\n      ? `tag \"${tagName}\" must be string`\n      : `value of tag \"${tagName}\" must be in oneOf`,\n  params: ({params: {discrError, tag, tagName}}) =>\n    _`{error: ${discrError}, tag: ${tagName}, tagValue: ${tag}}`,\n}\n\nconst def: CodeKeywordDefinition = {\n  keyword: \"discriminator\",\n  type: \"object\",\n  schemaType: \"object\",\n  error,\n  code(cxt: KeywordCxt) {\n    const {gen, data, schema, parentSchema, it} = cxt\n    const {oneOf} = parentSchema\n    if (!it.opts.discriminator) {\n      throw new Error(\"discriminator: requires discriminator option\")\n    }\n    const tagName = schema.propertyName\n    if (typeof tagName != \"string\") throw new Error(\"discriminator: requires propertyName\")\n    if (schema.mapping) throw new Error(\"discriminator: mapping is not supported\")\n    if (!oneOf) throw new Error(\"discriminator: requires oneOf keyword\")\n    const valid = gen.let(\"valid\", false)\n    const tag = gen.const(\"tag\", _`${data}${getProperty(tagName)}`)\n    gen.if(\n      _`typeof ${tag} == \"string\"`,\n      () => validateMapping(),\n      () => cxt.error(false, {discrError: DiscrError.Tag, tag, tagName})\n    )\n    cxt.ok(valid)\n\n    function validateMapping(): void {\n      const mapping = getMapping()\n      gen.if(false)\n      for (const tagValue in mapping) {\n        gen.elseIf(_`${tag} === ${tagValue}`)\n        gen.assign(valid, applyTagSchema(mapping[tagValue]))\n      }\n      gen.else()\n      cxt.error(false, {discrError: DiscrError.Mapping, tag, tagName})\n      gen.endIf()\n    }\n\n    function applyTagSchema(schemaProp?: number): Name {\n      const _valid = gen.name(\"valid\")\n      const schCxt = cxt.subschema({keyword: \"oneOf\", schemaProp}, _valid)\n      cxt.mergeEvaluated(schCxt, Name)\n      return _valid\n    }\n\n    function getMapping(): {[T in string]?: number} {\n      const oneOfMapping: {[T in string]?: number} = {}\n      const topRequired = hasRequired(parentSchema)\n      let tagRequired = true\n      for (let i = 0; i < oneOf.length; i++) {\n        let sch = oneOf[i]\n        if (sch?.$ref && !schemaHasRulesButRef(sch, it.self.RULES)) {\n          const ref = sch.$ref\n          sch = resolveRef.call(it.self, it.schemaEnv.root, it.baseId, ref)\n          if (sch instanceof SchemaEnv) sch = sch.schema\n          if (sch === undefined) throw new MissingRefError(it.opts.uriResolver, it.baseId, ref)\n        }\n        const propSch = sch?.properties?.[tagName]\n        if (typeof propSch != \"object\") {\n          throw new Error(\n            `discriminator: oneOf subschemas (or referenced schemas) must have \"properties/${tagName}\"`\n          )\n        }\n        tagRequired = tagRequired && (topRequired || hasRequired(sch))\n        addMappings(propSch, i)\n      }\n      if (!tagRequired) throw new Error(`discriminator: \"${tagName}\" must be required`)\n      return oneOfMapping\n\n      function hasRequired({required}: AnySchemaObject): boolean {\n        return Array.isArray(required) && required.includes(tagName)\n      }\n\n      function addMappings(sch: AnySchemaObject, i: number): void {\n        if (sch.const) {\n          addMapping(sch.const, i)\n        } else if (sch.enum) {\n          for (const tagValue of sch.enum) {\n            addMapping(tagValue, i)\n          }\n        } else {\n          throw new Error(`discriminator: \"properties/${tagName}\" must have \"const\" or \"enum\"`)\n        }\n      }\n\n      function addMapping(tagValue: unknown, i: number): void {\n        if (typeof tagValue != \"string\" || tagValue in oneOfMapping) {\n          throw new Error(`discriminator: \"${tagName}\" values must be unique strings`)\n        }\n        oneOfMapping[tagValue] = i\n      }\n    }\n  },\n}\n\nexport default def\n","{\n  \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n  \"$id\": \"http://json-schema.org/draft-07/schema#\",\n  \"title\": \"Core schema meta-schema\",\n  \"definitions\": {\n    \"schemaArray\": {\n      \"type\": \"array\",\n      \"minItems\": 1,\n      \"items\": {\"$ref\": \"#\"}\n    },\n    \"nonNegativeInteger\": {\n      \"type\": \"integer\",\n      \"minimum\": 0\n    },\n    \"nonNegativeIntegerDefault0\": {\n      \"allOf\": [{\"$ref\": \"#/definitions/nonNegativeInteger\"}, {\"default\": 0}]\n    },\n    \"simpleTypes\": {\n      \"enum\": [\"array\", \"boolean\", \"integer\", \"null\", \"number\", \"object\", \"string\"]\n    },\n    \"stringArray\": {\n      \"type\": \"array\",\n      \"items\": {\"type\": \"string\"},\n      \"uniqueItems\": true,\n      \"default\": []\n    }\n  },\n  \"type\": [\"object\", \"boolean\"],\n  \"properties\": {\n    \"$id\": {\n      \"type\": \"string\",\n      \"format\": \"uri-reference\"\n    },\n    \"$schema\": {\n      \"type\": \"string\",\n      \"format\": \"uri\"\n    },\n    \"$ref\": {\n      \"type\": \"string\",\n      \"format\": \"uri-reference\"\n    },\n    \"$comment\": {\n      \"type\": \"string\"\n    },\n    \"title\": {\n      \"type\": \"string\"\n    },\n    \"description\": {\n      \"type\": \"string\"\n    },\n    \"default\": true,\n    \"readOnly\": {\n      \"type\": \"boolean\",\n      \"default\": false\n    },\n    \"examples\": {\n      \"type\": \"array\",\n      \"items\": true\n    },\n    \"multipleOf\": {\n      \"type\": \"number\",\n      \"exclusiveMinimum\": 0\n    },\n    \"maximum\": {\n      \"type\": \"number\"\n    },\n    \"exclusiveMaximum\": {\n      \"type\": \"number\"\n    },\n    \"minimum\": {\n      \"type\": \"number\"\n    },\n    \"exclusiveMinimum\": {\n      \"type\": \"number\"\n    },\n    \"maxLength\": {\"$ref\": \"#/definitions/nonNegativeInteger\"},\n    \"minLength\": {\"$ref\": \"#/definitions/nonNegativeIntegerDefault0\"},\n    \"pattern\": {\n      \"type\": \"string\",\n      \"format\": \"regex\"\n    },\n    \"additionalItems\": {\"$ref\": \"#\"},\n    \"items\": {\n      \"anyOf\": [{\"$ref\": \"#\"}, {\"$ref\": \"#/definitions/schemaArray\"}],\n      \"default\": true\n    },\n    \"maxItems\": {\"$ref\": \"#/definitions/nonNegativeInteger\"},\n    \"minItems\": {\"$ref\": \"#/definitions/nonNegativeIntegerDefault0\"},\n    \"uniqueItems\": {\n      \"type\": \"boolean\",\n      \"default\": false\n    },\n    \"contains\": {\"$ref\": \"#\"},\n    \"maxProperties\": {\"$ref\": \"#/definitions/nonNegativeInteger\"},\n    \"minProperties\": {\"$ref\": \"#/definitions/nonNegativeIntegerDefault0\"},\n    \"required\": {\"$ref\": \"#/definitions/stringArray\"},\n    \"additionalProperties\": {\"$ref\": \"#\"},\n    \"definitions\": {\n      \"type\": \"object\",\n      \"additionalProperties\": {\"$ref\": \"#\"},\n      \"default\": {}\n    },\n    \"properties\": {\n      \"type\": \"object\",\n      \"additionalProperties\": {\"$ref\": \"#\"},\n      \"default\": {}\n    },\n    \"patternProperties\": {\n      \"type\": \"object\",\n      \"additionalProperties\": {\"$ref\": \"#\"},\n      \"propertyNames\": {\"format\": \"regex\"},\n      \"default\": {}\n    },\n    \"dependencies\": {\n      \"type\": \"object\",\n      \"additionalProperties\": {\n        \"anyOf\": [{\"$ref\": \"#\"}, {\"$ref\": \"#/definitions/stringArray\"}]\n      }\n    },\n    \"propertyNames\": {\"$ref\": \"#\"},\n    \"const\": true,\n    \"enum\": {\n      \"type\": \"array\",\n      \"items\": true,\n      \"minItems\": 1,\n      \"uniqueItems\": true\n    },\n    \"type\": {\n      \"anyOf\": [\n        {\"$ref\": \"#/definitions/simpleTypes\"},\n        {\n          \"type\": \"array\",\n          \"items\": {\"$ref\": \"#/definitions/simpleTypes\"},\n          \"minItems\": 1,\n          \"uniqueItems\": true\n        }\n      ]\n    },\n    \"format\": {\"type\": \"string\"},\n    \"contentMediaType\": {\"type\": \"string\"},\n    \"contentEncoding\": {\"type\": \"string\"},\n    \"if\": {\"$ref\": \"#\"},\n    \"then\": {\"$ref\": \"#\"},\n    \"else\": {\"$ref\": \"#\"},\n    \"allOf\": {\"$ref\": \"#/definitions/schemaArray\"},\n    \"anyOf\": {\"$ref\": \"#/definitions/schemaArray\"},\n    \"oneOf\": {\"$ref\": \"#/definitions/schemaArray\"},\n    \"not\": {\"$ref\": \"#\"}\n  },\n  \"default\": true\n}\n","import type {AnySchemaObject} from \"./types\"\nimport AjvCore from \"./core\"\nimport draft7Vocabularies from \"./vocabularies/draft7\"\nimport discriminator from \"./vocabularies/discriminator\"\nimport * as draft7MetaSchema from \"./refs/json-schema-draft-07.json\"\n\nconst META_SUPPORT_DATA = [\"/properties\"]\n\nconst META_SCHEMA_ID = \"http://json-schema.org/draft-07/schema\"\n\nexport class Ajv extends AjvCore {\n  _addVocabularies(): void {\n    super._addVocabularies()\n    draft7Vocabularies.forEach((v) => this.addVocabulary(v))\n    if (this.opts.discriminator) this.addKeyword(discriminator)\n  }\n\n  _addDefaultMetaSchema(): void {\n    super._addDefaultMetaSchema()\n    if (!this.opts.meta) return\n    const metaSchema = this.opts.$data\n      ? this.$dataMetaSchema(draft7MetaSchema, META_SUPPORT_DATA)\n      : draft7MetaSchema\n    this.addMetaSchema(metaSchema, META_SCHEMA_ID, false)\n    this.refs[\"http://json-schema.org/schema\"] = META_SCHEMA_ID\n  }\n\n  defaultMeta(): string | AnySchemaObject | undefined {\n    return (this.opts.defaultMeta =\n      super.defaultMeta() || (this.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : undefined))\n  }\n}\n\nmodule.exports = exports = Ajv\nmodule.exports.Ajv = Ajv\nObject.defineProperty(exports, \"__esModule\", {value: true})\n\nexport default Ajv\n\nexport {\n  Format,\n  FormatDefinition,\n  AsyncFormatDefinition,\n  KeywordDefinition,\n  KeywordErrorDefinition,\n  CodeKeywordDefinition,\n  MacroKeywordDefinition,\n  FuncKeywordDefinition,\n  Vocabulary,\n  Schema,\n  SchemaObject,\n  AnySchemaObject,\n  AsyncSchema,\n  AnySchema,\n  ValidateFunction,\n  AsyncValidateFunction,\n  SchemaValidateFunction,\n  ErrorObject,\n  ErrorNoParams,\n} from \"./types\"\n\nexport {Plugin, Options, CodeOptions, InstanceOptions, Logger, ErrorsTextOptions} from \"./core\"\nexport {SchemaCxt, SchemaObjCxt} from \"./compile\"\nexport {KeywordCxt} from \"./compile/validate\"\nexport {DefinedError} from \"./vocabularies/errors\"\nexport {JSONType} from \"./compile/rules\"\nexport {JSONSchemaType} from \"./types/json-schema\"\nexport {_, str, stringify, nil, Name, Code, CodeGen, CodeGenOptions} from \"./compile/codegen\"\nexport {default as ValidationError} from \"./runtime/validation_error\"\nexport {default as MissingRefError} from \"./compile/ref_error\"\n","import type { Schema } from '@internal/ai-v6';\nimport type { StandardSchemaV1, StandardJSONSchemaV1 } from '@standard-schema/spec';\nimport type { JSONSchema7 } from 'json-schema';\nimport type { StandardSchemaWithJSON, StandardSchemaWithJSONProps } from '../standard-schema.types';\n\n/**\n * Vendor name for AI SDK wrapped schemas.\n */\nconst VENDOR = 'ai-sdk';\n\n/**\n * A wrapper class that makes AI SDK Schema compatible with @standard-schema/spec.\n *\n * This class implements both `StandardSchemaV1` (validation) and `StandardJSONSchemaV1`\n * (JSON Schema conversion) interfaces. It wraps an AI SDK Schema and adapts its\n * validation method and jsonSchema property to the standard-schema interface.\n *\n * @typeParam T - The TypeScript type that the AI SDK Schema represents\n *\n * @example\n * ```typescript\n * import { jsonSchema } from '@internal/ai-v6';\n * import { toStandardSchema } from '@mastra/schema-compat/adapters/ai-sdk';\n *\n * // Create an AI SDK schema\n * const aiSdkSchema = jsonSchema<{ name: string; age: number }>({\n *   type: 'object',\n *   properties: {\n *     name: { type: 'string' },\n *     age: { type: 'number' },\n *   },\n *   required: ['name', 'age'],\n * });\n *\n * // Convert to standard-schema\n * const standardSchema = toStandardSchema(aiSdkSchema);\n *\n * // Use validation (from StandardSchemaV1)\n * const result = standardSchema['~standard'].validate({ name: 'John', age: 30 });\n *\n * // Get JSON Schema (from StandardJSONSchemaV1)\n * const jsonSchema = standardSchema['~standard'].jsonSchema.output({ target: 'draft-07' });\n * ```\n */\nexport class AiSdkSchemaWrapper<Input = unknown, Output = Input> implements StandardSchemaWithJSON<Input, Output> {\n  readonly #schema: Schema<Output>;\n  readonly '~standard': StandardSchemaWithJSONProps<Input, Output>;\n\n  constructor(schema: Schema<Output>) {\n    this.#schema = schema;\n\n    // Create the ~standard property\n    this['~standard'] = {\n      version: 1,\n      vendor: VENDOR,\n      validate: this.#validate.bind(this),\n      jsonSchema: {\n        input: this.#toJsonSchema.bind(this),\n        output: this.#toJsonSchema.bind(this),\n      },\n    };\n  }\n\n  /**\n   * Validates a value against the AI SDK Schema.\n   *\n   * @param value - The value to validate\n   * @returns A result object with either the validated value or validation issues\n   */\n  #validate(value: unknown): StandardSchemaV1.Result<Output> | Promise<StandardSchemaV1.Result<Output>> {\n    // Check if the schema has a validate method (it's optional on AI SDK Schema)\n    if (!this.#schema.validate) {\n      // If no validate method, we can't validate - just pass through\n      return { value: value as Output };\n    }\n\n    try {\n      const result = this.#schema.validate(value);\n\n      // Handle both sync and async validation results\n      // The AI SDK Schema.validate returns ValidationResult<OBJECT> | PromiseLike<ValidationResult<OBJECT>>\n      // We need to check if it's a thenable (promise-like)\n      if (result && typeof result === 'object' && 'then' in result && typeof result.then === 'function') {\n        // Wrap PromiseLike in a proper Promise to satisfy the StandardSchemaV1 interface\n        return Promise.resolve(\n          result as PromiseLike<{ success: true; value: Output } | { success: false; error: Error }>,\n        )\n          .then(res => this.#convertValidationResult(res))\n          .catch((error: unknown) => {\n            // Convert rejected promises to the expected { issues: [...] } shape\n            const message = error instanceof Error ? error.message : 'Unknown validation error';\n            return {\n              issues: [{ message: `Schema validation error: ${message}` }],\n            } as StandardSchemaV1.Result<Output>;\n          });\n      }\n\n      // It's a sync result\n      return this.#convertValidationResult(\n        result as { success: true; value: Output } | { success: false; error: Error },\n      );\n    } catch (error) {\n      // If validation fails unexpectedly, return a validation error\n      const message = error instanceof Error ? error.message : 'Unknown validation error';\n      return {\n        issues: [{ message: `Schema validation error: ${message}` }],\n      };\n    }\n  }\n\n  /**\n   * Converts an AI SDK ValidationResult to a StandardSchemaV1.Result.\n   *\n   * @param result - The AI SDK validation result\n   * @returns A StandardSchemaV1.Result\n   */\n  #convertValidationResult(\n    result: { success: true; value: Output } | { success: false; error: Error },\n  ): StandardSchemaV1.Result<Output> {\n    if (result.success) {\n      return { value: result.value };\n    }\n\n    // Convert the AI SDK error to a Standard Schema issue\n    // Cast to the failure type since TypeScript can't narrow discriminated unions with private field access\n    const failureResult = result as { success: false; error: Error };\n    return {\n      issues: [{ message: failureResult.error.message }],\n    };\n  }\n\n  /**\n   * Returns the JSON Schema in the requested target format.\n   *\n   * @param options - Options including the target format\n   * @returns The JSON Schema as a Record\n   */\n  #toJsonSchema(options: StandardJSONSchemaV1.Options): Record<string, unknown> {\n    const { target } = options;\n\n    // Clone the schema to avoid mutations\n    const clonedSchema = JSON.parse(JSON.stringify(this.#schema.jsonSchema)) as Record<string, unknown>;\n\n    // Add $schema if not present, based on target\n    if (!clonedSchema.$schema) {\n      switch (target) {\n        case 'draft-07':\n          clonedSchema.$schema = 'http://json-schema.org/draft-07/schema#';\n          break;\n        case 'draft-2020-12':\n          clonedSchema.$schema = 'https://json-schema.org/draft/2020-12/schema';\n          break;\n        case 'openapi-3.0':\n          // OpenAPI 3.0 doesn't use $schema\n          break;\n        default:\n          // For unknown targets, don't add $schema\n          break;\n      }\n    }\n\n    return clonedSchema;\n  }\n\n  /**\n   * Returns the original AI SDK Schema.\n   */\n  getSchema(): Schema<Output> {\n    return this.#schema;\n  }\n\n  /**\n   * Returns the original JSON Schema from the AI SDK Schema.\n   */\n  getJsonSchema(): JSONSchema7 {\n    return this.#schema.jsonSchema as JSONSchema7;\n  }\n}\n\n/**\n * Wraps an AI SDK Schema to implement the full @standard-schema/spec interface.\n *\n * This function creates a wrapper that implements both `StandardSchemaV1` (validation)\n * and `StandardJSONSchemaV1` (JSON Schema conversion) interfaces.\n *\n * @typeParam T - The TypeScript type that the AI SDK Schema represents\n * @param schema - The AI SDK Schema to wrap\n * @returns A wrapper implementing StandardSchemaWithJSON\n *\n * @example\n * ```typescript\n * import { jsonSchema } from '@internal/ai-v6';\n * import { toStandardSchema } from '@mastra/schema-compat/adapters/ai-sdk';\n *\n * const aiSdkSchema = jsonSchema<{ name: string; age: number }>({\n *   type: 'object',\n *   properties: {\n *     name: { type: 'string' },\n *     age: { type: 'number' },\n *   },\n *   required: ['name', 'age'],\n * });\n *\n * const standardSchema = toStandardSchema(aiSdkSchema);\n *\n * // Validate data\n * const result = standardSchema['~standard'].validate({ name: 'John', age: 30 });\n *\n * // Get JSON Schema\n * const jsonSchema = standardSchema['~standard'].jsonSchema.output({ target: 'draft-07' });\n * ```\n */\nexport function toStandardSchema<T = unknown>(schema: Schema<T>): AiSdkSchemaWrapper<T, T> {\n  return new AiSdkSchemaWrapper<T, T>(schema);\n}\n","import type { StandardSchemaV1, StandardJSONSchemaV1 } from '@standard-schema/spec';\nimport Ajv from 'ajv';\nimport type { JSONSchema7 } from 'json-schema';\nimport type { StandardSchemaWithJSON, StandardSchemaWithJSONProps } from '../standard-schema.types';\n\n/**\n * Vendor name for JSON Schema wrapped schemas.\n */\nconst VENDOR = 'json-schema';\n\n/**\n * Options for creating a Standard Schema from JSON Schema.\n */\nexport interface JsonSchemaAdapterOptions {\n  /**\n   * Custom name for the schema (used for error messages).\n   */\n  name?: string;\n\n  /**\n   * Ajv options to customize validation behavior.\n   * @see https://ajv.js.org/options.html\n   */\n  ajvOptions?: ConstructorParameters<typeof Ajv>[0];\n}\n\n/**\n * A wrapper class that makes JSON Schema compatible with @standard-schema/spec.\n *\n * This class implements both `StandardSchemaV1` (validation) and `StandardJSONSchemaV1`\n * (JSON Schema conversion) interfaces. Validation is performed using Ajv (Another JSON\n * Schema Validator).\n *\n * @typeParam T - The TypeScript type that the JSON Schema represents\n *\n * @example\n * ```typescript\n * import { toStandardSchema } from '@mastra/schema-compat/adapters/json-schema';\n *\n * const userJsonSchema = {\n *   type: 'object',\n *   properties: {\n *     name: { type: 'string' },\n *     age: { type: 'number', minimum: 0 },\n *   },\n *   required: ['name', 'age'],\n * } as const;\n *\n * const standardSchema = toStandardSchema<{ name: string; age: number }>(userJsonSchema);\n *\n * // Use validation (from StandardSchemaV1)\n * const result = standardSchema['~standard'].validate({ name: 'John', age: 30 });\n *\n * // Get JSON Schema (from StandardJSONSchemaV1)\n * const jsonSchema = standardSchema['~standard'].jsonSchema.output({ target: 'draft-07' });\n * ```\n */\nexport class JsonSchemaWrapper<Input = unknown, Output = Input> implements StandardSchemaWithJSON<Input, Output> {\n  readonly #schema: JSONSchema7;\n  readonly #options: JsonSchemaAdapterOptions;\n  #ajvValidateCache: ReturnType<Ajv['compile']> | null = null;\n  #ajvInstance: Ajv | null = null;\n\n  readonly '~standard': StandardSchemaWithJSONProps<Input, Output>;\n\n  constructor(schema: JSONSchema7, options: JsonSchemaAdapterOptions = {}) {\n    this.#schema = schema;\n    this.#options = options;\n\n    // Create the ~standard property\n    this['~standard'] = {\n      version: 1,\n      vendor: VENDOR,\n      validate: this.#validate.bind(this),\n      jsonSchema: {\n        input: this.#toJsonSchema.bind(this),\n        output: this.#toJsonSchema.bind(this),\n      },\n    };\n  }\n\n  /**\n   * Validates a value against the JSON Schema using Ajv.\n   *\n   * @param value - The value to validate\n   * @returns A result object with either the validated value or validation issues\n   */\n  #validate(value: unknown): StandardSchemaV1.Result<Output> | Promise<StandardSchemaV1.Result<Output>> {\n    try {\n      const validateFn = this.#getAjvValidator();\n      const result = validateFn(value);\n\n      // Handle async validators (when schema uses $async: true)\n      if ((validateFn as any).$async) {\n        return (result as Promise<void>)\n          .then(() => ({ value: value as Output }))\n          .catch(err => {\n            const errors = (err as any)?.errors ?? [];\n            const issues: StandardSchemaV1.Issue[] = errors.map((e: any) => ({\n              message: e.message ?? 'Validation error',\n              path: this.#ajvPathToStandardPath(e.instancePath),\n            }));\n            return { issues };\n          });\n      }\n\n      if (result) {\n        return { value: value as Output };\n      }\n\n      // Convert Ajv errors to Standard Schema issues\n      const issues: StandardSchemaV1.Issue[] = (validateFn.errors ?? []).map(err => ({\n        message: err.message ?? 'Validation error',\n        path: this.#ajvPathToStandardPath(err.instancePath),\n      }));\n\n      return { issues };\n    } catch (error) {\n      // If validation fails unexpectedly, return a validation error\n      const message = error instanceof Error ? error.message : 'Unknown validation error';\n      return {\n        issues: [{ message: `Schema validation error: ${message}` }],\n      };\n    }\n  }\n\n  /**\n   * Converts an Ajv instance path (e.g., \"/foo/0/bar\") to a Standard Schema path array.\n   *\n   * @param instancePath - The Ajv instance path\n   * @returns An array of path segments\n   */\n  #ajvPathToStandardPath(instancePath: string): Array<PropertyKey> {\n    if (!instancePath || instancePath === '') {\n      return [];\n    }\n\n    // Remove leading slash and split by '/'\n    const parts = instancePath.slice(1).split('/');\n\n    return parts.map(part => {\n      // Try to parse as number for array indices\n      const num = parseInt(part, 10);\n      if (!isNaN(num) && String(num) === part) {\n        return num;\n      }\n      // Decode JSON Pointer escapes: ~1 -> /, ~0 -> ~\n      return part.replace(/~1/g, '/').replace(/~0/g, '~');\n    });\n  }\n\n  /**\n   * Returns the JSON Schema in the requested target format.\n   *\n   * Since we're already working with JSON Schema, this is mostly a pass-through.\n   * Different targets may require slight modifications in the future.\n   *\n   * @param options - Options including the target format\n   * @returns The JSON Schema as a Record\n   */\n  #toJsonSchema(options: StandardJSONSchemaV1.Options): Record<string, unknown> {\n    const { target } = options;\n\n    // Clone the schema to avoid mutations\n    const clonedSchema = JSON.parse(JSON.stringify(this.#schema)) as Record<string, unknown>;\n\n    // Add $schema if not present, based on target\n    if (!clonedSchema.$schema) {\n      switch (target) {\n        case 'draft-07':\n          clonedSchema.$schema = 'http://json-schema.org/draft-07/schema#';\n          break;\n        case 'draft-2020-12':\n          clonedSchema.$schema = 'https://json-schema.org/draft/2020-12/schema';\n          break;\n        case 'openapi-3.0':\n          // OpenAPI 3.0 doesn't use $schema\n          break;\n        default:\n          // For unknown targets, don't add $schema\n          break;\n      }\n    }\n\n    return clonedSchema;\n  }\n\n  /**\n   * Gets or creates an Ajv validator for the schema.\n   * The validator is cached for performance.\n   */\n  #getAjvValidator(): ReturnType<Ajv['compile']> {\n    if (!this.#ajvValidateCache) {\n      this.#ajvInstance = new Ajv({\n        allErrors: true, // Report all errors, not just the first one\n        strict: false, // Be lenient with schema keywords\n        ...this.#options.ajvOptions,\n      });\n\n      this.#ajvValidateCache = this.#ajvInstance.compile(this.#schema);\n    }\n    return this.#ajvValidateCache;\n  }\n\n  /**\n   * Returns the original JSON Schema.\n   */\n  getSchema(): JSONSchema7 {\n    return this.#schema;\n  }\n\n  /**\n   * Returns the Ajv instance used for validation.\n   * Useful for advanced use cases like adding custom formats or keywords.\n   */\n  getAjv(): Ajv {\n    // Ensure the validator is created (which creates the Ajv instance)\n    this.#getAjvValidator();\n    return this.#ajvInstance!;\n  }\n}\n\n/**\n * Wraps a JSON Schema to implement the full @standard-schema/spec interface.\n *\n * This function creates a wrapper that implements both `StandardSchemaV1` (validation)\n * and `StandardJSONSchemaV1` (JSON Schema conversion) interfaces. Validation is performed\n * using Ajv (Another JSON Schema Validator).\n *\n * @typeParam T - The TypeScript type that the JSON Schema represents\n * @param schema - The JSON Schema to wrap\n * @param options - Optional configuration options\n * @returns A wrapper implementing StandardSchemaWithJSON\n *\n * @example\n * ```typescript\n * import { toStandardSchema } from '@mastra/schema-compat/adapters/json-schema';\n *\n * const userSchema = {\n *   type: 'object',\n *   properties: {\n *     name: { type: 'string' },\n *     age: { type: 'number' },\n *   },\n *   required: ['name'],\n * } as const;\n *\n * type User = { name: string; age?: number };\n *\n * const standardSchema = toStandardSchema<User>(userSchema);\n *\n * // Validate data\n * const result = standardSchema['~standard'].validate({ name: 'John' });\n *\n * // Get JSON Schema\n * const jsonSchema = standardSchema['~standard'].jsonSchema.output({ target: 'draft-07' });\n * ```\n */\nexport function toStandardSchema<T = unknown>(\n  schema: JSONSchema7,\n  options?: JsonSchemaAdapterOptions,\n): JsonSchemaWrapper<T, T> {\n  return new JsonSchemaWrapper<T, T>(schema, options);\n}\n","import type { StandardSchemaV1, StandardJSONSchemaV1 } from '@standard-schema/spec';\nimport traverse from 'json-schema-traverse';\n// Use zod/v3 types for v3 compatibility (v4's v3-compat layer)\nimport type { ZodType, ZodTypeDef } from 'zod/v3';\nimport zodToJsonSchemaOriginal from 'zod-to-json-schema';\nimport type {\n  StandardSchemaWithJSON,\n  StandardSchemaWithJSONProps,\n  ZodToJsonSchemaTarget,\n} from '../standard-schema.types';\n/**\n * Target mapping from Standard Schema targets to zod-to-json-schema targets.\n */\nconst TARGET_MAP: Record<string, ZodToJsonSchemaTarget> = {\n  'draft-07': 'jsonSchema7',\n  'openapi-3.0': 'openApi3',\n};\n\n/**\n * Converts a Zod schema to JSON Schema using the specified target format.\n *\n * @param zodSchema - The Zod schema to convert\n * @param options - Standard Schema JSON options including the target format\n * @returns The JSON Schema representation\n * @throws Error if the target format is not supported\n *\n * @internal\n */\nfunction convertToJsonSchema<T extends ZodType<any, ZodTypeDef, any>>(\n  zodSchema: T,\n  options: StandardJSONSchemaV1.Options,\n): Record<string, unknown> {\n  const target = TARGET_MAP[options.target];\n\n  if (!target) {\n    // For unknown targets, try to use jsonSchema7 as fallback or throw\n    const supportedTargets = Object.keys(TARGET_MAP);\n    throw new Error(\n      `Unsupported JSON Schema target: \"${options.target}\". ` + `Supported targets are: ${supportedTargets.join(', ')}`,\n    );\n  }\n\n  const jsonSchema = zodToJsonSchemaOriginal(zodSchema, {\n    $refStrategy: 'none',\n    target,\n  });\n\n  traverse(jsonSchema, {\n    cb: {\n      pre: schema => {\n        if (schema.type === 'string' && schema.format === 'email') {\n          schema.pattern = `^(?!\\\\.)(?!.*\\\\.\\\\.)([A-Za-z0-9_'+\\\\-\\\\.]*)[A-Za-z0-9_+-]@([A-Za-z0-9][A-Za-z0-9\\\\-]*\\\\.)+[A-Za-z]{2,}$`;\n        }\n      },\n      // post: (schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema) => {\n      //   this.postProcessJSONNode(schema, parentSchema);\n      // },\n    },\n  });\n\n  return jsonSchema as Record<string, unknown>;\n}\n\n/**\n * Wraps a Zod v3 schema to implement the full @standard-schema/spec interface.\n *\n * While Zod v3 natively implements `StandardSchemaV1` (validation), it does not\n * implement `StandardJSONSchemaV1` (JSON Schema conversion). This adapter adds\n * the `jsonSchema` property to provide JSON Schema conversion capabilities.\n *\n * @typeParam T - The Zod schema type\n *\n * @example\n * ```typescript\n * import { z } from 'zod';\n * import { toStandardSchema } from '@mastra/schema-compat/adapters/zod-v3';\n *\n * const userSchema = z.object({\n *   name: z.string(),\n *   age: z.number().min(0),\n * });\n *\n * const standardSchema = toStandardSchema(userSchema);\n *\n * // Use validation (from StandardSchemaV1)\n * const result = standardSchema['~standard'].validate({ name: 'John', age: 30 });\n *\n * // Get JSON Schema (from StandardJSONSchemaV1)\n * const jsonSchema = standardSchema['~standard'].jsonSchema.output({ target: 'draft-07' });\n * ```\n */\nexport function toStandardSchema<T>(zodSchema: ZodType<T, ZodTypeDef, T>): T & StandardSchemaWithJSON<T, T> {\n  // Create a wrapper object that includes the jsonSchema converter\n  const wrapper = Object.create(zodSchema) as T & StandardSchemaWithJSON<T, T>;\n\n  // Get the existing ~standard property from Zod\n  const existingStandard = zodSchema['~standard'] as StandardSchemaV1.Props<T, T>;\n\n  // Create the JSON Schema converter\n  const jsonSchemaConverter: StandardJSONSchemaV1.Converter = {\n    input: (options: StandardJSONSchemaV1.Options): Record<string, unknown> => {\n      return convertToJsonSchema(zodSchema, options);\n    },\n    output: (options: StandardJSONSchemaV1.Options): Record<string, unknown> => {\n      // For Zod schemas, input and output JSON Schema are typically the same\n      // unless using transforms, which would need special handling\n      return convertToJsonSchema(zodSchema, options);\n    },\n  };\n\n  // Define the enhanced ~standard property\n  Object.defineProperty(wrapper, '~standard', {\n    value: {\n      ...existingStandard,\n      jsonSchema: jsonSchemaConverter,\n    } satisfies StandardSchemaWithJSONProps<T, T>,\n    writable: false,\n    enumerable: true,\n    configurable: false,\n  });\n\n  return wrapper;\n}\n","import type { Schema } from '@internal/ai-v6';\nimport type { StandardJSONSchemaV1, StandardSchemaV1 } from '@standard-schema/spec';\nimport type { JSONSchema7 } from 'json-schema';\nimport z3 from 'zod/v3';\nimport type { ZodType } from 'zod/v3';\nimport type { PublicSchema } from '../schema.types';\nimport { toStandardSchema as toStandardSchemaAiSdk } from './adapters/ai-sdk';\nimport { toStandardSchema as toStandardSchemaJsonSchema } from './adapters/json-schema';\nimport { toStandardSchema as toStandardSchemaZodV3 } from './adapters/zod-v3';\nimport type { StandardSchemaWithJSON } from './standard-schema.types';\n\n/**\n * Override function for JSON Schema conversion.\n * Handles types that Zod v4 cannot natively represent in JSON Schema:\n * - z.date() -> { type: 'string', format: 'date-time' }\n */\nfunction jsonSchemaOverride(ctx: { zodSchema: unknown; jsonSchema: Record<string, unknown> }): undefined {\n  const zodSchema = ctx.zodSchema as { type?: string; _zod?: { def?: { type?: string } }; optional?: () => unknown };\n  if (zodSchema) {\n    // Convert z.date() to JSON Schema string with date-time format\n    if (zodSchema?.type === 'date') {\n      ctx.jsonSchema.type = 'string';\n      ctx.jsonSchema.format = 'date-time';\n    }\n  }\n  return undefined;\n}\n/**\n * Library options for JSON Schema conversion.\n * - unrepresentable: 'any' allows z.custom() and other unrepresentable types to be converted to {}\n *   instead of throwing \"Custom types cannot be represented in JSON Schema\"\n * - override: converts z.date() to { type: 'string', format: 'date-time' }\n */\nexport const JSON_SCHEMA_LIBRARY_OPTIONS = {\n  unrepresentable: 'any' as const,\n  override: jsonSchemaOverride,\n};\n\nexport type {\n  StandardSchemaWithJSON,\n  StandardSchemaWithJSONProps,\n  InferInput,\n  InferOutput,\n  StandardSchemaIssue,\n} from './standard-schema.types';\n\nfunction isVercelSchema(schema: unknown): schema is Schema {\n  return (\n    typeof schema === 'object' &&\n    schema !== null &&\n    '_type' in schema &&\n    'jsonSchema' in schema &&\n    typeof (schema as Schema).jsonSchema === 'object'\n  );\n}\n\n/**\n * Check if a schema is Zod v4 (has _zod property which is v4-only)\n */\nfunction isZodV4(schema: unknown): boolean {\n  return typeof schema === 'object' && schema !== null && '_zod' in schema;\n}\n\n/**\n * Check if a schema is Zod v3.\n *\n * Zod v3 can come from:\n * 1. The old standalone 'zod-v3' package\n * 2. The 'zod/v3' compat export from modern zod\n *\n * We detect Zod v3 by checking:\n * - Has ~standard.vendor === 'zod' (both v3 and v4 have this)\n * - Does NOT have ~standard.jsonSchema (only Zod v4 has native JSON Schema support)\n * - Does NOT have _zod property (only Zod v4 has this)\n *\n * Note: We can't use instanceof z3.ZodType because the old 'zod-v3' package\n * has a different prototype chain than 'zod/v3'.\n */\nfunction isZodV3(schema: unknown): schema is ZodType {\n  if (schema === null || typeof schema !== 'object') {\n    return false;\n  }\n\n  // Must not be Zod v4\n  if (isZodV4(schema)) {\n    return false;\n  }\n\n  // Check for ~standard with vendor 'zod' but no jsonSchema\n  if ('~standard' in schema) {\n    const std = (schema as any)['~standard'];\n    if (typeof std === 'object' && std !== null && std.vendor === 'zod' && !('jsonSchema' in std)) {\n      return true;\n    }\n  }\n\n  // Fallback: check instanceof for zod/v3 compat export\n  return schema instanceof z3.ZodType;\n}\n\nexport function toStandardSchema<T = unknown>(schema: PublicSchema<T>): StandardSchemaWithJSON<T> {\n  // First check: if already StandardSchemaWithJSON, return as-is\n  // This handles ArkType, Zod v4 (when it has jsonSchema), and pre-wrapped schemas\n  if (isStandardSchemaWithJSON(schema)) {\n    return schema;\n  }\n\n  // Check for Zod v3 schemas (need wrapping to add JSON Schema support)\n  // Important: Must use isZodV3() not instanceof z3.ZodType because\n  // Zod v4 schemas are also instanceof z3.ZodType due to prototype compatibility\n  if (isZodV3(schema)) {\n    return toStandardSchemaZodV3(schema as ZodType);\n  }\n\n  // Check for AI SDK Schema objects (Vercel's jsonSchema wrapper)\n  if (isVercelSchema(schema)) {\n    return toStandardSchemaAiSdk(schema as Schema<T>);\n  }\n\n  // At this point, assume it's a plain JSON Schema object\n  // JSON Schema objects are plain objects with properties like 'type', 'properties', etc.\n  if (schema === null || (typeof schema !== 'object' && typeof schema !== 'function')) {\n    throw new Error(`Unsupported schema type: ${typeof schema}`);\n  }\n\n  // If it's a function that's not StandardSchemaWithJSON, it's not supported\n  if (typeof schema === 'function') {\n    throw new Error(`Unsupported schema type: function (schema libraries should implement StandardSchemaWithJSON)`);\n  }\n\n  return toStandardSchemaJsonSchema(schema as JSONSchema7);\n}\n\n/**\n * Type guard to check if a value implements the StandardSchemaV1 interface.\n *\n * @param value - The value to check\n * @returns True if the value implements StandardSchemaV1\n *\n * @example\n * ```typescript\n * import { isStandardSchema } from '@mastra/schema-compat';\n *\n * if (isStandardSchema(someValue)) {\n *   const result = someValue['~standard'].validate(input);\n * }\n * ```\n */\nexport function isStandardSchema(value: unknown): value is StandardSchemaV1 {\n  // Check for object or function (some libraries like ArkType use callable schemas)\n  if (value === null || (typeof value !== 'object' && typeof value !== 'function')) {\n    return false;\n  }\n  if (!('~standard' in value)) {\n    return false;\n  }\n  const std = (value as any)['~standard'];\n  return (\n    typeof std === 'object' &&\n    std !== null &&\n    'version' in std &&\n    std.version === 1 &&\n    'vendor' in std &&\n    'validate' in std &&\n    typeof std.validate === 'function'\n  );\n}\n\n/**\n * Type guard to check if a value implements the StandardJSONSchemaV1 interface.\n *\n * @param value - The value to check\n * @returns True if the value implements StandardJSONSchemaV1\n *\n * @example\n * ```typescript\n * import { isStandardJSONSchema } from '@mastra/schema-compat';\n *\n * if (isStandardJSONSchema(someValue)) {\n *   const jsonSchema = someValue['~standard'].jsonSchema.output({ target: 'draft-07' });\n * }\n * ```\n */\nexport function isStandardJSONSchema(value: unknown): value is StandardJSONSchemaV1 {\n  // Check for object or function (some libraries like ArkType use callable schemas)\n  if (value === null || (typeof value !== 'object' && typeof value !== 'function')) {\n    return false;\n  }\n  if (!('~standard' in value)) {\n    return false;\n  }\n  const std = (value as any)['~standard'];\n  if (typeof std !== 'object' || std === null) {\n    return false;\n  }\n  if (!('version' in std) || std.version !== 1 || !('vendor' in std)) {\n    return false;\n  }\n  if (!('jsonSchema' in std) || typeof std.jsonSchema !== 'object') {\n    return false;\n  }\n  return typeof std.jsonSchema.input === 'function' && typeof std.jsonSchema.output === 'function';\n}\n\n/**\n * Type guard to check if a value implements both StandardSchemaV1 and StandardJSONSchemaV1.\n *\n * @param value - The value to check\n * @returns True if the value implements both interfaces\n *\n * @example\n * ```typescript\n * import { isStandardSchemaWithJSON } from '@mastra/schema-compat';\n *\n * if (isStandardSchemaWithJSON(someValue)) {\n *   // Can use both validation and JSON Schema conversion\n *   const result = someValue['~standard'].validate(input);\n *   const jsonSchema = someValue['~standard'].jsonSchema.output({ target: 'draft-07' });\n * }\n * ```\n */\nexport function isStandardSchemaWithJSON(value: unknown): value is StandardSchemaWithJSON {\n  return isStandardSchema(value) && isStandardJSONSchema(value);\n}\n\n/**\n * Converts a StandardSchemaWithJSON to a JSON Schema.\n *\n * @param schema - The StandardSchemaWithJSON schema to convert\n * @param options - Conversion options\n * @param options.target - The JSON Schema target version (default: 'draft-07')\n * @param options.io - Whether to use input or output schema (default: 'output')\n *   - 'input': Use for tool parameters, function arguments, request bodies\n *   - 'output': Use for return types, response bodies\n * @returns The JSON Schema representation\n *\n * @example\n * ```typescript\n * import { standardSchemaToJSONSchema, toStandardSchema } from '@mastra/schema-compat';\n * import { z } from 'zod';\n *\n * const zodSchema = z.object({ name: z.string() });\n * const standardSchema = toStandardSchema(zodSchema);\n *\n * // For output types (default)\n * const outputSchema = standardSchemaToJSONSchema(standardSchema);\n *\n * // For input types (tool parameters)\n * const inputSchema = standardSchemaToJSONSchema(standardSchema, { io: 'input' });\n * ```\n */\nexport function standardSchemaToJSONSchema(\n  schema: StandardSchemaWithJSON,\n  options: {\n    target?: StandardJSONSchemaV1.Target;\n    io?: 'input' | 'output';\n    override?: (typeof JSON_SCHEMA_LIBRARY_OPTIONS)['override'];\n  } = {},\n): JSONSchema7 {\n  const { target = 'draft-07', io = 'output', override = JSON_SCHEMA_LIBRARY_OPTIONS.override } = options;\n  const jsonSchemaFn = schema['~standard'].jsonSchema[io];\n  return jsonSchemaFn({\n    target,\n    libraryOptions: {\n      ...JSON_SCHEMA_LIBRARY_OPTIONS,\n      override,\n    },\n  }) as JSONSchema7;\n}\n"]}