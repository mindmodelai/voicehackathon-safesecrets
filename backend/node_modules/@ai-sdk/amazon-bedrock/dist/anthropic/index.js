"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/anthropic/index.ts
var anthropic_exports = {};
__export(anthropic_exports, {
  bedrockAnthropic: () => bedrockAnthropic,
  createBedrockAnthropic: () => createBedrockAnthropic
});
module.exports = __toCommonJS(anthropic_exports);

// src/anthropic/bedrock-anthropic-provider.ts
var import_provider = require("@ai-sdk/provider");
var import_provider_utils3 = require("@ai-sdk/provider-utils");
var import_internal = require("@ai-sdk/anthropic/internal");

// src/bedrock-sigv4-fetch.ts
var import_provider_utils = require("@ai-sdk/provider-utils");
var import_aws4fetch = require("aws4fetch");

// src/version.ts
var VERSION = true ? "4.0.60" : "0.0.0-test";

// src/bedrock-sigv4-fetch.ts
function createSigV4FetchFunction(getCredentials, fetch = globalThis.fetch) {
  return async (input, init) => {
    var _a, _b;
    const request = input instanceof Request ? input : void 0;
    const originalHeaders = (0, import_provider_utils.combineHeaders)(
      (0, import_provider_utils.normalizeHeaders)(request == null ? void 0 : request.headers),
      (0, import_provider_utils.normalizeHeaders)(init == null ? void 0 : init.headers)
    );
    const headersWithUserAgent = (0, import_provider_utils.withUserAgentSuffix)(
      originalHeaders,
      `ai-sdk/amazon-bedrock/${VERSION}`,
      (0, import_provider_utils.getRuntimeEnvironmentUserAgent)()
    );
    let effectiveBody = (_a = init == null ? void 0 : init.body) != null ? _a : void 0;
    if (effectiveBody === void 0 && request && request.body !== null) {
      try {
        effectiveBody = await request.clone().text();
      } catch (e) {
      }
    }
    const effectiveMethod = (_b = init == null ? void 0 : init.method) != null ? _b : request == null ? void 0 : request.method;
    if ((effectiveMethod == null ? void 0 : effectiveMethod.toUpperCase()) !== "POST" || !effectiveBody) {
      return fetch(input, {
        ...init,
        headers: headersWithUserAgent
      });
    }
    const url = typeof input === "string" ? input : input instanceof URL ? input.href : input.url;
    const body = prepareBodyString(effectiveBody);
    const credentials = await getCredentials();
    const signer = new import_aws4fetch.AwsV4Signer({
      url,
      method: "POST",
      headers: Object.entries(headersWithUserAgent),
      body,
      region: credentials.region,
      accessKeyId: credentials.accessKeyId,
      secretAccessKey: credentials.secretAccessKey,
      sessionToken: credentials.sessionToken,
      service: "bedrock"
    });
    const signingResult = await signer.sign();
    const signedHeaders = (0, import_provider_utils.normalizeHeaders)(signingResult.headers);
    const combinedHeaders = (0, import_provider_utils.combineHeaders)(headersWithUserAgent, signedHeaders);
    return fetch(input, {
      ...init,
      body,
      headers: combinedHeaders
    });
  };
}
function prepareBodyString(body) {
  if (typeof body === "string") {
    return body;
  } else if (body instanceof Uint8Array) {
    return new TextDecoder().decode(body);
  } else if (body instanceof ArrayBuffer) {
    return new TextDecoder().decode(new Uint8Array(body));
  } else {
    return JSON.stringify(body);
  }
}
function createApiKeyFetchFunction(apiKey, fetch = globalThis.fetch) {
  return async (input, init) => {
    const originalHeaders = (0, import_provider_utils.normalizeHeaders)(init == null ? void 0 : init.headers);
    const headersWithUserAgent = (0, import_provider_utils.withUserAgentSuffix)(
      originalHeaders,
      `ai-sdk/amazon-bedrock/${VERSION}`,
      (0, import_provider_utils.getRuntimeEnvironmentUserAgent)()
    );
    const finalHeaders = (0, import_provider_utils.combineHeaders)(headersWithUserAgent, {
      Authorization: `Bearer ${apiKey}`
    });
    return fetch(input, {
      ...init,
      headers: finalHeaders
    });
  };
}

// src/anthropic/bedrock-anthropic-fetch.ts
var import_provider_utils2 = require("@ai-sdk/provider-utils");

// src/bedrock-event-stream-decoder.ts
var import_eventstream_codec = require("@smithy/eventstream-codec");
var import_util_utf8 = require("@smithy/util-utf8");
function createBedrockEventStreamDecoder(body, processEvent) {
  const codec = new import_eventstream_codec.EventStreamCodec(import_util_utf8.toUtf8, import_util_utf8.fromUtf8);
  let buffer = new Uint8Array(0);
  const textDecoder = new TextDecoder();
  return body.pipeThrough(
    new TransformStream({
      async transform(chunk, controller) {
        var _a, _b;
        const newBuffer = new Uint8Array(buffer.length + chunk.length);
        newBuffer.set(buffer);
        newBuffer.set(chunk, buffer.length);
        buffer = newBuffer;
        while (buffer.length >= 4) {
          const totalLength = new DataView(
            buffer.buffer,
            buffer.byteOffset,
            buffer.byteLength
          ).getUint32(0, false);
          if (buffer.length < totalLength) {
            break;
          }
          try {
            const subView = buffer.subarray(0, totalLength);
            const decoded = codec.decode(subView);
            buffer = buffer.slice(totalLength);
            const messageType = (_a = decoded.headers[":message-type"]) == null ? void 0 : _a.value;
            const eventType = (_b = decoded.headers[":event-type"]) == null ? void 0 : _b.value;
            const data = textDecoder.decode(decoded.body);
            await processEvent({ messageType, eventType, data }, controller);
          } catch (e) {
            break;
          }
        }
      }
    })
  );
}

// src/anthropic/bedrock-anthropic-fetch.ts
function createBedrockAnthropicFetch(baseFetch) {
  return async (url, options) => {
    const response = await baseFetch(url, options);
    const contentType = response.headers.get("content-type");
    if ((contentType == null ? void 0 : contentType.includes("application/vnd.amazon.eventstream")) && response.body != null) {
      const transformedBody = transformBedrockEventStreamToSSE(response.body);
      return new Response(transformedBody, {
        status: response.status,
        statusText: response.statusText,
        headers: new Headers({
          ...Object.fromEntries(response.headers.entries()),
          "content-type": "text/event-stream"
        })
      });
    }
    return response;
  };
}
function transformBedrockEventStreamToSSE(body) {
  const textEncoder = new TextEncoder();
  return createBedrockEventStreamDecoder(body, async (event, controller) => {
    if (event.messageType === "event") {
      if (event.eventType === "chunk") {
        const parsed = await (0, import_provider_utils2.safeParseJSON)({ text: event.data });
        if (!parsed.success) {
          controller.enqueue(textEncoder.encode(`data: ${event.data}

`));
          return;
        }
        const bytes = parsed.value.bytes;
        if (bytes) {
          const anthropicEvent = new TextDecoder().decode(
            (0, import_provider_utils2.convertBase64ToUint8Array)(bytes)
          );
          controller.enqueue(textEncoder.encode(`data: ${anthropicEvent}

`));
        } else {
          controller.enqueue(textEncoder.encode(`data: ${event.data}

`));
        }
      } else if (event.eventType === "messageStop") {
        controller.enqueue(textEncoder.encode("data: [DONE]\n\n"));
      }
    } else if (event.messageType === "exception") {
      controller.enqueue(
        textEncoder.encode(
          `data: ${JSON.stringify({ type: "error", error: event.data })}

`
        )
      );
    }
  });
}

// src/anthropic/bedrock-anthropic-provider.ts
var BEDROCK_TOOL_VERSION_MAP = {
  bash_20241022: "bash_20250124",
  text_editor_20241022: "text_editor_20250728",
  computer_20241022: "computer_20250124"
};
var BEDROCK_TOOL_NAME_MAP = {
  text_editor_20250728: "str_replace_based_edit_tool"
};
var BEDROCK_TOOL_BETA_MAP = {
  bash_20250124: "computer-use-2025-01-24",
  bash_20241022: "computer-use-2024-10-22",
  text_editor_20250124: "computer-use-2025-01-24",
  text_editor_20241022: "computer-use-2024-10-22",
  text_editor_20250429: "computer-use-2025-01-24",
  text_editor_20250728: "computer-use-2025-01-24",
  computer_20250124: "computer-use-2025-01-24",
  computer_20241022: "computer-use-2024-10-22"
};
function createBedrockAnthropic(options = {}) {
  const rawApiKey = (0, import_provider_utils3.loadOptionalSetting)({
    settingValue: options.apiKey,
    environmentVariableName: "AWS_BEARER_TOKEN_BEDROCK"
  });
  const apiKey = rawApiKey && rawApiKey.trim().length > 0 ? rawApiKey.trim() : void 0;
  const baseFetchFunction = apiKey ? createApiKeyFetchFunction(apiKey, options.fetch) : createSigV4FetchFunction(async () => {
    const region = (0, import_provider_utils3.loadSetting)({
      settingValue: options.region,
      settingName: "region",
      environmentVariableName: "AWS_REGION",
      description: "AWS region"
    });
    if (options.credentialProvider) {
      try {
        return {
          ...await options.credentialProvider(),
          region
        };
      } catch (error) {
        const errorMessage = error instanceof Error ? error.message : String(error);
        throw new Error(
          `AWS credential provider failed: ${errorMessage}. Please ensure your credential provider returns valid AWS credentials with accessKeyId and secretAccessKey properties.`
        );
      }
    }
    try {
      return {
        region,
        accessKeyId: (0, import_provider_utils3.loadSetting)({
          settingValue: options.accessKeyId,
          settingName: "accessKeyId",
          environmentVariableName: "AWS_ACCESS_KEY_ID",
          description: "AWS access key ID"
        }),
        secretAccessKey: (0, import_provider_utils3.loadSetting)({
          settingValue: options.secretAccessKey,
          settingName: "secretAccessKey",
          environmentVariableName: "AWS_SECRET_ACCESS_KEY",
          description: "AWS secret access key"
        }),
        sessionToken: (0, import_provider_utils3.loadOptionalSetting)({
          settingValue: options.sessionToken,
          environmentVariableName: "AWS_SESSION_TOKEN"
        })
      };
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      if (errorMessage.includes("AWS_ACCESS_KEY_ID") || errorMessage.includes("accessKeyId")) {
        throw new Error(
          `AWS SigV4 authentication requires AWS credentials. Please provide either:
1. Set AWS_ACCESS_KEY_ID and AWS_SECRET_ACCESS_KEY environment variables
2. Provide accessKeyId and secretAccessKey in options
3. Use a credentialProvider function
4. Use API key authentication with AWS_BEARER_TOKEN_BEDROCK or apiKey option
Original error: ${errorMessage}`
        );
      }
      if (errorMessage.includes("AWS_SECRET_ACCESS_KEY") || errorMessage.includes("secretAccessKey")) {
        throw new Error(
          `AWS SigV4 authentication requires both AWS_ACCESS_KEY_ID and AWS_SECRET_ACCESS_KEY. Please ensure both credentials are provided.
Original error: ${errorMessage}`
        );
      }
      throw error;
    }
  }, options.fetch);
  const fetchFunction = createBedrockAnthropicFetch(baseFetchFunction);
  const getBaseURL = () => {
    var _a, _b;
    return (_b = (0, import_provider_utils3.withoutTrailingSlash)(
      (_a = options.baseURL) != null ? _a : `https://bedrock-runtime.${(0, import_provider_utils3.loadSetting)({
        settingValue: options.region,
        settingName: "region",
        environmentVariableName: "AWS_REGION",
        description: "AWS region"
      })}.amazonaws.com`
    )) != null ? _b : "https://bedrock-runtime.us-east-1.amazonaws.com";
  };
  const getHeaders = async () => {
    var _a;
    const baseHeaders = (_a = await (0, import_provider_utils3.resolve)(options.headers)) != null ? _a : {};
    return (0, import_provider_utils3.withUserAgentSuffix)(baseHeaders, `ai-sdk/amazon-bedrock/${VERSION}`);
  };
  const createChatModel = (modelId) => new import_internal.AnthropicMessagesLanguageModel(modelId, {
    provider: "bedrock.anthropic.messages",
    baseURL: getBaseURL(),
    headers: getHeaders,
    fetch: fetchFunction,
    buildRequestUrl: (baseURL, isStreaming) => `${baseURL}/model/${encodeURIComponent(modelId)}/${isStreaming ? "invoke-with-response-stream" : "invoke"}`,
    transformRequestBody: (args) => {
      const { model, stream, tool_choice, tools, ...rest } = args;
      const transformedToolChoice = tool_choice != null ? {
        type: tool_choice.type,
        ...tool_choice.name != null ? { name: tool_choice.name } : {}
      } : void 0;
      const requiredBetas = /* @__PURE__ */ new Set();
      const transformedTools = tools == null ? void 0 : tools.map((tool) => {
        const toolType = tool.type;
        if (toolType && toolType in BEDROCK_TOOL_VERSION_MAP) {
          const newType = BEDROCK_TOOL_VERSION_MAP[toolType];
          if (newType in BEDROCK_TOOL_BETA_MAP) {
            requiredBetas.add(BEDROCK_TOOL_BETA_MAP[newType]);
          }
          const newName = newType in BEDROCK_TOOL_NAME_MAP ? BEDROCK_TOOL_NAME_MAP[newType] : tool.name;
          return {
            ...tool,
            type: newType,
            name: newName
          };
        }
        if (toolType && toolType in BEDROCK_TOOL_BETA_MAP) {
          requiredBetas.add(BEDROCK_TOOL_BETA_MAP[toolType]);
        }
        if (toolType && toolType in BEDROCK_TOOL_NAME_MAP) {
          return {
            ...tool,
            name: BEDROCK_TOOL_NAME_MAP[toolType]
          };
        }
        return tool;
      });
      return {
        ...rest,
        ...transformedTools != null ? { tools: transformedTools } : {},
        ...transformedToolChoice != null ? { tool_choice: transformedToolChoice } : {},
        ...requiredBetas.size > 0 ? { anthropic_beta: Array.from(requiredBetas) } : {},
        anthropic_version: "bedrock-2023-05-31"
      };
    },
    // Bedrock Anthropic doesn't support URL sources, force download and base64 conversion
    supportedUrls: () => ({}),
    // force the use of JSON tool fallback for structured outputs since beta header isn't supported
    supportsNativeStructuredOutput: false
  });
  const provider = function(modelId) {
    if (new.target) {
      throw new Error(
        "The Bedrock Anthropic model function cannot be called with the new keyword."
      );
    }
    return createChatModel(modelId);
  };
  provider.specificationVersion = "v3";
  provider.languageModel = createChatModel;
  provider.chat = createChatModel;
  provider.messages = createChatModel;
  provider.embeddingModel = (modelId) => {
    throw new import_provider.NoSuchModelError({ modelId, modelType: "embeddingModel" });
  };
  provider.textEmbeddingModel = provider.embeddingModel;
  provider.imageModel = (modelId) => {
    throw new import_provider.NoSuchModelError({ modelId, modelType: "imageModel" });
  };
  provider.tools = import_internal.anthropicTools;
  return provider;
}
var bedrockAnthropic = createBedrockAnthropic();
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  bedrockAnthropic,
  createBedrockAnthropic
});
//# sourceMappingURL=index.js.map